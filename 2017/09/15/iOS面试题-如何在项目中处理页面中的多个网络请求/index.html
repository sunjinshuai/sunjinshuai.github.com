<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈如何在项目中处理页面中的多个网络请求 · 孙金帅的技术博客</title><meta name="description" content="浅谈如何在项目中处理页面中的多个网络请求 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈如何在项目中处理页面中的多个网络请求</h1><div class="post-info">2017年9月15日</div><div class="post-content"><p>在开发中很多时候会有这样的场景，同一个界面有多个请求，而且要在这几个请求都成功返回的时候再去进行下一操作，对于这种场景，如何来设计请求操作呢？今天我们就来讨论一下有哪几种方案。</p>
<p>分析：</p>
<p>在网络请求的开发中，经常会遇到两种情况，一种是多个请求结束后统一操作，在一个界面需要同时请求多种数据，比如列表数据、广告数据等，全部请求到后再一起刷新界面。另一种是多个请求顺序执行，比如必须先请求个人信息，然后根据个人信息请求相关内容。这些要求对于普通的操作是可以做到并发控制和依赖操作的，但是对于网络请求这种需要时间的请求来说，效果往往与预期的不一样。因为网络请求是异步的，并不知道什么时候网络请求。很多开发人员为了省事，对于网络请求必须满足一定顺序这种情况，一般都是嵌套网络请求，即一个网络请求成功之后再请求另一个网络请求，虽然采用嵌套请求的方式能解决此问题，但存在很多问题，如：其中一个请求失败会导致后续请求无法正常进行、多个请求在时间上没有复用，即无并发性。来看一下下面几种方案：</p>
<h4 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore 信号量"></a>dispatch_semaphore 信号量</h4><p>信号量是一个整数，在创建的时候会有一个初始值，这个初始值往往代表我要控制的同时操作的并发数。<br>在操作中，对信号量会有两种操作：信号通知与等待。信号通知时，信号量会+1，等待时，如果信号量大于0，则会将信号量-1，否则，会等待直到信号量大于0。什么时候会大于零呢？往往是在之前某个操作结束后，我们发出信号通知，让信号量+1。</p>
<p>在 GCD 中，提供了以下这么几个函数，可用于请求同步等处理，模拟同步请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个信号量（semaphore）</span><br><span class="line">dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(value);</span><br><span class="line">&#x2F;&#x2F; 等待，直到信号量大于0时，即可操作，同时将信号量-1</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#x2F;&#x2F; 信号通知，即让信号量+1</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure>
<p>在使用的时候，往往会创建一个信号量，然后进行多个操作，每次操作都等待信号量大于0再操作，同时信号量-1，操作完后将信号量+1。当信号量就减小到0了，这时候wait操作会起作用，<code>DISPATCH_TIME_FOREVER</code> 表示会永远等待，一直等到信号量大于0，也就是有操作完成了，将信号量+1了，这时候才可以结束等待，进行操作，并且将信号量-1，这样新的任务又要等待。</p>
<p>下面我们展示一段代码来模拟同步请求：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aa64ae793cdd057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从打印结果可以看出，在每个请求开始之前，我们创建一个信号量，初始为0，在请求操作之后，我们设一个 <code>dispatch_semaphore_wait</code>，在请求到结果之后，再将信号量+1，也即是 <code>dispatch_semaphore_signal</code>。这样做的目的是保证在请求结果没有返回之前，一直让线程等待在那里，这样一个线程的任务一直在等待，就不会算作完成，<code>notify</code> 的内容也就不会执行了，直到每个请求的结果都返回了，线程任务才能够结束，这时候 <code>notify</code> 也才能够执行。</p>
<h4 id="dispatch-group（组）"><a href="#dispatch-group（组）" class="headerlink" title="dispatch_group（组）"></a>dispatch_group（组）</h4><p>可以使用 <code>dispatch_group_async</code> 函数将多个任务关联到一个 <code>dispatch_group</code> 和相应的 <code>queue</code> 中，<code>dispatch_group</code> 会并发地同时执行这些任务。而且 <code>dispatch_group</code> 可以用来阻塞一个线程，直到 <code>dispatch_group</code> 关联的所有的任务完成执行。有时候必须等待任务完成的结果，然后才能继续后面的处理。</p>
<p>主要使用如下两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_group_leave(group);</span><br></pre></td></tr></table></figure>
<p>注意：<br>以上这两个函数必须配对使用，否则 <code>dispatch_group_notify</code> 不会触发。</p>
<p>下面我们展示一段代码来模拟同步请求：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-685e74e14ff066c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>dispatch_group</code> 会等和它关联的所有的 <code>dispatch_queue_t</code> 上的任务都执行完毕才会发出同步信号，<code>dispathc_group_notify</code> 的代码块 <code>block</code> 会被执行。从控制台的打印结构可以看出，如果将上面三个操作改成真实的网络操作后，这个简单的做法会变得无效，因为网络请求需要时间，而线程的执行并不会等待请求完成后才真正算作完成，而是只负责将请求发出去，线程就认为自己的任务算完成了，当三个请求都发送出去，就会执行 <code>dispathc_group_notify</code> 中的内容，但请求结果返回的时间是不一定的，也就导致界面都刷新了，请求才返回，这就是无效的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2975a73bd15b8d5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>notify</code> 的作用就是在 <code>group</code> 中的其他操作全部完成后，再操作自己的内容，所以我们会看到上面事件 A、B、C 执行之后，才执行事件 E。<br>和 <code>dispatch_async</code> 相比，当我们调用 <code>n</code> 次 <code>dispatch_group_enter</code> 后再调用 <code>n</code> 次 <code>dispatch_group_level</code> 时，<code>dispatch_group_notify</code> 和 <code>dispatch_group_wait</code> 会收到同步信号；这个特点使得它非常适合处理异步任务的同步当异步任务开始前调用 <code>dispatch_group_enter</code> 异步任务结束后调用 <code>dispatch_group_leve</code>；</p>
<h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p><code>NSOperationQueue</code> 只有两种队列，即主队列和并行队列。通过 <code>[[NSOperationQueue alloc] init];</code> 创建的队列都是并行队列，并且可以将一个或多个 <code>NSOperation</code> 对象放到队列中去执行，而且是异步执行的，一个 <code>NSOperation</code> 对象可以通过调用 <code>start</code> 方法来执行任务，但是默认是同步执行的。则主队列通过 <code>[NSOperationQueue mainQueue];</code> 获得，而且其中所有 <code>NSOperation</code> 都会在主线程中执行。</p>
<p>当然也可以利用 <code>NSOperationQueue</code> 的线程依赖，当某个 <code>NSOperation</code> 对象依赖于其它 <code>NSOperation</code> 对象的完成时，就可以通过 <code>addDependency</code> 方法添加一个或者多个依赖的对象，只有所有依赖的对象都已经完成操作，当前 <code>NSOperation</code> 对象才会开始执行操作。需要先添加依赖关系,再将操作添加到队列中。另外，通过 <code>removeDependency</code> 方法来删除依赖对象。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在开发过程中，我们应尽量避免发送同步请求；假设我们一个页面需要同时进行多个请求，他们之间倒是不要求顺序关系，但是要求等他们都请求完毕了再进行界面刷新或者其他什么操作。并且在某个操作依赖于其他几个任务的完成时，采用 <code>dispatch_group</code> or <code>dispatch_semaphore</code> 来实现同步等处理。如果在某个操作依赖于其他几个任务的完成，可以考虑使用 <code>NSOperationQueue</code> 的线程之间依赖。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="prev">上一篇</a><a href="/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2017/09/15/iOS面试题-如何在项目中处理页面中的多个网络请求/';
var disqus_title = '浅谈如何在项目中处理页面中的多个网络请求';
var disqus_url = 'https://sunjinshuai.github.io/2017/09/15/iOS面试题-如何在项目中处理页面中的多个网络请求/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>