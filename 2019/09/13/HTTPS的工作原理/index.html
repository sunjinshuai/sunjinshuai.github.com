<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> HTTPS的工作原理 · 孙金帅的技术博客</title><meta name="description" content="HTTPS的工作原理 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">HTTPS的工作原理</h1><div class="post-info">2019年9月13日</div><div class="post-content"><p><code>HTTPS</code> 和 <code>HTTP</code> 协议相比提供了</p>
<ul>
<li>数据完整性：内容传输经过完整性校验</li>
<li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li>
<li>身份认证：第三方无法伪造服务端（客户端）身份</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>HTTPS</code> 在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。<code>TLS/SSL</code> 协议是一套加密传输的协议，使用了非对称加密，对称加密以及 <code>HASH</code> 算法。以浏览器和服务器为例，<code>HTTPS</code> 通信过程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-0e87f4003f1e85ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="握手.png"></p>
<p><strong>上图中的 <code>CA</code> 证书验证，这一步是可选的，对于安全性要求高的场景会用到，比如，预防中间人攻击。</strong></p>
<h4 id="第一步-Client-Hello"><a href="#第一步-Client-Hello" class="headerlink" title="第一步 Client Hello"></a>第一步 <code>Client Hello</code></h4><p>客户端向服务端发送 <code>Client Hello</code> 消息，这个消息里包含了一个客户端生成的随机数 <code>Random1</code>、客户端支持的加密套件和 <code>TLS/SSL Version</code> 等信息。</p>
<h4 id="第二步-Server-Hello"><a href="#第二步-Server-Hello" class="headerlink" title="第二步 Server Hello"></a>第二步 <code>Server Hello</code></h4><p>服务端向客户端发送 <code>Server Hello</code> 消息，这个消息会从 <code>Client Hello</code> 传过来的加密套件里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <code>Random2</code>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<h5 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a><code>Certificate</code></h5><p>服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p>
<h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a><code>Server Key Exchange</code></h4><p>这个消息会紧随在 <code>Server</code> 证书消息之后发送，<code>ServerKeyExchange</code> 消息由 <code>Server</code> 发送，但仅在 <code>Server</code> 证书消息(如果发送了)没有包含足够的数据以允许 <code>Client</code> 交换一个预密钥时。如果是 <code>DH</code> 算法，这里发送服务器使用的 <code>DH</code> 参数，<code>RSA</code> 算法不需要这一步；</p>
<h5 id="Certificate-Request"><a href="#Certificate-Request" class="headerlink" title="Certificate Request"></a><code>Certificate Request</code></h5><p>Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</p>
<h5 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a><code>Server Hello Done</code></h5><p>Server Hello Done 通知客户端 Server Hello 过程结束。</p>
<h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>客户端收到了服务器发来的数据包后，会做这么几件事情：</p>
<h5 id="Certificate-Verify"><a href="#Certificate-Verify" class="headerlink" title="Certificate Verify"></a><code>Certificate Verify</code></h5><p>验证一下证书是否合法；如果证书合法，或者客户端接受和信任了不合法的证书，验证通过后取出证书中的服务端公钥，再生成一个随机数 <code>Random3</code>，再用服务端公钥非对称加密 <code>Random3</code> 生成 <code>PreMaster Key</code>。</p>
<h5 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a><code>Client Key Exchange</code></h5><p>客户端根据服务器传来的公钥生成了 <code>PreMaster Key</code>，<code>Client Key Exchange</code> 就是将这个 <code>key</code> 传给服务端。</p>
<h5 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec Client"></a><code>Change Cipher Spec Client</code></h5><p>将刚才的消息使用刚才的随机数进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。</p>
<h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>服务器接受到客户端发来的消息后，会做这么几件事情：</p>
<h5 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message Client"></a><code>Encrypted Handshake Message Client</code></h5><p>这一步对应的是 <code>Client Finish</code> 消息，使用私钥解密上面第2步中公钥加密的消息，得到客户端产生的随机序列号。使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。</p>
<h5 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec Server"></a><code>Change Cipher Spec Server</code></h5><p>使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。</p>
<h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>客户端收到服务器端的消息后，接着做这么几件事情：</p>
<h5 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message Server"></a><code>Encrypted Handshake Message Server</code></h5><p>这一步对应的是 <code>Server Finish</code> 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p>
<h4 id="第六步-Application-Data"><a href="#第六步-Application-Data" class="headerlink" title="第六步 Application Data"></a>第六步 <code>Application Data</code></h4><p>握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>采用 <code>HTTPS</code> 协议的服务器必须要有自己制作或者 <code>CA</code> 证书，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用 <code>CA</code> 证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p>
<p>客户端收到服务器的回复后，首先客户端会从内置的证书列表中索引，查找服务器下发 <code>CA</code> 证书，如果没有找到，此时就会提示用户该证书是不可信任的。如果查到了对应 <code>CA</code> 证书，则取出 <code>public key</code> 公钥。然后，用 <code>public key</code> 公钥解密得到证书的内容和证书签名，内容包括证书的颁发机构，过期时间等。客户端会先验证证书签名的合法性，签名通过后，会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，客户端就可以安全使用 <code>public key</code> 公钥了。 </p>
<h3 id="中间人攻击原理"><a href="#中间人攻击原理" class="headerlink" title="中间人攻击原理"></a>中间人攻击原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/588630-4d9774eeb807e95d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中间人攻击原理"></p>
<p>针对 <code>SSL</code> 的中间人攻击方式主要有两类，分别是 <code>SSL</code> 劫持攻击和 <code>SSL</code> 剥离攻击，详细请看<a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/#mitm" target="_blank" rel="noopener">中间人攻击原理</a>。</p>
<h3 id="预防中间人攻击"><a href="#预防中间人攻击" class="headerlink" title="预防中间人攻击"></a>预防中间人攻击</h3><p>单向认证：<br>上图中的第二次握手，其实就是一次服务器-&gt;客户端的单向验证，服务器将自己的 <code>CA</code> 证书下发给客户端，让客户端验证自己的身份。</p>
<p>双向认证：<br>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务器 <code>CA</code> 证书以外，增加了服务器对客户端的 <code>CA</code> 证书认证。<br><a href="https://blog.csdn.net/duanbokan/article/details/50847612" target="_blank" rel="noopener">Https双向认证</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="prev">上一篇</a><a href="/2019/08/06/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2019/09/13/HTTPS的工作原理/';
var disqus_title = 'HTTPS的工作原理';
var disqus_url = 'https://sunjinshuai.github.io/2019/09/13/HTTPS的工作原理/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>