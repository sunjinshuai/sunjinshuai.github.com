<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈 iOS NSNotification · 孙金帅的技术博客</title><meta name="description" content="浅谈 iOS NSNotification - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunjinshuai" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈 iOS NSNotification</h1><div class="post-info">2016年10月17日</div><div class="post-content"><h4 id="NSNotification-解决的问题"><a href="#NSNotification-解决的问题" class="headerlink" title="NSNotification 解决的问题"></a>NSNotification 解决的问题</h4><ul>
<li>可以实现跨层的传递，例如A页面跳转到B页面，B页面再跳转到C页面，这时候如果我们通过委托回调的模式让A知道C的一些修改，那么实现起来就会很麻烦。</li>
<li>可以实现一对多，<code>NSNotification</code> 的实际是一种观察者模式。</li>
</ul>
<h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><p><code>NSNotificationCenter</code> 就相当于一个广播站，使用 <code>[NSNotificationCenter defaultCenter]</code> 来获取，<code>NSNotificationCenter</code> 实际上是 <code>iOS</code> 程序内部之间的一种消息广播机制，主要为了解决应用程序内部不同对象之间解耦而设计。<br><code>NSNotificationCenter</code> 是整个通知机制的关键所在，它管理着监听者的注册和注销，通知的发送和接收。<code>NSNotificationCenter</code> 维护着一个通知的分发表，把所有通知发送者发送的通知，转发给对应的监听者们。每一个 <code>iOS</code> 程序都有一个唯一的通知中心，不必自己去创建一个，它是一个单例，通过 <code>[NSNotificationCenter defaultCenter]</code> 方法获取。<br><code>NSNotificationCenter</code> 是基于观察者模式设计的，不能跨应用程序进程通信，当 <code>NSNotificationCenter</code> 接收到消息之后会根据内部的消息转发表，将消息发送给订阅者；它可以向应用任何地方发送和接收通知。<br>在 <code>NSNotificationCenter</code> 注册观察者，发送者使用通知中心广播时，以 <code>NSNotification</code> 的 <code>name</code> 和 <code>object</code> 来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</p>
<h4 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h4><p><code>NSNotification</code> 是 <code>NSNotificationCenter</code> 接收到消息之后根据内部的消息转发表，将消息发送给订阅者封装的对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</div><div class="line"></div><div class="line">//这个成员变量是这个消息对象的唯一标识，用于辨别消息对象</div><div class="line">@property (readonly, copy) NSString *name;</div><div class="line">// 这个成员变量定义一个对象，可以理解为针对某一个对象的消息，代表通知的发送者</div><div class="line">@property (nullable, readonly, retain) id object;</div><div class="line">//这个成员变量是一个字典，可以用其来进行传值</div><div class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</div><div class="line">// 初始化方法</div><div class="line">- (instancetype)initWithName:(NSString *)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo NS_AVAILABLE(10_6, 4_0) NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>由于 <code>NSNotification</code> 属性都是只读的，如果要创建通知则要用下面 <code>NSNotification(NSNotificationCreation)</code> 分类相应的方法进行初始化；</p>
<p><code>NSNotification</code> 不能通过 <code>init</code> 实例化，这样会引起下面的异常，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSNotification *notif = [[NSNotification alloc] init];</div><div class="line"></div><div class="line">*** Terminating app due to uncaught exception &apos;NSGenericException&apos;, reason: &apos;*** -[NSConcreteNotification init]: should never be used&apos;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface NSNotification (NSNotificationCreation)</div><div class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject;</div><div class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</div><div class="line">- (instancetype)init /*NS_UNAVAILABLE*/;    /* do not invoke; not a valid initializer for this class */</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意：<br>如果 <code>NSNotification</code> 对象中的 <code>notificationName</code> 为 <code>nil</code>，则会接收所有的通知。通知中心是以 <code>NSNotification</code> 的 <code>name</code> 和 <code>object</code> 来确定需要发送给哪个观察者。监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的，所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</p>
<p>通知中心默认是以同步的方式发送通知的，也就是说，当一个对象发送了一个通知，<strong>只有当该通知的所有接受者都接受到了通知中心分发的通知消息并且处理完成后，发送通知的对象才能继续执行接下来的方法。</strong></p>
<h4 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h4><p><code>NSNotificationQueue</code> 通知队列，用来管理多个通知的调用。通知队列通常以先进先出 <code>FIFO</code> 顺序维护通。<code>NSNotificationQueue</code> 就像一个缓冲池把一个个通知放进池子中，使用特定方式通过 <code>NSNotificationCenter</code> 发送到相应的观察者。下面我们会提到特定的方式即合并通知和异步通知。</p>
<p>创建通知队列方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithNotificationCenter:(NSNotificationCenter *)notificationCenter NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure></p>
<p>往队列加入通知方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;</div><div class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSNotificationCoalescing)coalesceMask forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes;</div></pre></td></tr></table></figure></p>
<p>移除队列中的通知方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;</div></pre></td></tr></table></figure></p>
<h5 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h5><p>NSPostingStyle包括三种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</div><div class="line">    NSPostWhenIdle = 1,</div><div class="line">    NSPostASAP = 2,</div><div class="line">    NSPostNow = 3  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>NSPostWhenIdle</code>：空闲发送通知，当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。<br><code>NSPostASAP</code>：尽快发送通知，当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。<br><code>NSPostNow</code> ：同步发送通知，如果不使用合并通知和 <code>postNotification:</code> 一样是同步通知。</p>
<h5 id="合并通知"><a href="#合并通知" class="headerlink" title="合并通知"></a>合并通知</h5><p>NSNotificationCoalescing也包括三种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123;</div><div class="line">    NSNotificationNoCoalescing = 0,</div><div class="line">    NSNotificationCoalescingOnName = 1,</div><div class="line">    NSNotificationCoalescingOnSender = 2</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>NSNotificationNoCoalescing</code>：不合并通知。<br><code>NSNotificationCoalescingOnName</code>：合并相同名称的通知。<br><code>NSNotificationCoalescingOnSender</code>：合并相同通知和同一对象的通知。</p>
<p>通过合并我们可以用来保证相同的通知只被发送一次。<code>forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes</code> 可以使用不同的 <code>NSRunLoopMode</code> 配合来发送通知，可以看出实际上 <code>NSNotificationQueue</code> 与 <code>RunLoop</code> 的机制以及运行循环有关系，通过 <code>NSNotificationQueue</code> 队列来发送的通知和关联的 <code>RunLoop</code> 运行机制来进行的。</p>
<h4 id="iOS-9-NSNotificationCenter-无需手动移除观察者"><a href="#iOS-9-NSNotificationCenter-无需手动移除观察者" class="headerlink" title="iOS 9 NSNotificationCenter 无需手动移除观察者"></a>iOS 9 NSNotificationCenter 无需手动移除观察者</h4><p>众所周知，在观察者对象释放之前，需要调用 <code>removeObserver</code> 方法，将观察者从通知中心移除，否则程序可能会出现崩溃。其实，从 <code>iOS 9</code> 开始，即使不移除观察者对象，程序也不会出现异常。这是为什么呢？我们先了解一下，为什么 <code>iOS 9</code> 之前需要手动移除观察者对象。</p>
<p>在 <code>MRC</code> 时代，观察者注册时，通知中心并不会对观察者对象做 <code>retain</code> 操作，而是对观察者对象进行 <code>unsafe_unretained</code> 引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// for attribute</div><div class="line">@property (unsafe_unretained) NSObject *unsafeProperty;</div><div class="line">// for variables</div><div class="line">NSObject *__unsafe_unretained unsafeReference;</div></pre></td></tr></table></figure>
<p>不安全引用（<code>unsafe reference</code>）和弱引用 (<code>weak reference</code>) 类似，它并不会让被引用的对象保持存活，但是和弱引用不同的是，当被引用的对象释放的时，不安全引用并不会自动被置为 <code>nil</code>，这就意味着它变成了野指针，而对野指针发送消息会导致程序崩溃。</p>
<blockquote>
<p>If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method.</p>
</blockquote>
<p>而在 <code>iOS 9</code> 以后，通知中心持有的是注册者的 <code>weak</code> 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。但是，通过 <code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock]</code> 方法注册的观察者依然需要手动的释放，因为通知中心对它们持有的是强引用。</p>
<h4 id="NSNotification在多线程中使用"><a href="#NSNotification在多线程中使用" class="headerlink" title="NSNotification在多线程中使用"></a>NSNotification在多线程中使用</h4><p>在多线程中，无论在哪个线程注册了观察者，<code>Notification</code> 接收和处理都是在发送 <code>Notification</code> 的线程中的。所以，当我们需要在接收到 <code>Notification</code> 后作出更新 <code>UI</code> 操作的话，就需要考虑线程的问题了，如果在子线程中发送 <code>Notification</code>，想要在接收到 <code>Notification</code> 后更新 <code>UI</code> 的话就要切换回到主线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    NSString *NOTIFICATION_NAME = @&quot;NOTIFICATION_NAME&quot;;</div><div class="line">    </div><div class="line">    NSLog(@&quot;Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">    </div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:NOTIFICATION_NAME object:nil];</div><div class="line">    </div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">         NSLog(@&quot;Post notification，Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:NOTIFICATION_NAME object:nil userInfo:nil];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)handleNotification:(NSNotification *)notification &#123;</div><div class="line">    NSLog(@&quot;Receive notification，Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-03-11 17:56:33.898 NotificationTest[23457:1615587] Current thread = &lt;NSThread: 0x608000078080&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-03-11 17:56:33.899 NotificationTest[23457:1615738] Post notification，Current thread = &lt;NSThread: 0x60000026c500&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">2017-03-11 17:56:33.899 NotificationTest[23457:1615738] Receive notification，Current thread = &lt;NSThread: 0x60000026c500&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>上面我们在主线程注册观察者，在子线程发送 <code>Notification</code>，最后 <code>Notification</code> 的接收和处理也是在子线程。</p>
<p>注意：<br>在一个多线程的程序中，发送方发送通知的线程通常就是监听者接受通知的线程，这可能和监听者注册时的线程不一样。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="MachPort的使用方式"><a href="#MachPort的使用方式" class="headerlink" title="MachPort的使用方式"></a>MachPort的使用方式</h6><p>最好的方法是在 <code>Notification</code> 所在的默认线程中捕获发送的通知，然后将其重定向到指定的线程中。关于 <code>Notification</code> 的重定向官方文档给出了一个方法：</p>
<blockquote>
<p>一种重定向的实现思路是自定义一个通知队列(不是 <code>NSNotificationQueue</code> 对象)，让这个队列去维护那些我们需要重定向的 <code>Notification</code>。我们仍然是像之前一样去注册一个通知的观察者，当 <code>Notification</code> 到达时，先看看 <code>post</code> 这个 <code>Notification</code> 的线程是不是我们所期望的线程，如果不是，就将这个 <code>Notification</code> 放到我们的队列中，然后发送一个信号<code>signal</code>到期望的线程中，来告诉这个线程需要处理一个 <code>Notification</code>。指定的线程收到这个信号<code>signal</code>后，将 <code>Notification</code> 从队列中移除，并进行后续处理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">//  ViewController.m</div><div class="line">//  NotificationTest</div><div class="line">//</div><div class="line">//  Created by sunjinshuai on 2017/3/11.</div><div class="line">//  Copyright © 2017年 sunjinshuai. All rights reserved.</div><div class="line">//</div><div class="line"> </div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"> </div><div class="line">@interface ViewController ()&lt;NSMachPortDelegate&gt;</div><div class="line"> </div><div class="line">@property (nonatomic) NSMutableArray    *notifications;         // 通知队列</div><div class="line">@property (nonatomic) NSThread          *notificationThread;    // 想要处理通知的线程（目标线程）</div><div class="line">@property (nonatomic) NSLock            *notificationLock;      // 用于对通知队列加锁的锁对象，避免线程冲突</div><div class="line">@property (nonatomic) NSMachPort        *notificationPort;      // 用于向目标线程发送信号的通信端口</div><div class="line"> </div><div class="line">@end</div><div class="line"> </div><div class="line">@implementation ViewController</div><div class="line"> </div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    NSString *NOTIFICATION_NAME = @&quot;NOTIFICATION_NAME&quot;;</div><div class="line"> </div><div class="line">    NSLog(@&quot;Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">    </div><div class="line">    [self setUpThreadingSupport];</div><div class="line">    </div><div class="line">    // 注册观察者</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:NOTIFICATION_NAME object:nil];</div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">        // 发送Notification</div><div class="line">        NSLog(@&quot;Post notification，Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:NOTIFICATION_NAME object:nil userInfo:nil];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/*</div><div class="line">    在注册任何通知之前，需要先初始化属性。下面方法初始化了队列和锁定对象，保留对当前线程对象的引用，并创建一个Mach通信端口，将其添加到当前线程的运行循环中。</div><div class="line">    此方法运行后，发送到notificationPort的任何消息都会在首次运行此方法的线程的run loop中接收。如果接收线程的run loop在Mach消息到达时没有运行，则内核保持该消息，直到下一次进入run loop。接收线程的run loop将传入消息发送到端口delegate的handleMachMessage：方法。</div><div class="line"> */</div><div class="line">- (void)setUpThreadingSupport &#123;</div><div class="line">    if (self.notifications) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.notifications      = [[NSMutableArray alloc] init];</div><div class="line">    self.notificationLock   = [[NSLock alloc] init];</div><div class="line">    self.notificationThread = [NSThread currentThread];</div><div class="line">    </div><div class="line">    self.notificationPort = [[NSMachPort alloc] init];</div><div class="line">    [self.notificationPort setDelegate:self];</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:self.notificationPort</div><div class="line">                                forMode:(__bridge NSString*)kCFRunLoopCommonModes];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">/**</div><div class="line"> 端口的代理方法</div><div class="line"> */</div><div class="line">- (void)handleMachMessage:(void *)msg &#123;</div><div class="line">    </div><div class="line">    [self.notificationLock lock];</div><div class="line">    </div><div class="line">    while ([self.notifications count]) &#123;</div><div class="line">        NSNotification *notification = [self.notifications objectAtIndex:0];</div><div class="line">        [self.notifications removeObjectAtIndex:0];</div><div class="line">        [self.notificationLock unlock];</div><div class="line">        [self processNotification:notification];</div><div class="line">        [self.notificationLock lock];</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    [self.notificationLock unlock];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)processNotification:(NSNotification *)notification &#123;</div><div class="line">    </div><div class="line">    //判断是不是目标线程，不是则转发到目标线程</div><div class="line">    if ([NSThread currentThread] != _notificationThread) &#123;</div><div class="line">        // 将Notification转发到目标线程</div><div class="line">        [self.notificationLock lock];</div><div class="line">        [self.notifications addObject:notification];</div><div class="line">        [self.notificationLock unlock];</div><div class="line">        [self.notificationPort sendBeforeDate:[NSDate date]</div><div class="line">                                   components:nil</div><div class="line">                                         from:nil</div><div class="line">                                     reserved:0];</div><div class="line">    &#125; else &#123;</div><div class="line">        // 在此处理通知</div><div class="line">        NSLog(@&quot;Receive notification，Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">        NSLog(@&quot;Process notification&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2017-03-11 18:28:55.788 NotificationTest[24080:1665269] Current thread = &lt;NSThread: 0x60800006d4c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-03-11 18:28:55.789 NotificationTest[24080:1665396] Post notification，Current thread = &lt;NSThread: 0x60800026bc40&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">2017-03-11 18:28:55.795 NotificationTest[24080:1665269] Receive notification，Current thread = &lt;NSThread: 0x60800006d4c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">2017-03-11 18:28:55.795 NotificationTest[24080:1665269] Process notification</div></pre></td></tr></table></figure>
<p>在发送通知的子线程处理通知的事件时，将 <code>NSNotification</code> 暂存，然后通过 <code>MachPort</code> 往相应线程的 <code>RunLoop</code> 中发送事件。相应的线程收到该事件后，取出在队列中暂存的 <code>NSNotification</code> , 然后在当前线程中调用处理通知的方法。<br>可以看到，运行结果结果我们想要的：在子线程中发送 <code>Notification</code>，在主线程中接收与处理 <code>Notification</code>。</p>
<p>上面的实现方法也不是绝对完美的，苹果官方指出了这种方法的限制：</p>
<ul>
<li>所有线程的 <code>Notification</code> 的处理都必须通过相同的方法 <code>processNotification:</code>。</li>
<li>每个对象必须提供自己的实现和通信端口。</li>
</ul>
<h6 id="block"><a href="#block" class="headerlink" title="block"></a>block</h6><p>上面苹果官方给我们提供的方法外，我们还可以利用基于 <code>block</code> 的 <code>NSNotification</code> 去实现，<code>apple</code> 从 <code>ios4</code> 之后提供了带有 <code>block</code> 的 <code>NSNotification</code>。使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (id&lt;NSObject&gt;)addObserverForName:(NSString *)name</div><div class="line">                           object:(id)obj</div><div class="line">                            queue:(NSOperationQueue *)queue</div><div class="line">                       usingBlock:(void (^)(NSNotification *note))block</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>观察者就是当前对象</li>
<li><code>queue</code> 定义了 <code>block</code> 执行的线程，<code>nil</code> 则表示 <code>block</code> 的执行线程和发通知在同一个线程</li>
<li><code>block</code> 就是相应通知的处理函数</li>
</ul>
<p>这个 <code>API</code> 已经能够让我们方便的控制通知的线程切换。但是，这里有个问题需要注意。就是其 <code>remove</code> 操作。</p>
<p>原来的 <code>NSNotification</code> 的 <code>remove</code> 方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)removeObservers &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:POST_NOTIFICATION object:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是带 <code>block</code> 方式的 <code>remove</code> 便不能像上面这样处理了。其方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)removeObservers &#123;</div><div class="line">    if（_observer）&#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] removeObserver:_observer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>_observer</code> 是 <code>addObserverForName</code> 方式的 <code>api</code> 返回观察者对象。这也就意味着，你需要为每一个观察者记录一个成员对象，然后在 <code>remove</code> 的时候依次删除。试想一下，你如果需要 10 个观察者，则需要记录 10 个成员对象，这个想想就是很麻烦，而且它还不能够方便的指定 <code>observer</code> 。因此，理想的做法就是自己再做一层封装，将这些细节封装起来。</p>
<p>当然，想要在子线程发送 <code>Notification</code>、接收到 <code>Notification</code> 后在主线程中做后续操作，可以用一个很笨的方法，在 <code>handleNotification</code> 里面强制切换线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)handleNotification:(NSNotification *)notification &#123;</div><div class="line">   NSLog(@&quot;Receive notification，Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">   dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">      NSLog(@&quot;Current thread = %@&quot;, [NSThread currentThread]);</div><div class="line">   &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在简单情况下可以使用这种方法，但是当我们发送了多个 <code>Notification</code> 并且有多个观察者的时候，难道我们要在每个地方都手动切换线程？所以，这种方法并不是一个有效的方法。</p>
<h4 id="通知的实现原理"><a href="#通知的实现原理" class="headerlink" title="通知的实现原理"></a>通知的实现原理</h4><p>以下源码来自于<a href="https://github.com/gnustep/libs-base" target="_blank" rel="external">libs-base</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">typedef struct NCTbl &#123;</div><div class="line">  Observation		*wildcard;	/* Get ALL messages.		*/</div><div class="line">  GSIMapTable		nameless;	/* Get messages for any name.	*/</div><div class="line">  GSIMapTable		named;		/* Getting named messages only.	*/</div><div class="line">  unsigned		lockCount;	/* Count recursive operations.	*/</div><div class="line">  NSRecursiveLock	*_lock;		/* Lock out other threads.	*/</div><div class="line">  Observation		*freeList;</div><div class="line">  Observation		**chunks;</div><div class="line">  unsigned		numChunks;</div><div class="line">  GSIMapTable		cache[CACHESIZE];</div><div class="line">  unsigned short	chunkIndex;</div><div class="line">  unsigned short	cacheIndex;</div><div class="line">&#125; NCTable;</div><div class="line"></div><div class="line">typedef	struct	Obs &#123;</div><div class="line">  id		observer;	/* Object to receive message.	*/</div><div class="line">  SEL		selector;	/* Method selector.		*/</div><div class="line">  struct Obs	*next;		/* Next item in linked list.	*/</div><div class="line">  int		retained;	/* Retain count for structure.	*/</div><div class="line">  struct NCTbl	*link;		/* Pointer back to chunk table	*/</div><div class="line">&#125; Observation;</div></pre></td></tr></table></figure>
<p>从源码中可以看出，在 <code>NSNotificationCenter</code> 内部是由链表组成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">- (void) addObserver: (id)observer</div><div class="line">	    selector: (SEL)selector</div><div class="line">                name: (NSString*)name</div><div class="line">	      object: (id)object</div><div class="line">&#123;</div><div class="line">  Observation	*list;</div><div class="line">  Observation	*o;</div><div class="line">  GSIMapTable	m;</div><div class="line">  GSIMapNode	n;</div><div class="line"></div><div class="line">  if (observer == nil)</div><div class="line">    [NSException raise: NSInvalidArgumentException</div><div class="line">		format: @&quot;Nil observer passed to addObserver ...&quot;];</div><div class="line"></div><div class="line">  if (selector == 0)</div><div class="line">    [NSException raise: NSInvalidArgumentException</div><div class="line">		format: @&quot;Null selector passed to addObserver ...&quot;];</div><div class="line"></div><div class="line">  if ([observer respondsToSelector: selector] == NO)</div><div class="line">    &#123;</div><div class="line">      [NSException raise: NSInvalidArgumentException</div><div class="line">        format: @&quot;[%@-%@] Observer &apos;%@&apos; does not respond to selector &apos;%@&apos;&quot;,</div><div class="line">        NSStringFromClass([self class]), NSStringFromSelector(_cmd),</div><div class="line">        observer, NSStringFromSelector(selector)];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  lockNCTable(TABLE);</div><div class="line"></div><div class="line">  o = obsNew(TABLE, selector, observer);</div><div class="line"></div><div class="line">  /*</div><div class="line">   * Record the Observation in one of the linked lists.</div><div class="line">   *</div><div class="line">   * NB. It is possible to register an observer for a notification more than</div><div class="line">   * once - in which case, the observer will receive multiple messages when</div><div class="line">   * the notification is posted... odd, but the MacOS-X docs specify this.</div><div class="line">   */</div><div class="line"></div><div class="line">  if (name)</div><div class="line">    &#123;</div><div class="line">      /*</div><div class="line">       * Locate the map table for this name - create it if not present.</div><div class="line">       */</div><div class="line">      n = GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name);</div><div class="line">      if (n == 0)</div><div class="line">	&#123;</div><div class="line">	  m = mapNew(TABLE);</div><div class="line">	  /*</div><div class="line">	   * As this is the first observation for the given name, we take a</div><div class="line">	   * copy of the name so it cannot be mutated while in the map.</div><div class="line">	   */</div><div class="line">	  name = [name copyWithZone: NSDefaultMallocZone()];</div><div class="line">	  GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m);</div><div class="line">	  GS_CONSUMED(name)</div><div class="line">	&#125;</div><div class="line">      else</div><div class="line">	&#123;</div><div class="line">	  m = (GSIMapTable)n-&gt;value.ptr;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">      /*</div><div class="line">       * Add the observation to the list for the correct object.</div><div class="line">       */</div><div class="line">      n = GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</div><div class="line">      if (n == 0)</div><div class="line">	&#123;</div><div class="line">	  o-&gt;next = ENDOBS;</div><div class="line">	  GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</div><div class="line">	&#125;</div><div class="line">      else</div><div class="line">	&#123;</div><div class="line">	  list = (Observation*)n-&gt;value.ptr;</div><div class="line">	  o-&gt;next = list-&gt;next;</div><div class="line">	  list-&gt;next = o;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">  else if (object)</div><div class="line">    &#123;</div><div class="line">      n = GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</div><div class="line">      if (n == 0)</div><div class="line">	&#123;</div><div class="line">	  o-&gt;next = ENDOBS;</div><div class="line">	  GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</div><div class="line">	&#125;</div><div class="line">      else</div><div class="line">	&#123;</div><div class="line">	  list = (Observation*)n-&gt;value.ptr;</div><div class="line">	  o-&gt;next = list-&gt;next;</div><div class="line">	  list-&gt;next = o;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">  else</div><div class="line">    &#123;</div><div class="line">      o-&gt;next = WILDCARD;</div><div class="line">      WILDCARD = o;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  unlockNCTable(TABLE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSNotificationTheory" target="_blank" rel="external">https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSNotificationTheory</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/11/17/iOS多线程之一：基本概念/" class="prev">上一篇</a><a href="/2016/10/06/浅谈-AutoreleasePool-的实现原理/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/10/17/浅谈-iOS-NSNotification/';
var disqus_title = '浅谈 iOS NSNotification';
var disqus_url = 'https://sunjinshuai.github.io/2016/10/17/浅谈-iOS-NSNotification/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>