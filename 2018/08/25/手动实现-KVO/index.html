<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 手动实现 KVO · 孙金帅的技术博客</title><meta name="description" content="手动实现 KVO - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunjinshuai" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">手动实现 KVO</h1><div class="post-info">2018年8月25日</div><div class="post-content"><p><code>KVO</code> 全称 <code>KeyValueObserving</code> 是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，指定一个被观察对象，当被观察对象的某个属性发生更改时，监听对象会获得通知，并作出相应处理；</p>
<p>在 <code>MVC</code> 设计架构下的项目，<code>KVO</code> 机制很适合实现 <code>Mode</code> 模型和 <code>View</code> 视图之间的通讯。</p>
<p><code>KVO</code> 和通知都是 <code>iOS</code> 中观察者模式的一种实现；<br>区别在于，相对于被观察者和观察者之间的关系，<code>KVO</code> 是一对一的，而通知一对多的。</p>
<h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul>
<li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li>
<li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li>
<li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li>
</ul>
<p><code>KVO</code> 的实现也依赖于 <code>Objective-C</code> 强大的 <code>Runtime</code> ，<code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>
</blockquote>
<h4 id="简单概述下-KVO-的实现："><a href="#简单概述下-KVO-的实现：" class="headerlink" title="简单概述下 KVO 的实现："></a>简单概述下 <code>KVO</code> 的实现：</h4><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。自然，重写的 <code>setter</code> 方法会负责在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针 ( <code>isa</code> 指针告诉 <code>Runtime</code> 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例，被观察对象的 <code>isa</code> 指针会指向一个中间类，而不是原来真正的类。</p>
<h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a><code>KVO</code> 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface TestKVOViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) Message *message;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestKVOViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor whiteColor];</div><div class="line">    </div><div class="line">    Message *message = [[Message alloc] init];</div><div class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div><div class="line">    </div><div class="line">    message.text = @&quot;hello object-c&quot;;</div><div class="line">    self.message = message;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, change);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</div><div class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</div><div class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">	0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</div><div class="line">	1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</div><div class="line">	2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</div><div class="line">	3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</div><div class="line">	4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</div><div class="line">	5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</div><div class="line">	6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</div><div class="line">	7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</div><div class="line">	8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</div><div class="line">	9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</div><div class="line">	10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</div><div class="line">	11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</div><div class="line">	12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</div><div class="line">	13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</div><div class="line">	14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</div><div class="line">	15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</div><div class="line">	16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</div><div class="line">	17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</div><div class="line">	18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</div><div class="line">	19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</div><div class="line">	20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</div><div class="line">	21  ImplementKVO                        0x000000010dd2dfef main + 111</div><div class="line">	22  libdyld.dylib                       0x00000001129fe955 start + 1</div><div class="line">	23  ???                                 0x0000000000000001 0x0 + 1</div><div class="line">)</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div></pre></td></tr></table></figure>
<h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</div><div class="line"></div><div class="line">@interface NSObject (KVO)</div><div class="line"></div><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">forKey:(NSString *)key</div><div class="line">withBlock:(ObservingBlock)block;</div><div class="line"></div><div class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p>
<ul>
<li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li>
<li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li>
<li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li>
<li>添加这个观察者；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</div><div class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</div><div class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</div><div class="line"> 4. 将调用对象添加到数组中。</div><div class="line"> */</div><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">             forKey:(NSString *)key</div><div class="line">          withBlock:(ObservingBlock)block &#123;</div><div class="line">    </div><div class="line">    SEL setterSelector = NSSelectorFromString(setterForGetter(key));</div><div class="line">    Method setterMethod = class_getInstanceMethod([self class], setterSelector);</div><div class="line">    if (!setterMethod) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Class clazz = object_getClass(self);</div><div class="line">    NSString *clazzName = NSStringFromClass(clazz);</div><div class="line">    </div><div class="line">    // if not an KVO class yet</div><div class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</div><div class="line">        clazz = [self makeKvoClassWithOriginalClassName:clazzName];</div><div class="line">        object_setClass(self, clazz);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // add our kvo setter if this class (not superclasses) doesn&apos;t implement the setter?</div><div class="line">    if (![self hasSelector:setterSelector]) &#123;</div><div class="line">        const char *types = method_getTypeEncoding(setterMethod);</div><div class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ObservationInfo *info = [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</div><div class="line">    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</div><div class="line">    if (!observers) &#123;</div><div class="line">        observers = [NSMutableArray array];</div><div class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    [observers addObject:info];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p>
<p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 1. 判断是否存在KVO类，如果存在则返回。</div><div class="line"> 2. 如果不存在，则创建KVO类。</div><div class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</div><div class="line"> */</div><div class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</div><div class="line">    NSString *kvoClazzName = [kKVOClassPrefix stringByAppendingString:originalClazzName];</div><div class="line">    Class clazz = NSClassFromString(kvoClazzName);</div><div class="line">    </div><div class="line">    if (clazz) &#123;</div><div class="line">        return clazz;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // class doesn&apos;t exist yet, make it</div><div class="line">    Class originalClazz = object_getClass(self);</div><div class="line">    Class kvoClazz = objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</div><div class="line">    </div><div class="line">    // grab class method&apos;s signature so we can borrow it</div><div class="line">    Method clazzMethod = class_getInstanceMethod(originalClazz, @selector(class));</div><div class="line">    const char *types = method_getTypeEncoding(clazzMethod);</div><div class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</div><div class="line">    </div><div class="line">    objc_registerClassPair(kvoClazz);</div><div class="line">    </div><div class="line">    return kvoClazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p>
<p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</div><div class="line">    NSString *setterName = NSStringFromSelector(_cmd);</div><div class="line">    NSString *getterName = getterForSetter(setterName);</div><div class="line">    </div><div class="line">    if (!getterName) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id oldValue = [self valueForKey:getterName];</div><div class="line">    </div><div class="line">    struct objc_super superclazz = &#123;</div><div class="line">        .receiver = self,</div><div class="line">        .super_class = class_getSuperclass(object_getClass(self))</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    // cast our pointer so the compiler won&apos;t complain</div><div class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;</div><div class="line">    </div><div class="line">    // call super&apos;s setter, which is original class&apos;s setter method</div><div class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</div><div class="line">    </div><div class="line">    // look up observers and call the blocks</div><div class="line">    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</div><div class="line">    for (ObservationInfo *each in observers) &#123;</div><div class="line">        if ([each.key isEqualToString:getterName]) &#123;</div><div class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                each.block(self, getterName, oldValue, newValue);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p>
<p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface ObservationInfo : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) NSObject *observer;</div><div class="line">@property (nonatomic, copy) NSString *key;</div><div class="line">@property (nonatomic, copy) ObservingBlock block;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ObservationInfo</div><div class="line"></div><div class="line">- (instancetype)initWithObserver:(NSObject *)observer</div><div class="line">                             Key:(NSString *)key</div><div class="line">                           block:(ObservingBlock)block &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _observer = observer;</div><div class="line">        _key = key;</div><div class="line">        _block = block;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/25/Flutter之环境搭建/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2018/08/25/手动实现-KVO/';
var disqus_title = '手动实现 KVO';
var disqus_url = 'https://sunjinshuai.github.io/2018/08/25/手动实现-KVO/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>