<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2020-01-10T03:21:59.933Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈如何在项目中处理页面中的多个网络请求</title>
    <link href="https://sunjinshuai.github.io/2020/01/10/%E6%B5%85%E8%B0%88%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%84%E7%90%86%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>https://sunjinshuai.github.io/2020/01/10/%E6%B5%85%E8%B0%88%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%84%E7%90%86%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/</id>
    <published>2020-01-10T03:21:43.000Z</published>
    <updated>2020-01-10T03:21:59.933Z</updated>
    
    <content type="html"><![CDATA[<p>在开发中很多时候会有这样的场景，同一个界面有多个请求，而且要在这几个请求都成功返回的时候再去进行下一操作，对于这种场景，如何来设计请求操作呢？今天我们就来讨论一下有哪几种方案。</p><p>分析：</p><p>在网络请求的开发中，经常会遇到两种情况，一种是多个请求结束后统一操作，在一个界面需要同时请求多种数据，比如列表数据、广告数据等，全部请求到后再一起刷新界面。另一种是多个请求顺序执行，比如必须先请求个人信息，然后根据个人信息请求相关内容。这些要求对于普通的操作是可以做到并发控制和依赖操作的，但是对于网络请求这种需要时间的请求来说，效果往往与预期的不一样。因为网络请求是异步的，并不知道什么时候网络请求。很多开发人员为了省事，对于网络请求必须满足一定顺序这种情况，一般都是嵌套网络请求，即一个网络请求成功之后再请求另一个网络请求，虽然采用嵌套请求的方式能解决此问题，但存在很多问题，如：其中一个请求失败会导致后续请求无法正常进行、多个请求在时间上没有复用，即无并发性。来看一下下面几种方案：</p><h4 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore 信号量"></a>dispatch_semaphore 信号量</h4><p>信号量是一个整数，在创建的时候会有一个初始值，这个初始值往往代表我要控制的同时操作的并发数。<br>在操作中，对信号量会有两种操作：信号通知与等待。信号通知时，信号量会+1，等待时，如果信号量大于0，则会将信号量-1，否则，会等待直到信号量大于0。什么时候会大于零呢？往往是在之前某个操作结束后，我们发出信号通知，让信号量+1。</p><p>在 GCD 中，提供了以下这么几个函数，可用于请求同步等处理，模拟同步请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个信号量（semaphore）</span><br><span class="line">dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(value);</span><br><span class="line">&#x2F;&#x2F; 等待，直到信号量大于0时，即可操作，同时将信号量-1</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#x2F;&#x2F; 信号通知，即让信号量+1</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure><p>在使用的时候，往往会创建一个信号量，然后进行多个操作，每次操作都等待信号量大于0再操作，同时信号量-1，操作完后将信号量+1。当信号量就减小到0了，这时候wait操作会起作用，<code>DISPATCH_TIME_FOREVER</code> 表示会永远等待，一直等到信号量大于0，也就是有操作完成了，将信号量+1了，这时候才可以结束等待，进行操作，并且将信号量-1，这样新的任务又要等待。</p><p>下面我们展示一段代码来模拟同步请求：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-aa64ae793cdd057a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从打印结果可以看出，在每个请求开始之前，我们创建一个信号量，初始为0，在请求操作之后，我们设一个 <code>dispatch_semaphore_wait</code>，在请求到结果之后，再将信号量+1，也即是 <code>dispatch_semaphore_signal</code>。这样做的目的是保证在请求结果没有返回之前，一直让线程等待在那里，这样一个线程的任务一直在等待，就不会算作完成，<code>notify</code> 的内容也就不会执行了，直到每个请求的结果都返回了，线程任务才能够结束，这时候 <code>notify</code> 也才能够执行。</p><h4 id="dispatch-group（组）"><a href="#dispatch-group（组）" class="headerlink" title="dispatch_group（组）"></a>dispatch_group（组）</h4><p>可以使用 <code>dispatch_group_async</code> 函数将多个任务关联到一个 <code>dispatch_group</code> 和相应的 <code>queue</code> 中，<code>dispatch_group</code> 会并发地同时执行这些任务。而且 <code>dispatch_group</code> 可以用来阻塞一个线程，直到 <code>dispatch_group</code> 关联的所有的任务完成执行。有时候必须等待任务完成的结果，然后才能继续后面的处理。</p><p>主要使用如下两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_group_leave(group);</span><br></pre></td></tr></table></figure><p>注意：<br>以上这两个函数必须配对使用，否则 <code>dispatch_group_notify</code> 不会触发。</p><p>下面我们展示一段代码来模拟同步请求：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-685e74e14ff066c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>dispatch_group</code> 会等和它关联的所有的 <code>dispatch_queue_t</code> 上的任务都执行完毕才会发出同步信号，<code>dispathc_group_notify</code> 的代码块 <code>block</code> 会被执行。从控制台的打印结构可以看出，如果将上面三个操作改成真实的网络操作后，这个简单的做法会变得无效，因为网络请求需要时间，而线程的执行并不会等待请求完成后才真正算作完成，而是只负责将请求发出去，线程就认为自己的任务算完成了，当三个请求都发送出去，就会执行 <code>dispathc_group_notify</code> 中的内容，但请求结果返回的时间是不一定的，也就导致界面都刷新了，请求才返回，这就是无效的。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-2975a73bd15b8d5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>notify</code> 的作用就是在 <code>group</code> 中的其他操作全部完成后，再操作自己的内容，所以我们会看到上面事件 A、B、C 执行之后，才执行事件 E。<br>和 <code>dispatch_async</code> 相比，当我们调用 <code>n</code> 次 <code>dispatch_group_enter</code> 后再调用 <code>n</code> 次 <code>dispatch_group_level</code> 时，<code>dispatch_group_notify</code> 和 <code>dispatch_group_wait</code> 会收到同步信号；这个特点使得它非常适合处理异步任务的同步当异步任务开始前调用 <code>dispatch_group_enter</code> 异步任务结束后调用 <code>dispatch_group_leve</code>；</p><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p><code>NSOperationQueue</code> 只有两种队列，即主队列和并行队列。通过 <code>[[NSOperationQueue alloc] init];</code> 创建的队列都是并行队列，并且可以将一个或多个 <code>NSOperation</code> 对象放到队列中去执行，而且是异步执行的，一个 <code>NSOperation</code> 对象可以通过调用 <code>start</code> 方法来执行任务，但是默认是同步执行的。则主队列通过 <code>[NSOperationQueue mainQueue];</code> 获得，而且其中所有 <code>NSOperation</code> 都会在主线程中执行。</p><p>当然也可以利用 <code>NSOperationQueue</code> 的线程依赖，当某个 <code>NSOperation</code> 对象依赖于其它 <code>NSOperation</code> 对象的完成时，就可以通过 <code>addDependency</code> 方法添加一个或者多个依赖的对象，只有所有依赖的对象都已经完成操作，当前 <code>NSOperation</code> 对象才会开始执行操作。需要先添加依赖关系,再将操作添加到队列中。另外，通过 <code>removeDependency</code> 方法来删除依赖对象。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在开发过程中，我们应尽量避免发送同步请求；假设我们一个页面需要同时进行多个请求，他们之间倒是不要求顺序关系，但是要求等他们都请求完毕了再进行界面刷新或者其他什么操作。并且在某个操作依赖于其他几个任务的完成时，采用 <code>dispatch_group</code> or <code>dispatch_semaphore</code> 来实现同步等处理。如果在某个操作依赖于其他几个任务的完成，可以考虑使用 <code>NSOperationQueue</code> 的线程之间依赖。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发中很多时候会有这样的场景，同一个界面有多个请求，而且要在这几个请求都成功返回的时候再去进行下一操作，对于这种场景，如何来设计请求操作呢？今天我们就来讨论一下有哪几种方案。&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;p&gt;在网络请求的开发中，经常会遇到两种情况，一种是多个请求结束后
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CocoaPods 使用总结</title>
    <link href="https://sunjinshuai.github.io/2020/01/10/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sunjinshuai.github.io/2020/01/10/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2020-01-10T01:39:14.000Z</published>
    <updated>2020-01-10T02:05:06.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocoaPods简介"><a href="#CocoaPods简介" class="headerlink" title="CocoaPods简介"></a>CocoaPods简介</h2><p><code>CocoaPods</code> 是专门为 <code>iOS</code> 工程提供第三方依赖库的管理工具，通过 <code>CocoaPods</code>，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置，就可以直观、集中和自动化地管理我们项目的第三方库。</p><p><code>CocoaPods</code> 将所有依赖的库都放在一个名为 <code>Pods</code> 的项目下，然后让主项目依赖 <code>Pods</code> 项目。然后，我们编码工作都从主项目转移到 <code>Pods</code> 项目。<code>Pods</code> 项目最终会编译为一个 <code>libPod-项目名.a</code> 静态库，主项目依赖于这个静态库。</p><p>对于资源文件，<code>CocoaPods</code> 提供了一个名为 <code>Pods-resources.sh</code> 的 <code>bash</code> 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。<code>CocoaPods</code> 通过一个名为 <code>Pods.xcconfig</code> 的文件来在编译时设置所有的依赖和参数。<code>CocoaPods</code> 是用 <code>Ruby</code> 写的，并由若干个 <code>Ruby</code> 包 (gems) 构成的。在解析整合过程中，最重要的几个 <code>gems</code> 分别是： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCocoaPods%2F" target="_blank" rel="noopener">CocoaPods/CocoaPods</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCore" target="_blank" rel="noopener">CocoaPods/Core</a> 和 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FXcodeproj" target="_blank" rel="noopener">CocoaPods/Xcodeproj</a>。</p><h2 id="CocoaPod的核心组件"><a href="#CocoaPod的核心组件" class="headerlink" title="CocoaPod的核心组件"></a>CocoaPod的核心组件</h2><ul><li>CocoaPods/CocoaPod<br>这是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 <code>CocoaPods</code> 涉及到的功能，并且还能通过调用所有其它的 <code>gems</code> 来执行任务。</li><li>CocoaPods/Core<br><code>Core</code> 组件提供支持与 <code>CocoaPods</code> 相关文件的处理，文件主要是 <code>Podfile</code> 和 <code>podspecs</code>。</li><li>Podfile<br><code>Podfile</code> 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <code>Podfile</code> 指南。</li><li>Podspec<br><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、<code>framework</code>、编译选项和某个库所需要的依赖等。</li><li>CocoaPods/Xcodeproj<br>这个 <code>gem</code> 组件负责所有工程文件的整合。它能够创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 <code>gem</code> 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 <code>gem</code>。</li></ul><h2 id="私有库开发流程"><a href="#私有库开发流程" class="headerlink" title="私有库开发流程"></a>私有库开发流程</h2><p>一般公司都会搭建自己的 <code>git</code> 服务器，在实战项目中，经常使用 <code>Cocoapods</code> 管理自己的私有库。</p><ul><li><code>git</code> 仓库至少需要两个，一个用于管理私有库对应版本的 <code>podspec</code> 文件，一个用于存放私有库的源文件。</li><li>查看现有的 <code>podspec</code> 源地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建一个私有的-podspec-主要包括如下几步："><a href="#创建一个私有的-podspec-主要包括如下几步：" class="headerlink" title="创建一个私有的 podspec 主要包括如下几步："></a>创建一个私有的 <code>podspec</code> 主要包括如下几步：</h3><ul><li>创建一个私有的 <code>Spec Repo</code>，用于管理私有库对应版本的 <code>podspec</code> 文件；</li><li>创建 <code>pod</code> 私有库所需要的项目工程文件，并上传到私有库；</li><li>创建 <code>pod</code> 所对应的 <code>podspec</code> 文件，并进行验证／测试；</li><li>向私有的 <code>Spec Repo</code> 中提交 <code>podspec</code>；</li><li>使用 <code>pod</code> 库；</li></ul><h3 id="创建一个私有的-Spec-Repo"><a href="#创建一个私有的-Spec-Repo" class="headerlink" title="创建一个私有的 Spec Repo"></a>创建一个私有的 <code>Spec Repo</code></h3><ul><li>在自己公司的 <code>git</code> 服务器上创建 <code>SpecsRepo</code> 仓库；</li><li>将私有 <code>SpecsRepo</code> 关联到本地；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add IMXSpecsRepo http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure></li></ul><p>查看 <code>SpecsRepo</code> 是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure><h3 id="创建-pod-私有库所需要的项目工程"><a href="#创建-pod-私有库所需要的项目工程" class="headerlink" title="创建 pod 私有库所需要的项目工程"></a>创建 pod 私有库所需要的项目工程</h3><h4 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create 仓库名字 --template-url&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXPodTemplte</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>手动创建</p><p>手动创建 <code>Xcode</code> 工程项目，创建 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create XXXX.podspec</span><br></pre></td></tr></table></figure><p>修改 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name             &#x3D; &#39;AKCBrowser&#39;</span><br><span class="line">  s.version          &#x3D; &#39;0.0.1&#39;</span><br><span class="line">  s.summary          &#x3D; &#39;A short description of AKCBrowser.&#39;</span><br><span class="line"></span><br><span class="line">  # This description is used to generate tags and improve search results.</span><br><span class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">  #   * Try to keep it short, snappy and to the point.</span><br><span class="line">  #   * Write the description between the DESC delimiters below.</span><br><span class="line">  #   * Finally, don&#39;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">  TODO: Add long description of the pod here.</span><br><span class="line">  DESC</span><br><span class="line"></span><br><span class="line">  s.homepage         &#x3D; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;</span><br><span class="line">  # s.screenshots     &#x3D; &#39;www.example.com&#x2F;screenshots_1&#39;, &#39;www.example.com&#x2F;screenshots_2&#39;</span><br><span class="line">  s.license          &#x3D; &#123; :type &#x3D;&gt; &#39;MIT&#39;, :file &#x3D;&gt; &#39;LICENSE&#39; &#125;</span><br><span class="line">  s.author           &#x3D; &#123; &#39;sunjinshuai&#39; &#x3D;&gt; &#39;s_mike@163.com&#39; &#125;</span><br><span class="line">  s.source           &#x3D; &#123; :git &#x3D;&gt; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line"></span><br><span class="line">  s.static_framework      &#x3D; true</span><br><span class="line">  s.requires_arc &#x3D; true</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;, &#39;Foundation&#39;</span><br><span class="line">  s.ios.deployment_target &#x3D; &#39;8.0&#39;</span><br><span class="line">  s.xcconfig &#x3D; &#123;</span><br><span class="line">    &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;MAS_SHORTHAND_GLOBALS&#x3D;1&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  s.resource_bundles &#x3D; &#123;</span><br><span class="line">    &#39;Browser&#39; &#x3D;&gt; [&#39;AKCBrowser&#x2F;Assets&#x2F;Browser&#x2F;*.*&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">  s.source_files &#x3D; &#39;AKCBrowser&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line"></span><br><span class="line">  s.dependency &#39;SDWebImage&#39;,&#39;4.2.3&#39;</span><br><span class="line">  s.dependency &#39;YYImage&#39;</span><br><span class="line">  s.dependency &#39;AKCFoundation&#39;</span><br><span class="line">  s.dependency &#39;AFNetworking&#x2F;Reachability&#39;</span><br><span class="line">  s.dependency &#39;SVProgressHUD&#39;</span><br><span class="line">  s.dependency &#39;AKCLog&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="podspec-语法简介"><a href="#podspec-语法简介" class="headerlink" title="podspec 语法简介"></a>podspec 语法简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure><p>更多语法查看(<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="noopener">http://guides.cocoapods.org/making/specs-and-specs-repo.html</a>)</p><h3 id="上传项目工程的源文件"><a href="#上传项目工程的源文件" class="headerlink" title="上传项目工程的源文件"></a>上传项目工程的源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><h3 id="验证-podspec-文件"><a href="#验证-podspec-文件" class="headerlink" title="验证 podspec 文件"></a>验证 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings --verbose</span><br><span class="line">pod lib lint --use-libraries --allow-warnings   &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line">pod lib lint --sources&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure><p>当看到 <code>AKCBrowser passed validation</code>。表示验证通过。</p><h3 id="向-Spec-Repo-中提交-podspec-文件"><a href="#向-Spec-Repo-中提交-podspec-文件" class="headerlink" title="向 Spec Repo 中提交 podspec 文件"></a>向 Spec Repo 中提交 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings</span><br><span class="line">pod repo push IMXSpecsRepo AKCProtobuf.podspec --allow-warnings --use-libraries  &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line"></span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings --sources&#x3D;&#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;ddcang&#x2F;iOSGiftBox&#x2F;SpecsRepo.git&#39;</span><br></pre></td></tr></table></figure><h2 id="多-target-时-Podfile-该如何写"><a href="#多-target-时-Podfile-该如何写" class="headerlink" title="多 target 时 Podfile 该如何写"></a>多 target 时 Podfile 该如何写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line"></span><br><span class="line">def commonPods #通用pods集</span><br><span class="line">    pod &#39;AFNetworking&#39;, &#39;~&gt; 2.0&#39;</span><br><span class="line">    pod &#39;Masonry&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def appOnlyPods #app专用pods集</span><br><span class="line">    pod &#39;MBProgressHUD&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def extensionPods #扩展专用pods集</span><br><span class="line">    pod &#39;GTSDKExtension&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :TestCocoaPods do</span><br><span class="line">    commonPods</span><br><span class="line">    appOnlyPods</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsTests do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsUITests do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # Pods for testing</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :SecondTarget do</span><br><span class="line">    commonPods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="如何忽略Pods警告"><a href="#如何忽略Pods警告" class="headerlink" title="如何忽略Pods警告"></a>如何忽略Pods警告</h2><p>在 <code>Podfile</code> 中对应的 <code>target</code> 或分组下加上关键字 <code>inhibit_all_warnings</code>即可。</p><h2 id="如何直接引用第三方库中的头文件"><a href="#如何直接引用第三方库中的头文件" class="headerlink" title="如何直接引用第三方库中的头文件"></a>如何直接引用第三方库中的头文件</h2><p>在用 <code>CocoaPods</code> 集成第三方库之后，默认情况下，我们需要使用类似 <code>#import &lt;XXX/YYY.h&gt;</code>的方式引入第三方库的头文件。</p><p>可以在 <code>Build Settings -&gt; User Header Search Paths</code> 中添加 <code>${SRCROOT}</code> 并设置成 <code>recursive</code>，这样我们就可以直接使用 <code>#impot &quot;YYY.h&quot;</code>这种方式了。</p><p>pod install 和 pod update 的选择</p><p>pod install：</p><p>按照官方文档所说，<code>pod install</code>在第一次检索集成第三方以及每一次在 <code>Podfile</code> 中新增、更改或删除 pod 的时候使用。每一次执行 <code>pod install</code>命令，它都会下载安装新的 <code>pod</code>，并且会把每一个安装的 <code>pod</code> 的版本信息写入 <code>Podfile.lock</code> 文件。<code>Podfile.lock</code> 文件跟踪每一个安装的 <code>pod</code> 的版本并且上锁。每一次执行 <code>pod install</code>命令，只解决还没有在 <code>Podfile.lock</code> 中列出的依赖：对于已在 Podfile.lock 中列出的 <code>pod</code>，会下载指定的版本，不会检查是否有新版本。对于没有在 <code>Podfile.lock</code> 中列出的 <code>pod</code>，它会搜索并安装 <code>Podfile</code> 中指定的版本。</p><p>pod update：</p><p>直接执行 <code>pod update</code>命令会检查安装 <code>Podfile</code> 中列出的所有 <code>pod</code> 的最新版本。只有当你想要更新 <code>pod</code> 库的版本时才使用 <code>pod update</code>；它不管 <code>Podfile.lock</code>是否存在，都会读取 <code>Podfile</code> 文件的最新版本，下载好之后，重新生成 <code>Podfile.lock</code>文件。</p><p>两者的区别：</p><ul><li><p>用 <code>pod install</code>命令来安装新的 <code>pod</code>，每次在 <code>Podfile</code> 中新增和删除 <code>pod</code> 都使用 <code>pod install</code>命令。</p></li><li><p>在 <code>Podfile</code> 中添加新的 <code>pod</code> 后应该用 <code>pod install</code>命令，而不是 <code>pod update</code>命令。通过 <code>pod install</code>命令安装新的 <code>pod</code> 而不用担心在同一进程中修改已有的 <code>pod</code>。</p></li><li><p><code>pod update</code>命令仅用在更新指定 <code>pod</code> 到指定版本或者更新所有 <code>pod</code>。</p></li></ul><p>如果想更新指定的 <code>pod</code> 仓库，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update XXX –no-repo-update</span><br></pre></td></tr></table></figure><p>如果想安装新添加的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install –no-repo-update</span><br></pre></td></tr></table></figure><p>当需要在 <code>CocoaPods</code> 中删除一个我们不要的库时 可以在 <code>Podfile</code> 中直接删除相关库；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod update --no-repo-update 会在删除相关库时 更新其他库版本</span><br><span class="line">pod update XXX --no-repo-update 只会删除相关库 和下方一致</span><br><span class="line">pod install --no-repo-update 只会删除相关库</span><br></pre></td></tr></table></figure><p>关于版本指定约束</p><p>一般我们在使用 <code>cocoapods</code> 导入第三方库前都会生成一个 <code>podfile</code> 文件，文件中记录着我们要导入的第三方库以及对应的版本信息，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39;, &#39;~&gt; 4.3.2&#39;</span><br></pre></td></tr></table></figure><p>让 <code>cocoapods</code> 导入 <code>SDWbImage</code>，版本号 <code>4.3.2</code> 和版本号处于 <code>4.3.2-4.4</code> 之间的，不包括 <code>4.4</code> 和更高版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39; --- 不指定版本，表示希望使用最新版本</span><br><span class="line">pod &#39;SDWebImage&#39;, &#39;4.3.2&#39; --- 指定明确版本，表示只想要这个版本</span><br><span class="line">逻辑关系</span><br><span class="line">&#39;&gt; 0.1&#39; --- 版本号大于0.1的</span><br><span class="line">&#39;&gt;&#x3D; 0.1&#39; --- 版本0.1和版本号大于0.1的</span><br><span class="line">&#39;&lt; 0.1&#39; --- 版本号小于0.1的</span><br><span class="line">&#39;&lt;&#x3D; 0.1&#39; --- 版本号0.1和版本号小于0.1的</span><br><span class="line">最优匹配</span><br><span class="line">&#39;~&gt; 0.1.2&#39; --- 版本0.1.2和版本号处于0.1.2-0.2之间的,不包括0.2和更高版本</span><br><span class="line">&#39;~&gt; 0.1&#39; --- 版本0.1和版本号处于0.1-1.0之间的,不包括1.0和更高版本</span><br><span class="line">&#39;~&gt; 0&#39; --- 版本0和更高，和没设没啥区</span><br></pre></td></tr></table></figure><p>tag 改动原则:  </p><ul><li>增加 api，修改第三位;   </li><li>修改 api，修改第二位；</li><li>大版本变更修改第一位;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CocoaPods简介&quot;&gt;&lt;a href=&quot;#CocoaPods简介&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods简介&quot;&gt;&lt;/a&gt;CocoaPods简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CocoaPods&lt;/code&gt; 是专门为 &lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git 奇技淫巧</title>
    <link href="https://sunjinshuai.github.io/2019/07/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>https://sunjinshuai.github.io/2019/07/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</id>
    <published>2019-07-12T13:45:47.000Z</published>
    <updated>2020-01-10T03:30:53.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><h2 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h2><p>例如：1.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 1.0.0 -m &quot;1.0.0 版本的备注信息.&quot;</span><br></pre></td></tr></table></figure><h2 id="推送所有-tag，同步到远程仓库："><a href="#推送所有-tag，同步到远程仓库：" class="headerlink" title="推送所有 tag，同步到远程仓库："></a>推送所有 tag，同步到远程仓库：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="删除本地-Tag"><a href="#删除本地-Tag" class="headerlink" title="删除本地 Tag"></a>删除本地 Tag</h2><p>例如：1.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 1.0.0</span><br></pre></td></tr></table></figure><p>删除远程标签需要先删除本地标签，再执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;1.0.0</span><br><span class="line">git push origin --delete tag 1.0.0</span><br></pre></td></tr></table></figure><h2 id="展示当前分支的最近的tag"><a href="#展示当前分支的最近的tag" class="headerlink" title="展示当前分支的最近的tag"></a>展示当前分支的最近的tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev&#x3D;0</span><br></pre></td></tr></table></figure><h2 id="默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag："><a href="#默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag：" class="headerlink" title="默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag："></a>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;version-number&gt; -m &quot;v1.0.0 发布(描述)&quot; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v &#39;^\*\|  master&#39; | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><h2 id="列出远程服务器和本地的所有分支，以及分支上的最后提交"><a href="#列出远程服务器和本地的所有分支，以及分支上的最后提交" class="headerlink" title="列出远程服务器和本地的所有分支，以及分支上的最后提交"></a>列出远程服务器和本地的所有分支，以及分支上的最后提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="列出所有远程服务器上的分支"><a href="#列出所有远程服务器上的分支" class="headerlink" title="列出所有远程服务器上的分支"></a>列出所有远程服务器上的分支</h2><p>-r参数相当于：remote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="同步本地与远程分支"><a href="#同步本地与远程分支" class="headerlink" title="同步本地与远程分支"></a>同步本地与远程分支</h2><p>删除远程不存在的本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --p</span><br></pre></td></tr></table></figure><h2 id="更新远程跟踪分支"><a href="#更新远程跟踪分支" class="headerlink" title="更新远程跟踪分支"></a>更新远程跟踪分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1><h2 id="合并本地的最后两次-commit"><a href="#合并本地的最后两次-commit" class="headerlink" title="合并本地的最后两次 commit"></a>合并本地的最后两次 commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^git commit --amend</span><br></pre></td></tr></table></figure><h2 id="修改上一次的-commit-信息"><a href="#修改上一次的-commit-信息" class="headerlink" title="修改上一次的 commit 信息"></a>修改上一次的 commit 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  #默认就是-mixed参数。</span><br><span class="line">git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span><br><span class="line">git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   </span><br><span class="line">git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span><br></pre></td></tr></table></figure><h2 id="查看指定路径文件代码是谁写的"><a href="#查看指定路径文件代码是谁写的" class="headerlink" title="查看指定路径文件代码是谁写的"></a>查看指定路径文件代码是谁写的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="删除远程仓库地址"><a href="#删除远程仓库地址" class="headerlink" title="删除远程仓库地址"></a>删除远程仓库地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><p>暂存命令stash使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash #将本地修改暂时存储起来</span><br><span class="line">git stash list #查看暂存的信息</span><br><span class="line">git stash pop  #应用最近一次暂存的内容</span><br><span class="line">git stash apply stash@&#123;1&#125; #应用指定版本的暂存内容</span><br><span class="line">git stash clear  #清空暂存栈</span><br><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt; #从stash中拿出某个文件的修改</span><br></pre></td></tr></table></figure><h1 id="Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法"><a href="#Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法" class="headerlink" title="Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法"></a>Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法</h1><p>例如：取消某次合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort #如果Git版本 &gt;&#x3D; 1.7.4</span><br><span class="line">git reset --merge #如果Git版本 &gt;&#x3D; 1.6.1</span><br></pre></td></tr></table></figure><p>注意：<br>在合并之前要保证没有未提交的文件，如果有未提交的文件但现在又不想提交，用stash命令暂存。</p><p>回退到某个版本并应用指定的几次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1d7444 #回退到某个版本</span><br><span class="line">git cherry-pick 626335 #将某次commit的更改应用到当前版本</span><br><span class="line">git cherry-pick …</span><br><span class="line">git push origin HEAD --force  #强制提交</span><br></pre></td></tr></table></figure><p>注意：<br>如果是撤销某次提交，可以用revert命令，git revert是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留; git reset是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区。</p><h1 id="git强制push"><a href="#git强制push" class="headerlink" title="git强制push"></a>git强制push</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure><h1 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h1><p>不添加参数，默认是-mixed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h1 id="撤销所有未提交的本地修改"><a href="#撤销所有未提交的本地修改" class="headerlink" title="撤销所有未提交的本地修改"></a>撤销所有未提交的本地修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h1 id="Push-本地分支到指定远程分支"><a href="#Push-本地分支到指定远程分支" class="headerlink" title="Push 本地分支到指定远程分支"></a>Push 本地分支到指定远程分支</h1><p>例如：Push 本地当前分支到远程仓库 origin 的 master 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tag&quot;&gt;&lt;a href=&quot;#Tag&quot; class=&quot;headerlink&quot; title=&quot;Tag&quot;&gt;&lt;/a&gt;Tag&lt;/h1&gt;&lt;h2 id=&quot;添加-Tag&quot;&gt;&lt;a href=&quot;#添加-Tag&quot; class=&quot;headerlink&quot; title=&quot;添加 Tag&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 __attribute__</title>
    <link href="https://sunjinshuai.github.io/2019/02/25/%E6%B5%85%E8%B0%88-attribute/"/>
    <id>https://sunjinshuai.github.io/2019/02/25/%E6%B5%85%E8%B0%88-attribute/</id>
    <published>2019-02-25T03:16:35.000Z</published>
    <updated>2020-01-10T03:17:54.115Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code> 是一个编译器指令，其实是 <code>GNU C</code> 的一种机制，本质是一个编译器的指令，在声明的时候可以提供一些属性，在编译阶段起作用，来做多样化的错误检查和高级优化。用于在 <code>C</code>、<code>C++</code>、<code>Objective-C</code> 中修饰变量、函数、参数、方法、类等。</p><p>合理使用 <code>__attribute__</code> 有什么好处？</p><ul><li>给编译器提供上下文，帮助编译器做优化，合理使用可以收到显著的优化效果。</li><li>编译器会根据 <code>__attribute__</code> 产生一些编译警告，使代码更规范。</li><li>给代码阅读者提供必要的注解，助其理解代码意图。</li></ul><p><strong>总之，<code>__attribute__</code> 起到了给编译器提供上下文的作用，如果错误的使用 <code>__attribute__</code> 指令，因为给编译器提供了错误的上下文，由此引起的错误通常很难被发现。</strong></p><h1 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h1><p>适用于方法、属性。告诉编译器已经过时，如果使用了，会报过时警告</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以自定义描述信息</span><br><span class="line">__attribute__((deprecated(&quot;已过期!&quot;)))</span><br><span class="line">&#x2F;&#x2F; 系统的宏定义</span><br><span class="line">DEPRECATED_ATTRIBUTE</span><br></pre></td></tr></table></figure><p>使用场景：</p><p>在组件化、<code>SDK</code> 的时候，因为某个需求，我们升级了 <code>API</code>，但是需要兼容老的版本，并且希望使用者调用最新的 <code>API</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 标记这个属性已过期</span><br><span class="line">@property (nonatomic, copy) NSString *name __attribute__((deprecated(&quot;属性已过期&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 标记方法已过期</span><br><span class="line">- (void)testOld __attribute__((deprecated(&quot;方法已过期, 请使用 test2&quot;))) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testNew &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译器警告，&#39;testOld&#39; is deprecated: 已过期, 请使用 testNew</span><br><span class="line">    [self testOld];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译器警告，提示 &quot;&#39;name&#39; 已过期...&quot;</span><br><span class="line">    NSLog(@&quot;%@&quot;, self.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unavailable"><a href="#unavailable" class="headerlink" title="unavailable"></a>unavailable</h1><p>适用于方法、属性。告诉编译器不可用。如果使用了，就会编译失败，提示错误信息</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以自定义描述信息</span><br><span class="line">__attribute__((unavailable(&quot;已经废弃,请使用 xxxx&quot;)))</span><br><span class="line">&#x2F;&#x2F; 系统宏定义</span><br><span class="line">NS_UNAVAILABLE;</span><br><span class="line">UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure><p>使用场景：</p><p>自定义了 <code>Class</code> 的初始化方法，不希望外界使用 <code>init</code> 初始化，并且给出正确的提示。<br>比希望继续使用某个属性，并且给出正确的提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name __attribute__((unavailable(&quot;这个属性已经废弃&quot;)));</span><br><span class="line"></span><br><span class="line">#pragma mark - 初始化</span><br><span class="line">- (instancetype)init __attribute__((unavailable(&quot;这个方法已经废弃,请使用 initWithName:&quot;)));</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)Name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void) test &#123;</span><br><span class="line">    &#x2F;&#x2F; 编译不通过，提示 &quot;&#39;init&#39; 已经废弃了...&quot;</span><br><span class="line">    ViewController *vc &#x3D; [[ViewController alloc] init];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译不通过，提示 &quot;&#39;name&#39; 已经废弃了...&quot;</span><br><span class="line">    NSLog(@&quot;%@&quot;, vc.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h1><p>适用于 <code>Class</code>。告诉编译器我不能有子类，类似 <code>final</code> 关键字</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface ClangTest : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ClangTest.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里编译出错，提示“Cannot subclass a class that was declared with the &#39;objc_subclassing_restricted&#39; attribute”</span><br><span class="line">@interface ClangSonTest : ClangTest</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h1><p>适用于方法。告诉编译器子类重写这个方法的时候，必须调用[Super xxx]</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通用写法</span><br><span class="line">__attribute__((objc_requires_super))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统宏定义，其实和上面是一样的</span><br><span class="line">NS_REQUIRES_SUPER</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ClangTest : NSObject</span><br><span class="line"></span><br><span class="line">- (void)instanceMethod1 __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;ClangTest.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ClangSonTest : KDClangTest</span><br><span class="line">@end</span><br><span class="line">@implementation KDClangSonTest</span><br><span class="line"></span><br><span class="line">- (void)instanceMethod1 &#123;</span><br><span class="line">    NSLog(@&quot;I am son&quot;);</span><br><span class="line">    &#x2F;&#x2F; 这里编译器会出现警告： Method possibly missing a [super instanceMethod1] call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="constructor-与-destructor"><a href="#constructor-与-destructor" class="headerlink" title="constructor 与 destructor"></a>constructor 与 destructor</h1><p>使用 <code>constructor</code> 属性修饰的函数能在 <code>main()</code> 函数之前执行，而使用 <code>destructor</code> 属性修饰的函数，在 <code>main()</code> 函数结束或 <code>exit()</code> 函数调用后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main之前调用</span><br><span class="line">__attribute__((constructor))</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) void before_main() &#123;</span><br><span class="line">    printf(&quot;app before main\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) void after_main() &#123;</span><br><span class="line">    printf(&quot;app after main\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    printf(&quot;excute main\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>因为 <code>load</code> 是在 <code>class</code> 被加载的时候，就执行了，所以早于 <code>constructor</code>。<br>所以顺序应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load -&gt; attribute((constructor)) -&gt; main -&gt; attribute((destructor)) -&gt; initialize</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://nshipster.cn/__attribute__/" target="_blank" rel="noopener">https://nshipster.cn/__attribute__/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个编译器指令，其实是 &lt;code&gt;GNU C&lt;/code&gt; 的一种机制，本质是一个编译器的指令，在声明的时候可以提供一些属性，在编译阶段起作用，来做多样化的错误检查和高级优化。用于在 &lt;code&gt;C&lt;/code&gt;、&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 iOS ARC 内存管理</title>
    <link href="https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-02-13T09:15:20.000Z</published>
    <updated>2020-01-10T03:16:03.779Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 采用的是引用计数式的内存管理方式：</p><ul><li>自己生成的对象自己持有。</li><li>非自己生成的对象自己也能持有。</li><li>自己持有的对象不再需要时释放。</li><li>非自己持有的对象自己无法释放。</li></ul><p>在 ARC 环境下，id 类型和对象类型和 C 语言其他类型不同，类型前必须加上所有权的修饰符。<br>所有权修饰符总共有4种：</p><ul><li>__strong</li><li>__weak</li><li>__autoreleasing</li><li>__unsafe_unretained</li></ul><h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h2><p><code>__strong</code> 表示强引用，对应定义 <code>property</code> 时用到的 <code>strong</code>。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 <code>nil</code>。<code>__strong</code> 修饰符是 <code>id</code> 类型和对象类型默认的所有权修饰符。</p><h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 <code>weak</code>。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 <code>nil</code>，这样可以防止野指针。<code>__weak</code> 最常见的一个作用就是用来避免强引用循环。</p><p><code>__weak</code> 的几个使用场景：</p><ul><li>在 <code>Delegate</code> 关系中防止强引用循环。在 ARC 特性下，通常我们应该设置 <code>Delegate</code> 属性为 <code>weak</code> 的。但是这里有一个疑问，我们常用到的 <code>UITableView</code> 的 <code>delegate</code> 属性是这样定义的： <code>@property (nonatomic, assign) id&lt;UITableViewDelegate&gt; delegate;</code>，为什么用的修饰符是 <code>assign</code> 而不是 <code>weak</code>？其实这个 <code>assign</code> 在 ARC 中意义等同于 <code>__unsafe_unretained</code>（后面会讲到），它是为了在 <code>ARC</code> 特性下兼容 <code>iOS4</code> 及更低版本来实现弱引用机制。一般情况下，你应该尽量使用 <code>weak</code>。</li><li>在 <code>Block</code> 中防止强引用循环。</li><li>用来修饰指向由 <code>Interface Builder</code> 创建的控件。比如：<code>@property (nonatomic, weak) IBOutlet UIButton *testButton;</code>。</li></ul><p>另外，<code>__weak</code> 修饰符的变量，会被注册到 <code>autoreleasePool</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 &#x3D; obj;</span><br><span class="line">    NSLog(@&quot;obj2-%@&quot;,obj1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器转换上述代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initweak(&amp;obj1,obj);</span><br><span class="line">id tmp &#x3D; objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;,tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><p><code>objc_loadWeakRetained</code> 函数获取附有 <code>__weak</code> 修饰符变量所引用的对象并 <code>retain</code>, <code>objc_autorelease</code> 函数将对象放入 <code>autoreleasePool</code> 中，据此当我们访问 <code>weak</code> 修饰指针指向的对象时，实际上是访问注册到自动释放池的对象。因此，如果大量使用 <code>weak</code> 的话，在我们去访问 <code>weak</code> 修饰的对象时，会有大量对象注册到自动释放池,这会影响程序的性能。</p><p>解决方案：<br>要访问 <code>weak</code> 修饰的变量时，先将其赋给一个 <code>strong</code> 变量，然后进行访问。</p><p>为什么访问 <code>weak</code> 修饰的对象就会访问注册到自动释放池的对象呢?</p><p>因为 <code>weak</code> 不会引起对象的引用计数器变化，因此，该对象在运行过程中很有可能会被释放。所以，需要将对象注册到自动释放池中并在 <code>autoreleasePool</code> 销毁时释放对象占用的内存。</p><h2 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h2><p>在 <code>ARC</code> 模式下，我们不能显示的使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，通过将对象赋给 <code>__autoreleasing</code> 修饰的变量就能达到在 <code>MRC</code> 模式下调用对象的 <code>autorelease</code> 方法同样的效果。</p><p><code>__autoreleasing</code> 修饰的对象会被注册到 <code>Autorelease Pool</code> 中，并在 <code>Autorelease Pool</code> 销毁时被释放。</p><p><strong>注意：定义 <code>property</code> 时不能使用这个修饰符，因为任何一个对象的 <code>property</code> 都不应该是 <code>autorelease</code> 类型的。</strong></p><h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h2><p><code>ARC</code> 是在 <code>iOS5</code> 引入的，而 <code>__unsafe_unretained</code> 这个修饰符主要是为了在 <code>ARC</code> 刚发布时兼容 <code>iOS4</code> 以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义 <code>property</code> 时对应的是 <code>unsafe_unretained</code>。<code>__unsafe_unretained</code> 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 <code>retainCount +1</code>。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 <code>nil</code>，所以成为了野指针，非常不安全。</p><p><code>__unsafe_unretained</code> 的应用场景：</p><ul><li>在 ARC 环境下但是要兼容 iOS4.x 的版本，用 <code>__unsafe_unretained</code> 替代 <code>__weak</code> 解决强引用循环的问题。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结， <code>autorelease</code> 的机制却依然在很多地方默默起着作用，我们来看看这些场景：</p><ul><li>方法返回值。</li><li>访问 __weak 修饰的变量。</li><li>id 的指针或对象的指针(id *)。</li></ul><h3 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h3><p>首先，我们看这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  (NSMutableArray *)array  &#123;</span><br><span class="line">    NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(array);</span><br><span class="line">objc_release(array);</span><br></pre></td></tr></table></figure><p>这里 <code>array</code> 的所有权修饰符是默认的 <code>__strong</code>。由于 <code>return</code> 使得 <code>array</code> 超出其作用域，它强引用持有的对象本该被释放，但是由于该对象作为函数返回值，所以<strong>一般情况下编译器会自动将其注册到 <code>AutoreleasePool</code> 中（注意这里是一般情况下，在一些特定情况下，<code>ARC</code> 机制提出了巧妙的运行时优化方案来跳过 <code>autorelease</code> 机制。）</strong>。</p><h4 id="ARC-模式下方法返回值跳过-autorelease-机制的优化方案"><a href="#ARC-模式下方法返回值跳过-autorelease-机制的优化方案" class="headerlink" title="ARC 模式下方法返回值跳过 autorelease 机制的优化方案"></a>ARC 模式下方法返回值跳过 autorelease 机制的优化方案</h4><p>为什么方法返回值的时候需要用到 <code>autorelease</code>机制呢？</p><p>当对象被作为参数返回 <code>return</code> 之后，如果调用者需要使用就需要强引用它，那么它 <code>retainCount + 1</code>，用完之后再清理，使它 <code>retainCount - 1</code>。</p><p>如果在方法中创建了对象并作为返回值时，根据 <code>ARC</code> 内存管理的原则，谁创建谁释放。既然作为返回值，就必须保证返回时对象没被释放以便方法外的调用者能拿到有效的对象，否则你返回的是 nil，有何意义呢。所以就需要找一个合理的机制既能延长这个对象的生命周期，又能保证对其释放。这个机制就是 <code>autorelease 机制</code>。</p><p><code>ARC</code> 模式下在方法 <code>return</code> 的时候，会调用 <code>objc_autoreleaseReturnValue()</code><br>方法替代 <code>autorelease</code>。在调用者强引用方法返回对象的时候，会调用 <code>objc_retainAutoreleasedReturnValue()</code> 方法，该方法会去检查该方法或者调用方的执行命令列表，是否会被传给 <code>objc_retainAutoreleasedReturnValue()</code> 方法。如果里面有 <code>objc_retainAutoreleasedReturnValue()</code> 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 <code>autoreleasepool</code>中，也可以返回拿到相应的对象。如果没传，那么它就会走 <code>autorelease</code> 的过程注册到 <code>autoreleasepool</code> 中。</p><h3 id="访问-weak-修饰的变量"><a href="#访问-weak-修饰的变量" class="headerlink" title="访问 __weak 修饰的变量"></a>访问 __weak 修饰的变量</h3><p>在访问 <code>__weak</code> 修饰的变量时，实际上必定会访问注册到 <code>AutoreleasePool</code> 的对象。如下来年两段代码是相同的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [obj1 class]);</span><br><span class="line">&#x2F;&#x2F; 等同于：</span><br><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">id __autoreleasing tmp &#x3D; obj1;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [tmp class]);</span><br></pre></td></tr></table></figure><p>为什么会这样呢？因为 <code>__weak</code> 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 <code>AutoreleasePool</code> 中，就能保证 <code>AutoreleasePool</code> 被销毁前对象是存在的。</p><h3 id="id-的指针或对象的指针-id"><a href="#id-的指针或对象的指针-id" class="headerlink" title="id 的指针或对象的指针(id *)"></a>id 的指针或对象的指针(id *)</h3><p>另一个隐式地使用 <code>__autoreleasing</code> 的例子就是使用 id 的指针或对象的指针(id *) 的时候。</p><p>看一个最常见的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSError *__autoreleasing error;</span><br><span class="line">￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123;</span><br><span class="line">    　　NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 即使上面你没有写 __autoreleasing 来修饰 error，编译器也会帮你做下面的事情：</span><br><span class="line">NSError *error;</span><br><span class="line">NSError *__autoreleasing tempError &#x3D; error; &#x2F;&#x2F; 编译器添加</span><br><span class="line">if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError])</span><br><span class="line">￼&#123;</span><br><span class="line">    　　error &#x3D; tempError; &#x2F;&#x2F; 编译器添加</span><br><span class="line">    　　NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error</code> 对象在你调用的方法中被创建，然后被放到 <code>AutoreleasePool</code> 中，等到使用结束后随着 <code>AutoreleasePool</code> 的销毁而释放，所以函数外 <code>error</code> 对象的使用者不需要关心它的释放。</p><p>在 <code>ARC</code> 中，所有这种指针的指针类型<code>（id *）</code>的函数参数如果不加修饰符，编译器会默认将他们认定为 <code>__autoreleasing</code> 类型。</p><p>有一点特别需要注意的是，某些类的方法会隐式地使用自己的 <code>AutoreleasePool</code>，在这种时候使用 <code>__autoreleasing</code> 类型要特别小心。比如 <code>NSDictionary</code> 的 <code>enumerateKeysAndObjectsUsingBlock</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; do stuff</span><br><span class="line">        if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">            *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; ￼code:1 userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        ￼</span><br><span class="line">    &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中其实会隐式地创建一个 <code>AutoreleasePool</code>，类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        @autoreleasepool &#123;  &#x2F;&#x2F; 被隐式创建。</span><br><span class="line">            if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">                *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; ￼code:1 userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            ￼          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#x2F;&#x2F; *error 在这里已经被dict的做枚举遍历时创建的 Autorelease Pool释放掉了。</span><br><span class="line">    ￼&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够正常的使用 <code>*error</code>，我们需要一个 <code>strong</code> 类型的临时引用，在 <code>dict</code> 的枚举 <code>Block</code> 中是用这个临时引用，保证引用指向的对象不会在出了 <code>dict</code> 的枚举 <code>Block</code> 后被释放，正确的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    　　NSError * __block tempError; &#x2F;&#x2F; 加 __block 保证可以在Block内被修改。</span><br><span class="line">    　　[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        　　　　if (there is some error) &#123;</span><br><span class="line">            　　　　　　*tempError &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; ￼code:1 userInfo:nil];</span><br><span class="line">            　　　　&#125; ￼</span><br><span class="line">        　　&#125;]</span><br><span class="line">    　　if (error !&#x3D; nil) &#123;</span><br><span class="line">        　　　　*error &#x3D; tempError;</span><br><span class="line">        　　&#125; ￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C 采用的是引用计数式的内存管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己生成的对象自己持有。&lt;/li&gt;
&lt;li&gt;非自己生成的对象自己也能持有。&lt;/li&gt;
&lt;li&gt;自己持有的对象不再需要时释放。&lt;/li&gt;
&lt;li&gt;非自己持有的对象自己无法释放。&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈面向对象的六大设计原则</title>
    <link href="https://sunjinshuai.github.io/2018/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://sunjinshuai.github.io/2018/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2018-10-27T03:13:57.000Z</published>
    <updated>2020-01-10T03:14:33.156Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/588630-7d17a7d220c612f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="原则一、单一职责原则（Single Responsibility Principle，简称SRP ）"></a>原则一、单一职责原则（Single Responsibility Principle，简称SRP ）</h3><p>定义：应该有且仅有一个原因引起类的变更。</p><p>一个类只负责一项职责，如果发生变更时，可以考虑将一个类拆分成两个类，或者在一个类中添加新的方法。</p><p><strong>在真实的开发中，不仅仅是类、函数和接口也要遵循单一职责原则。即：一个函数负责一个功能。如果一个函数里面有不同的功能，则需要将不同的功能的函数分离出去。</strong></p><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li><li>类的可读性提高，复杂性减低。</li></ul><p>如果接口或者函数的单一职责做得好，一个接口或者函数的修改只对相应的类有影响，对其他接口或者函数无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><p>例如，需求上指出用一个类描述食肉和食草动物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 17:55:25.775317+0800 DesignPatterns[54087:24701786] 狼 吃肉</span><br><span class="line">2018-10-27 17:55:25.775689+0800 DesignPatterns[54087:24701786] 豹 吃肉</span><br><span class="line">2018-10-27 17:55:25.775721+0800 DesignPatterns[54087:24701786] 虎 吃肉</span><br></pre></td></tr></table></figure><p>上线后，发现问题了，并不是所有的动物都是吃肉的，比如羊就是吃草的。修改时如果遵循单一职责原则，需要将 <code>Animal</code> 类细分为食草动物类 <code>Herbivore</code>，食肉动物 <code>Carnivore</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Herbivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Herbivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Herbivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Carnivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Carnivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Carnivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Animal *carnivore &#x3D; [Carnivore new];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">NSLog(@&quot;\n&quot;);</span><br><span class="line">Animal *herbivore &#x3D; [Herbivore new];</span><br><span class="line">[herbivore eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>在子类里面重写父类的 <code>eatWithAnimalName</code> 函数，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:04:49.189722+0800 DesignPatterns[54422:24725132] 狼 吃肉</span><br><span class="line">2018-10-27 18:04:49.190450+0800 DesignPatterns[54422:24725132] 豹 吃肉</span><br><span class="line">2018-10-27 18:04:49.190482+0800 DesignPatterns[54422:24725132] 虎 吃肉</span><br><span class="line">2018-10-27 18:04:49.190498+0800 DesignPatterns[54422:24725132] </span><br><span class="line">2018-10-27 18:04:49.190530+0800 DesignPatterns[54422:24725132] 羊 吃草</span><br></pre></td></tr></table></figure><p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加食肉动物和食草动物的其他功能，就可以直接在这两个类里面添加即可。但是，有一点，修改花销是很大的，除了将原来的类分解之外，还需要修改 <code>main</code> 函数 。而直接修改类 <code>Animal</code> 来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    if ([@&quot;羊&quot; isEqualToString:animalName]) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:16:10.910397+0800 DesignPatterns[54677:24751636] 狼 吃肉</span><br><span class="line">2018-10-27 18:16:10.911105+0800 DesignPatterns[54677:24751636] 豹 吃肉</span><br><span class="line">2018-10-27 18:16:10.911138+0800 DesignPatterns[54677:24751636] 虎 吃肉</span><br><span class="line">2018-10-27 18:16:10.911160+0800 DesignPatterns[54677:24751636] 羊 吃草</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。<br>但是却存在着隐患：<strong>有一天需求上增加牛和马也需要吃草，则又需要修改 <code>Animal</code> 类的 <code>eatWithAnimalName</code> 函数，而对原有代码的修改会对调用狼、豹和虎吃肉等功能带来风险，也许某一天你会发现运行结果变为虎也吃草了。</strong>这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃草</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃肉</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatGrassWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:31:30.321473+0800 DesignPatterns[55048:24787008] 狼 吃肉</span><br><span class="line">2018-10-27 18:31:30.321884+0800 DesignPatterns[55048:24787008] 豹 吃肉</span><br><span class="line">2018-10-27 18:31:30.321922+0800 DesignPatterns[55048:24787008] 虎 吃肉</span><br><span class="line">2018-10-27 18:31:30.321939+0800 DesignPatterns[55048:24787008] 羊 吃草</span><br></pre></td></tr></table></figure><p>通过运行结果可以看到，这种修改方式没有改动原来的函数，而是在类中新加了一个函数，这样虽然也违背了<strong>类单一职责原则</strong>，但在函数级别上却是符合单一职责原则的，因为它并没有动原来函数的代码。</p><p>在实际的开发应用中，有很多复杂的场景，怎么设计一个类或者一个函数，让应用程序更加灵活，是更多程序员们值得思考的，需要结合特定的需求场景，有可能有些类里面有很多的功能，但是切记不要将不属于这个类本身的功能也强加进来，这样不仅带来不必要的维护成本，也违反了<strong>单一职责的设计原则</strong>。</p><h3 id="原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）"><a href="#原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）" class="headerlink" title="原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）"></a>原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）</h3><p>定义：如果对一个类型为 <code>T1</code> 的对象 <code>o1</code>，都有类型为 <code>T2</code> 的对象 <code>o2</code>，使得以 <code>T1</code> 定义的所有程序 <code>P</code> 在所有的对象 <code>o1</code> 都替换成 <code>o2</code> 时，程序 <code>P</code> 的行为没有发生变化，那么类型 <code>T2</code> 是类型 <code>T1</code> 的子类型。有点拗口，通俗点讲，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应</strong>。</p><p>面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。当使用继承时，遵循里氏替换原则。但是使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生影响。子类可以扩展父类的功能，但不能改变父类原有的功能。</p><p>注意：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>比如，需要完成一个两数相加的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; A.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface A : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"></span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">A *a &#x3D; [[A alloc] init];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, [a addition:100 b:50]);</span><br><span class="line">NSLog(@&quot;100+80&#x3D;%ld&quot;, [a addition:100 b:80]);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 22:53:23.549358+0800 DesignPatterns[18063:363232] 100+50&#x3D;150</span><br><span class="line">2018-11-01 22:53:23.549586+0800 DesignPatterns[18063:363232] 100+80&#x3D;180</span><br></pre></td></tr></table></figure><p>接着，需求上需要增加一个新的功能，完成两数相加，然后再与 <code>100</code> 求差，由类 <code>B</code> 来负责。即类 <code>B</code> 需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加 <code>100</code>。</li></ul><p>由于类 <code>A</code> 已经实现了加法功能，所以 <code>B</code> 继承 <code>A</code> 之后，只需要完成减法功能就可以了，但是在类 <code>B</code> 中不小心重写了父类 <code>A</code> 的减法功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface B : A</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 减法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)subtraction:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">B *b &#x3D; [[B alloc] init];</span><br><span class="line">NSInteger sub &#x3D; [b addition:100 b:50];</span><br><span class="line">NSInteger difference &#x3D; [b subtraction:sub b:100];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, sub);</span><br><span class="line">NSLog(@&quot;100+100+50&#x3D;%ld&quot;, difference);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 23:15:06.530080+0800 DesignPatterns[18363:375940] 100+50&#x3D;5000</span><br><span class="line">2018-11-01 23:15:06.530758+0800 DesignPatterns[18363:375940] 100+100+50&#x3D;4900</span><br></pre></td></tr></table></figure><p>发现原本运行正常的相减功能发生了错误，原因就是类 <code>B</code> 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 <code>B</code> 重写后的方法，造成原本运行正常的功能出现了错误。如果按照“里氏替换原则”，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类</strong>，是不成立的。</p><p>在平时的日常开发中，通常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。</p><h3 id="原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）"><a href="#原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）" class="headerlink" title="原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）"></a>原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）</h3><p><strong>依赖倒置原则的核心思想是面向接口编程。</strong></p><p>定义：模块间的依赖通过抽象发生，高层模块和低层模块之间不应该发生直接的依赖关系，二者都应该是通过接口或抽象类产生的；即依赖抽象，而不依赖具体的实现。</p><p>例如：类 <code>A</code> 直接依赖类 <code>B</code>，假如要将类 <code>A</code> 改为依赖类 <code>C</code>，则必须通过修改类 <code>A</code> 的代码来达成。比如在这种场景下，业务逻辑层类 <code>A</code> 相对于数据层类 <code>B</code> 是高层模块，因为业务逻辑层需要调用数据层去连接数据库，如果业务逻辑层类 <code>A</code> 依赖数据层类 <code>B</code> 的话，那么将来需求变更，需要把旧的数据层类 <code>B</code> 修改为新的数据层类 <code>C</code>，就必须通过修改类 <code>A</code>，这样就会给应用程序带来不必要的风险。</p><p>解决方案：将类 <code>A</code> 修改为依赖接口 <code>I</code>，类 <code>B</code> 和类 <code>C</code> 各自实现接口 <code>I</code>，类 <code>A</code> 通过接口 <code>I</code> 间接与类 <code>B</code> 或者类 <code>C</code> 发生联系，则会大大降低修改类 <code>A</code> 的几率。要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。</p><p>比如：母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@class Book;</span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(Book *)book;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">[mother tellStory:book];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 14:52:08.759154+0800 DesignPatterns[6135:458778] 妈妈开始讲故事</span><br><span class="line">2018-11-09 14:52:08.759365+0800 DesignPatterns[6135:458778] 很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure><p>将来有一天，需求变更成，增加让母亲讲一下报纸上的故事的功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 报纸内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如果将 <code>Newspaper</code> 类替换 <code>Book</code> 类，发现母亲看不懂报纸上的故事，必须要修改 <code>Mother</code> 类里面的 <code>tellStory</code> 方法才能看不懂报纸上的故事。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code> 类，这显然不是好的设计，高层模块都依赖了低层模块的改动，因此上述设计不符合依赖倒置原则。<code>Mother</code> 类与 <code>Book</code> 类之间的耦合性太高了，必须降低他们之间的耦合度才行。</p><p>解决方案，将母亲讲故事的方法抽象一个接口或者 <code>Protocol</code>，让<code>Mother</code> 类不再依赖 <code>Newspaper</code> 和 <code>Book</code> 类具体实现，而是依赖抽象出来的接口或者 <code>Protocol</code>。并且 <code>Newspaper</code> 和 <code>Book</code> 类也都依赖这个抽象出来的接口或者 <code>Protocol</code>，通过实现接口或者 <code>Protocol</code> 来做自己的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>Mother</code> 类与接口 <code>IReader</code> 发生依赖关系，而 <code>Book</code> 和 <code>Newspaper</code> 都属于读物的范畴，他们各自都去实现 <code>IReader</code> 接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Mother</span><br><span class="line"></span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading &#123;</span><br><span class="line">    NSLog(@&quot;妈妈开始讲故事&quot;);</span><br><span class="line">    if ([reading respondsToSelector:@selector(theStoryContent)]) &#123;</span><br><span class="line">        [reading theStoryContent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">Newspaper *newspaper &#x3D; [Newspaper new];</span><br><span class="line">[mother tellStory:book];</span><br><span class="line">[mother tellStory:newspaper];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 15:28:01.182603+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182879+0800 DesignPatterns[7055:532924] 很久很久以前有一个阿拉伯的故事……</span><br><span class="line">2018-11-09 15:28:01.182916+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182955+0800 DesignPatterns[7055:532924] 雄鹿终结勇士八连胜……</span><br></pre></td></tr></table></figure><p>这样修改后，无论以后怎样扩展 main 函数，都不需要再修改 <code>Mother</code> 类了。这里只是举了一个比较简单的例子，在实际的项目开发中，尽可能的采用“低耦合，高内聚”的原则，<strong>采用依赖倒置原则给多人并行开发带来了极大的便利</strong>，无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><h3 id="原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="原则四、接口隔离原则（Interface Segregation Principle,简称ISP）"></a>原则四、接口隔离原则（Interface Segregation Principle,简称ISP）</h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#39;ClassB&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br><span class="line">Class &#39;ClassD&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br></pre></td></tr></table></figure><p><strong>注意：在 <code>Objective-C</code> 中的协议可以通过 <code>@optional</code> 关键字声明不需要必须实现的方法，这个只是 <code>Objective-C</code> 的一个特性，可以消除在 <code>ClassB</code> 和 <code>ClassD</code> 中没有实现 <code>InterfaceH</code> 的 <code>protocol</code> 协议。</strong></p><p>比如，类 A 依赖接口 H 中的方法1、方法2、方法5，类 B 是对类 A 依赖的实现。类 C 依赖接口 H 中的方法3、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法，但由于实现了接口 H，因为接口 <code>H</code> 对于类 <code>A</code> 和类 <code>C</code> 来说不是最小接口，所以也必须要实现这些用不到的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。</p><p><strong>解决方法：将臃肿的接口 <code>H</code> 拆分为独立的几个接口，类 <code>A</code> 和类 <code>C</code> 分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH1 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH2 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH1&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH2&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。在实际项目开发中，只暴露给调用的类需要的方法，不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，不要试图去建立一个很庞大的接口供所有依赖它的类去调用。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><h3 id="原则五、迪米特法则（Law-of-Demeter，简称LOD）"><a href="#原则五、迪米特法则（Law-of-Demeter，简称LOD）" class="headerlink" title="原则五、迪米特法则（Law of Demeter，简称LOD）"></a>原则五、迪米特法则（Law of Demeter，简称LOD）</h3><p>定义：一个对象应该对其他对象保持最少的了解。</p><p>当类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外只暴露必要的接口。</p><p>解决方案：尽量降低类与类之间的耦合。</p><p>比如，有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工 <code>ID</code>：<br>Model 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; EmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface EmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 总公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *employee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubEmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubEmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 分公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *subemployee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Company 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; subCompany.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>从上面可以看出，打印 <code>Company</code> 所有员工的 <code>ID</code>，需要依赖分公司 <code>SubCompany</code>。但是在 <code>printAllEmployeeWithSubCompany:</code> 方法里面必须要初始化分公司员工 <code>SubEmployeeModel</code>。而<code>SubEmployeeModel</code> 和 <code>Company</code> 并不是直接联系，换句话说，总公司 <code>Company</code> 只需要依赖分公司 <code>SubCompany</code>，与分公司的员工 <code>SubEmployeeModel</code> 并没有任何联系，这样设计显然是增加了不必要的耦合。</p><p><strong>按照迪米特法则，类与类之间的应该减少不必要的关联程度。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    [subCompany printAllEmployee];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印分公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployee &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>修改后，为分公司增加了打印所有公钥 <code>ID</code> 的方法，总公司直接调分公司的打印方法，从而避免了与分公司的员工发生耦合。</p><p>耦合的方式很多，依赖、关联、组合、聚合等。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是过分的使用迪米特原则，会产生大量传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="原则六、开闭原则（Open-Close-Principle，简称OCP）"><a href="#原则六、开闭原则（Open-Close-Principle，简称OCP）" class="headerlink" title="原则六、开闭原则（Open Close Principle，简称OCP）"></a>原则六、开闭原则（Open Close Principle，简称OCP）</h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>核心思想：<strong>尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。</strong></p><p><strong>用抽象构建框架，用实现扩展细节</strong>，对扩展开放的关键是抽象，而对象的多态则保证了这种扩展的开放性。开放原则首先意味着我们可以自由地增加功能，而不会影响原有功能。这就要求我们能够通过继承完成功能的扩展。其次，开放原则还意味着实现是可替换的。只有利用抽象，才可以为定义提供不同的实现，然后根据不同的需求实例化不同的实现子类。</p><p>开放封闭原则的优点：</p><ul><li>代码可读性高，可维护性强。</li><li>帮助缩小逻辑粒度，以提高可复用性。</li><li>可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性。</li><li>在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求。</li></ul><p>比如，书店售书的经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IBookProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IBookProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍售价</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (CGFloat)bookPrice;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍作者</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookAuthor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; NovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface NovelBook : NSObject &lt;IBookProtocol&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟书店卖书</span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:11:32.642070+0800 DesignPatterns[1863:5763476] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：50.000000</span><br><span class="line">2018-11-12 15:11:32.642495+0800 DesignPatterns[1863:5763476] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:11:32.642530+0800 DesignPatterns[1863:5763476] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:11:32.642558+0800 DesignPatterns[1863:5763476] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br></pre></td></tr></table></figure><p>将来某一天需求变更为项目投产，书店盈利，书店决定，<code>40</code> 元以上打 <code>8</code> 折，<code>40</code> 元以下打 <code>9</code> 折。</p><p>在实际的项目开发中，如果不懂得开闭原则的话，很容易犯下面的错误：</p><ul><li>在 <code>IBookProtocol</code> 上新增加一个方法 <code>bookOffPrice()</code> 方法，专门进行打折，所有实现类实现这个方法，但是如果其他不想打折的书籍也会因为实现了书籍的接口必须打折。 </li><li>修改 <code>NovelBook</code> 实现类中的 <code>bookPrice()</code> 方中实现打折处理，由于该方法已经实现了打折处理价格，因此采购书籍人员看到的也是打折后的价格的情况。</li></ul><p>很显然按照上面两种方案的话，随着需求的增加，需要反复修改之前创建的类，给新增的类造成了不必要的冗余，业务逻辑的处理和需求不相符合等情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; OffNovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface OffNovelBook : NovelBook</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OffNovelBook</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author &#123;</span><br><span class="line">    return [super initWithBookName:name price:price author:author];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)bookPrice &#123;</span><br><span class="line">    CGFloat originalPrice &#x3D; [super bookPrice];</span><br><span class="line">    CGFloat offPrice      &#x3D; 0;</span><br><span class="line">    if (originalPrice &gt; 40) &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.8;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line">    return offPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BookStore</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book1 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book2 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book3 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book4 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book1 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book2 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book3 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book4 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的原价书籍记录如下：------------&quot;);</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的打折书籍记录如下：------------&quot;);</span><br><span class="line">for (OffNovelBook *novelBook in bookStore.offBookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:52:01.639550+0800 DesignPatterns[2962:6151804] ------------书店卖出去的原价书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.639895+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：30.000000</span><br><span class="line">2018-11-12 15:52:01.639927+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:52:01.639951+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:52:01.639971+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br><span class="line">2018-11-12 15:52:01.639988+0800 DesignPatterns[2962:6151804] ------------书店卖出去的打折书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.640029+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：27.000000</span><br><span class="line">2018-11-12 15:52:01.640145+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：56.000000</span><br><span class="line">2018-11-12 15:52:01.640194+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：64.000000</span><br><span class="line">2018-11-12 15:52:01.640217+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：36.000000</span><br></pre></td></tr></table></figure><p>在实际的项目开发中，</p><ul><li><p>对抽象定义的修改，要保证定义的接口或者 <code>Protocol</code> 的稳定，尤其要保证被其他对象调用的接口的稳定；否则，就会导致修改蔓延，牵一发而动全身。</p></li><li><p>对具体实现的修改，因为具体实现的修改，可能会给调用者带来意想不到的结果。如果确实需要修改具体的实现，就需要做好达到测试覆盖率要求的单元测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/588630-7d17a7d220c612f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅析 NSTimer 和 CADisplayLink 内存泄漏</title>
    <link href="https://sunjinshuai.github.io/2018/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://sunjinshuai.github.io/2018/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2018-10-12T13:48:52.000Z</published>
    <updated>2020-01-10T03:23:16.085Z</updated>
    
    <content type="html"><![CDATA[<p>谈论 <code>NSTimer &amp; CADisplayLink</code> 内存泄漏，要理解 <code>NSTimer &amp; CADisplayLink</code> 的基础概念，下面通过一个倒计时的实现的 <code>demo</code> 进入正题。</p><ul><li>第一种就是直接在 <code>TableView</code> 的 <code>Cell</code> 上使用 <code>NSTimer</code>，然后添加到当前线程所对应的 <code>RunLoop</code> 中的 <code>commonModes</code> 中。</li><li>第二种是通过 <code>Dispatch</code> 中的 <code>TimerSource</code> 来实现定时器。</li><li>第三种是使用 <code>CADisplayLink</code> 来实现。</li></ul><p>以 <code>UITableViewCell</code> 为例：</p><h3 id="一、在-Cell-中直接使用-NSTimer"><a href="#一、在-Cell-中直接使用-NSTimer" class="headerlink" title="一、在 Cell 中直接使用 NSTimer"></a>一、在 <code>Cell</code> 中直接使用 <code>NSTimer</code></h3><p>首先我们按照常规做法，直接在 <code>UITableView</code> 的 <code>Cell</code> 上添加相应的 <code>NSTimer</code>, 并使用 <code>scheduledTimer</code> 执行相应的代码块。<br>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(countDown:) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown:(NSTimer *)timer &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.textLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时:%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:36:11.981473+0800 NSTimer&amp;CADisplayLink[24050:457782] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h3 id="二、DispatchTimerSource"><a href="#二、DispatchTimerSource" class="headerlink" title="二、DispatchTimerSource"></a>二、DispatchTimerSource</h3><p>接下来我们就在 <code>TableView</code> 的 <code>Cell</code> 上添加 <code>DispatchTimerSource</code>，然后看一下运行效果。当然下方代码片段我们是在全局队列中添加的 <code>DispatchTimerSource</code>，在主线程中进行更新。当然我们也可以在 <code>mainQueue</code> 中添加 <code>DispatchTimerSource</code>，这样也是可以正常工作的。当然我们不建议在 <code>MainQueue</code> 中做，因为在编程时尽量的把一些和主线程关联不太大的操作放到子线程中去做。<br>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        [self countDown];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    &#x2F;&#x2F; 倒计时时间</span><br><span class="line">    __block NSInteger timeOut &#x3D; 60.0f;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    &#x2F;&#x2F; 每秒执行一次</span><br><span class="line">    dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</span><br><span class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 倒计时结束，关闭</span><br><span class="line">        if (timeOut &lt;&#x3D; 0) &#123;</span><br><span class="line">            dispatch_source_cancel(_timer);</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                self.detailTextLabel.text &#x3D; @&quot;倒计时结束&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">                dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">                self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">            &#125;);</span><br><span class="line">            timeOut--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h3 id="三、CADisplayLink"><a href="#三、CADisplayLink" class="headerlink" title="三、CADisplayLink"></a>三、CADisplayLink</h3><p>接下来我们来使用 <code>CADisplayLink</code> 来实现定时器功能，<code>CADisplayLink</code> 可以添加到 <code>RunLoop</code> 中，每当屏幕需要刷新的时候，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，这时 <code>target</code> 可以读到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。</p><p>可以设想一下，我们在动画的过程中，<code>runloop</code> 被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行  <code>CADisplayLink</code> 的调用，从而造成动画过程的卡顿，使动画不流畅。</p><p>下方代码，为了不让屏幕的卡顿等引起的主线程所对应的 <code>RunLoop</code> 阻塞所造成的定时器不精确的问题。我们开启了一个新的线程，并且将 <code>CADisplayLink</code> 对象添加到这个子线程的 <code>RunLoop</code> 中，然后在主线程中更新UI即可。<br>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        dispatch_queue_t disqueue &#x3D;  dispatch_queue_create(&quot;com.countdown&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        dispatch_group_t disgroup &#x3D; dispatch_group_create();</span><br><span class="line">        dispatch_group_async(disgroup, disqueue, ^&#123;</span><br><span class="line">            self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">            [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.link invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h2 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h2><p>从上面的三种 <code>demo</code> 可以看出 <code>UITableViewCell</code> 没有被释放，由此得出结论，当 <code>UITableViewCell</code> 里面强引用了定时器，定时器又强引用了 <code>UITableViewCell</code>，这样两者的 <code>retainCount</code> 值一直都无法为0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>定时器的运行需要结合一个 <code>NSRunLoop</code>，同时 <code>NSRunLoop</code> 对该定时器会有一个强引用，这也是为什么我们不能对 <code>NSRunLoop</code> 中的定时器进行强引的原因。</p><p>由于 <code>NSRunLoop</code> 对定时器有引用，定时器怎样才能被释放掉。</p><blockquote><p>Removes the object from all runloop modes (releasing the receiver if it has been implicitly retained) and releases the target object.</p></blockquote><p>据官方介绍可知，<code>- invalidate</code> 做了两件事，首先是把本身（定时器）从 <code>NSRunLoop</code> 中移除，然后就是释放对 <code>target</code> 对象的强引用，从而解决定时器带来的内存泄漏问题。</p><p>从上面的 <code>demo</code> 中看出，在 <code>UITableViewCell</code> 的 <code>dealloc</code> 方法中调用 <code>invalidate</code> 方法，并没有解决问题。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里使用下 <code>Xcode8</code> 调试黑科技 <code>Memory Graph</code> 来检测下内存泄漏：</p><p><img src="https://upload-images.jianshu.io/upload_images/588630-f2c2468c9ecf756f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图中可以看出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop  ---&gt; 定时器 ---&gt; UITableViewCell</span><br></pre></td></tr></table></figure><p>导致 <code>UITableViewCell</code> 中没有释放掉定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>从代码中看出，<code>Target</code> 直接设置成 <code>self</code> 会造成内存泄， <code>CADisplayLink</code> 会强引用 <code>Target</code>。当 <code>CADisplayLink</code> 添加到 <code>NSRunLoop</code> 中，<code>NSRunLoop</code> 会强引用 <code>CADisplayLink</code>。如果仅仅在 <code>dealloc</code> 中调用 <code>CADisplayLink</code> 的 <code>invalidate</code> 方法是没用的，因为 <code>NSRunLoop</code> 的存在 <code>CADisplayLink</code> 不会被释放，<code>Target</code> 被强引用，<code>Target</code> 的 <code>dealloc</code> 方法不会被调用，<code>CADisplayLink</code> 的 <code>invalidate</code> 方法也不被调用，<code>CADisplayLink</code> 不会从 <code>NSRunLoop</code> 中移除，从而导致内存泄漏。</p><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">NSRunLoop 的问题请查看这里</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、Target"><a href="#1、Target" class="headerlink" title="1、Target"></a>1、Target</h3><p>为了解决定时器与 <code>Target</code> 之间类似死锁的问题，我们会将定时器中的 <code>target</code> 对象替换成定时器自己，采用分类实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+TimerTarget.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSTimer (TimerTarget)</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">repeat:(BOOL)yesOrNo </span><br><span class="line"> block:(void (^)(NSTimer *))block &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(startTimer:) userInfo:[block copy] repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)startTimer:(NSTimer *)timer &#123;</span><br><span class="line">    void (^block)(NSTimer *timer) &#x3D; timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2、Proxy"><a href="#2、Proxy" class="headerlink" title="2、Proxy"></a>2、Proxy</h3><p>这种方式就是创建一个 <code>NSProxy</code> 子类 <code>TimerProxy</code>，<code>TimerProxy</code> 的作用是什么呢？就是什么也不做，可以说只会重载消息转发机制，如果创建一个 <code>TimerProxy</code> 对象将其作为定时器的 <code>target</code>，专门用于转发定时器消息至 <code>Target</code> 对象，那么问题是不是就解决了呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 target:[TimerProxy timerProxyWithTarget:self] selector:@selector(startTimer) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure><h3 id="3、NSTimer-Block"><a href="#3、NSTimer-Block" class="headerlink" title="3、NSTimer Block"></a>3、NSTimer Block</h3><p>还有一种方式就是采用Block，iOS 10增加的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ scheduledTimerWithTimeInterval:repeats:block:</span><br><span class="line"></span><br><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;MYNSTimerTargetController timer start&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSTimer%26CADisplayLink" target="_blank" rel="noopener">浅析NSTimer &amp; CADisplayLink内存泄漏</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谈论 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 内存泄漏，要理解 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 的基础概念，下面通过一个倒计时的实现的 &lt;code&gt;demo&lt;/code&gt; 进入正题。
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVO 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2018-09-11T13:28:58.000Z</published>
    <updated>2020-01-10T03:23:43.249Z</updated>
    
    <content type="html"><![CDATA[<p><code>KVO</code> 全称 <code>KeyValueObserving</code> 是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，当指定的对象的属性被修改后，则对象就会接受收到通知。简单的说就是每次指定的被观察的对象的属性被修改后，<code>KVO</code> 就会自动通知相应的观察者了。</p><h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul><li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li><li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li><li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li></ul><h1 id="KVO-实现原理："><a href="#KVO-实现原理：" class="headerlink" title="KVO 实现原理："></a>KVO 实现原理：</h1><p><code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p></blockquote><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。重写的 <code>setter</code> 方法会在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针指向这个新创建的类，对象变成了新创建的类的实例，而不是原来真正的类。</p><h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a>KVO 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。<br>例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@interface TestKVOViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Message *message;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestKVOViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    </span><br><span class="line">    Message *message &#x3D; [[Message alloc] init];</span><br><span class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    message.text &#x3D; @&quot;hello object-c&quot;;</span><br><span class="line">    self.message &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</span><br><span class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &#39;NSRangeException&#39;, reason: &#39;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&#39;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</span><br><span class="line">1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</span><br><span class="line">2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</span><br><span class="line">3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</span><br><span class="line">4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</span><br><span class="line">5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</span><br><span class="line">6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</span><br><span class="line">7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</span><br><span class="line">8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</span><br><span class="line">9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</span><br><span class="line">10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</span><br><span class="line">11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</span><br><span class="line">12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</span><br><span class="line">14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</span><br><span class="line">16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</span><br><span class="line">17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</span><br><span class="line">18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</span><br><span class="line">19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</span><br><span class="line">20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</span><br><span class="line">21  ImplementKVO                        0x000000010dd2dfef main + 111</span><br><span class="line">22  libdyld.dylib                       0x00000001129fe955 start + 1</span><br><span class="line">23  ???                                 0x0000000000000001 0x0 + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure><h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (KVO)</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">forKey:(NSString *)key</span><br><span class="line">withBlock:(ObservingBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p><ul><li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li><li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li><li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li><li>添加这个观察者；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</span><br><span class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</span><br><span class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</span><br><span class="line"> 4. 将调用对象添加到数组中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">             forKey:(NSString *)key</span><br><span class="line">          withBlock:(ObservingBlock)block &#123;</span><br><span class="line">    </span><br><span class="line">    SEL setterSelector &#x3D; NSSelectorFromString(setterForGetter(key));</span><br><span class="line">    Method setterMethod &#x3D; class_getInstanceMethod([self class], setterSelector);</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class clazz &#x3D; object_getClass(self);</span><br><span class="line">    NSString *clazzName &#x3D; NSStringFromClass(clazz);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; if not an KVO class yet</span><br><span class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</span><br><span class="line">        clazz &#x3D; [self makeKvoClassWithOriginalClassName:clazzName];</span><br><span class="line">        object_setClass(self, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; add our kvo setter if this class (not superclasses) doesn&#39;t implement the setter?</span><br><span class="line">    if (![self hasSelector:setterSelector]) &#123;</span><br><span class="line">        const char *types &#x3D; method_getTypeEncoding(setterMethod);</span><br><span class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ObservationInfo *info &#x3D; [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    if (!observers) &#123;</span><br><span class="line">        observers &#x3D; [NSMutableArray array];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p><p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 判断是否存在KVO类，如果存在则返回。</span><br><span class="line"> 2. 如果不存在，则创建KVO类。</span><br><span class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</span><br><span class="line">    NSString *kvoClazzName &#x3D; [kKVOClassPrefix stringByAppendingString:originalClazzName];</span><br><span class="line">    Class clazz &#x3D; NSClassFromString(kvoClazzName);</span><br><span class="line">    </span><br><span class="line">    if (clazz) &#123;</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class doesn&#39;t exist yet, make it</span><br><span class="line">    Class originalClazz &#x3D; object_getClass(self);</span><br><span class="line">    Class kvoClazz &#x3D; objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; grab class method&#39;s signature so we can borrow it</span><br><span class="line">    Method clazzMethod &#x3D; class_getInstanceMethod(originalClazz, @selector(class));</span><br><span class="line">    const char *types &#x3D; method_getTypeEncoding(clazzMethod);</span><br><span class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</span><br><span class="line">    </span><br><span class="line">    objc_registerClassPair(kvoClazz);</span><br><span class="line">    </span><br><span class="line">    return kvoClazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p><p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSString *setterName &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line">    NSString *getterName &#x3D; getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    if (!getterName) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id oldValue &#x3D; [self valueForKey:getterName];</span><br><span class="line">    </span><br><span class="line">    struct objc_super superclazz &#x3D; &#123;</span><br><span class="line">        .receiver &#x3D; self,</span><br><span class="line">        .super_class &#x3D; class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; cast our pointer so the compiler won&#39;t complain</span><br><span class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) &#x3D; (void *)objc_msgSendSuper;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; call super&#39;s setter, which is original class&#39;s setter method</span><br><span class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; look up observers and call the blocks</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    for (ObservationInfo *each in observers) &#123;</span><br><span class="line">        if ([each.key isEqualToString:getterName]) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                each.block(self, getterName, oldValue, newValue);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p><p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface ObservationInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) NSObject *observer;</span><br><span class="line">@property (nonatomic, copy) NSString *key;</span><br><span class="line">@property (nonatomic, copy) ObservingBlock block;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ObservationInfo</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObserver:(NSObject *)observer</span><br><span class="line">                             Key:(NSString *)key</span><br><span class="line">                           block:(ObservingBlock)block &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _observer &#x3D; observer;</span><br><span class="line">        _key &#x3D; key;</span><br><span class="line">        _block &#x3D; block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Strikers/MYKit" target="_blank" rel="noopener">KVO crash 防护方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 全称 &lt;code&gt;KeyValueObserving&lt;/code&gt; 是 &lt;code&gt;Objective-C&lt;/code&gt; 对观察者模式&lt;code&gt;(Observer Pattern)&lt;/code&gt;的实现；&lt;code&gt;KVO&lt;/code&gt; 提
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flutter之环境搭建</title>
    <link href="https://sunjinshuai.github.io/2018/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://sunjinshuai.github.io/2018/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2018-07-25T03:11:45.000Z</published>
    <updated>2018-08-25T03:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、获取Flutter SDK</p><p>要获得 <code>Flutter</code>，请先使用 <code>git</code> 克隆 <code>Flutter</code>，然后将该 <code>flutter</code> 工具添加到您的用户路径。运行 <code>flutter doctor</code> 显示您可能需要安装的剩余依赖项。</p><p>由于国内被墙，需要设置下载镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn &#x2F;&#x2F;国内用户需要设置</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn &#x2F;&#x2F;国内用户需要设置</span><br></pre></td></tr></table></figure><p>Clone Flutter repo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b beta https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter.git</span><br></pre></td></tr></table></figure><p>二、配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">export PATH&#x3D;&#96;pwd&#96;&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">(或者)</span><br><span class="line"># export FLUTTER_HOME&#x3D;&#x2F;Users&#x2F;sunjinshuai&#x2F;flutter</span><br><span class="line"># export PATH&#x3D;$PATH:$FLUTTER_HOME&#x2F;bin:</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>三、运行 flutter doctor</p><p>查看是否需要安装其它依赖项来完成安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>该命令检查您的环境并在终端窗口中显示报告，仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line">[✗] Android toolchain - develop for Android devices</span><br><span class="line">✗ Unable to locate Android SDK.</span><br><span class="line">Install Android Studio from: https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;index.html</span><br><span class="line">On first launch it will assist you in installing the Android SDK components.</span><br><span class="line">(or visit https:&#x2F;&#x2F;flutter.io&#x2F;setup&#x2F;#android-setup for detailed instructions).</span><br><span class="line">If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location.</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.25.1)</span><br><span class="line">[✓] Connected devices (2 available)</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>在 <a href="https://github.com/flutter/flutter/issues/13078" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13078</a> 找到了解决方法，其实就是在 <code>bash_profile</code> 添加安卓SDK的环境变量即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br><span class="line"></span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK 28.0.1)</span><br><span class="line">✗ Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.25.1)</span><br><span class="line">[✓] Connected devices (2 available)</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 2 categories.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、获取Flutter SDK&lt;/p&gt;
&lt;p&gt;要获得 &lt;code&gt;Flutter&lt;/code&gt;，请先使用 &lt;code&gt;git&lt;/code&gt; 克隆 &lt;code&gt;Flutter&lt;/code&gt;，然后将该 &lt;code&gt;flutter&lt;/code&gt; 工具添加到您的用户路径。运行 &lt;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 NSUserDefaults</title>
    <link href="https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/"/>
    <id>https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/</id>
    <published>2018-06-20T13:38:40.000Z</published>
    <updated>2018-09-12T13:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>NSUserDefaults</code> 适用于快速读取小规模的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br></pre></td></tr></table></figure><p>写入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *string &#x3D; @&quot;hahaha&quot;;</span><br><span class="line">[standardDefaults setObject:string forKey:@&quot;myKey&quot;];</span><br><span class="line">[standardDefaults synchronize];&#x2F;&#x2F; 写完别忘了同步</span><br></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *value &#x3D; [standardDefaults objectForKey:@&quot;myKey&quot;];</span><br></pre></td></tr></table></figure><p><code>NSUserDefaults</code> 可以理解成键值对</p><p>有时在写数据之前，想判断下这个健是否已经设置过默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if ([standardDefaults stringForKey:@&quot;favoriteColor&quot;] &#x3D;&#x3D; nil) &#123;</span><br><span class="line">    [standardDefaults setObject:@&quot;Green&quot; forKey:@&quot;favoriteColor&quot;];</span><br><span class="line">    [standardDefaults synchronize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以使用 <code>registerDefaults:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">[standardDefaults registerDefaults:@&#123;@&quot;favoriteColor&quot;: @&quot;Green&quot;&#125;];</span><br><span class="line">[standardDefaults synchronize];</span><br></pre></td></tr></table></figure><p>每次程序启动的时候调用 <code>registerDefaults:</code> 方法都是安全的，完全可以将这个方法的调用放到 <code>applicationDidFinishLaunching:</code> 方法中，这个方法永远都不会覆盖用户设置的值。</p><p>但是并不是所有类型的对象都能够直接放入 <code>NSUserDefaults</code>，<code>NSUserDefaults</code> 只支持 <code>Foundation</code> 类型的对象，如果自定义 <code>NSObject</code> 对象存入 <code>NSUserDefaults</code> 就要实现 <code>NSCoding</code> 协议了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *age;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)coder;</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)coder;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)initWithCoder:(NSCoder *)coder &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        self.age  &#x3D; [coder decodeObjectForKey:@&quot;age&quot;];</span><br><span class="line">        self.name &#x3D; [coder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder: (NSCoder *)coder &#123;</span><br><span class="line">    [coder encodeObject:self.age forKey:@&quot;age&quot;];</span><br><span class="line">    [coder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再存取时通过 <code>NSData</code> 做载体：</p><p>存入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">NSData *personData &#x3D; [NSKeyedArchiver archivedDataWithRootObject:person];</span><br><span class="line">[standardDefaults setObject:personData forKey:@&quot;personKey&quot;];</span><br><span class="line">[standardDefaults synchronize];</span><br></pre></td></tr></table></figure><p>读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSData *newPersonData &#x3D; [standardDefaults objectForKey:&quot;personKey&quot;];</span><br><span class="line">Person *Person &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:newPersonData];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt; 适用于快速读取小规模的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVC</title>
    <link href="https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/"/>
    <id>https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/</id>
    <published>2018-04-12T14:37:32.000Z</published>
    <updated>2018-09-12T13:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>KVC</code> 是 <code>KeyValue Coding</code> 的简称，遵循 <code>NSKeyValueCoding</code> 协议，它是一种可以直接通过字符串的名字 <code>key</code> 来访问类属性的机制，而不是通过调用 <code>setter</code>、<code>getter</code> 方法访问。</p><p>对于 <code>KVC</code>，<code>Cocoa</code> 自动放入和取出基本数据类型放入 <code>NSNumber</code> 或 <code>NSValue</code> 中，当使用 <code>setValue:ForKey:</code> 或者 <code>valueForKey:</code> 时，它自动将基本数据类型从这些对象中取出，仅 <code>KVC</code> 具有这种自动包装功能，常规方法调用和属性语法不具备该功能。</p><h1 id="setValue-forKey-的实现方式："><a href="#setValue-forKey-的实现方式：" class="headerlink" title="setValue:forKey 的实现方式："></a><code>setValue:forKey</code> 的实现方式：</h1><p>以字符串的形式向对象发送消息，首先查找以 <code>set&lt;Key&gt;</code> 命名的 <code>setter</code> 方法，如果成员用 <code>@property</code>，<code>@synthsize</code> 处理，因为 <code>@synthsize</code> 告诉编译器自动生成 <code>set&lt;Key&gt;:</code> 格式的 <code>setter</code> 方法，所以这种情况下会直接搜索到。如果上面的 <code>setter</code> 方法没有找到，如果类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。如果找到则设置成员的值，如果没有查找调用 <code>setValue:forUndefinedKey:</code>。</p><h1 id="valueForKey-的实现方式："><a href="#valueForKey-的实现方式：" class="headerlink" title="valueForKey: 的实现方式："></a><code>valueForKey:</code> 的实现方式：</h1><ul><li>首先查找以 <code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code> 命名的 <code>getter</code> 方法，找到直接调用。</li><li>如果上面的 <code>getter</code> 没有找到，则会查找 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 格式的方法，找到就会调用 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 方法，还有一个可选的 <code>get&lt;Key&gt;:range:</code> 方法。</li><li>若是还没查到，那么查找 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 格式的方法，如果找到就调用 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 方法。</li><li>若是还没查到，那么如果类方法 accessInstanceVariablesDirectly 返回 YES，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。</li><li>再没查到，调用 <code>valueForUndefinedKey:</code>。</li></ul><p>综上，<strong>使用 KVC 访问属性的代价比直接使用存取方法性能开销要大</strong>。</p><h1 id="值的正确性核查"><a href="#值的正确性核查" class="headerlink" title="值的正确性核查"></a>值的正确性核查</h1><p>KVC 提供属性值确认的 API，它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p><p>实现核查方法，为如下格式：<code>validate&lt;Key&gt;:error:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</span><br><span class="line">    &#x2F;&#x2F; The name must not be nil, and must be at least two characters long.</span><br><span class="line">    if ((*ioValue &#x3D;&#x3D; nil) || ([(NSString *)*ioValue length] &lt; 2]) &#123;</span><br><span class="line">        if (outError !&#x3D; NULL) &#123;</span><br><span class="line">            NSString *errorString &#x3D; NSLocalizedStringFromTable(</span><br><span class="line">                    @&quot;A Person&#39;s name must be at least two characters long&quot;, @&quot;Person&quot;,</span><br><span class="line">                    @&quot;validation: too short name error&quot;);</span><br><span class="line">            NSDictionary *userInfoDict &#x3D;</span><br><span class="line">                [NSDictionary dictionaryWithObject:errorString</span><br><span class="line">                                            forKey:NSLocalizedDescriptionKey];</span><br><span class="line">            *outError &#x3D; [[[NSError alloc] initWithDomain:PERSON_ERROR_DOMAIN</span><br><span class="line">                                                    code:PERSON_INVALID_NAME_CODE</span><br><span class="line">                                                userInfo:userInfoDict] autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用核查方法：<br><code>validateValue:forKey:error:</code>，默认实现会搜索 <code>validate&lt;Key&gt;:error:</code>格式的核查方法，找到则调用，未找到默认返回 <code>YES</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;KVC&lt;/code&gt; 是 &lt;code&gt;KeyValue Coding&lt;/code&gt; 的简称，遵循 &lt;code&gt;NSKeyValu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>九宫格常用的宏</title>
    <link href="https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/"/>
    <id>https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/</id>
    <published>2018-01-16T13:47:19.000Z</published>
    <updated>2018-09-12T13:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用九宫格定义的宏如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**************************无间距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_SUPERVIEW_AND_WIDTH(SUPERVIEW,WIDTH,COLUMN) SUPERVIEW.subviews.count % COLUMN * WIDTH</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_SUPERVIEW_AND_HEIGHT(SUPERVIEW,HEIGHT,COLUMN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT</span><br><span class="line"></span><br><span class="line">&#x2F;**************************有间距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的横向间距</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + SUPERVIEW.subviews.count % COLUMN  * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * HEIGHT    指九宫格每个小格子的高度</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的纵向间距</span><br><span class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT + SUPERVIEW.subviews.count &#x2F; COLUMN * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;**************************有间距、有边距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度 int width &#x3D; (SCREEN_WIDTH - (colunm + 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的横向间距 和 外边距</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_EDGE_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + (SUPERVIEW.subviews.count % COLUMN + 1) * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * HEIGHT    指九宫格每个小格子的高度</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的纵向间距 和 外边距</span><br><span class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_EDGE_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT + (SUPERVIEW.subviews.count &#x2F; COLUMN + 1) * MARGIN</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/SudokuDemo" target="_blank" rel="noopener">九宫格demo地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用九宫格定义的宏如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>谈谈 Autolayout</title>
    <link href="https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/"/>
    <id>https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/</id>
    <published>2017-12-18T14:16:11.000Z</published>
    <updated>2018-08-25T02:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unable to simultaneously satisfy constraints.</span><br><span class="line">Probably at least one of the constraints in the following list is one you don&#39;t want.</span><br><span class="line">Try this:</span><br><span class="line"></span><br><span class="line">(1) look at each constraint and try to figure out which you don&#39;t expect;</span><br><span class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</span><br><span class="line">(Note: If you&#39;re seeing NSAutoresizingMaskLayoutConstraints that you don&#39;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</span><br><span class="line">(...........)</span><br><span class="line"></span><br><span class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</span><br><span class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit&#x2F;UIView.h&gt; may also be helpful.</span><br></pre></td></tr></table></figure><p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p><p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p><ul><li>打开断点导航（cmd+7）</li><li>点击左下角的+按钮</li><li>选择Add Symbolic Breakpoint</li><li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p><p>所以交给你一个小技巧，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">po [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; OC项目</span><br><span class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; Swift项目</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这样就可以直接看到输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</span><br><span class="line">UIWindow:0x7f9481c93360</span><br><span class="line">|   •UIView:0x7f9481c9d680</span><br><span class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</span><br></pre></td></tr></table></figure><p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p><p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x7f9481c9d990</span><br><span class="line">&lt;UIView: 0x7f9481c9d990; frame &#x3D; (0 0; 768 359); autoresize &#x3D; RM+BM; layer &#x3D; &lt;CALayer: 0x7fc82d338960&gt;&gt;</span><br></pre></td></tr></table></figure><p>改变颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor &#x3D; [UIColor redColor]</span><br><span class="line">(UICachedDeviceRGBColor *) $4 &#x3D; 0x0000000174469cc0</span><br></pre></td></tr></table></figure><p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p><h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p><ul><li>layoutSubViews：</li></ul><p>当 <code>View</code> 及其所有子视图的 <code>frame</code> 发生改变的时候，会调用 <code>layoutSubviews</code>，所以在需要更新 frame 来重新定位或更改大小时重载它。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。注意：<strong>最好不要在代码中手动调用 <code>layoutSubviews</code> 方法</strong>。当 <code>layoutSubviews</code> 完成后，在 <code>view</code> 的所有者 <code>view controller</code> 上，会触发  <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 <code>view</code> 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。</p><p>触发 <code>layoutSubviews</code> 的时机：</p><ul><li><p><code>addSubview</code> 方法会触发 <code>layoutSubviews</code>。</p></li><li><p>当 <code>view</code> 的 <code>Frame</code> 发生变化也会触发<code>layoutSubviews</code>。</p></li><li><p>滚动一个 <code>UIScrollView</code> 会触发 <code>layoutSubviews</code>。</p></li><li><p>旋转屏幕会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p></li><li><p>改变一个 <code>View</code> 大小的时候也会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p></li><li><p>setNeedsLayout<br>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法，表示视图的布局需要重新计算。告知页面需要更新，但是不会立刻开始更新视图，视图会在下一个 <code>runloop</code> 中更新，调用 <code>setNeedsLaylout</code> 方法视图被重新绘制并布局之间会有一段任意时间的间隔。</p></li><li><p>layoutIfNeeded<br>调用 <code>layoutIfNeeded</code> 会触发 <code>layoutSubviews</code>，告知页面布局立刻更新，所以一般都会和 <code>setNeedsLayout</code> 一起使用。如果希望立刻生成新的 <code>frame</code> 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p></li><li><p>setNeedsUpdateConstraints<br>告知需要更新约束，但是不会立刻开始，在下一次 <code>runloop</code> 中更新约束，通过标记 <code>update constraints</code> 来触发 <code>updateConstraints</code>。</p></li><li><p>updateConstraintsIfNeeded<br>告知立刻更新约束，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 <code>update constraints</code> 标记。如果认为这些约束需要被更新，它会立即触发 <code>updateConstraints</code>，而不会等到 <code>run loop</code> 的末尾。</p></li><li><p>updateConstraints<br>系统更新约束，注意：<strong>最好不要在代码中手动调用 <code>updateConstraints</code> 方法</strong>。通常在 <code>updateConstraints</code> 方法中实现必须要更新的约束，在设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 <code>update constarints</code>，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。</p></li></ul><p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p><h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.bounds &#x3D; CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</span><br></pre></td></tr></table></figure><p>那么很可能拿到 layer 的宽度是0。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">[self.view addSubview:redView];</span><br><span class="line">self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 设置约束</span><br><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">  make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame &#x3D; (0 0; 0 0); layer &#x3D; &lt;CALayer: 0x6040002274a0&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p><p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x60000003c460&gt;&gt;</span><br></pre></td></tr></table></figure><p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">    [redView setNeedsLayout];</span><br><span class="line">    [redView layoutIfNeeded];</span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame &#x3D; (-75 -40; 150 80); layer &#x3D; &lt;CALayer: 0x6040004207a0&gt;&gt;</span><br></pre></td></tr></table></figure><p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x600000233540&gt;&gt;</span><br></pre></td></tr></table></figure><p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于Autolayout的调试&quot;&gt;&lt;a href=&quot;#关于Autolayout的调试&quot; class=&quot;headerlink&quot; title=&quot;关于Autolayout的调试&quot;&gt;&lt;/a&gt;关于Autolayout的调试&lt;/h4&gt;&lt;p&gt;刚开始使用 Autolayout 遇
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="noopener">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>持续的软件版本发布/测试项目。</li><li>监控外部调用执行的工作。</li></ul><p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins官网</a>下载Jenkins；</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>点击Download：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p><p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><ul><li>在Safari浏览器上，会出现Safari不能连接到服务器。</li><li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li></ul><p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="noopener">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以通过下面两种方式获取初始化密码：</p><ul><li>打开terminal，执行cat命令即可(需要管理员权限)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat &#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;Home&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>输入用户名和密码之后，Jenkins就彻底安装好了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p><h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&#x2F;Uninstall.command</span><br></pre></td></tr></table></figure><h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist    </span><br><span class="line">sudo rm !$    </span><br><span class="line">sudo rm -rf &#x2F;Applications&#x2F;Jenkins &quot;&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&quot; &#x2F;Library&#x2F;Documentation&#x2F;Jenkins    </span><br><span class="line">sudo rm -rf &#x2F;Users&#x2F;Shared&#x2F;Jenkins    </span><br><span class="line"># if you want to get rid of all the jobs and builds:    </span><br><span class="line">sudo dscl . -delete &#x2F;Users&#x2F;jenkins    </span><br><span class="line"># delete the jenkins user and group (if you chose to use them):    </span><br><span class="line">sudo dscl . -delete &#x2F;Groups&#x2F;jenkins</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>App的生命周期</title>
    <link href="https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2017-11-17T16:02:28.000Z</published>
    <updated>2018-08-25T02:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS程序的启动执行顺序"><a href="#iOS程序的启动执行顺序" class="headerlink" title="iOS程序的启动执行顺序"></a>iOS程序的启动执行顺序</h4><p>程序启动顺序图<br><img src="http://upload-images.jianshu.io/upload_images/588630-5837771421fe9e63?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS启动原理图"></p><p>具体执行流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);&#x2F;&#x2F;__func__打印方法名</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</span><br><span class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</span><br><span class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</span><br><span class="line">  NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123;</span><br><span class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</span><br><span class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>APP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate application:didFinishLaunchingWithOptions:] </span><br><span class="line">-[AppDelegate applicationDidBecomeActive:]</span><br></pre></td></tr></table></figure><p>按下 <code>Home</code> 键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate applicationWillResignActive:]</span><br><span class="line">-[AppDelegate applicationDidEnterBackground:]</span><br></pre></td></tr></table></figure><p>返回 <code>APP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate applicationWillEnterForeground:]</span><br><span class="line">-[AppDelegate applicationDidBecomeActive:]</span><br></pre></td></tr></table></figure><p>内存警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate applicationDidReceiveMemoryWarning:]</span><br></pre></td></tr></table></figure><p>注意：<br><code>application:didFinishLaunchingWithOptions:</code>： <code>App</code> 首次启动时调用，一般在这个函数里创建 <code>window</code> 对象，初始化 <code>App</code> 可能用到的第三方 <code>SDK</code> 等。<br><code>applicationWillResignActive:</code>：<code>App</code> 将要进入后台时调用，比如有电话进来或者按下 <code>Home</code> 键。<br>该函数里面主要执行操作:</p><ul><li>暂停正在执行的任务</li><li>停止计时器</li><li>减少OpenGL ES帧率</li></ul><p><code>applicationDidEnterBackground:</code>：<code>App</code> 已经进入后台，一般该方法用来:</p><ul><li>释放共享资源</li><li>保存用户数据(写到硬盘)</li><li>销毁计时器</li></ul><p><code>applicationWillEnterForeground:</code>：<code>App</code> 即将进入前台，一般该方法用来撤销 <code>applicationWillResignActive:</code> 中做的改变。<br><code>applicationDidBecomeActive:</code>：<code>App</code> 已经进入前台，若 <code>App</code> 之前在后台，在此方法内刷新用户界面。</p><h4 id="UIViewController-的生命周期"><a href="#UIViewController-的生命周期" class="headerlink" title="UIViewController 的生命周期"></a><code>UIViewController</code> 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 非storyBoard(xib或非xib)都走这个方法</span><br><span class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    if (self &#x3D; [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; storyBoard走这个方法</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    if (self &#x3D; [super initWithCoder:aDecoder]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; xib 加载 完成</span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加载视图(默认从nib)</span><br><span class="line">- (void)loadView &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    self.view &#x3D; [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图控制器中的视图加载完成，viewController自带的view加载完成</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图将要出现</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view 即将布局其 Subviews</span><br><span class="line">- (void)viewWillLayoutSubviews &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewWillLayoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view 已经布局其 Subviews</span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图已经出现</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图将要消失</span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图已经消失</span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 出现内存警告 </span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图被销毁</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 </p><ul><li><p><code>initWithNibName:bundle:</code><br>初始化<code>UIViewController</code>，执行关键数据初始化操作，非<code>StoryBoard</code>创建<code>UIViewController</code>都会调用这个方法。</p></li><li><p><em>注意: 不要在这里做<code>View</code>相关操作，<code>View</code>在<code>loadView</code>方法中才初始化。*</em></p></li><li><p><code>initWithCoder:</code><br>如果使用<code>StoryBoard</code>进行视图管理，程序不会直接初始化一个<code>UIViewController</code>，<code>StoryBoard</code>会自动初始化或在<code>segue</code>被触发时自动初始化，因此方法<code>initWithNibName:bundle</code>不会被调用，但是<code>initWithCoder</code>会被调用。</p></li><li><p><code>awakeFromNib</code><br>当<code>awakeFromNib</code>方法被调用时，所有视图的<code>outlet</code>和<code>action</code>已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在<code>storyBoard</code>或<code>xib</code>中，所以可以在<code>awakeFromNib</code>方法中被加载进来。</p></li><li><p><code>loadView</code><br>当执行到<code>loadView</code>方法时，如果视图控制器是通过<code>nib</code>创建，那么视图控制器已经从<code>nib</code>文件中被解档并创建好了，接下来任务就是对<code>view</code>进行初始化。<br><code>loadView</code>方法在<code>UIViewController</code>对象的<code>view</code>被访问且为空的时候调用。这是它与<code>awakeFromNib</code>方法的一个区别。<br>假设我们在处理内存警告时释放<code>view</code>属性：<code>self.view = nil</code>。因此<code>loadView</code>方法在视图控制器的生命周期内可能被调用多次。<br><code>loadView</code>方法不应该直接被调用，而是由系统调用，它会加载或创建一个<code>view</code>并把它赋值给<code>UIViewController</code>的<code>view</code>属性。<br>在创建<code>view</code>的过程中，首先会根据<code>nibName</code>去找对应的<code>nib</code>文件然后加载。如果<code>nibName</code>为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码)</p></li><li><p><em>注意:在重写loadView方法的时候，不要调用父类的方法。*</em></p></li><li><p><code>viewDidLoad</code><br>当<code>loadView</code>将<code>view</code>载入内存中，会进一步调用<code>viewDidLoad</code>方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。</p></li><li><p><code>viewWillAppear</code><br>系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。<br>另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。</p></li><li><p><code>viewWillLayoutSubviews</code><br><code>view</code>即将布局其<code>Subviews</code>。 比如<code>view</code>的<code>bounds</code>改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整<code>Subviews</code>的位置，在调整之前要做的工作可以放在该方法中实现</p></li><li><p><code>viewDidLayoutSubviews</code><br><code>view</code>已经布局其<code>Subviews</code>，这里可以放置调整完成之后需要做的工作。</p></li><li><p><code>viewDidAppear</code><br>在<code>view</code>被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。</p></li><li><p><code>viewWillDisappear</code><br>在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用<code>removeFromSuperview</code>。</p></li><li><p><code>viewDidDisappear</code><br><code>view</code>已经消失或被覆盖，此时已经调用<code>removeFromSuperView</code>;</p></li><li><p><code>dealloc</code><br>视图被销毁，此次需要对你在<code>init</code>和<code>viewDidLoad</code>中创建的对象进行释放。</p></li><li><p><code>didReceiveMemoryWarning</code><br>在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。</p></li></ul><h4 id="UIView-的生命周期"><a href="#UIView-的生命周期" class="headerlink" title="UIView 的生命周期"></a>UIView 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过代码创建控件就会调用这个方法</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self &#x3D; [super initWithFrame:frame]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过storyboared或者xib中创建控件就会调用这个方法</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self &#x3D; [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果在initWithFrame中添加子视图会调用两次</span><br><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didAddSubview:(UIView *)subview &#123;</span><br><span class="line">    [super didAddSubview:subview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willRemoveSubview:(UIView *)subview &#123;</span><br><span class="line">    [super willRemoveSubview:subview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview &#123;</span><br><span class="line">    [super willMoveToSuperview:newSuperview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didMoveToSuperview &#123;</span><br><span class="line">    [super didMoveToSuperview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow &#123;</span><br><span class="line">    [super willMoveToWindow:newWindow];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didMoveToWindow &#123;</span><br><span class="line">    [super didMoveToWindow];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeFromSuperview &#123;</span><br><span class="line">    [super removeFromSuperview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>view</code> 创建时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View initWithFrame:]</span><br><span class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View init]</span><br><span class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:35:12.353483+0800 iOSLife[7587:2353869] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:35:12.353644+0800 iOSLife[7587:2353869] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:35:12.363861+0800 iOSLife[7587:2353869] -[View layoutSubviews]</span><br></pre></td></tr></table></figure><p>当 <code>view</code> 销毁时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:41:28.152448+0800 iOSLife[7607:2356750] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:41:28.152693+0800 iOSLife[7607:2356750] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:41:28.155160+0800 iOSLife[7607:2356750] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:41:28.155281+0800 iOSLife[7607:2356750] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:41:28.155336+0800 iOSLife[7607:2356750] -[View removeFromSuperview]</span><br><span class="line">2017-11-06 10:41:28.155399+0800 iOSLife[7607:2356750] -[View dealloc]</span><br></pre></td></tr></table></figure><p>注意：<br>可以看出上面方法中只会执行一次的方法有 <code>removeFromSuperview</code>、<code>dealloc</code> 两个方法，<code>layoutSubviews</code> 在子视图布局变动时会多次调用，所以可以在 <code>removeFromSuperview</code>、<code>dealloc</code> 这两个方法中执行释放内存等操作，比如移除观察者，定时器等。</p><p>给 <code>view</code> 添加子视图时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View initWithFrame:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View init]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView initWithFrame:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView init]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didAddSubview:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView layoutSubviews]</span><br></pre></td></tr></table></figure><p>注意：<code>didAddSubview:</code> 和 <code>willRemoveSubview:</code> 需要有子视图才能执行。</p><p>此时再销毁该 <code>view</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View removeFromSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View dealloc]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willRemoveSubview:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView removeFromSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView dealloc]</span><br></pre></td></tr></table></figure><p><code>willRemoveSubview</code> 是在 <code>dealloc</code> 后面执行的。如果有多个子视图，<code>willRemoveSubview</code> 会循环执行，直到移除所有子视图。</p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview;</span><br><span class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow;</span><br></pre></td></tr></table></figure><p>这俩个方法可以根据参数判断，<code>nil</code> 则为销毁，否则为创建；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)didMoveToSuperview;</span><br><span class="line">- (void)didMoveToWindow;</span><br></pre></td></tr></table></figure><p>这个方法可以根据 <code>self.superview</code> 判断，<code>nil</code> 则为销毁，否则为创建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;a href=&quot;#iOS程序的启动执行顺序&quot; class=&quot;headerlink&quot; title=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;/a&gt;iOS程序的启动执行顺序&lt;/h4&gt;&lt;p&gt;程序启动顺序图&lt;br&gt;&lt;img src=&quot;http://up
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之iconfont实战</title>
    <link href="https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/</id>
    <published>2017-08-08T07:45:34.000Z</published>
    <updated>2017-08-08T08:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了<code>APP Slicing</code>功能，我司项目在itunes store下载的IPA体积大约在44M。</p><p>把我司iPA解压之后里面的<code>Assert.car</code>资源包的体积大约在22.1M，使用软件导出内部的资源文件发现3X系列的图片大小约为13.1M，2X系列的图片大小约为9.4M，两份加起来大于22.1M，所以可以看出我们的图片还是有很大的优化空间的。</p><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>技术的主要目的是为减少应用体积而生。首先<code>icon</code>代表图标<code>font</code>代表字体。此技术便是将图标转化为字体，从而达到减小应用体积的目的(这样避免了@2X图和@3X图的使用，只需要一个字体图标就可搞定)。如需在项目中使用iconfont技术，图标矢量图一开始都应合并转化为字体库，只需要在项目中引入字体库就可以了。</p><p>优点:</p><ul><li>减小应用体积，字体文件比图片要小；</li><li>图标保真缩放，解决2x/3x乃至将来nx图问题；</li><li>方便更改图标颜色大小，图片复用；</li><li>一套图标资源可以在不用平台上使用(android、iOS、web)；</li></ul><p>缺点:</p><ul><li>只适用于纯色的icon；</li></ul><h4 id="iconfont实战"><a href="#iconfont实战" class="headerlink" title="iconfont实战"></a>iconfont实战</h4><ul><li><p>获取<code>.ttf</code>文件<br>登录<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>，创建一个项目，设计师做好图标，把<code>.ttf</code>文件下载下来。<br>iconfont中的图标是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/588630-fff854d89142120b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>字体注册<br>iOS中使用自定义字体，将字体加入项目后，还需要注册字体。<br>注册的方式有两种：<br>－ 在Info.plist中声明”Fonts provided by application”</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b6a5790bed65a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>－ 调用API来注册。考虑到需要支持独立版和插件版，调用API注册更加方便。字体注册和获取的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerFontWithURL:(NSURL *)url &#123;</span><br><span class="line">    NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&#39;t exist&quot;);</span><br><span class="line">    CGDataProviderRef fontDataProvider &#x3D; CGDataProviderCreateWithURL((__bridge CFURLRef)url);</span><br><span class="line">    CGFontRef newFont &#x3D; CGFontCreateWithDataProvider(fontDataProvider);</span><br><span class="line">    CGDataProviderRelease(fontDataProvider);</span><br><span class="line">    CTFontManagerRegisterGraphicsFont(newFont, nil);</span><br><span class="line">    CGFontRelease(newFont);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UIFont *)fontWithSize:(CGFloat)size &#123;</span><br><span class="line">    UIFont *font &#x3D; [UIFont fontWithName:[self fontName] size:size];</span><br><span class="line">    if (font &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        [self registerFontWithURL: [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;]];</span><br><span class="line">        font &#x3D; [UIFont fontWithName:[self fontName] size:size];</span><br><span class="line">        NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&#39;re using the correct font name.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return font;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字体应用方式<br>可能的应用方式：<ul><li>UILabel作为Icon</li><li>UIButton的titleLabel作为Icon</li><li>根据字体生成UIImage</li></ul></li></ul><p>在实际项目中，鉴于将我们本来的icon当作字体使用，会让我们在项目中添加的控件方式有所变化，而且不容易控制颜色和图标大小，所以我这里推荐第三种方案，根据图片大小、颜色和Unicode码来生成并返回图片。</p><ul><li>应用到项目中<br>将<code>.ttf</code>文件引入到自己的工程中</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-b463acca775cd8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>目前我司项目重构之后的图标为IconFont，新需求用到的图标也会优先采用IconFont。</p><p><a href="https://github.com/sunjinshuai/MYUtils" target="_blank" rel="noopener">demo地址</a></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="noopener">使用IconFont减小iOS应用体积</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了&lt;code&gt;APP Slicing&lt;/code&gt;功能，我司项目在i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 中 Label 的抗拉伸和抗压缩</title>
    <link href="https://sunjinshuai.github.io/2017/07/18/%E6%B5%85%E8%B0%88%20iOS%20AutoLayout%20%E4%B8%AD%20Label%20%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/"/>
    <id>https://sunjinshuai.github.io/2017/07/18/%E6%B5%85%E8%B0%88%20iOS%20AutoLayout%20%E4%B8%AD%20Label%20%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/</id>
    <published>2017-07-17T16:42:23.000Z</published>
    <updated>2018-09-12T13:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIView</code> 中关于 <code>Content Hugging</code> 和 <code>Content Compression Resistance</code> 的方法有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br><span class="line">- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br><span class="line"></span><br><span class="line">- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br><span class="line">- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br></pre></td></tr></table></figure><p>在 <code>Autolayout</code> 优先级的范围是 <code>1 ~ 1000</code>，创建一个约束，默认的优先级是最高的 <code>1000</code>。</p><h4 id="Content-Hugging-Priority"><a href="#Content-Hugging-Priority" class="headerlink" title="Content Hugging Priority"></a>Content Hugging Priority</h4><p>Content Hugging Priority: 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是251。</p><p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，子视图的总和，不够填充父视图区域时，此属性可以控制优先拉伸哪个视图内容。</p><h4 id="Content-Compression-Resistance-Priority"><a href="#Content-Compression-Resistance-Priority" class="headerlink" title="Content Compression Resistance Priority"></a>Content Compression Resistance Priority</h4><p>Content Compression Resistance Priority: 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750。</p><p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，并且子控件可能会超出父视图的区域时，此属性可控制哪些视图被内容被优先压缩，使其不超出父视图区域。</p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>Content Compression Resistance Priority</p><p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *yellowLabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">yellowLabel.text &#x3D; @&quot;我是黄色Label,我是黄色Label,我是黄色Label,我是黄色Label&quot;;</span><br><span class="line">yellowLabel.backgroundColor &#x3D; [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:yellowLabel];</span><br><span class="line"></span><br><span class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100);</span><br><span class="line">make.right.equalTo(self.view).offset(-100);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-76c5062f92a502d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从最后的显示效果来看，中间的 <code>Label</code> 被压缩了。因为左右约束的优先级比固有内容相关的优先级要高，所以 <code>Autolayout</code> 布局的时候会优先满足左右两个约束。这时候：<strong>左边约束宽度 + 右边约束宽度 +  <code>Label</code> 的固有内容宽度 &gt; 屏幕宽度</strong>。所以最后只能压缩 <code>Label</code> 显示的宽度。</p><p>修改 <code>View</code> 左边约束和右边约束的优先级，或者只修改左(右)边约束优先级，然后设置 <code>Label</code> 抗压缩的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *yellowLabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">yellowLabel.text &#x3D; @&quot;我是黄色Label,我是黄色Label&quot;;</span><br><span class="line">yellowLabel.backgroundColor &#x3D; [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:yellowLabel];</span><br><span class="line">[yellowLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100).priority(250);</span><br><span class="line">make.right.equalTo(self.view).offset(-100).priority(250);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-457044f53dc6af44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这时候 <code>Label</code> 控件的抗压缩约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗压缩特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被压缩的就是左边和右边的约束。</p><p>Content Hugging Priority</p><p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *bluelabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">bluelabel.text &#x3D; @&quot;我是蓝色Label&quot;;</span><br><span class="line">bluelabel.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">[self.view addSubview:bluelabel];</span><br><span class="line"></span><br><span class="line">[bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100);</span><br><span class="line">make.right.equalTo(self.view).offset(-100);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-a81805a367faf561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>拉伸和压缩的时候类似，左右约束优先级比 <code>Label</code> 的 <code>Content Hugging Priority</code> 优先级高，并且此时：<strong>左边约束宽度 + 右边约束宽度+ <code>Label</code> 的固有内容宽度 &lt; 屏幕宽度</strong>。为了满足左右两个约束，就只有拉伸 <code>Label</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *bluelabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">bluelabel.text &#x3D; @&quot;我是蓝色Label&quot;;</span><br><span class="line">bluelabel.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">[self.view addSubview:bluelabel];</span><br><span class="line">[bluelabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">[bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100).priority(250);</span><br><span class="line">make.right.equalTo(self.view).offset(-100).priority(250);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-556aa245eb387eae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这时候 <code>Label</code> 控件的抗拉伸约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗拉伸特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被拉伸的就是左边和右边的约束。</p><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/Label%26Compress%26Hugging" target="_blank" rel="noopener">Label 的抗拉伸和抗压缩</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;UIView&lt;/code&gt; 中关于 &lt;code&gt;Content Hugging&lt;/code&gt; 和 &lt;code&gt;Content Compression Resistance&lt;/code&gt; 的方法有：&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mac iterm2 配色方案</title>
    <link href="https://sunjinshuai.github.io/2017/06/12/Mac-iterm2-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://sunjinshuai.github.io/2017/06/12/Mac-iterm2-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</id>
    <published>2017-06-12T13:44:57.000Z</published>
    <updated>2018-09-12T13:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装</strong></p><p>首先我们下载的 iTem2 这个软件，比 Mac 自带的终端更加强大。直接官网 <a href="http://iterm2.com/" target="_blank" rel="noopener">http://iterm2.com/</a> 下载并安装即可。</p><p><strong>配色方案</strong></p><p>我选用的是 <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">solarized</a>，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors，或者在 github 上下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;altercation&#x2F;solarized.git</span><br></pre></td></tr></table></figure><p>但是打开 iterm2 发现灰蒙蒙的，就像下面这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-79f94acb51b5baf8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>打开 iTerm2 - Preferences - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉，彩色的世界就回来了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-721e68e0e940bd75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们下载的 iTem2 这个软件，比 Mac 自带的终端更加强大。直接官网 &lt;a href=&quot;http://iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ite
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 Zombie Objects</title>
    <link href="https://sunjinshuai.github.io/2017/05/10/%E6%B5%85%E8%B0%88-Zombie-Objects/"/>
    <id>https://sunjinshuai.github.io/2017/05/10/%E6%B5%85%E8%B0%88-Zombie-Objects/</id>
    <published>2017-05-10T14:49:17.000Z</published>
    <updated>2018-09-12T14:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p><h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li></ul><p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p><h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p><p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#x2F;&#x2F; Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    __unsafe_unretained NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    [array addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：</p><ul><li>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针。<code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</li><li><code>assign</code>仅用于修饰<code>NSInteger</code>等OC基础类型，以及<code>short</code>、<code>int</code>、<code>double</code>、结构体等C数据类型，不修饰对象指针。</li><li>如果需要弱引用OC对象，建议使用<code>weak</code>关键字，因为被<code>weak</code>指针所引用的对象被回收后，<code>weak</code>指针会被赋为<code>nil</code>（空指针），给<code>nil</code>发任何消息都不会出问题。使用<code>weak</code>修饰代理对象属性就是很好的例子。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;僵尸对象（Zombie-Objects）&quot;&gt;&lt;a href=&quot;#僵尸对象（Zombie-Objects）&quot; class=&quot;headerlink&quot; title=&quot;僵尸对象（Zombie Objects）&quot;&gt;&lt;/a&gt;僵尸对象（Zombie Objects）&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/05/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/05/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2017-05-08T10:31:52.000Z</published>
    <updated>2020-01-10T01:22:41.846Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p><p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p><ul><li><p><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</p></li><li><p>查看现有的<code>podspec</code>源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul><li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li><li>创建pod私有库所需要的项目工程文件，并上传到私有库</li><li>创建pod所对应的podspec文件，并进行验证／测试</li><li>向私有的Spec Repo中提交podspec</li><li>使用pod库</li></ul><h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul><li><p>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</p></li><li><p>将私有Spec Repo关联到本地</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add FXSpesc http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git</span><br></pre></td></tr></table></figure><p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p></li><li><p>执行命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p><h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul><li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>手动创建Xcode工程(过于简单)</p></li></ul><h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul><li>如果用<code>pod</code>命令创建，</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 你项目工程文件</span><br><span class="line">pod spec create FXKit.podspec</span><br></pre></td></tr></table></figure></li><li><p>修改<code>podspec</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.name         &#x3D; &quot;FXKit&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;FXKit，繁星优选私有库&quot;</span><br><span class="line">  s.description  &#x3D; &lt;&lt;-DESC</span><br><span class="line">   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  s.homepage     &#x3D; &quot;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git&quot;</span><br><span class="line"></span><br><span class="line">  # s.license    &#x3D; &quot;MIT (example)&quot;</span><br><span class="line">  s.license      &#x3D; &#123; :type &#x3D;&gt; &quot;MIT&quot;, :file &#x3D;&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line">  s.author       &#x3D; &#123; &quot;孙金帅&quot; &#x3D;&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</span><br><span class="line">  s.platform     &#x3D; :ios</span><br><span class="line">  s.source       &#x3D; &#123;</span><br><span class="line">:git &#x3D;&gt; &quot;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git&quot;,</span><br><span class="line">:tag &#x3D;&gt; &quot;#&#123;s.version&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s.source_files &#x3D; &#39;FXKit&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;</span><br><span class="line"></span><br><span class="line">  # s.resource_bundles &#x3D; &#123;</span><br><span class="line">  #   &#39;FXKit&#39; &#x3D;&gt; [&#39;FXKit&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">  # &#125;</span><br><span class="line"></span><br><span class="line">  s.public_header_files &#x3D; &#39;FXKit&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;</span><br><span class="line">  # s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure></li><li><p>commit项目工程的源文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint FXKit.podspec --sources&#x3D;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p><h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</span><br><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push FXSpesc NAME.podspec --sources&#x3D;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings --use-libraries</span><br></pre></td></tr></table></figure><h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
