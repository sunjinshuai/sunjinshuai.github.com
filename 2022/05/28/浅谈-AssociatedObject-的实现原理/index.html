<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈 AssociatedObject 的实现原理 · 孙金帅的技术博客</title><meta name="description" content="浅谈 AssociatedObject 的实现原理 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈 AssociatedObject 的实现原理</h1><div class="post-info">2022年5月28日</div><div class="post-content"><p>思考，如何给动态添加属性和方法？<br>答案：可以使用 <code>@property</code> 给分类添加属性和方法；</p>
<p><code>@property</code> 会做三件事：</p>
<ul>
<li>生成实例变量 <code>_property</code></li>
<li>生成 <code>getter</code> 方法 <code>- property</code></li>
<li>生成 <code>setter</code> 方法 <code>- setProperty:</code></li>
</ul>
<p>创建一个 <code>NSObject</code> 的分类 <code>Category</code>，并添加一个属性 <code>name</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Category)</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson (Test)</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(name));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><img src="66ee0244-4780-490d-8de1-f223dee02725.png" alt="image.png"></p>
<p>发现编译器报错了，</p>
<p><strong>在这里的警告告诉我们 name 属性的存取方法需要自己手动去实现，或者使用 @dynamic 在运行时实现这些方法。</strong><br><strong>换句话说，分类中的 @property 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。</strong><br>在分类中，因为类的实例变量的布局已经固定，使用 <code>@property</code> 已经无法向固定的布局中添加新的实例变量。</p>
<h3 id="Associated-Object"><a href="#Associated-Object" class="headerlink" title="Associated Object"></a>Associated Object</h3><p>关联对象是 <code>Objective-C 2.0</code> 运行时的一个特性，最早开始使用是在 <code>OS X Snow Leopard</code> 和 <code>iOS 4</code> 中。在 <code>&lt;objc/runtime.h&gt;</code> 中定义的三个方法，关联对象允许开发者对已经存在的类在扩展中添加自定义的属性，这几乎弥补了 <code>Objective-C</code> 最大的缺点；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Sets an associated value for a given object using a given key and association policy.</span><br><span class="line"> * 使用给定的键和关联策略为给定的对象设置关联的值。</span><br><span class="line"> * </span><br><span class="line"> * @param object The source object for the association.</span><br><span class="line"> * 关联的源对象</span><br><span class="line"> *</span><br><span class="line"> * @param key The key for the association.</span><br><span class="line"> * 关联的 key</span><br><span class="line"> * @param value The value to associate with the key key for object. </span><br><span class="line"> * Pass nil to clear an existing association.</span><br><span class="line"> * 与对象的键相关联的值。传递 nil 以清除现有的关联。</span><br><span class="line"> *</span><br><span class="line"> * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.”</span><br><span class="line"> * 关联策略</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> * @see objc_removeAssociatedObjects</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Returns the value associated with a given object for a given key.</span><br><span class="line"> * 返回与给定键的给定对象关联的值</span><br><span class="line"> * </span><br><span class="line"> * @param object The source object for the association.</span><br><span class="line"> * 关联的源对象</span><br><span class="line"> * @param key The key for the association.</span><br><span class="line"> * 关联的 key</span><br><span class="line"> * </span><br><span class="line"> * @return The value associated with the key \e key for \e object.</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Removes all associations for a given object.</span><br><span class="line"> * 删除给定对象的所有关联</span><br><span class="line"> * </span><br><span class="line"> * @param object An object that maintains associated objects.</span><br><span class="line"> * </span><br><span class="line"> * @note The main purpose of this function is to make it easy to return an object</span><br><span class="line"> * to a &quot;pristine state”. You should not use this function for general removal of</span><br><span class="line"> * associations from objects, since it also removes associations that other clients</span><br><span class="line"> * may have added to the object. Typically you should use \c objc_setAssociatedObject</span><br><span class="line"> * with a nil value to clear an association.</span><br><span class="line"> *</span><br><span class="line"> * 意指此函数会一下删除对象全部的关联对象，如果我们想要删除指定的关联对象，</span><br><span class="line"> * 应该使用 objc_setAssociatedObject 函数把 value 参数传递 nil 即可。</span><br><span class="line"> *</span><br><span class="line"> * 此功能的主要目的是使对象轻松返回“原始状态”，因此不应从该对象中普遍删除关联，</span><br><span class="line"> * 因为它还会删除其他 clients 可能已添加到该对象的关联。</span><br><span class="line"> * 通常，您应该将 objc_setAssociatedObject 与 nil 一起使用以清除指定关联。</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> * @see objc_getAssociatedObject</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_removeAssociatedObjects(id _Nonnull object)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>

<p><code>const void *key</code>：存取函数中的参数 <code>key</code> 我们都使用了 <code>@selector(name)</code>，其实也可以使用静态指针 <code>static void *</code> 类型的参数来代替，不过这里强烈建议使用 <code>@selector(name)</code> 作为 <code>key</code> 传入，因为这种方法省略了声明参数的代码，并且能很好地保证 <code>key</code> 的唯一性。<br><strong>关联对象存储在全局的统一的一个 <code>AssociationsManager</code> 中。</strong></p>
<h3 id="关联策略"><a href="#关联策略" class="headerlink" title="关联策略"></a>关联策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN &#x3D; 0,           &#x2F;&#x2F; 指定一个弱引用相关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC &#x3D; 1, &#x2F;&#x2F; 指定相关对象的强引用，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC &#x3D; 3,   &#x2F;&#x2F; 指定相关的对象被复制，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN &#x3D; 01401,       &#x2F;&#x2F; 指定相关对象的强引用，原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY &#x3D; 01403          &#x2F;&#x2F; 指定相关的对象被复制，原子性   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    &#x2F;&#x2F; retain the new value (if any) outside the lock.</span><br><span class="line">    &#x2F;&#x2F; 创建一个ObjcAssociation对象</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通过policy为value创建对应属性，如果policy不存在，则默认为assign</span><br><span class="line">    id new_value &#x3D; value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">    	&#x2F;&#x2F; 创建AssociationsManager对象</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 在manager取_map成员，其实是一个map类型的映射</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建指针指向即将拥有成员的Class</span><br><span class="line">		&#x2F;&#x2F; 至此该类已经包含这个关联对象</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F; 以下是记录强引用类型成员的过程</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            &#x2F;&#x2F; break any existing association.</span><br><span class="line">            &#x2F;&#x2F; 在即将拥有成员的Class中查找是否已经存在改关联属性</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; secondary table exists</span><br><span class="line">                &#x2F;&#x2F; 当存在时候，访问这个空间的map</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                &#x2F;&#x2F; 遍历其成员对应的key</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                	&#x2F;&#x2F; 如果存在key，重新更改Key的指向到新关联属性</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    j-&gt;second &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	&#x2F;&#x2F; 否则以新的key创建一个关联</span><br><span class="line">                    (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; create the new association (first time).</span><br><span class="line">                &#x2F;&#x2F; key不存在的时候，直接创建关联</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] &#x3D; refs;</span><br><span class="line">                (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; setting the association to nil breaks the association.</span><br><span class="line">            &#x2F;&#x2F; 这种情况是policy不存在或者为assign的时候</span><br><span class="line">            &#x2F;&#x2F; 在即将拥有的Class中查找是否已经存在Class</span><br><span class="line">            &#x2F;&#x2F; 其实这里的意思就是如果之前有这个关联对象，并且是非assign形的，直接erase</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 如果有该类型成员检查是否有key</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                	&#x2F;&#x2F; 如果有key，记录旧对象，释放</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; release the old value (outside of the lock).</span><br><span class="line">    &#x2F;&#x2F; 如果存在旧对象，则将其释放</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数执行过程中有两种情况：</p>
<ul>
<li><code>value != nil</code> 新增/更新关联对象的值；</li>
<li><code>value == nil</code> 删除一个关联对象；</li>
</ul>
<p>初始化一个 <code>AssociationsManager</code> 对象，然后获取一个 <code>AssociationsHashMap</code> 哈希表，然后通过 <code>DISGUISE</code> 方法作为去哈希表查找的 <code>key</code>。这里的 <code>DISGUISE</code> 其实进行了按位取反的操作。</p>
<ul>
<li>通过上一步按位取反之后的结果，在 <code>AssociationsHashMap</code> 哈希表中查询，这里是通过迭代器的方式进行查询，查询的结果是 <code>ObjcAssociation</code> 对象，这个结构也是一个哈希表，其内部存储的是 <code>_object_set_associative_reference</code> 方法传入的 <code>key</code> 为键，<code>ObjcAssociation</code> 对象为值的键值对。</li>
<li>如果没有查询到，说明之前在当前类上没有设置过关联对象。则需要初始化一个 <code>ObjectAssociationMap</code> 出来，然后通过 <code>setHasAssociatedObjects</code> 设置当前对象的 <code>isa</code> 的 <code>has_assoc</code> 属性为 <code>true</code>。</li>
<li>如果查询到了，说明之前在当前类上设置过关联对象，接着需要看 <code>key</code> 是否存在，如果 <code>key</code> 存在，那么就需要<strong>覆盖原有的关联对象</strong>；如果 <code>key</code> 不存在，则需要新增一个关联对象。</li>
</ul>
<p>最后会判断 <code>old_association</code> 是否有值，如果有的话就释放掉，当然前提是旧的关联对象的策略是 <code>OBJC_ASSOCIATION_SETTER_RETAIN</code>。</p>
<h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject_non_gc(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value &#x3D; nil;</span><br><span class="line">    uintptr_t policy &#x3D; OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">        if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">            if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry &#x3D; j-&gt;second;</span><br><span class="line">                value &#x3D; entry.value();</span><br><span class="line">                policy &#x3D; entry.policy();</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，跟 <code>objc_setAssociatedObject</code> 一样，<code>objc_getAssociatedObject</code> 这里又包裹了一层，其实现为 <code>_object_get_associative_reference</code>，而这个方法相比于上一节的 <code>_object_set_associative_reference</code> 要简单一些；</p>
<ul>
<li>先初始化一个空的 <code>value</code>，以及一个策略为 <code>OBJC_ASSOCIATION_ASSIGN</code> 的 <code>policy</code>。</li>
<li>初始化一个 <code>AssociationsManager</code> 关联对象管理类。</li>
<li>然后以 <code>DISGUISE(object)</code> 按位取反之后的结果为键去查询 <code>AssociationsHashMap</code>。</li>
<li>如果在 <code>AssociationsHashMap</code> 中找到了，接着以 <code>key</code> 为键去 <code>ObjectAssociationMap</code> 中查询 <code>ObjcAssociation</code><br>如果在 <code>ObjectAssociationMap</code> 中查询到了 <code>ObjcAssociation</code>，则把值和策略赋值给方法入口声明的两个临时变量，然后判断获取到的关联对象的策略是否为 <code>OBJC_ASSOCIATION_GETTER_RETAIN</code>，如果是的话，需要对关联值进行 <code>retain</code> 操作。</li>
<li>最后判断如果关联值是否存在且策略为 <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>，是的话就需要调用 <code>objc_autorelease</code> 来释放关联值。</li>
<li>最后返回关联值。</li>
</ul>
<h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object) </span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() &#x3D;&#x3D; 0) return;</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">        if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            &#x2F;&#x2F; copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">            for (ObjectAssociationMap::iterator j &#x3D; refs-&gt;begin(), end &#x3D; refs-&gt;end(); j !&#x3D; end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; remove the secondary table.</span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>objc_removeAssociatedObjects</code> 方法我们平时可能用的不多，从字面含义来看，这个方法应该是用来删除关联对象。<br>这里会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p>
<h3 id="关联对象原理"><a href="#关联对象原理" class="headerlink" title="关联对象原理"></a>关联对象原理</h3><p>实现关联对象技术的核心对象有</p>
<ul>
<li>AssociationsManager</li>
<li>AssociationsHashMap</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ul>
<h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static spinlock_t _lock;</span><br><span class="line">    static AssociationsHashMap *_map;               &#x2F;&#x2F; associative references:  object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; _lock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; _lock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map &#x3D;&#x3D; NULL)</span><br><span class="line">            _map &#x3D; new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它维护了 <code>spinlock_t</code> 和 <code>AssociationsHashMap</code> 的单例，初始化它的时候会调用 <code>lock.lock()</code> 方法，在析构时会调用 <code>lock.unlock()</code>，而 <code>associations</code> 方法用于取得一个全局的 <code>AssociationsHashMap</code> 单例。</p>
<p>也就是说 <code>AssociationsManager</code> 通过持有一个自旋锁 <code>spinlock_t</code> 保证对 <code>AssociationsHashMap</code> 的操作是线程安全的，即每次只会有一个线程对 <code>AssociationsHashMap</code> 进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">    id value() const &#123; return _value; &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasValue() &#123; return _value !&#x3D; nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先，<code>AssociationsHashMap</code> 用与保存从对象的 <code>disguised_ptr_t</code> 到 <code>ObjectAssociationMap</code> 的映射；<br><code>ObjectAssociationMap</code> 则保存了从 <code>key</code> 到关联对象 <code>ObjcAssociation</code> 的映射，这个数据结构保存了当前对象对应的所有关联对象；<br>最关键的 <code>ObjcAssociation</code> 包含了 <code>policy</code> 以及 <code>value</code>。而这两个值我们可以发现正是我们调用 <code>objc_setAssociatedObject</code> 函数传入的值，也就是说我们在调用 <code>objc_setAssociatedObject</code> 函数中传入的 <code>value</code> 和 <code>policy</code> 这两个值最终是存储在 <code>ObjcAssociation</code> 中的。</p>
<p><img src="e5392d89-02bd-459d-aeda-bd59e0a71fd6.png" alt="image.png"></p>
<p>通过上图我们可以总结为：一个实例对象就对应一个 <code>ObjectAssociationMap</code>，而 <code>ObjectAssociationMap</code> 中存储着多个此实例对象的关联对象的 <code>key</code> 以及 <code>ObjcAssociation</code>，为 <code>ObjcAssociation</code> 中存储着关联对象的 <code>value</code> 和 <code>policy</code> 策略，关联对象由  <code>AssociationsManager</code> 管理并在  <code>AssociationsHashMap</code> 存储。</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果 <code>category</code> 中的一个关联对象与 <code>Class</code> 中的某个成员同名，虽然 <code>key</code> 值不一定相同，自身的 <code>Class</code> 不一定相同，<code>policy</code> 也不一定相同，但是这样做会直接覆盖之前的成员，造成无法访问，但是其内部所有信息及数据全部存在。<br>例如我们对 <code>ViewController</code> 做一个 <code>Category</code>，来创建一个叫做 <code>view</code> 的成员，我们会发现在运行工程的时候，模拟器直接黑屏。<br>在 <code>viewDidLoad</code> 中下断点，甚至无法进入 <code>debug</code> 模式。因为 <code>view</code> 属性已经被覆盖，所以不会继续进行 <code>viewController</code> 的生命周期。<br>这一点很危险，所以我们要杜绝覆盖 <code>Class</code> 原来的属性，这会破坏 <code>Class</code> 原有的功能。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/05/31/Block-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/" class="prev">上一篇</a><a href="/2022/05/23/iOS-load-%E5%92%8Cinitialize-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2022/05/28/浅谈-AssociatedObject-的实现原理/';
var disqus_title = '浅谈 AssociatedObject 的实现原理';
var disqus_url = 'https://sunjinshuai.github.io/2022/05/28/浅谈-AssociatedObject-的实现原理/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>