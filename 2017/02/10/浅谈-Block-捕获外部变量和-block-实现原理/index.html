<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈 Block 捕获外部变量和 __block 实现原理 · 孙金帅的技术博客</title><meta name="description" content="浅谈 Block 捕获外部变量和 __block 实现原理 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈 Block 捕获外部变量和 __block 实现原理</h1><div class="post-info">2017年2月10日</div><div class="post-content"><p><img src="588630-08c2619e323632fa.png" alt="image.png"></p>
<p><code>block</code> 是 <code>C</code> 语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。<code>block</code> 在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它使用方法。</p>
<p>完整的 <code>block</code> 语法是如下形式：<br><code>block</code> 的声明格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^blockName)(参数列表);</span><br><span class="line">&#x2F;&#x2F; block的声明</span><br><span class="line">int (^sumblock)(int arg1, int arg2);</span><br><span class="line">void (^blockName)(int arg1, int arg2)</span><br></pre></td></tr></table></figure>

<p><code>block</code> 的定义格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^block变量名)(形参列表) &#x3D; ^(形参列表) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明并使用 <code>block</code><br>开发者使用 <code>^</code> 操作符声明 <code>block</code> 变量，<code>^</code> 表示是一个 <code>block</code> 的开始。<code>block</code> 的 <code>body</code> 体在 <code>{ }</code>之内。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int multiplier &#x3D; 7;</span><br><span class="line">int (^myblock)(int) &#x3D; ^(int num) &#123;</span><br><span class="line">  return num * multiplier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>block</code> 可以使用“在其定义作用范围内的”变量；如果你声明了一个 <code>block</code> 变量，可以像函数一样使用它。</p>
<h4 id="block的用法"><a href="#block的用法" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的 <code>block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)() &#x3D; ^&#123;</span><br><span class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">blockName();</span><br></pre></td></tr></table></figure>
<p>有参数无返回值的 <code>block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)(int a, int b) &#x3D; ^(int a, int b) &#123;</span><br><span class="line">  NSLog(@&quot;%d + %d &#x3D; %d&quot;,a,b,a+b);</span><br><span class="line">&#125;;</span><br><span class="line">blockName(10,10);</span><br></pre></td></tr></table></figure>
<p>有参数有返回值的 <code>block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (^sumblock)(int a, int b) &#x3D; ^(int a, int b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">int sum &#x3D; sumblock(10,10);</span><br><span class="line">NSLog(@&quot;sum &#x3D; %d&quot;,sum);</span><br></pre></td></tr></table></figure>
<p><code>block</code> 结合 <code>typedef</code> 使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^sumblock)(int, int);</span><br><span class="line"></span><br><span class="line">interface ViewController ()</span><br><span class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  self.sumblock &#x3D; ^(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  NSLog(@&quot;sum &#x3D; %d&quot;,self.sumblock(10,10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="block-作为函数参数"><a href="#block-作为函数参数" class="headerlink" title="block 作为函数参数"></a><code>block</code> 作为函数参数</h4><p><code>block</code> 作为 <code>C</code> 函数参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的C函数</span><br><span class="line">void useblockForC(int(^ablock)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">useblockForC(addblock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">useblockForC(^(int x, int y) &#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>block</code> 作为 <code>OC</code> 函数参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的OC函数</span><br><span class="line">- (void)useblockForOC:(int(^)(int, int))ablock</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">[self useblockForOC:addblock];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">[self useblockForOC:^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<p><code>block</code> 是 <code>C</code> 语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。<code>block</code> 在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它使用方法。</p>
<p>完整的 <code>block</code> 语法是如下形式：<br><code>block</code> 的声明格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^blockName)(参数列表);</span><br><span class="line">&#x2F;&#x2F; block的声明</span><br><span class="line">int (^sumblock)(int arg1, int arg2);</span><br><span class="line">void (^blockName)(int arg1, int arg2)</span><br></pre></td></tr></table></figure>

<p><code>block</code> 的定义格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^block变量名)(形参列表) &#x3D; ^(形参列表) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明并使用 <code>block</code><br>开发者使用 <code>^</code> 操作符声明 <code>block</code> 变量，<code>^</code> 表示是一个 <code>block</code> 的开始。<code>block</code> 的 <code>body</code> 体在 <code>{ }</code>之内。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int multiplier &#x3D; 7;</span><br><span class="line">int (^myblock)(int) &#x3D; ^(int num) &#123;</span><br><span class="line">  return num * multiplier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>block</code> 可以使用“在其定义作用范围内的”变量；如果你声明了一个 <code>block</code> 变量，可以像函数一样使用它。</p>
<h4 id="block的用法-1"><a href="#block的用法-1" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的 <code>block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)() &#x3D; ^&#123;</span><br><span class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">blockName();</span><br></pre></td></tr></table></figure>
<p>有参数无返回值的 <code>block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)(int a, int b) &#x3D; ^(int a, int b) &#123;</span><br><span class="line">  NSLog(@&quot;%d + %d &#x3D; %d&quot;,a,b,a+b);</span><br><span class="line">&#125;;</span><br><span class="line">blockName(10,10);</span><br></pre></td></tr></table></figure>
<p>有参数有返回值的 <code>block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (^sumblock)(int a, int b) &#x3D; ^(int a, int b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">int sum &#x3D; sumblock(10,10);</span><br><span class="line">NSLog(@&quot;sum &#x3D; %d&quot;,sum);</span><br></pre></td></tr></table></figure>
<p><code>block</code> 结合 <code>typedef</code> 使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^sumblock)(int, int);</span><br><span class="line"></span><br><span class="line">interface ViewController ()</span><br><span class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  self.sumblock &#x3D; ^(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  NSLog(@&quot;sum &#x3D; %d&quot;,self.sumblock(10,10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="block-作为函数参数-1"><a href="#block-作为函数参数-1" class="headerlink" title="block 作为函数参数"></a><code>block</code> 作为函数参数</h4><p><code>block</code> 作为 <code>C</code> 函数参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的C函数</span><br><span class="line">void useblockForC(int(^ablock)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">useblockForC(addblock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">useblockForC(^(int x, int y) &#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>block</code> 作为 <code>OC</code> 函数参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的OC函数</span><br><span class="line">- (void)useblockForOC:(int(^)(int, int))ablock</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">[self useblockForOC:addblock];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">[self useblockForOC:^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>通过下面几个例子，探讨 <code>block</code> 是如何实现的：</p>
<h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了研究编译器是如何实现 <code>block</code> 的，我们需要使用 <code>clang</code>。<code>clang</code> 提供一个命令，可以将 <code>Objetive-C</code> 的源码改写成 <code>c</code> 语言的，借此可以研究 <code>block</code> 具体的源码实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc block.c</span><br></pre></td></tr></table></figure>

<p>转化之后，生成 <code>block.app</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从结构体的命名可以看出这是 <code>block</code> 的实现，<code>block</code> 在 <code>clang</code> 编译器编译之后，生成了一个 <code>__block_impl</code> 结构体，<code>isa</code> 指针表明了 <code>block</code> 可以是一个对象，而 <code>FuncPtr</code> 指针显然是 <code>block</code> 对应的函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们就具体看一下是如何实现的，<code>__main_block_impl_0</code> 就是该 <code>block</code> 的实现，从中我们可以看出：</p>
<ul>
<li><code>__main_block_impl_0</code> 中包含了两个成员变量和一个构造函数，成员变量分别是 <code>__block_impl</code> 结构体和描述信息 <code>__main_block_desc_0</code>，之后在构造函数中初始化 <code>block</code> 的类型信息和函数指针等信息。</li>
<li><code>__main_block_func_0</code> 函数，即 <code>block</code> 对应的函数体。该函数接受一个 <code>__cself</code> 参数，即对应的 <code>block</code> 自身。</li>
<li><code>__main_block_desc_0</code> 结构体，其中 <code>Block_size</code> 存储 <code>block</code> 大小。</li>
</ul>
<p>从上面代码，<strong>可以看出执行 <code>block</code>  就是调用一个以 <code>block</code>  自身作为参数的函数，这个函数对应着 <code>block</code>  的执行体</strong>。</p>
<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><p><code>block</code> 如何捕获自动变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i &#x3D; 1024;</span><br><span class="line">  void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;%d&quot;,i);</span><br><span class="line">  &#125;;</span><br><span class="line">  blk();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int i;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags&#x3D;0) : i(_i) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line">  printf(&quot;%d&quot;,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 1024;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尝试修改局部变量，编译会报错：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-121cf0b90c682d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p>在 <code>__main_block_impl_0</code> 中，可以看到自动变量 <code>i</code>，被 <code>block</code> 从外面捕获进来，成为 <code>__main_block_impl_0</code> 这个结构体的成员变量了。</p>
<p>接着看构造函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags&#x3D;0) : i(_i)</span><br></pre></td></tr></table></figure>
<p>这个构造函数中，自动变量被捕获为成员变量追加到了构造函数中。<br><code>block</code> 捕获外部变量仅仅只捕获 <code>block</code> 闭包里面会用到的值，其他用不到的值，它并不会去捕获。</p>
<p>我们注意到 <code>__main_block_func_0</code> 这个函数的实现，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line">  printf(&quot;%d&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，系统自动给我们加上的注释，<code>bound by copy</code>，自动变量 <code>i</code> 虽然被捕获进来了，但是是用 <code>__cself-&gt;i</code> 来访问的。<code>block</code> 仅仅捕获了 <code>i</code> 的值，并没有捕获 <code>i</code> 的内存地址。所以在 <code>__main_block_func_0</code> 这个函数中即使我们重写这个自动变量 <code>i</code> 的值，依旧没法去改变 <code>block</code> 外面自动变量<code>i</code> 的值。</p>
<p>编译器基于这一点，在编译的层面就防止开发者可能犯的错误，因为自动变量没法在 <code>block</code> 中改变外部变量的值，所以编译过程中就报编译错误，<strong>错误原因告诉我们变量不可赋值，也提醒我们要使用 <code>__block</code> 类型标识符。</strong>错误就是最开始的那张截图。</p>
<p>自动变量是以值传递方式传递到 <code>block</code> 的构造函数里面去的。<code>block</code> 只捕获 <code>block</code> 中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以 <code>block</code> 内部不能改变自动变量的值。</p>
<h4 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h4><p>静态局部变量是如何在 <code>__block</code> 执行体中被修改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    static int i &#x3D; 10;</span><br><span class="line">    void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">        i &#x3D; 30;</span><br><span class="line">        printf(&quot;%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int *i;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_i, int flags&#x3D;0) : i(_i) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">        (*i) &#x3D; 30;</span><br><span class="line">        printf(&quot;%d&quot;, (*i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    static int i &#x3D; 10;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;i));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>__main_block_impl_0</code> 中，可以看到静态变量 <code>i</code>，被 <code>block</code> 从外面捕获进来，成为 <code>__main_block_impl_0</code> 这个结构体的成员变量了。</p>
<p>接着看构造函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_i, int flags&#x3D;0) : i(_i)</span><br></pre></td></tr></table></figure>
<p>这个构造函数中，静态变量被捕获为成员变量追加到了构造函数中。<br><code>block</code> 捕获外部变量仅仅只捕获 <code>block</code> 闭包里面会用到的值，其他用不到的值，它并不会去捕获。<code>__main_block_impl_0</code> 结构体中成员 <code>i</code> 变成指针类型(<code>int *</code>)。 静态变量传递给 <code>block</code> 是内存地址值，所以能在 <code>block</code> 里面直接改变值。</p>
<p>当然，全局变量、静态全局变量都可以在 <code>block</code> 执行体内被修改。因为是全局的，作用域很广，所以 <code>block</code> 捕获了它们进去之后，<code>block</code> 结束之后，它们的值依旧可以得以保存下来。更准确地讲，<code>block</code> 可以修改它被调用(这里是 <code>__main_block_func_0</code> )时所处作用域内的变量。比如一个 <code>block</code> 作为成员变量时，它也可以访问同一个对象里的其它成员变量。</p>
<h4 id="例子4："><a href="#例子4：" class="headerlink" title="例子4："></a>例子4：</h4><p><code>__block</code> 类型变量是如何支持修改。<br><code>int</code> 类型变量加上<code>__block</code>指示符，使得变量 <code>i</code> 可以在 <code>block</code> 函数体中被修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __block int i &#x3D; 1024;</span><br><span class="line">    void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">        i &#x3D; 1023;</span><br><span class="line">        printf(&quot;%d&quot;,i);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>clang</code> 编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags&#x3D;0) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by ref</span><br><span class="line">  (i-&gt;__forwarding-&gt;i) &#x3D; 1023;</span><br><span class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i &#x3D; &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看出，多出了一个 <code>__Block_byref_i_0</code> 的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__isa</code> 指针也可以知道 <code>__Block_byref_i_0</code> 也可以是对象。</li>
<li><code>__forwarding</code> 指针指向 <code>__Block_byref_i_0</code> </li>
<li>成员变量 <code>i</code>，用来存储使用到的局部变量 <code>i</code>。</li>
</ul>
<p><code>__main_block_impl_0</code> 对应的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags&#x3D;0) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by ref</span><br><span class="line">  (i-&gt;__forwarding-&gt;i) &#x3D; 1023;</span><br><span class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__main_block_impl_0</code> 的成员变量 <code>i</code> 变成了 <code>__Block_byref_i_0*</code> 指针类型。</li>
<li><code>__Block_byref_i_0</code> 指针类型变量 <code>i</code>，通过其成员变量 <code>__forwarding</code> 指针来操作另一个成员变量。</li>
</ul>
<p>注意：<br><code>__Block_byref_i_0</code> 类型变量i仍然处于栈上，当 <code>block</code> 被回调执行时，变量 <code>i</code> 所在的栈已经被展开。<br>查看 <code>__main_block_desc_0</code> 结构体，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，<code>__main_block_desc_0</code> 多了两个成员函数：<code>copy</code> 和 <code>dispose</code>，分别指向 <code>__main_block_copy_0</code>和 <code>__main_block_dispose_0</code>。</p>
<p>当 <code>block</code> 从栈上被 <code>copy</code> 到堆上时，会调用 <code>__main_block_copy_0</code> 将 <code>__block</code> 类型的成员变量 <code>i</code> 从栈上复制到堆上；而当 <code>block</code> 被释放时，相应地会调用 <code>__main_block_dispose_0</code> 来释放 <code>__block</code> 类型的成员变量 <code>i</code>。如果栈上和堆上同时对该变量进行操作，<code>__forwarding</code> 的作用就体现出来了，当一个 <code>__block</code> 变量从栈上被复制到堆上时，栈上的那个 <code>__Block_byref_i_0</code> 结构体中的 <code>__forwarding</code> 指针也会指向堆上的结构。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/07/Object-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" class="prev">上一篇</a><a href="/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2017/02/10/浅谈-Block-捕获外部变量和-block-实现原理/';
var disqus_title = '浅谈 Block 捕获外部变量和 __block 实现原理';
var disqus_url = 'https://sunjinshuai.github.io/2017/02/10/浅谈-Block-捕获外部变量和-block-实现原理/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>