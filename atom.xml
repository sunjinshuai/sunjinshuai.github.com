<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2017-07-18T10:33:02.000Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/03/18/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/03/18/iOS之使用Cocoapods创建私有仓库/</id>
    <published>2017-03-18T10:31:52.000Z</published>
    <updated>2017-07-18T10:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
<p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p>
<ul>
<li><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</li>
<li><p>查看现有的<code>podspec</code>源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul>
<li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li>
<li>创建pod私有库所需要的项目工程文件，并上传到私有库</li>
<li>创建pod所对应的podspec文件，并进行验证／测试</li>
<li>向私有的Spec Repo中提交podspec</li>
<li>使用pod库</li>
</ul>
<h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul>
<li>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</li>
<li><p>将私有Spec Repo关联到本地</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add FXSpesc http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git</div></pre></td></tr></table></figure>
<p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p>
<h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul>
<li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>手动创建Xcode工程(过于简单)</p>
</li>
</ul>
<h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul>
<li>如果用<code>pod</code>命令创建，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你项目工程文件</div><div class="line">pod spec create FXKit.podspec</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  s.name         = &quot;FXKit&quot;</div><div class="line">  s.version      = &quot;0.0.1&quot;</div><div class="line">  s.summary      = &quot;FXKit，繁星优选私有库&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">		   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</div><div class="line">                   DESC</div><div class="line"></div><div class="line">  s.homepage     = &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;</div><div class="line"></div><div class="line">  # s.license    = &quot;MIT (example)&quot;</div><div class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line">  s.author       = &#123; &quot;孙金帅&quot; =&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</div><div class="line">  s.platform     = :ios</div><div class="line">  s.source       = &#123;</div><div class="line">	:git =&gt; &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;,</div><div class="line">	:tag =&gt; &quot;#&#123;s.version&#125;&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.source_files = &apos;FXKit/**/*.&#123;h,m&#125;&apos;</div><div class="line"></div><div class="line">  # s.resource_bundles = &#123;</div><div class="line">  #   &apos;FXKit&apos; =&gt; [&apos;FXKit/Assets/*.png&apos;]</div><div class="line">  # &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;FXKit/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;</div><div class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">s.name：私有库的名称，`pod search`搜索的关键词，注意这里一定要和`.podspec`的名称一样，否则报错。</div><div class="line">s.version：私有库的版本。</div><div class="line">s.ios.deployment_target：支持的pod最低版本。</div><div class="line">s.summary：私有库简介。</div><div class="line">s.description：私有库详细介绍。</div><div class="line">s.homepage：私有库在GitHub上的地址。</div><div class="line">s.license：开源协议。</div><div class="line">s.author：作者。</div><div class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</div><div class="line">s.source：私有库在GitHub上的地址和版本号。</div><div class="line">s.source_files：私有库对外共享的.h和.m文件。</div><div class="line">s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<ul>
<li>commit项目工程的源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git</div><div class="line">git push -u origin master</div><div class="line">git tag -m &quot;first release&quot; 0.0.1</div><div class="line">git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<ul>
<li>验证</li>
</ul>
<p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint FXKit.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p>
<h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</div><div class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</div><div class="line">pod repo push FXSpesc NAME.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings --use-libraries</div></pre></td></tr></table></figure>
<h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AutoreleasePool的实现原理</title>
    <link href="https://sunjinshuai.github.io/2016/10/06/AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2016/10/06/AutoreleasePool的实现原理/</id>
    <published>2016-10-06T06:32:16.000Z</published>
    <updated>2017-07-06T08:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题：autorelease对象什么时候释放。"><a href="#面试题：autorelease对象什么时候释放。" class="headerlink" title="面试题：autorelease对象什么时候释放。"></a>面试题：autorelease对象什么时候释放。</h4><p>autorelease的本质就是延迟调用<code>release</code>方法，在MRC的环境下，可以通过调用<code>[obj autorelease]</code>来延迟释放内存，在ARC的环境下，当我们创建一个对象，会将对象添加到当前的<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时，会对<code>autoreleasepool</code>里面的所有对象做一次<code>release</code>操作。在没有手动加入<code>autoreleasepool</code>的情况下，<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池<code>push</code>和<code>pop</code>。</p>
<p>当<code>autoreleasepool</code>销毁时，在调用堆栈中可以发现，系统调用了<code>-[NSAutoreleasePool release]</code>方法，这个方法最终通过调用<code>AutoreleasePoolPage::pop(void *)</code>函数来负责对<code>autoreleasepool</code>中的<code>autorelease</code>对象执行<code>release</code>操作。</p>
<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>我们打开<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a> 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到<code>autoreleasepool</code>的实现源码。其实，<code>autoreleasepool</code>是没有单独的内存结构的，它是通过以<code>AutoreleasePoolPage</code>为结点的双向链表来实现的。</p>
<ul>
<li>每一个线程的<code>autoreleasepool</code>其实就是一个指针的堆栈，结构中的thread指针指向当前线程；</li>
<li>每一个指针代表一个需要<code>release</code>的对象或者<code>POOL_SENTINEL</code>（哨兵对象，代表一个<code>autoreleasepool</code>的边界）；</li>
<li>一个<code>pool token</code>指向<code>autoreleasepool</code>所对应的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>；</li>
</ul>
<p>一个空的<code>AutoreleasePoolPage</code>的内存结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/588630-f64cda7c9112e5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><code>magic</code>用来校验<code>AutoreleasePoolPage</code>的结构是否完整；</li>
<li><code>next</code>指向最新添加的<code>autorelease</code>对象的下一个位置，初始化时指向 begin() ；</li>
<li><code>thread</code>指向当前线程；</li>
<li><code>parent</code>指向父结点，第一个结点的 parent 值为 nil ；</li>
<li><code>child</code>指向子结点，最后一个结点的 child 值为 nil ；</li>
<li><code>depth</code>代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code>代表 high water mark 。</li>
</ul>
<p>当<code>AutoreleasePoolPage</code>里面的<code>autorelease</code>对象满了，也就是next指针指向了栈顶，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>AutoreleasePoolPage</code>加入，新<code>AutoreleasePoolPage</code>的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。<br>另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。<br>所以，向一个对象发送<code>release</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶next指针指向的位置。</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a><code>autoreleasepool</code></h4><p>使用<code>clang -rewrite-objc</code>命令将下面的 Objective-C 代码重写成 C++ 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</div><div class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</div><div class="line"></div><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个<code>__AtAutoreleasePool</code>类型的局部变量<code>__autoreleasepool</code>来实现<code>@autoreleasepool {}</code>。当声明<code>__autoreleasepool</code>变量时，构造函数<code>__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p>当出了当前作用域时，析构函数<code>~__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure></p>
<p>也就是说<code>@autoreleasepool {}</code>的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line">    void *atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">    // 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</div><div class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code>、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a>objc_autoreleasePoolPush()</h4><p>上面提到的<code>objc_autoreleasePoolPush()</code>函数本质上就是调用的<code>AutoreleasePoolPage</code>的<code>push</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return nil;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据源码得出，每次执行<code>objc_autoreleasePoolPush</code>其实就是创建了一个新的<code>autoreleasepool</code>，对应<code>AutoreleasePoolPage</code>的具体实现就是往<code>AutoreleasePoolPage</code>中的<code>next</code>位置插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>的内存地址。并且把<code>pool token</code>指针指向这个地址，在执行<code>pop</code>操作的时候作为函数的入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline void *push()</div><div class="line">&#123;</div><div class="line">    id *dest = autoreleaseFast(POOL_SENTINEL);</div><div class="line">    assert(*dest == POOL_SENTINEL);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>push</code>函数通过调用<code>autoreleaseFast</code>函数来执行具体的插入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>autoreleaseFast</code>函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前<code>page</code>存在且没有满时，直接将对象添加到当前<code>page</code>中，即<code>next</code>指向的位置；</li>
<li>当前<code>page</code>存在且已满时，创建一个新的<code>page</code> ，并将对象添加到新创建的<code>page</code>中；</li>
<li>当前<code>page</code>不存在时，即还没有<code>page</code>时，创建第一个<code>page</code>，并将对象添加到新创建的<code>page</code>中。<br>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。</li>
</ul>
<h4 id="objc-autoreleasePoolPop-void"><a href="#objc-autoreleasePoolPop-void" class="headerlink" title="objc_autoreleasePoolPop(void *)"></a>objc_autoreleasePoolPop(void *)</h4><p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return;</div><div class="line"></div><div class="line">    // fixme rdar://9167170</div><div class="line">    if (!ctxt) return;</div><div class="line"></div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pop</code>函数的入参就是<code>push</code>函数的返回值，也就是<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>，直到<code>pool token</code>所在<code>page</code>的<code>next</code>指向<code>pool token</code>为止。</p>
<h4 id="autorelease对象释放原理"><a href="#autorelease对象释放原理" class="headerlink" title="autorelease对象释放原理"></a>autorelease对象释放原理</h4><p>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，在执行<code>objc_autoreleasePoolPop(void *)</code>操作的时候作为函数的入参。<br><img src="http://upload-images.jianshu.io/upload_images/588630-cf6a8a8bd44f721c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前<code>AutoreleasePoolPage</code>中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次<code>release</code>消息，并向回移动next指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个<code>AutoreleasePoolPage</code>，直到哨兵所在的<code>AutoreleasePoolPage</code>。</li>
</ul>
<p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数，当执行<code>pop</code>操作后，<br><img src="http://upload-images.jianshu.io/upload_images/588630-ee6388ccaec8b86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;a href=&quot;#面试题：autorelease对象什么时候释放。&quot; class=&quot;headerlink&quot; title=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;/a&gt;面试题：autoreleas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第1期(2015.10.05)</title>
    <link href="https://sunjinshuai.github.io/2015/10/05/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E6%9C%9F-2015-10-05/"/>
    <id>https://sunjinshuai.github.io/2015/10/05/iOS学习笔记-第1期-2015-10-05/</id>
    <published>2015-10-05T03:10:07.000Z</published>
    <updated>2017-07-18T05:31:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本期主要记录了以下几个问题："><a href="#本期主要记录了以下几个问题：" class="headerlink" title="本期主要记录了以下几个问题："></a>本期主要记录了以下几个问题：</h4><ul>
<li>NSString属性什么时候用copy，什么时候用strong?</li>
<li>rvm: command not found</li>
<li>关于HEXO安装失败的解决方法</li>
<li>Mac iterm2 配色方案</li>
</ul>
<h4 id="NSString属性什么时候用copy，什么时候用strong"><a href="#NSString属性什么时候用copy，什么时候用strong" class="headerlink" title="NSString属性什么时候用copy，什么时候用strong?"></a>NSString属性什么时候用copy，什么时候用strong?</h4><p>我们在声明一个<code>NSString</code>属性时，对于其内存相关特性，通常有两种选择(基于<code>ARC</code>环境)：<code>strong</code>与<code>copy</code>。那这两者有什么区别呢？什么时候该用<code>strong</code>，什么时候该用<code>copy</code>呢？让我们先来看个例子。</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>我们定义一个类，并为其声明两个字符串属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface TestStringClass ()</div><div class="line">@property (nonatomic, strong) NSString *strongString;</div><div class="line">@property (nonatomic, copy) NSString *copyedString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码声明了两个字符串属性，其中一个内存特性是<code>strong</code>，一个是<code>copy</code>。下面我们来看看它们的区别。</p>
<p>首先，我们用一个不可变字符串来为这两个属性赋值，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">    NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">    self.strongString = string;</div><div class="line">    self.copyedString = string;</div><div class="line">    NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);</div><div class="line">    NSLog(@&quot;strong string: %p, %p&quot;, strongString, &amp;strongString);</div><div class="line">    NSLog(@&quot;copy string: %p, %p&quot;, copyedString, &amp;copyedString);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7fe441592e20, 0x7fff57519a48</div><div class="line">strong string: 0x7fe441592e20, 0x7fe44159e1f8</div><div class="line">copy string: 0x7fe441592e20, 0x7fe44159e200</div></pre></td></tr></table></figure></p>
<p>我们要以看到，这种情况下，不管是<code>strong</code>还是<code>copy</code>属性的对象，其指向的地址都是同一个，即为<code>string</code>指向的地址。如果我们换作<code>MRC</code>环境，打印<code>string</code>的引用计数的话，会看到其引用计数值是3，即<code>strong</code>操作和<code>copy</code>操作都使原字符串对象的引用计数值加了1。</p>
<p>接下来，我们把<code>string</code>由不可变改为可变对象，看看会是什么结果。即将下面这一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure></p>
<p>改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure></p>
<p>其输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7ff5f2e33c90, 0x7fff59937a48</div><div class="line">strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8</div><div class="line">copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</div></pre></td></tr></table></figure></p>
<p>可以发现，此时<code>copy</code>属性字符串已不再指向<code>string</code>字符串对象，而是深拷贝了<code>string</code>字符串，并让<code>_copyedString</code>对象指向这个字符串。在<code>MRC</code>环境下，打印两者的引用计数，可以看到<code>string</code>对象的引用计数是2，而<code>_copyedString</code>对象的引用计数是1。</p>
<p>此时，我们如果去修改<code>string</code>字符串的话，可以看到：因为<code>_strongString</code>与<code>string</code>是指向同一对象，所以<code>_strongString</code>的值也会跟随着改变(需要注意的是，此时<code>_strongString</code>的类型实际上是<code>NSMutableString</code>，而不是<code>NSString</code>)；而<code>_copyedString</code>是指向另一个对象的，所以并不会改变。</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>由于<code>NSMutableString</code>是<code>NSString</code>的子类，所以一个<code>NSString</code>指针可以指向<code>NSMutableString</code>对象，让我们的<code>strongString</code>指针指向一个可变字符串是OK的。</p>
<p>而上面的例子可以看出，当原字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是<code>strong</code>还是<code>copy</code>属性的对象，都是指向原对象，<code>copy</code>操作只是做了次浅拷贝。</p>
<p>当原字符串是<code>NSMutableString</code>时，<code>strong</code>属性只是增加了原字符串的引用计数，而<code>copy</code>属性则是对原字符串做了次深拷贝，产生一个新的对象，且<code>copy</code>属性对象指向这个新的对象。另外需要注意的是，这个<code>copy</code>属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>
<p>这里还有一个性能问题，即在原字符串是<code>NSMutableString</code>，<code>strong</code>是单纯的增加对象的引用计数，而<code>copy</code>操作是执行了一次深拷贝，所以性能上会有所差异。而如果原字符串是<code>NSString</code>时，则没有这个问题。</p>
<p>所以，在声明<code>NSString</code>属性时，到底是选择<code>strong</code>还是<code>copy</code>，可以根据实际情况来定。不过，一般我们将对象声明为<code>NSString</code>时，都不希望它改变，所以大多数情况下，我们建议用<code>copy</code>，以免因可变字符串的修改导致的一些非预期问题。</p>
<h4 id="rvm-command-not-found"><a href="#rvm-command-not-found" class="headerlink" title="rvm: command not found"></a>rvm: command not found</h4><p>在Mac上安装好ruby的RVM后，在终端输入时，出现rvm: command not found，经过OverStackFlow上的查找，发现了解决办法：<a href="https://stackoverflow.com/questions/11677771/rvm-command-not-found-mac-ox" target="_blank" rel="external">rvm: command not found MAC OX</a></p>
<p>可能是因为ram的shell配置没有加载，在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.rvm/scripts/rvm</div></pre></td></tr></table></figure></p>
<p>接着输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type rvm | head -n 1</div></pre></td></tr></table></figure></p>
<p>如果输出是<code>rvm is a function</code>，则需要将<code>source ~/.rvm/scripts/rvm</code>添加到<code>~/.bash_profile</code>文件中。</p>
<h4 id="关于HEXO安装失败的解决方法"><a href="#关于HEXO安装失败的解决方法" class="headerlink" title="关于HEXO安装失败的解决方法"></a>关于HEXO安装失败的解决方法</h4><p>目前国内npm源有问题；所以键入如下代码即可安装成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div class="line">cnpm install hexo-cli -g</div></pre></td></tr></table></figure>
<h4 id="Mac-iterm2-配色方案"><a href="#Mac-iterm2-配色方案" class="headerlink" title="Mac iterm2 配色方案"></a>Mac iterm2 配色方案</h4><p>iTerm2，更改配色方案为 Solarized：<br>注意：iTerm2 3.0.12（应该比这更早）已经内置 Solarized 的配色方案了，直接在 iTerm2 - Preferences - Profiles - Colors 里面配置就好了</p>
<p>Solarized 的主页：<a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">http://ethanschoonover.com/solarized</a></p>
<p>直接去主页下载或者使用 Git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/altercation/solarized.git</div></pre></td></tr></table></figure></p>
<p>然后打开 solarized/iterm2-colors-solarized/ 双击里面的文件<br>遇到的问题<br>终端灰蒙蒙的，就像下面这样</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b5ce8061f9696756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面我们来回到彩色世界：<br>依次打开 iTerm2 - Preferences - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉<br>彩色的世界就回来了<br><img src="http://upload-images.jianshu.io/upload_images/588630-5ddfa20a33c4e95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本期主要记录了以下几个问题：&quot;&gt;&lt;a href=&quot;#本期主要记录了以下几个问题：&quot; class=&quot;headerlink&quot; title=&quot;本期主要记录了以下几个问题：&quot;&gt;&lt;/a&gt;本期主要记录了以下几个问题：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NSString属性什么时候用c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Object-C编码规范</title>
    <link href="https://sunjinshuai.github.io/2015/05/05/Object-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://sunjinshuai.github.io/2015/05/05/Object-C编码规范/</id>
    <published>2015-05-05T09:24:55.000Z</published>
    <updated>2017-07-05T09:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>1、任意函数长度不得超过50行。<br>2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。</p>
<p>3、在定义函数的行前留白一行。<br>4、功能相近的代码要放在一起。<br>5、使用#pragma来切分不同功能区域的代码。<br>6、二元运算符和参数之间需要放置一个空格，一元运算符、强制类型转换和参数之间不放置空格。关键字之后圆括号之前需要放置一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void *ptr = &amp;value + 10 * 3;</div><div class="line">NSString *str1 = (NSString *)str2;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">	[self doSomeThing];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7、长的字面值应被拆分为多行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSArray *theShit = @[</div><div class="line">    @&quot;Got some long string objects in here.&quot;,</div><div class="line">    [AndSomeModelObjects too],</div><div class="line">    @&quot;Moar strings.&quot;</div><div class="line">];</div><div class="line"></div><div class="line">NSDictionary *keyedShit = @&#123;</div><div class="line">    @&quot;this.key&quot;: @&quot;corresponds to this value&quot;,</div><div class="line">    @&quot;otherKey&quot;: @&quot;remoteData.payload&quot;,</div><div class="line">    @&quot;some&quot;: @&quot;more&quot;,</div><div class="line">    @&quot;JSON&quot;: @&quot;keys&quot;,</div><div class="line">    @&quot;and&quot;: @&quot;stuff&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名是编程中最基本的技能，我们给变量、函数、类、包等等命名。给他们以名字，让他们有意义，既能表示他们到底是做什么的，也能将其与其他变量区别开来。像人一样娶一个好名字至关重要，“丁当”总比“狗蛋”来的好听。 为什么要命名？ <strong>命名一定要“名副其实”，尽可能使用有意的名称，而且这个意义和指称的变量真实意义相关。</strong><br>1、基本原则<br>尽量不要出现没有任何意义的命名类似于下述形式的命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 1;</div><div class="line">int b = 3;</div><div class="line">CGPoint point = CGPointMake(a,b);</div></pre></td></tr></table></figure></p>
<p>如果换成下面的形式是不是可读性强了很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int startX = 1;</div><div class="line">int startY = 3;</div><div class="line">CGPoint startPoint = CGPointMake(startX,startY);</div></pre></td></tr></table></figure></p>
<p>命名首字母大写，其他命名首字母小写。并且采用驼峰格式分割单词。 例如：<code>FXTest</code><br>仿照 Cocoa 风格来，使用长命名风格。<br>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">extern ushort APIDefaultPageSize;        // 还行，能明白意思了</div><div class="line">extern ushort APIDefaultFetchPageSize;   // 加上些限定更好一些</div><div class="line">extern ushort APIFetchPageSizeDefault;   // 再好些，把重要的往前放</div><div class="line">FXToolbarComment    // 不推荐</div><div class="line">FXCommentToolbar    // OK，把类型（toolbar）置后</div></pre></td></tr></table></figure></p>
<p>2、类别的扩展名以“被扩展的类名+自定义命名部分组成” 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSSstring+Utils.h</div></pre></td></tr></table></figure></p>
<p>3、通知命名<br>基本命名格式是：<code>与通知相关的类名</code> + <code>Did | Will</code> + <code>UniquePartOfName</code> + <code>Notification</code>，例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSApplicationDidBecomeActiveNotification</div><div class="line">NSWindowDidMiniaturizeNotification</div><div class="line">NSTextViewDidChangeSelectionNotification</div><div class="line">NSColorPanelColorDidChangeNotification</div></pre></td></tr></table></figure></p>
<p>4、宏定义，全部字母大写，例如: <code>#define BW_DEBUG 1</code><br>5、常量定义，字符串定义以小写字母k开头，随后首字母大写，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static NSString* const kBWBarTitle = @&quot;动态&quot;;</div></pre></td></tr></table></figure></p>
<p>ps：如果要定义常量使用static const优于宏定义，前者会进行类型检查。<br>6、缩略词，以下是一些常用的首字母缩略词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ASCII,PDF,XML,HTML,URL,RTF,HTTP,TIFF,JPG,PNG,GIF,LZW,ROM,RGB,CMYK,MIDI,FTP</div></pre></td></tr></table></figure></p>
<p>7、命名空间，因为OC没有命名空间的概念，所以使用前两个或者多个字母来表示命名空间，例如<code>&quot;NSObject中的NS&quot;</code>，我们也使用自己的命名空间。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发现模块：DiscoverController，模块里面其他的控件或者model，DCModel，DCView</div><div class="line">个人中心模块：PersonalCenterViewController，模块里面其他的控件或者model，PCModel，PCView</div></pre></td></tr></table></figure></p>
<h4 id="点标记语法"><a href="#点标记语法" class="headerlink" title="点标记语法"></a>点标记语法</h4><p>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [UIColor orangeColor];</div><div class="line">[UIApplication sharedApplication].delegate;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[UIColor orangeColor]];</div><div class="line">UIApplication.sharedApplication.delegate;</div></pre></td></tr></table></figure></p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>1、方法命名尽可能清晰<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">insertObject:atIndex:</div><div class="line">removeObjectAtIndex:</div><div class="line">removeObject:</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insert:at:</div><div class="line">remove:</div></pre></td></tr></table></figure></p>
<p>2、类方法声明在方法类型与返回类型之间要有空格。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)methodName:(NSString *)string;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)methodName:(NSString *)string;</div></pre></td></tr></table></figure></p>
<p>3、函数<br>(1)、调用时所有参数应该在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</div></pre></td></tr></table></figure></p>
<p>(2)、或者每行一个参数，以冒号对齐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1</div><div class="line">                   name:arg2</div><div class="line">                   error:arg3];</div></pre></td></tr></table></figure></p>
<p>对于参数过多的函数，尽量使用后面一种对其方式。<br>(3)、不要使用下面的缩进风格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2  // some lines with &gt;1 arg</div><div class="line">              error:arg3];</div><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2 error:arg3];</div><div class="line">[myObject doFooWith:arg1</div><div class="line">          name:arg2  // aligning keywords instead of colons</div><div class="line">          error:arg3];</div></pre></td></tr></table></figure></p>
<p>(4)、如果对传入参数进行数据保护尽量不要用<code>if(!objc)</code>，使用断言来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)sendArgs:(NSDictionary*)args &#123;</div><div class="line">	NSAssert(args, @&quot;args is nil&quot;);</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(5)、方法参数名前一般使用的前缀包括“the”、“an”、“new”。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setTitle:(NSString *)aTitle;</div><div class="line">- (void)setName:(NSString *)newName;</div><div class="line">- (id)keyForOption:(CDCOption *)anOption</div><div class="line">- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;</div><div class="line">- (CDCEmail *)emailForRecipients: (NSArray *)theRecipients;</div></pre></td></tr></table></figure></p>
<p>4、方法名<br>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。<br>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。</p>
<ul>
<li><code>set</code> 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li>
<li><code>get</code> 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。<br>例：<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name;</div><div class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</div><div class="line">- (NSSize)cellSize;</div><div class="line">- (void)setupControllerObservers;</div><div class="line">- (void)setupController;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)getName;</div><div class="line">- (NSSize)calcCellSize;</div><div class="line">- (void)setController;</div></pre></td></tr></table></figure></p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>长的三元运算符应使用圆括号括起来。三元运算符仅用于赋值和做参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *gender = (stuff == thing ? @&quot;男&quot; : @&quot;女&quot;);</div></pre></td></tr></table></figure></p>
<p>当有nil时的三元运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *name = thingThatCouldBeNil ? defaultValue : @&quot;&quot;;</div></pre></td></tr></table></figure></p>
<p>不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *name = thingThatCouldBeNil ?: defaultValue;</div></pre></td></tr></table></figure></p>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>当使用<code>enum</code>关键字时，推荐使用苹果最新引入的固定基础类型语法，因为这将获得强类型检查与代码完成功能。SDK现在包含了一个固定基础类型的宏—<code>NS_ENUM()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, CertifiedModifyPassWordType)</div><div class="line">&#123;</div><div class="line">    CertifiedModifyPassWordTypeWithdrawals = 1,  // 提现</div><div class="line">    CertifiedModifyPassWordTypePaymentFail,  // 支付失败</div><div class="line">    CertifiedModifyPassWordTypePayment, // 支付</div><div class="line">    CertifiedModifyPassWordTypeOther</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>因为nil被解析为了NO，所以和nil作比较没有任何的必要。不要将变量和YES直接比较，因为YES被定义为1而BOOL类型是8位的unsigned int，即BOOL的值不仅仅是1或0。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (!someObject) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (someObject == nil) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (isAwesome)</div><div class="line">if (![someObject boolValue])</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if ([someObject boolValue] == NO)</div><div class="line">if (isAwesome == YES) // Never do this.</div></pre></td></tr></table></figure></p>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>应该使用线程安全的模式创建共享的单例实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">   static id sharedInstance = nil;</div><div class="line">   static dispatch_once_t onceToken;</div><div class="line">   dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      sharedInstance = [[self alloc] init];</div><div class="line">   &#125;);</div><div class="line">   return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单例的另一种做法，利用+ initialize方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static JSONAPI* sharedInstance = nil;</div><div class="line">+ (void)initialize &#123;</div><div class="line">    static dispatch_once_t once;</div><div class="line">    dispatch_once(&amp;once, ^&#123;</div><div class="line">        sharedInstance = [[JSONAPI alloc] init];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Block相关"><a href="#Block相关" class="headerlink" title="Block相关"></a>Block相关</h4><p>在block中使用到self变量的时候，一定要先weak再strong。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">[self doABlockOperation:^&#123;</div><div class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4><p>代理协议名，常用delegate、dateSource做结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</div><div class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</div></pre></td></tr></table></figure></p>
<p>以<code>did</code>、<code>will</code>、<code>should</code>等形容词，代表Event事件的Delegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)windowShouldClose:(id)sender;</div><div class="line">- (void)browserDidScroll:(NSBrowser *)sender;</div><div class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;</div></pre></td></tr></table></figure></p>
<h4 id="控制结构，if-else"><a href="#控制结构，if-else" class="headerlink" title="控制结构，if-else"></a>控制结构，if-else</h4><p>1、方法的花括号推荐另起一行。方法内部需要写在一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)methodName:(NSString *)string &#123;</div><div class="line">    if () &#123;</div><div class="line">    &#125; else &#123;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、条件判断的括号内侧不应有空格。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (a &lt; b) &#123;</div><div class="line">    // something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( a &lt; b ) &#123;</div><div class="line">    // something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、关系运算符（如<code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如<code>&amp;&amp;</code>、<code>||</code>）两边要有空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(someValue &gt; 100) ? YES : NO</div></pre></td></tr></table></figure></p>
<p>二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。<br>多个参数逗号后留一个空格（这也符合正常的西文语法）。<br>4、当需要满足一定条件时才执行某项操作时，使用return是正常合理的。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if (![someOther boolValue]) &#123;</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line">  //Do something important</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!error) &#123;</div><div class="line">    return success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if ([someOther boolValue]) &#123;</div><div class="line">      //Do something important</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!error)</div><div class="line">    return success;</div><div class="line">...</div><div class="line">if (!error) return success;</div></pre></td></tr></table></figure></p>
<h4 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h4><p>UIView的子类初始化的时候，不要进行任何布局操作。布局操作在LayoutSubViews里面做。<br>UIView的子类布局必须在layoutSubViews里面进行，需要布局的时候调用setNeedLayout来告诉系统，需要重新布局该View，不要直接调用layoutSubViews。</p>
<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4><p>在类定义中使用到自己定义的类的时候，尽量不要在头文件中引入自己定义的类的同文件，使用@class替换。在实现文件中引入相应头文件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// BWTest.h</div><div class="line">@class BWDataCenter;</div><div class="line">@interface BWTest : NSObject</div><div class="line">@property (nonatomic, strong) BWDataCenter* dataCenter;</div><div class="line">@end</div><div class="line"></div><div class="line">// BWTest.m</div><div class="line">#import &quot;BWDataCenter.h&quot;</div><div class="line">@implementation BWTest</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h4 id="项目工程文件"><a href="#项目工程文件" class="headerlink" title="项目工程文件"></a>项目工程文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#pragma mark - init Method</div><div class="line">填入init,initWithFrame等方法</div><div class="line">#pragma mark- View Life Cycle</div><div class="line">填入viewdidload,viewdidappear等方法</div><div class="line">#pragma mark- Delegate，DataSource, Callback Method</div><div class="line">填入tableview，scrollview等代理方法</div><div class="line">#pragma mark- Override Parent Methods</div><div class="line">填入updateViewConstraints,updateConstraint, prepareForSegue等方法</div><div class="line">#pragma mark- SubViews Configuration</div><div class="line">填入configureSubViews，configureTableView等方法，这里的方法在init方法或view life cycle被调用</div><div class="line">#pragma mark- Actions</div><div class="line">填入-(IBAction)action:(id)sender和[self addtarget:self action:@selector(action:)]动作指向的方法</div><div class="line">#pragma mark- Public Methods</div><div class="line">填入在.h外暴露的方法</div><div class="line">#pragma mark- Private Methods</div><div class="line">填入.m文件内部调用的方法</div><div class="line">#pragma mark- Getter Setter</div><div class="line">填入对@property初始化的方法</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h4&gt;&lt;p&gt;1、任意函数长度不得超过50行。&lt;br&gt;2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。&lt;/p&gt;
&lt;p&gt;3、在定义函数
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之block的实现原理</title>
    <link href="https://sunjinshuai.github.io/2014/07/10/block%E7%B3%BB%E5%88%97%E4%B9%8Bblock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2014/07/10/block系列之block的实现原理/</id>
    <published>2014-07-10T15:07:10.000Z</published>
    <updated>2017-07-05T08:23:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过下面几个例子，探讨block是如何实现的：</p>
<h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  void (^blk)(void) = ^&#123;</div><div class="line">    printf(&quot;Hello, World!\n&quot;);</div><div class="line">  &#125;;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了研究编译器是如何实现 <code>block</code> 的，我们需要使用 <code>clang</code>。<code>clang</code> 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 <code>block</code> 具体的源码实现方式。该命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc block.c</div></pre></td></tr></table></figure>
<p>转化之后，生成block.app：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>block</code>在<code>clang</code>编译器编译之后，生成了一个<code>__block_impl</code>结构体，<code>isa</code>指针表明了<code>block</code>可以是一个对象，而<code>FuncPtr</code>指针显然是<code>block</code>对应的函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  printf(&quot;Hello, World!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们就具体看一下是如何实现的，<code>__main_block_impl_0</code> 就是该 <code>block</code> 的实现，从中我们可以看出：</p>
<ul>
<li><code>__main_block_impl_0</code>中包含了两个成员变量和一个构造函数，成员变量分别是<code>__block_impl</code>结构体和描述信息<code>__main_block_desc_0</code>，之后在构造函数中初始化<code>block</code>的类型信息和函数指针等信息。</li>
<li><code>__main_block_func_0</code>函数，即<code>block</code>对应的函数体。该函数接受一个<code>__cself</code>参数，即对应的<code>block</code>自身。</li>
<li><code>__main_block_desc_0</code>结构体，其中<code>Block_size</code>存储<code>block</code>大小。<br>从上面代码，可以看出执行block就是调用一个以block自身作为参数的函数，这个函数对应着block的执行体。</li>
</ul>
<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><p>block如何捕获变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  int i = 1024;</div><div class="line">  void (^blk)(void) = ^&#123;</div><div class="line">    printf(&quot;%d&quot;,i);</div><div class="line">  &#125;;</div><div class="line">  blk();</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int i;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int i = __cself-&gt;i; // bound by copy</div><div class="line">  printf(&quot;%d&quot;,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i = 1024;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出这次的<code>block</code>结构体<code>__main_block_impl_0</code>多了个成员变量<code>i</code>，用来存储使用到的局部变量<code>i</code>。当在 <code>block</code> 中引用的变量<code>i</code>的时候，实际是在声明 <code>block</code> 时，被<code>copy</code>到<code>__main_block_impl_0</code>结构体中的那个成员变量<code>i</code>，并且把<code>__cself</code>指针指向成员变量<code>i</code>。</p>
<p>如果尝试修改局部变量，编译会报错：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-121cf0b90c682d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p><strong>错误原因告诉我们变量不可赋值，也提醒我们要使用__block类型标识符。</strong><br>因为<code>main</code>函数中的局部变量<code>i</code>和函数<code>__main_block_func_0</code>不在同一个作用域中，调用过程中只是进行了值传递。当然，在上面代码中，我们可以通过指针来实现局部变量的修改。不过这是由于在调用<code>__main_block_func_0</code>时，<code>main</code>函数栈还没展开完成，变量<code>i</code>还在栈中。但是在很多情况下，<code>block</code>是作为参数传递以供后续回调执行的。通常在这些情况下，<code>block</code>被执行时，定义时所在的函数栈已经被展开，局部变量已经不在栈中了已经被销毁了，再用指针访问就会报常见的<strong>坏内存访问</strong>。</p>
<h4 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h4><p><code>__block</code>类型变量是如何支持修改。<br>int类型变量加上<code>__block</code>指示符，使得变量i可以在block函数体中被修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __block int i = 1024;</div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        i = 1023;</div><div class="line">        printf(&quot;%d&quot;,i);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line">  (i-&gt;__forwarding-&gt;i) = 1023;</div><div class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出，多出了一个<code>__Block_byref_i_0</code> 的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>__isa</code>指针也可以知道<code>__Block_byref_i_0</code>也可以是对象。</li>
<li><code>__forwarding</code>指针指向<code>__Block_byref_i_0</code></li>
<li>成员变量<code>i</code>，用来存储使用到的局部变量<code>i</code>。</li>
</ul>
<p><code>__main_block_impl_0</code>对应的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line">  (i-&gt;__forwarding-&gt;i) = 1023;</div><div class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>__main_block_impl_0</code>的成员变量<code>i</code>变成了<code>__Block_byref_i_0*</code>指针类型。</li>
<li><code>__Block_byref_i_0</code>指针类型变量<code>i</code>，通过其成员变量<code>__forwarding</code>指针来操作另一个成员变量。</li>
</ul>
<p>注意：<br><code>__Block_byref_i_0</code>类型变量i仍然处于栈上，当block被回调执行时，变量i所在的栈已经被展开。<br>查看<code>__main_block_desc_0</code>结构体，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div></pre></td></tr></table></figure>
<p>此时，<code>__main_block_desc_0</code>多了两个成员函数：<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p>
<p>当<code>block</code>从栈上被<code>copy</code>到堆上时，会调用<code>__main_block_copy_0</code>将<code>__block</code>类型的成员变量i从栈上复制到堆上；而当<code>block</code>被释放时，相应地会调用<code>__main_block_dispose_0</code>来释放<code>__block</code>类型的成员变量i。如果栈上和堆上同时对该变量进行操作，<code>__forwarding</code>的作用就体现出来了，当一个<code>__block</code>变量从栈上被复制到堆上时，栈上的那个<code>__Block_byref_i_0</code>结构体中的<code>__forwarding</code>指针也会指向堆上的结构。</p>
<p>References：<br><a href="http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="external">iOS中block实现的探究</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过下面几个例子，探讨block是如何实现的：&lt;/p&gt;
&lt;h4 id=&quot;例子1：&quot;&gt;&lt;a href=&quot;#例子1：&quot; class=&quot;headerlink&quot; title=&quot;例子1：&quot;&gt;&lt;/a&gt;例子1：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之block的存储域</title>
    <link href="https://sunjinshuai.github.io/2014/07/07/block%E7%B3%BB%E5%88%97%E4%B9%8Bblock%E7%9A%84%E5%AD%98%E5%82%A8%E5%9F%9F/"/>
    <id>https://sunjinshuai.github.io/2014/07/07/block系列之block的存储域/</id>
    <published>2014-07-07T13:03:50.000Z</published>
    <updated>2017-07-05T08:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Objective-C 语言中，根据Block对象创建时所处数据区不同而进行区别，一共有 3 种类型的 block：</p>
<ul>
<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量，它是设置在程序的数据区域（.data区）中。</li>
<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁，超出变量作用域，栈上的Block以及  __block变量都被销毁。</li>
<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁，在变量作用域结束时不受影响。</li>
</ul>
<p>在ARC的环境下，block默认是从栈区copy到堆区。<br>栈上的block，如果其所属的变量作用域结束，该block就被废弃，如同一般的自动变量。当然，block中的__block变量也同时被废弃。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ef4fee05adf7961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p>在ARC的环境下，为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们需要把block复制到堆中，延长其生命周期。大多数情况下编译器会恰当地进行判断是否有需要将block从栈复制到堆，如果有，自动生成将block从栈上复制到堆上的代码。block的复制操作执行的是copy实例方法。Block只要调用了copy方法，栈块就会变成堆块。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f9ba1bdcc5db00f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Objective-C 语言中，根据Block对象创建时所处数据区不同而进行区别，一共有 3 种类型的 block：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_NSConcreteGlobalBlock&lt;/code&gt; 全局的静态 block，不会访问任何外部变量，它是设置
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之避免循环引用__weak与__strong的区别</title>
    <link href="https://sunjinshuai.github.io/2014/07/06/block%E7%B3%BB%E5%88%97%E4%B9%8B%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8-weak%E4%B8%8E-strong%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2014/07/06/block系列之避免循环引用-weak与-strong的区别/</id>
    <published>2014-07-06T08:04:47.000Z</published>
    <updated>2017-07-05T08:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>抛砖引玉：<br>我们一般都会遇到这样的问题，当A对象里面强引用了B对象，B对象又强引用了A对象，这样两者的retainCount值一直都无法为0。无论是A对象还是B对象销毁，A对象和B对象始终存在在内存无法中释放，从而导致内存泄露。</p>
<p>所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p>
<p>首先，先看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  [weakSelf doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在OC中，block是一个很实用的语法，特别是与GCD结合使用，可以很方便的实现多线程的并发。但是，如果使用不当，block也会引起一些循环引用的问题。</p>
<p><strong>__weak的出现就是为了解决在使用block时出现的循环引用问题。</strong>在使用block的时候，由于self是被强引用的，在ARC下，编译器自动将代码中的block从栈拷贝到堆时，block会强引用和持有self，而self恰好也强引用和持有了block，就造成了传说中的循环引用。在上面的代码中，在doSomething方法内，weakSelf不会被释放。<br>但是，像下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  [weakSelf doSomething];</div><div class="line">  [weakSelf doOtherThing];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在doSomething中，weakSelf不会变成nil，不过在doSomething执行完成，调用第二个方法doOtherThing的时候，weakSelf有可能被释放。</p>
<p><strong>__strong的出现为了保证在block内不会被释放。</strong>__strong表示强引用，当对象没有任何一个强引用指向它时，它才会被释放。weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  __strong __typeof(self) strongSelf = weakSelf;</div><div class="line">  [strongSelf doSomething];</div><div class="line">  [strongSelf doOtherThing];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 block 之前定义对 self 的一个弱引用 wself，因为是弱引用，所以当 self 被释放时 wself 会变为 nil；然后在 block 中引用该弱应用，<strong>考虑到多线程情况</strong>,通过使用强引用 self 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放；然后在之后的 block 块中使用该强引用 self，注意在使用前要对 self 进行了 nil 检测，因为多线程环境下在用弱引用 wself 对强引用 sself 赋值时，弱引用 wself 可能已经为 nil 了。<br>通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抛砖引玉：&lt;br&gt;我们一般都会遇到这样的问题，当A对象里面强引用了B对象，B对象又强引用了A对象，这样两者的retainCount值一直都无法为0。无论是A对象还是B对象销毁，A对象和B对象始终存在在内存无法中释放，从而导致内存泄露。&lt;/p&gt;
&lt;p&gt;所谓的内存泄露就是本应该
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之block基础</title>
    <link href="https://sunjinshuai.github.io/2014/07/05/block%E7%B3%BB%E5%88%97%E4%B9%8Bblock%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunjinshuai.github.io/2014/07/05/block系列之block基础/</id>
    <published>2014-07-05T08:01:25.000Z</published>
    <updated>2017-07-05T08:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>block是C语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。block在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它的由来和使用方法。</p>
<h4 id="block由来"><a href="#block由来" class="headerlink" title="block由来"></a>block由来</h4><p>先来看看C语言中标准的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int func(int count);</div></pre></td></tr></table></figure>
<p>它声明了名称为func的函数。下面看看怎么调用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int result = func(10);</div></pre></td></tr></table></figure>
<p>如果你知道函数指针，那么应该熟悉下面这个式子，它不用知道函数名也能够使用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int result = （*funcptr）(10);</div></pre></td></tr></table></figure>
<p>但是，实际上仍然需要知道函数的名称。在赋值函数指针时还是需要知道函数名称的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *funcptr (int)= &amp;func;</div></pre></td></tr></table></figure>
<p>为什么需要函数指针呢？<br>函数指针是为了获取函数的地址方便将函数作为参数时的调用.<br>为什么会出现匿名函数？<br>是为了代替函数指针，简化函数的书写。<br>block可以真正的实现不需要函数名称的函数，方便了函数的调用。通俗的讲block就是一段匿名代码块。</p>
<p>完整的block语法是如下形式：<br>block的声明格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">返回值类型 (^blockName)(参数列表);</div><div class="line">// block的声明</div><div class="line">int (^sumblock)(int arg1, int arg2);</div><div class="line">void (^blockName)(int arg1, int arg2)</div></pre></td></tr></table></figure>
<p>block的定义格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">返回值类型 (^block变量名)(形参列表) = ^(形参列表) &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>声明并使用block<br>开发者使用^操作符声明block变量，^表示是一个block的开始。block的body体在{ }之内。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myblock)(int) = ^(int num) &#123;</div><div class="line">  return num * multiplier;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-08c2619e323632fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>block可以使用“在其定义作用范围内的”变量；如果你声明了一个block变量，可以像函数一样使用它。</p>
<h4 id="block的用法"><a href="#block的用法" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void (^blockName)() = ^&#123;</div><div class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</div><div class="line">&#125;;</div><div class="line">blockName();</div></pre></td></tr></table></figure></p>
<p>有参数无返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void (^blockName)(int a, int b) = ^(int a, int b) &#123;</div><div class="line">  NSLog(@&quot;%d + %d = %d&quot;,a,b,a+b);</div><div class="line">&#125;;</div><div class="line">blockName(10,10);</div></pre></td></tr></table></figure></p>
<p>有参数有返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int (^sumblock)(int a, int b) = ^(int a, int b)&#123;</div><div class="line">  return a + b;</div><div class="line">&#125;;</div><div class="line">int sum = sumblock(10,10);</div><div class="line">NSLog(@&quot;sum = %d&quot;,sum);</div></pre></td></tr></table></figure></p>
<p>block结合typedef使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef int (^sumblock)(int, int);</div><div class="line"></div><div class="line">interface ViewController ()</div><div class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  self.sumblock = ^(int a, int b) &#123;</div><div class="line">    return a + b;</div><div class="line">  &#125;;</div><div class="line">  NSLog(@&quot;sum = %d&quot;,self.sumblock(10,10));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>block作为函数参数<br>block作为C函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1.定义一个形参为block的C函数</div><div class="line">void useblockForC(int(^ablock)(int, int))</div><div class="line">&#123;</div><div class="line">  NSLog(@&quot;result = %d&quot;, ablock(300,200));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.声明并赋值定义一个block变量</div><div class="line">int(^addblock)(int, int) = ^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 3.以block作为函数参数,把block像对象一样传递</div><div class="line">useblockForC(addblock);</div><div class="line"></div><div class="line">// 将第2点和第3点合并一起,以内联定义的block作为函数参数</div><div class="line">useblockForC(^(int x, int y) &#123;</div><div class="line">  return x+y;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>block作为OC函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1.定义一个形参为block的OC函数</div><div class="line">- (void)useblockForOC:(int(^)(int, int))ablock</div><div class="line">&#123;</div><div class="line">  NSLog(@&quot;result = %d&quot;, ablock(300,200));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.声明并赋值定义一个block变量</div><div class="line">int(^addblock)(int, int) = ^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 3.以block作为函数参数,把block像对象一样传递</div><div class="line">[self useblockForOC:addblock];</div><div class="line"></div><div class="line">// 将第2点和第3点合并一起,以内联定义的block作为函数参数</div><div class="line">[self useblockForOC:^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;block是C语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。block在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它的由来和使用方法。&lt;/p&gt;
&lt;h4 id=&quot;block由来&quot;&gt;&lt;a href=&quot;#block由来&quot; class=&quot;headerli
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HEXO搭建个人博客</title>
    <link href="https://sunjinshuai.github.io/2014/07/04/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunjinshuai.github.io/2014/07/04/HEXO搭建个人博客/</id>
    <published>2014-07-04T13:41:47.000Z</published>
    <updated>2017-07-04T14:39:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点会使用，并不难，但是要做到让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢。最近看到一些大神们的博客，貌似都是用hexo写得，本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装homebrew</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<p>安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install git</div></pre></td></tr></table></figure></p>
<p>安装node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure></p>
<p>安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p>
<h4 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h4><p>创建新建一个文件夹，用来存放本地博客。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>Hexo会在创建的文件夹创建本地博客所需的一切资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure></p>
<p>访问本地localhost:4000可以看到博客已经搭建成功。</p>
<h4 id="同步Hexo博客到Github"><a href="#同步Hexo博客到Github" class="headerlink" title="同步Hexo博客到Github"></a>同步Hexo博客到Github</h4><ul>
<li>在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。</li>
<li>开本地的创建的文件夹中的_config.yml配置文件，将其中的type设置为git。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">type: git</div><div class="line">repo: https://github.com/sunjinshuai/sunjinshuai.github.com</div><div class="line">branch: master</div></pre></td></tr></table></figure>
<p>在terminal终端，将当前目录切换到你的本地博客目录，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>在terminal终端，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate   // 可以简写成hexo g 根据markdown文件生成静态文件</div><div class="line">hexo deploy     // 或者简写成hexo d 将本地修改，部署到远端</div></pre></td></tr></table></figure></p>
<p>此时，打开浏览器，访问<a href="https://sunjinshuai.github.io">https://sunjinshuai.github.io</a> ，就可以看到你的博客。</p>
<h4 id="Hexo安装新主题apollo"><a href="#Hexo安装新主题apollo" class="headerlink" title="Hexo安装新主题apollo"></a>Hexo安装新主题apollo</h4><p>Hexo换皮肤还是比较简单的，既可以自己根据默认的主题来修改，也可以到<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a> 上去找主题。</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>github上的文档给出了详细的安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo init #blogname#</div><div class="line">cd #blogname# </div><div class="line">npm install</div><div class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</div><div class="line">git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo</div></pre></td></tr></table></figure></p>
<h5 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h5><p>安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: apollo</div><div class="line"></div><div class="line"># 在归档页面显示所有文章</div><div class="line"># 需要上面安装的 hexo-generator-archive 插件支持</div><div class="line">archive_generator:</div><div class="line">per_page: 0</div><div class="line">yearly: false</div><div class="line">monthly: false</div><div class="line">daily: false</div></pre></td></tr></table></figure></p>
<h4 id="hexo常用的命令"><a href="#hexo常用的命令" class="headerlink" title="hexo常用的命令"></a>hexo常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hexo init       //在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件</div><div class="line">hexo new “my new blog title”   //新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</div><div class="line">hexo clean      // 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存</div><div class="line">hexo generate   // 可以简写成hexo g 根据markdown文件生成静态文件</div><div class="line">hexo server     // 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问</div><div class="line">hexo deploy     // 或者简写成hexo d 将本地修改，部署到远端</div><div class="line">hexo version    // 显示hexo版本</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点会使用，并不难，但是要做到让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢。最近看到一些大神们的博客，貌似都是用hexo写得，本
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sunjinshuai.github.io/2014/07/04/hello-world/"/>
    <id>https://sunjinshuai.github.io/2014/07/04/hello-world/</id>
    <published>2014-07-04T13:40:47.000Z</published>
    <updated>2017-07-05T04:00:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
