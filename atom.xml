<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2018-09-12T13:35:30.000Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 KVO 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2018-09-11T13:28:58.000Z</published>
    <updated>2018-09-12T13:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>KVO</code> 全称 <code>KeyValueObserving</code> 是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，当指定的对象的属性被修改后，则对象就会接受收到通知。简单的说就是每次指定的被观察的对象的属性被修改后，<code>KVO</code> 就会自动通知相应的观察者了。</p><h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul><li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li><li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li><li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li></ul><p><code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p></blockquote><h4 id="简单概述下-KVO-的实现："><a href="#简单概述下-KVO-的实现：" class="headerlink" title="简单概述下 KVO 的实现："></a>简单概述下 <code>KVO</code> 的实现：</h4><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。重写的 <code>setter</code> 方法会在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针指向这个新创建的类，对象变成了新创建的类的实例，而不是原来真正的类。</p><h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a><code>KVO</code> 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。<br>例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@interface TestKVOViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Message *message;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestKVOViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    </span><br><span class="line">    Message *message &#x3D; [[Message alloc] init];</span><br><span class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    message.text &#x3D; @&quot;hello object-c&quot;;</span><br><span class="line">    self.message &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</span><br><span class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &#39;NSRangeException&#39;, reason: &#39;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&#39;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</span><br><span class="line">1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</span><br><span class="line">2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</span><br><span class="line">3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</span><br><span class="line">4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</span><br><span class="line">5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</span><br><span class="line">6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</span><br><span class="line">7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</span><br><span class="line">8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</span><br><span class="line">9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</span><br><span class="line">10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</span><br><span class="line">11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</span><br><span class="line">12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</span><br><span class="line">14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</span><br><span class="line">16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</span><br><span class="line">17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</span><br><span class="line">18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</span><br><span class="line">19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</span><br><span class="line">20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</span><br><span class="line">21  ImplementKVO                        0x000000010dd2dfef main + 111</span><br><span class="line">22  libdyld.dylib                       0x00000001129fe955 start + 1</span><br><span class="line">23  ???                                 0x0000000000000001 0x0 + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure><h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (KVO)</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">forKey:(NSString *)key</span><br><span class="line">withBlock:(ObservingBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p><ul><li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li><li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li><li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li><li>添加这个观察者；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</span><br><span class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</span><br><span class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</span><br><span class="line"> 4. 将调用对象添加到数组中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">             forKey:(NSString *)key</span><br><span class="line">          withBlock:(ObservingBlock)block &#123;</span><br><span class="line">    </span><br><span class="line">    SEL setterSelector &#x3D; NSSelectorFromString(setterForGetter(key));</span><br><span class="line">    Method setterMethod &#x3D; class_getInstanceMethod([self class], setterSelector);</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class clazz &#x3D; object_getClass(self);</span><br><span class="line">    NSString *clazzName &#x3D; NSStringFromClass(clazz);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; if not an KVO class yet</span><br><span class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</span><br><span class="line">        clazz &#x3D; [self makeKvoClassWithOriginalClassName:clazzName];</span><br><span class="line">        object_setClass(self, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; add our kvo setter if this class (not superclasses) doesn&#39;t implement the setter?</span><br><span class="line">    if (![self hasSelector:setterSelector]) &#123;</span><br><span class="line">        const char *types &#x3D; method_getTypeEncoding(setterMethod);</span><br><span class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ObservationInfo *info &#x3D; [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    if (!observers) &#123;</span><br><span class="line">        observers &#x3D; [NSMutableArray array];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p><p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 判断是否存在KVO类，如果存在则返回。</span><br><span class="line"> 2. 如果不存在，则创建KVO类。</span><br><span class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</span><br><span class="line">    NSString *kvoClazzName &#x3D; [kKVOClassPrefix stringByAppendingString:originalClazzName];</span><br><span class="line">    Class clazz &#x3D; NSClassFromString(kvoClazzName);</span><br><span class="line">    </span><br><span class="line">    if (clazz) &#123;</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class doesn&#39;t exist yet, make it</span><br><span class="line">    Class originalClazz &#x3D; object_getClass(self);</span><br><span class="line">    Class kvoClazz &#x3D; objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; grab class method&#39;s signature so we can borrow it</span><br><span class="line">    Method clazzMethod &#x3D; class_getInstanceMethod(originalClazz, @selector(class));</span><br><span class="line">    const char *types &#x3D; method_getTypeEncoding(clazzMethod);</span><br><span class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</span><br><span class="line">    </span><br><span class="line">    objc_registerClassPair(kvoClazz);</span><br><span class="line">    </span><br><span class="line">    return kvoClazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p><p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSString *setterName &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line">    NSString *getterName &#x3D; getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    if (!getterName) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id oldValue &#x3D; [self valueForKey:getterName];</span><br><span class="line">    </span><br><span class="line">    struct objc_super superclazz &#x3D; &#123;</span><br><span class="line">        .receiver &#x3D; self,</span><br><span class="line">        .super_class &#x3D; class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; cast our pointer so the compiler won&#39;t complain</span><br><span class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) &#x3D; (void *)objc_msgSendSuper;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; call super&#39;s setter, which is original class&#39;s setter method</span><br><span class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; look up observers and call the blocks</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    for (ObservationInfo *each in observers) &#123;</span><br><span class="line">        if ([each.key isEqualToString:getterName]) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                each.block(self, getterName, oldValue, newValue);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p><p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface ObservationInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) NSObject *observer;</span><br><span class="line">@property (nonatomic, copy) NSString *key;</span><br><span class="line">@property (nonatomic, copy) ObservingBlock block;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ObservationInfo</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObserver:(NSObject *)observer</span><br><span class="line">                             Key:(NSString *)key</span><br><span class="line">                           block:(ObservingBlock)block &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _observer &#x3D; observer;</span><br><span class="line">        _key &#x3D; key;</span><br><span class="line">        _block &#x3D; block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Strikers/MYKit" target="_blank" rel="noopener">KVO crash 防护方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 全称 &lt;code&gt;KeyValueObserving&lt;/code&gt; 是 &lt;code&gt;Objective-C&lt;/code&gt; 对观察者模式&lt;code&gt;(Observer Pattern)&lt;/code&gt;的实现；&lt;code&gt;KVO&lt;/code&gt; 提
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flutter之环境搭建</title>
    <link href="https://sunjinshuai.github.io/2018/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://sunjinshuai.github.io/2018/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2018-07-25T03:11:45.000Z</published>
    <updated>2018-08-25T03:12:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、获取Flutter SDK</p><p>要获得 <code>Flutter</code>，请先使用 <code>git</code> 克隆 <code>Flutter</code>，然后将该 <code>flutter</code> 工具添加到您的用户路径。运行 <code>flutter doctor</code> 显示您可能需要安装的剩余依赖项。</p><p>由于国内被墙，需要设置下载镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn &#x2F;&#x2F;国内用户需要设置</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn &#x2F;&#x2F;国内用户需要设置</span><br></pre></td></tr></table></figure><p>Clone Flutter repo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b beta https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter.git</span><br></pre></td></tr></table></figure><p>二、配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">export PATH&#x3D;&#96;pwd&#96;&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">(或者)</span><br><span class="line"># export FLUTTER_HOME&#x3D;&#x2F;Users&#x2F;sunjinshuai&#x2F;flutter</span><br><span class="line"># export PATH&#x3D;$PATH:$FLUTTER_HOME&#x2F;bin:</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>三、运行 flutter doctor</p><p>查看是否需要安装其它依赖项来完成安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>该命令检查您的环境并在终端窗口中显示报告，仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line">[✗] Android toolchain - develop for Android devices</span><br><span class="line">✗ Unable to locate Android SDK.</span><br><span class="line">Install Android Studio from: https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;index.html</span><br><span class="line">On first launch it will assist you in installing the Android SDK components.</span><br><span class="line">(or visit https:&#x2F;&#x2F;flutter.io&#x2F;setup&#x2F;#android-setup for detailed instructions).</span><br><span class="line">If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location.</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.25.1)</span><br><span class="line">[✓] Connected devices (2 available)</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>在 <a href="https://github.com/flutter/flutter/issues/13078" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13078</a> 找到了解决方法，其实就是在 <code>bash_profile</code> 添加安卓SDK的环境变量即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br><span class="line"></span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK 28.0.1)</span><br><span class="line">✗ Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.25.1)</span><br><span class="line">[✓] Connected devices (2 available)</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 2 categories.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、获取Flutter SDK&lt;/p&gt;
&lt;p&gt;要获得 &lt;code&gt;Flutter&lt;/code&gt;，请先使用 &lt;code&gt;git&lt;/code&gt; 克隆 &lt;code&gt;Flutter&lt;/code&gt;，然后将该 &lt;code&gt;flutter&lt;/code&gt; 工具添加到您的用户路径。运行 &lt;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 NSUserDefaults</title>
    <link href="https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/"/>
    <id>https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/</id>
    <published>2018-06-20T13:38:40.000Z</published>
    <updated>2018-09-12T13:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>NSUserDefaults</code> 适用于快速读取小规模的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br></pre></td></tr></table></figure><p>写入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *string &#x3D; @&quot;hahaha&quot;;</span><br><span class="line">[standardDefaults setObject:string forKey:@&quot;myKey&quot;];</span><br><span class="line">[standardDefaults synchronize];&#x2F;&#x2F; 写完别忘了同步</span><br></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *value &#x3D; [standardDefaults objectForKey:@&quot;myKey&quot;];</span><br></pre></td></tr></table></figure><p><code>NSUserDefaults</code> 可以理解成键值对</p><p>有时在写数据之前，想判断下这个健是否已经设置过默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if ([standardDefaults stringForKey:@&quot;favoriteColor&quot;] &#x3D;&#x3D; nil) &#123;</span><br><span class="line">    [standardDefaults setObject:@&quot;Green&quot; forKey:@&quot;favoriteColor&quot;];</span><br><span class="line">    [standardDefaults synchronize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以使用 <code>registerDefaults:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">[standardDefaults registerDefaults:@&#123;@&quot;favoriteColor&quot;: @&quot;Green&quot;&#125;];</span><br><span class="line">[standardDefaults synchronize];</span><br></pre></td></tr></table></figure><p>每次程序启动的时候调用 <code>registerDefaults:</code> 方法都是安全的，完全可以将这个方法的调用放到 <code>applicationDidFinishLaunching:</code> 方法中，这个方法永远都不会覆盖用户设置的值。</p><p>但是并不是所有类型的对象都能够直接放入 <code>NSUserDefaults</code>，<code>NSUserDefaults</code> 只支持 <code>Foundation</code> 类型的对象，如果自定义 <code>NSObject</code> 对象存入 <code>NSUserDefaults</code> 就要实现 <code>NSCoding</code> 协议了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *age;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)coder;</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)coder;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)initWithCoder:(NSCoder *)coder &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        self.age  &#x3D; [coder decodeObjectForKey:@&quot;age&quot;];</span><br><span class="line">        self.name &#x3D; [coder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder: (NSCoder *)coder &#123;</span><br><span class="line">    [coder encodeObject:self.age forKey:@&quot;age&quot;];</span><br><span class="line">    [coder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再存取时通过 <code>NSData</code> 做载体：</p><p>存入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">NSData *personData &#x3D; [NSKeyedArchiver archivedDataWithRootObject:person];</span><br><span class="line">[standardDefaults setObject:personData forKey:@&quot;personKey&quot;];</span><br><span class="line">[standardDefaults synchronize];</span><br></pre></td></tr></table></figure><p>读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSData *newPersonData &#x3D; [standardDefaults objectForKey:&quot;personKey&quot;];</span><br><span class="line">Person *Person &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:newPersonData];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt; 适用于快速读取小规模的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVC</title>
    <link href="https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/"/>
    <id>https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/</id>
    <published>2018-04-12T14:37:32.000Z</published>
    <updated>2018-09-12T13:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>KVC</code> 是 <code>KeyValue Coding</code> 的简称，遵循 <code>NSKeyValueCoding</code> 协议，它是一种可以直接通过字符串的名字 <code>key</code> 来访问类属性的机制，而不是通过调用 <code>setter</code>、<code>getter</code> 方法访问。</p><p>对于 <code>KVC</code>，<code>Cocoa</code> 自动放入和取出基本数据类型放入 <code>NSNumber</code> 或 <code>NSValue</code> 中，当使用 <code>setValue:ForKey:</code> 或者 <code>valueForKey:</code> 时，它自动将基本数据类型从这些对象中取出，仅 <code>KVC</code> 具有这种自动包装功能，常规方法调用和属性语法不具备该功能。</p><h1 id="setValue-forKey-的实现方式："><a href="#setValue-forKey-的实现方式：" class="headerlink" title="setValue:forKey 的实现方式："></a><code>setValue:forKey</code> 的实现方式：</h1><p>以字符串的形式向对象发送消息，首先查找以 <code>set&lt;Key&gt;</code> 命名的 <code>setter</code> 方法，如果成员用 <code>@property</code>，<code>@synthsize</code> 处理，因为 <code>@synthsize</code> 告诉编译器自动生成 <code>set&lt;Key&gt;:</code> 格式的 <code>setter</code> 方法，所以这种情况下会直接搜索到。如果上面的 <code>setter</code> 方法没有找到，如果类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。如果找到则设置成员的值，如果没有查找调用 <code>setValue:forUndefinedKey:</code>。</p><h1 id="valueForKey-的实现方式："><a href="#valueForKey-的实现方式：" class="headerlink" title="valueForKey: 的实现方式："></a><code>valueForKey:</code> 的实现方式：</h1><ul><li>首先查找以 <code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code> 命名的 <code>getter</code> 方法，找到直接调用。</li><li>如果上面的 <code>getter</code> 没有找到，则会查找 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 格式的方法，找到就会调用 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 方法，还有一个可选的 <code>get&lt;Key&gt;:range:</code> 方法。</li><li>若是还没查到，那么查找 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 格式的方法，如果找到就调用 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 方法。</li><li>若是还没查到，那么如果类方法 accessInstanceVariablesDirectly 返回 YES，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。</li><li>再没查到，调用 <code>valueForUndefinedKey:</code>。</li></ul><p>综上，<strong>使用 KVC 访问属性的代价比直接使用存取方法性能开销要大</strong>。</p><h1 id="值的正确性核查"><a href="#值的正确性核查" class="headerlink" title="值的正确性核查"></a>值的正确性核查</h1><p>KVC 提供属性值确认的 API，它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p><p>实现核查方法，为如下格式：<code>validate&lt;Key&gt;:error:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</span><br><span class="line">    &#x2F;&#x2F; The name must not be nil, and must be at least two characters long.</span><br><span class="line">    if ((*ioValue &#x3D;&#x3D; nil) || ([(NSString *)*ioValue length] &lt; 2]) &#123;</span><br><span class="line">        if (outError !&#x3D; NULL) &#123;</span><br><span class="line">            NSString *errorString &#x3D; NSLocalizedStringFromTable(</span><br><span class="line">                    @&quot;A Person&#39;s name must be at least two characters long&quot;, @&quot;Person&quot;,</span><br><span class="line">                    @&quot;validation: too short name error&quot;);</span><br><span class="line">            NSDictionary *userInfoDict &#x3D;</span><br><span class="line">                [NSDictionary dictionaryWithObject:errorString</span><br><span class="line">                                            forKey:NSLocalizedDescriptionKey];</span><br><span class="line">            *outError &#x3D; [[[NSError alloc] initWithDomain:PERSON_ERROR_DOMAIN</span><br><span class="line">                                                    code:PERSON_INVALID_NAME_CODE</span><br><span class="line">                                                userInfo:userInfoDict] autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用核查方法：<br><code>validateValue:forKey:error:</code>，默认实现会搜索 <code>validate&lt;Key&gt;:error:</code>格式的核查方法，找到则调用，未找到默认返回 <code>YES</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;KVC&lt;/code&gt; 是 &lt;code&gt;KeyValue Coding&lt;/code&gt; 的简称，遵循 &lt;code&gt;NSKeyValu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>九宫格常用的宏</title>
    <link href="https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/"/>
    <id>https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/</id>
    <published>2018-01-16T13:47:19.000Z</published>
    <updated>2018-09-12T13:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用九宫格定义的宏如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**************************无间距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_SUPERVIEW_AND_WIDTH(SUPERVIEW,WIDTH,COLUMN) SUPERVIEW.subviews.count % COLUMN * WIDTH</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_SUPERVIEW_AND_HEIGHT(SUPERVIEW,HEIGHT,COLUMN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT</span><br><span class="line"></span><br><span class="line">&#x2F;**************************有间距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的横向间距</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + SUPERVIEW.subviews.count % COLUMN  * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * HEIGHT    指九宫格每个小格子的高度</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的纵向间距</span><br><span class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT + SUPERVIEW.subviews.count &#x2F; COLUMN * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;**************************有间距、有边距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度 int width &#x3D; (SCREEN_WIDTH - (colunm + 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的横向间距 和 外边距</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_EDGE_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + (SUPERVIEW.subviews.count % COLUMN + 1) * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * HEIGHT    指九宫格每个小格子的高度</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的纵向间距 和 外边距</span><br><span class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_EDGE_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT + (SUPERVIEW.subviews.count &#x2F; COLUMN + 1) * MARGIN</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/SudokuDemo" target="_blank" rel="noopener">九宫格demo地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用九宫格定义的宏如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>谈谈 Autolayout</title>
    <link href="https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/"/>
    <id>https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/</id>
    <published>2017-12-18T14:16:11.000Z</published>
    <updated>2018-08-25T02:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unable to simultaneously satisfy constraints.</span><br><span class="line">Probably at least one of the constraints in the following list is one you don&#39;t want.</span><br><span class="line">Try this:</span><br><span class="line"></span><br><span class="line">(1) look at each constraint and try to figure out which you don&#39;t expect;</span><br><span class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</span><br><span class="line">(Note: If you&#39;re seeing NSAutoresizingMaskLayoutConstraints that you don&#39;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</span><br><span class="line">(...........)</span><br><span class="line"></span><br><span class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</span><br><span class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit&#x2F;UIView.h&gt; may also be helpful.</span><br></pre></td></tr></table></figure><p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p><p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p><ul><li>打开断点导航（cmd+7）</li><li>点击左下角的+按钮</li><li>选择Add Symbolic Breakpoint</li><li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p><p>所以交给你一个小技巧，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">po [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; OC项目</span><br><span class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; Swift项目</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这样就可以直接看到输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</span><br><span class="line">UIWindow:0x7f9481c93360</span><br><span class="line">|   •UIView:0x7f9481c9d680</span><br><span class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</span><br></pre></td></tr></table></figure><p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p><p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x7f9481c9d990</span><br><span class="line">&lt;UIView: 0x7f9481c9d990; frame &#x3D; (0 0; 768 359); autoresize &#x3D; RM+BM; layer &#x3D; &lt;CALayer: 0x7fc82d338960&gt;&gt;</span><br></pre></td></tr></table></figure><p>改变颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor &#x3D; [UIColor redColor]</span><br><span class="line">(UICachedDeviceRGBColor *) $4 &#x3D; 0x0000000174469cc0</span><br></pre></td></tr></table></figure><p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p><h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p><ul><li>layoutSubViews：</li></ul><p>当 <code>View</code> 及其所有子视图的 <code>frame</code> 发生改变的时候，会调用 <code>layoutSubviews</code>，所以在需要更新 frame 来重新定位或更改大小时重载它。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。注意：<strong>最好不要在代码中手动调用 <code>layoutSubviews</code> 方法</strong>。当 <code>layoutSubviews</code> 完成后，在 <code>view</code> 的所有者 <code>view controller</code> 上，会触发  <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 <code>view</code> 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。</p><p>触发 <code>layoutSubviews</code> 的时机：</p><ul><li><p><code>addSubview</code> 方法会触发 <code>layoutSubviews</code>。</p></li><li><p>当 <code>view</code> 的 <code>Frame</code> 发生变化也会触发<code>layoutSubviews</code>。</p></li><li><p>滚动一个 <code>UIScrollView</code> 会触发 <code>layoutSubviews</code>。</p></li><li><p>旋转屏幕会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p></li><li><p>改变一个 <code>View</code> 大小的时候也会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p></li><li><p>setNeedsLayout<br>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法，表示视图的布局需要重新计算。告知页面需要更新，但是不会立刻开始更新视图，视图会在下一个 <code>runloop</code> 中更新，调用 <code>setNeedsLaylout</code> 方法视图被重新绘制并布局之间会有一段任意时间的间隔。</p></li><li><p>layoutIfNeeded<br>调用 <code>layoutIfNeeded</code> 会触发 <code>layoutSubviews</code>，告知页面布局立刻更新，所以一般都会和 <code>setNeedsLayout</code> 一起使用。如果希望立刻生成新的 <code>frame</code> 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p></li><li><p>setNeedsUpdateConstraints<br>告知需要更新约束，但是不会立刻开始，在下一次 <code>runloop</code> 中更新约束，通过标记 <code>update constraints</code> 来触发 <code>updateConstraints</code>。</p></li><li><p>updateConstraintsIfNeeded<br>告知立刻更新约束，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 <code>update constraints</code> 标记。如果认为这些约束需要被更新，它会立即触发 <code>updateConstraints</code>，而不会等到 <code>run loop</code> 的末尾。</p></li><li><p>updateConstraints<br>系统更新约束，注意：<strong>最好不要在代码中手动调用 <code>updateConstraints</code> 方法</strong>。通常在 <code>updateConstraints</code> 方法中实现必须要更新的约束，在设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 <code>update constarints</code>，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。</p></li></ul><p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p><h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.bounds &#x3D; CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</span><br></pre></td></tr></table></figure><p>那么很可能拿到 layer 的宽度是0。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">[self.view addSubview:redView];</span><br><span class="line">self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 设置约束</span><br><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">  make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame &#x3D; (0 0; 0 0); layer &#x3D; &lt;CALayer: 0x6040002274a0&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p><p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x60000003c460&gt;&gt;</span><br></pre></td></tr></table></figure><p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">    [redView setNeedsLayout];</span><br><span class="line">    [redView layoutIfNeeded];</span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame &#x3D; (-75 -40; 150 80); layer &#x3D; &lt;CALayer: 0x6040004207a0&gt;&gt;</span><br></pre></td></tr></table></figure><p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x600000233540&gt;&gt;</span><br></pre></td></tr></table></figure><p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于Autolayout的调试&quot;&gt;&lt;a href=&quot;#关于Autolayout的调试&quot; class=&quot;headerlink&quot; title=&quot;关于Autolayout的调试&quot;&gt;&lt;/a&gt;关于Autolayout的调试&lt;/h4&gt;&lt;p&gt;刚开始使用 Autolayout 遇
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git 奇技淫巧</title>
    <link href="https://sunjinshuai.github.io/2017/12/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>https://sunjinshuai.github.io/2017/12/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</id>
    <published>2017-12-12T13:45:47.000Z</published>
    <updated>2018-09-12T13:46:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><h2 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h2><p>例如：1.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 1.0.0 -m &quot;1.0.0 版本的备注信息.&quot;</span><br></pre></td></tr></table></figure><h2 id="推送所有-tag，同步到远程仓库："><a href="#推送所有-tag，同步到远程仓库：" class="headerlink" title="推送所有 tag，同步到远程仓库："></a>推送所有 tag，同步到远程仓库：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="删除本地-Tag"><a href="#删除本地-Tag" class="headerlink" title="删除本地 Tag"></a>删除本地 Tag</h2><p>例如：1.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 1.0.0</span><br></pre></td></tr></table></figure><p>删除远程标签需要先删除本地标签，再执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;1.0.0</span><br><span class="line">git push origin --delete tag 1.0.0</span><br></pre></td></tr></table></figure><h2 id="展示当前分支的最近的tag"><a href="#展示当前分支的最近的tag" class="headerlink" title="展示当前分支的最近的tag"></a>展示当前分支的最近的tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev&#x3D;0</span><br></pre></td></tr></table></figure><h2 id="默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag："><a href="#默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag：" class="headerlink" title="默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag："></a>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;version-number&gt; -m &quot;v1.0.0 发布(描述)&quot; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v &#39;^\*\|  master&#39; | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><h2 id="列出远程服务器和本地的所有分支，以及分支上的最后提交"><a href="#列出远程服务器和本地的所有分支，以及分支上的最后提交" class="headerlink" title="列出远程服务器和本地的所有分支，以及分支上的最后提交"></a>列出远程服务器和本地的所有分支，以及分支上的最后提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="列出所有远程服务器上的分支"><a href="#列出所有远程服务器上的分支" class="headerlink" title="列出所有远程服务器上的分支"></a>列出所有远程服务器上的分支</h2><p>-r参数相当于：remote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="同步本地与远程分支"><a href="#同步本地与远程分支" class="headerlink" title="同步本地与远程分支"></a>同步本地与远程分支</h2><p>删除远程不存在的本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --p</span><br></pre></td></tr></table></figure><h2 id="更新远程跟踪分支"><a href="#更新远程跟踪分支" class="headerlink" title="更新远程跟踪分支"></a>更新远程跟踪分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1><h2 id="合并本地的最后两次-commit"><a href="#合并本地的最后两次-commit" class="headerlink" title="合并本地的最后两次 commit"></a>合并本地的最后两次 commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^git commit --amend</span><br></pre></td></tr></table></figure><h2 id="修改上一次的-commit-信息"><a href="#修改上一次的-commit-信息" class="headerlink" title="修改上一次的 commit 信息"></a>修改上一次的 commit 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  #默认就是-mixed参数。</span><br><span class="line">git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span><br><span class="line">git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   </span><br><span class="line">git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span><br></pre></td></tr></table></figure><h2 id="查看指定路径文件代码是谁写的"><a href="#查看指定路径文件代码是谁写的" class="headerlink" title="查看指定路径文件代码是谁写的"></a>查看指定路径文件代码是谁写的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="删除远程仓库地址"><a href="#删除远程仓库地址" class="headerlink" title="删除远程仓库地址"></a>删除远程仓库地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><p>暂存命令stash使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash #将本地修改暂时存储起来</span><br><span class="line">git stash list #查看暂存的信息</span><br><span class="line">git stash pop  #应用最近一次暂存的内容</span><br><span class="line">git stash apply stash@&#123;1&#125; #应用指定版本的暂存内容</span><br><span class="line">git stash clear  #清空暂存栈</span><br><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt; #从stash中拿出某个文件的修改</span><br></pre></td></tr></table></figure><h1 id="Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法"><a href="#Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法" class="headerlink" title="Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法"></a>Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法</h1><p>例如：取消某次合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort #如果Git版本 &gt;&#x3D; 1.7.4</span><br><span class="line">git reset --merge #如果Git版本 &gt;&#x3D; 1.6.1</span><br></pre></td></tr></table></figure><p>注意：<br>在合并之前要保证没有未提交的文件，如果有未提交的文件但现在又不想提交，用stash命令暂存。</p><p>回退到某个版本并应用指定的几次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1d7444 #回退到某个版本</span><br><span class="line">git cherry-pick 626335 #将某次commit的更改应用到当前版本</span><br><span class="line">git cherry-pick …</span><br><span class="line">git push origin HEAD --force  #强制提交</span><br></pre></td></tr></table></figure><p>注意：<br>如果是撤销某次提交，可以用revert命令，git revert是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留; git reset是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区。</p><h1 id="git强制push"><a href="#git强制push" class="headerlink" title="git强制push"></a>git强制push</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure><h1 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h1><p>不添加参数，默认是-mixed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h1 id="撤销所有未提交的本地修改"><a href="#撤销所有未提交的本地修改" class="headerlink" title="撤销所有未提交的本地修改"></a>撤销所有未提交的本地修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h1 id="Push-本地分支到指定远程分支"><a href="#Push-本地分支到指定远程分支" class="headerlink" title="Push 本地分支到指定远程分支"></a>Push 本地分支到指定远程分支</h1><p>例如：Push 本地当前分支到远程仓库 origin 的 master 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tag&quot;&gt;&lt;a href=&quot;#Tag&quot; class=&quot;headerlink&quot; title=&quot;Tag&quot;&gt;&lt;/a&gt;Tag&lt;/h1&gt;&lt;h2 id=&quot;添加-Tag&quot;&gt;&lt;a href=&quot;#添加-Tag&quot; class=&quot;headerlink&quot; title=&quot;添加 Tag&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="noopener">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>持续的软件版本发布/测试项目。</li><li>监控外部调用执行的工作。</li></ul><p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins官网</a>下载Jenkins；</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>点击Download：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p><p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><ul><li>在Safari浏览器上，会出现Safari不能连接到服务器。</li><li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li></ul><p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="noopener">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以通过下面两种方式获取初始化密码：</p><ul><li>打开terminal，执行cat命令即可(需要管理员权限)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat &#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;Home&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>输入用户名和密码之后，Jenkins就彻底安装好了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p><h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&#x2F;Uninstall.command</span><br></pre></td></tr></table></figure><h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist    </span><br><span class="line">sudo rm !$    </span><br><span class="line">sudo rm -rf &#x2F;Applications&#x2F;Jenkins &quot;&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&quot; &#x2F;Library&#x2F;Documentation&#x2F;Jenkins    </span><br><span class="line">sudo rm -rf &#x2F;Users&#x2F;Shared&#x2F;Jenkins    </span><br><span class="line"># if you want to get rid of all the jobs and builds:    </span><br><span class="line">sudo dscl . -delete &#x2F;Users&#x2F;jenkins    </span><br><span class="line"># delete the jenkins user and group (if you chose to use them):    </span><br><span class="line">sudo dscl . -delete &#x2F;Groups&#x2F;jenkins</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>App的生命周期</title>
    <link href="https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2017-11-17T16:02:28.000Z</published>
    <updated>2018-08-25T02:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS程序的启动执行顺序"><a href="#iOS程序的启动执行顺序" class="headerlink" title="iOS程序的启动执行顺序"></a>iOS程序的启动执行顺序</h4><p>程序启动顺序图<br><img src="http://upload-images.jianshu.io/upload_images/588630-5837771421fe9e63?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS启动原理图"></p><p>具体执行流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);&#x2F;&#x2F;__func__打印方法名</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</span><br><span class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</span><br><span class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</span><br><span class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</span><br><span class="line">  NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123;</span><br><span class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</span><br><span class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 <code>APP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate application:didFinishLaunchingWithOptions:] </span><br><span class="line">-[AppDelegate applicationDidBecomeActive:]</span><br></pre></td></tr></table></figure><p>按下 <code>Home</code> 键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate applicationWillResignActive:]</span><br><span class="line">-[AppDelegate applicationDidEnterBackground:]</span><br></pre></td></tr></table></figure><p>返回 <code>APP</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate applicationWillEnterForeground:]</span><br><span class="line">-[AppDelegate applicationDidBecomeActive:]</span><br></pre></td></tr></table></figure><p>内存警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-[AppDelegate applicationDidReceiveMemoryWarning:]</span><br></pre></td></tr></table></figure><p>注意：<br><code>application:didFinishLaunchingWithOptions:</code>： <code>App</code> 首次启动时调用，一般在这个函数里创建 <code>window</code> 对象，初始化 <code>App</code> 可能用到的第三方 <code>SDK</code> 等。<br><code>applicationWillResignActive:</code>：<code>App</code> 将要进入后台时调用，比如有电话进来或者按下 <code>Home</code> 键。<br>该函数里面主要执行操作:</p><ul><li>暂停正在执行的任务</li><li>停止计时器</li><li>减少OpenGL ES帧率</li></ul><p><code>applicationDidEnterBackground:</code>：<code>App</code> 已经进入后台，一般该方法用来:</p><ul><li>释放共享资源</li><li>保存用户数据(写到硬盘)</li><li>销毁计时器</li></ul><p><code>applicationWillEnterForeground:</code>：<code>App</code> 即将进入前台，一般该方法用来撤销 <code>applicationWillResignActive:</code> 中做的改变。<br><code>applicationDidBecomeActive:</code>：<code>App</code> 已经进入前台，若 <code>App</code> 之前在后台，在此方法内刷新用户界面。</p><h4 id="UIViewController-的生命周期"><a href="#UIViewController-的生命周期" class="headerlink" title="UIViewController 的生命周期"></a><code>UIViewController</code> 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 非storyBoard(xib或非xib)都走这个方法</span><br><span class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    if (self &#x3D; [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; storyBoard走这个方法</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    if (self &#x3D; [super initWithCoder:aDecoder]) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; xib 加载 完成</span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加载视图(默认从nib)</span><br><span class="line">- (void)loadView &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    self.view &#x3D; [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图控制器中的视图加载完成，viewController自带的view加载完成</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图将要出现</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view 即将布局其 Subviews</span><br><span class="line">- (void)viewWillLayoutSubviews &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewWillLayoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; view 已经布局其 Subviews</span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图已经出现</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图将要消失</span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图已经消失</span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super viewDidDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 出现内存警告 </span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 视图被销毁</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析 </p><ul><li><p><code>initWithNibName:bundle:</code><br>初始化<code>UIViewController</code>，执行关键数据初始化操作，非<code>StoryBoard</code>创建<code>UIViewController</code>都会调用这个方法。</p></li><li><p><em>注意: 不要在这里做<code>View</code>相关操作，<code>View</code>在<code>loadView</code>方法中才初始化。*</em></p></li><li><p><code>initWithCoder:</code><br>如果使用<code>StoryBoard</code>进行视图管理，程序不会直接初始化一个<code>UIViewController</code>，<code>StoryBoard</code>会自动初始化或在<code>segue</code>被触发时自动初始化，因此方法<code>initWithNibName:bundle</code>不会被调用，但是<code>initWithCoder</code>会被调用。</p></li><li><p><code>awakeFromNib</code><br>当<code>awakeFromNib</code>方法被调用时，所有视图的<code>outlet</code>和<code>action</code>已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在<code>storyBoard</code>或<code>xib</code>中，所以可以在<code>awakeFromNib</code>方法中被加载进来。</p></li><li><p><code>loadView</code><br>当执行到<code>loadView</code>方法时，如果视图控制器是通过<code>nib</code>创建，那么视图控制器已经从<code>nib</code>文件中被解档并创建好了，接下来任务就是对<code>view</code>进行初始化。<br><code>loadView</code>方法在<code>UIViewController</code>对象的<code>view</code>被访问且为空的时候调用。这是它与<code>awakeFromNib</code>方法的一个区别。<br>假设我们在处理内存警告时释放<code>view</code>属性：<code>self.view = nil</code>。因此<code>loadView</code>方法在视图控制器的生命周期内可能被调用多次。<br><code>loadView</code>方法不应该直接被调用，而是由系统调用，它会加载或创建一个<code>view</code>并把它赋值给<code>UIViewController</code>的<code>view</code>属性。<br>在创建<code>view</code>的过程中，首先会根据<code>nibName</code>去找对应的<code>nib</code>文件然后加载。如果<code>nibName</code>为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码)</p></li><li><p><em>注意:在重写loadView方法的时候，不要调用父类的方法。*</em></p></li><li><p><code>viewDidLoad</code><br>当<code>loadView</code>将<code>view</code>载入内存中，会进一步调用<code>viewDidLoad</code>方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。</p></li><li><p><code>viewWillAppear</code><br>系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。<br>另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。</p></li><li><p><code>viewWillLayoutSubviews</code><br><code>view</code>即将布局其<code>Subviews</code>。 比如<code>view</code>的<code>bounds</code>改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整<code>Subviews</code>的位置，在调整之前要做的工作可以放在该方法中实现</p></li><li><p><code>viewDidLayoutSubviews</code><br><code>view</code>已经布局其<code>Subviews</code>，这里可以放置调整完成之后需要做的工作。</p></li><li><p><code>viewDidAppear</code><br>在<code>view</code>被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。</p></li><li><p><code>viewWillDisappear</code><br>在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用<code>removeFromSuperview</code>。</p></li><li><p><code>viewDidDisappear</code><br><code>view</code>已经消失或被覆盖，此时已经调用<code>removeFromSuperView</code>;</p></li><li><p><code>dealloc</code><br>视图被销毁，此次需要对你在<code>init</code>和<code>viewDidLoad</code>中创建的对象进行释放。</p></li><li><p><code>didReceiveMemoryWarning</code><br>在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。</p></li></ul><h4 id="UIView-的生命周期"><a href="#UIView-的生命周期" class="headerlink" title="UIView 的生命周期"></a>UIView 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过代码创建控件就会调用这个方法</span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    if (self &#x3D; [super initWithFrame:frame]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过storyboared或者xib中创建控件就会调用这个方法</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">    if (self &#x3D; [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">        NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果在initWithFrame中添加子视图会调用两次</span><br><span class="line">- (void)layoutSubviews &#123;</span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didAddSubview:(UIView *)subview &#123;</span><br><span class="line">    [super didAddSubview:subview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willRemoveSubview:(UIView *)subview &#123;</span><br><span class="line">    [super willRemoveSubview:subview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview &#123;</span><br><span class="line">    [super willMoveToSuperview:newSuperview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didMoveToSuperview &#123;</span><br><span class="line">    [super didMoveToSuperview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow &#123;</span><br><span class="line">    [super willMoveToWindow:newWindow];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didMoveToWindow &#123;</span><br><span class="line">    [super didMoveToWindow];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeFromSuperview &#123;</span><br><span class="line">    [super removeFromSuperview];</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>view</code> 创建时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View initWithFrame:]</span><br><span class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View init]</span><br><span class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:35:12.353483+0800 iOSLife[7587:2353869] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:35:12.353644+0800 iOSLife[7587:2353869] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:35:12.363861+0800 iOSLife[7587:2353869] -[View layoutSubviews]</span><br></pre></td></tr></table></figure><p>当 <code>view</code> 销毁时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:41:28.152448+0800 iOSLife[7607:2356750] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:41:28.152693+0800 iOSLife[7607:2356750] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:41:28.155160+0800 iOSLife[7607:2356750] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:41:28.155281+0800 iOSLife[7607:2356750] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:41:28.155336+0800 iOSLife[7607:2356750] -[View removeFromSuperview]</span><br><span class="line">2017-11-06 10:41:28.155399+0800 iOSLife[7607:2356750] -[View dealloc]</span><br></pre></td></tr></table></figure><p>注意：<br>可以看出上面方法中只会执行一次的方法有 <code>removeFromSuperview</code>、<code>dealloc</code> 两个方法，<code>layoutSubviews</code> 在子视图布局变动时会多次调用，所以可以在 <code>removeFromSuperview</code>、<code>dealloc</code> 这两个方法中执行释放内存等操作，比如移除观察者，定时器等。</p><p>给 <code>view</code> 添加子视图时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View initWithFrame:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View init]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView initWithFrame:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView init]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didAddSubview:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</span><br><span class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView layoutSubviews]</span><br></pre></td></tr></table></figure><p>注意：<code>didAddSubview:</code> 和 <code>willRemoveSubview:</code> 需要有子视图才能执行。</p><p>此时再销毁该 <code>view</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View removeFromSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View dealloc]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willRemoveSubview:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView removeFromSuperview]</span><br><span class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView dealloc]</span><br></pre></td></tr></table></figure><p><code>willRemoveSubview</code> 是在 <code>dealloc</code> 后面执行的。如果有多个子视图，<code>willRemoveSubview</code> 会循环执行，直到移除所有子视图。</p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview;</span><br><span class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow;</span><br></pre></td></tr></table></figure><p>这俩个方法可以根据参数判断，<code>nil</code> 则为销毁，否则为创建；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)didMoveToSuperview;</span><br><span class="line">- (void)didMoveToWindow;</span><br></pre></td></tr></table></figure><p>这个方法可以根据 <code>self.superview</code> 判断，<code>nil</code> 则为销毁，否则为创建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;a href=&quot;#iOS程序的启动执行顺序&quot; class=&quot;headerlink&quot; title=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;/a&gt;iOS程序的启动执行顺序&lt;/h4&gt;&lt;p&gt;程序启动顺序图&lt;br&gt;&lt;img src=&quot;http://up
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅析 NSTimer 和 CADisplayLink 内存泄漏</title>
    <link href="https://sunjinshuai.github.io/2017/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://sunjinshuai.github.io/2017/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2017-10-12T13:48:52.000Z</published>
    <updated>2018-09-12T13:49:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>谈论 <code>NSTimer &amp; CADisplayLink</code> 内存泄漏，要理解 <code>NSTimer &amp; CADisplayLink</code> 的基础概念，下面通过一个倒计时的实现的 <code>demo</code> 进入正题。</p><ul><li>第一种就是直接在 <code>TableView</code> 的 <code>Cell</code> 上使用 <code>NSTimer</code>，然后添加到当前线程所对应的 <code>RunLoop</code> 中的 <code>commonModes</code> 中。</li><li>第二种是通过 <code>Dispatch</code> 中的 <code>TimerSource</code> 来实现定时器。</li><li>第三种是使用 <code>CADisplayLink</code> 来实现。</li></ul><p>以 <code>UITableViewCell</code> 为例：</p><h3 id="一、在-Cell-中直接使用-NSTimer"><a href="#一、在-Cell-中直接使用-NSTimer" class="headerlink" title="一、在 Cell 中直接使用 NSTimer"></a>一、在 <code>Cell</code> 中直接使用 <code>NSTimer</code></h3><p>首先我们按照常规做法，直接在 <code>UITableView</code> 的 <code>Cell</code> 上添加相应的 <code>NSTimer</code>, 并使用 <code>scheduledTimer</code> 执行相应的代码块。<br>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(countDown:) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown:(NSTimer *)timer &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.textLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时:%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:36:11.981473+0800 NSTimer&amp;CADisplayLink[24050:457782] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h3 id="二、DispatchTimerSource"><a href="#二、DispatchTimerSource" class="headerlink" title="二、DispatchTimerSource"></a>二、DispatchTimerSource</h3><p>接下来我们就在 <code>TableView</code> 的 <code>Cell</code> 上添加 <code>DispatchTimerSource</code>，然后看一下运行效果。当然下方代码片段我们是在全局队列中添加的 <code>DispatchTimerSource</code>，在主线程中进行更新。当然我们也可以在 <code>mainQueue</code> 中添加 <code>DispatchTimerSource</code>，这样也是可以正常工作的。当然我们不建议在 <code>MainQueue</code> 中做，因为在编程时尽量的把一些和主线程关联不太大的操作放到子线程中去做。<br>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        [self countDown];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    &#x2F;&#x2F; 倒计时时间</span><br><span class="line">    __block NSInteger timeOut &#x3D; 60.0f;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    &#x2F;&#x2F; 每秒执行一次</span><br><span class="line">    dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</span><br><span class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 倒计时结束，关闭</span><br><span class="line">        if (timeOut &lt;&#x3D; 0) &#123;</span><br><span class="line">            dispatch_source_cancel(_timer);</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                self.detailTextLabel.text &#x3D; @&quot;倒计时结束&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">                dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">                self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">            &#125;);</span><br><span class="line">            timeOut--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h3 id="三、CADisplayLink"><a href="#三、CADisplayLink" class="headerlink" title="三、CADisplayLink"></a>三、CADisplayLink</h3><p>接下来我们来使用 <code>CADisplayLink</code> 来实现定时器功能，<code>CADisplayLink</code> 可以添加到 <code>RunLoop</code> 中，每当屏幕需要刷新的时候，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，这时 <code>target</code> 可以读到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。</p><p>可以设想一下，我们在动画的过程中，<code>runloop</code> 被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行  <code>CADisplayLink</code> 的调用，从而造成动画过程的卡顿，使动画不流畅。</p><p>下方代码，为了不让屏幕的卡顿等引起的主线程所对应的 <code>RunLoop</code> 阻塞所造成的定时器不精确的问题。我们开启了一个新的线程，并且将 <code>CADisplayLink</code> 对象添加到这个子线程的 <code>RunLoop</code> 中，然后在主线程中更新UI即可。<br>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        dispatch_queue_t disqueue &#x3D;  dispatch_queue_create(&quot;com.countdown&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        dispatch_group_t disgroup &#x3D; dispatch_group_create();</span><br><span class="line">        dispatch_group_async(disgroup, disqueue, ^&#123;</span><br><span class="line">            self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">            [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.link invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h2 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h2><p>从上面的三种 <code>demo</code> 可以看出 <code>UITableViewCell</code> 没有被释放，由此得出结论，当 <code>UITableViewCell</code> 里面强引用了定时器，定时器又强引用了 <code>UITableViewCell</code>，这样两者的 <code>retainCount</code> 值一直都无法为0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>定时器的运行需要结合一个 <code>NSRunLoop</code>，同时 <code>NSRunLoop</code> 对该定时器会有一个强引用，这也是为什么我们不能对 <code>NSRunLoop</code> 中的定时器进行强引的原因。</p><p>由于 <code>NSRunLoop</code> 对定时器有引用，定时器怎样才能被释放掉。</p><blockquote><p>Removes the object from all runloop modes (releasing the receiver if it has been implicitly retained) and releases the target object.</p></blockquote><p>据官方介绍可知，<code>- invalidate</code> 做了两件事，首先是把本身（定时器）从 <code>NSRunLoop</code> 中移除，然后就是释放对 <code>target</code> 对象的强引用，从而解决定时器带来的内存泄漏问题。</p><p>从上面的 <code>demo</code> 中看出，在 <code>UITableViewCell</code> 的 <code>dealloc</code> 方法中调用 <code>invalidate</code> 方法，并没有解决问题。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里使用下 <code>Xcode8</code> 调试黑科技 <code>Memory Graph</code> 来检测下内存泄漏：</p><p><img src="https://upload-images.jianshu.io/upload_images/588630-f2c2468c9ecf756f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图中可以看出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop  ---&gt; 定时器 ---&gt; UITableViewCell</span><br></pre></td></tr></table></figure><p>导致 <code>UITableViewCell</code> 中没有释放掉定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>从代码中看出，<code>Target</code> 直接设置成 <code>self</code> 会造成内存泄， <code>CADisplayLink</code> 会强引用 <code>Target</code>。当 <code>CADisplayLink</code> 添加到 <code>NSRunLoop</code> 中，<code>NSRunLoop</code> 会强引用 <code>CADisplayLink</code>。如果仅仅在 <code>dealloc</code> 中调用 <code>CADisplayLink</code> 的 <code>invalidate</code> 方法是没用的，因为 <code>NSRunLoop</code> 的存在 <code>CADisplayLink</code> 不会被释放，<code>Target</code> 被强引用，<code>Target</code> 的 <code>dealloc</code> 方法不会被调用，<code>CADisplayLink</code> 的 <code>invalidate</code> 方法也不被调用，<code>CADisplayLink</code> 不会从 <code>NSRunLoop</code> 中移除，从而导致内存泄漏。</p><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">NSRunLoop 的问题请查看这里</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、Target"><a href="#1、Target" class="headerlink" title="1、Target"></a>1、Target</h3><p>为了解决定时器与 <code>Target</code> 之间类似死锁的问题，我们会将定时器中的 <code>target</code> 对象替换成定时器自己，采用分类实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+TimerTarget.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSTimer (TimerTarget)</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">repeat:(BOOL)yesOrNo </span><br><span class="line"> block:(void (^)(NSTimer *))block &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(startTimer:) userInfo:[block copy] repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)startTimer:(NSTimer *)timer &#123;</span><br><span class="line">    void (^block)(NSTimer *timer) &#x3D; timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2、Proxy"><a href="#2、Proxy" class="headerlink" title="2、Proxy"></a>2、Proxy</h3><p>这种方式就是创建一个 <code>NSProxy</code> 子类 <code>TimerProxy</code>，<code>TimerProxy</code> 的作用是什么呢？就是什么也不做，可以说只会重载消息转发机制，如果创建一个 <code>TimerProxy</code> 对象将其作为定时器的 <code>target</code>，专门用于转发定时器消息至 <code>Target</code> 对象，那么问题是不是就解决了呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 target:[TimerProxy timerProxyWithTarget:self] selector:@selector(startTimer) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure><h3 id="3、NSTimer-Block"><a href="#3、NSTimer-Block" class="headerlink" title="3、NSTimer Block"></a>3、NSTimer Block</h3><p>还有一种方式就是采用Block，iOS 10增加的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ scheduledTimerWithTimeInterval:repeats:block:</span><br><span class="line"></span><br><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;MYNSTimerTargetController timer start&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSTimer%26CADisplayLink" target="_blank" rel="noopener">浅析NSTimer &amp; CADisplayLink内存泄漏</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谈论 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 内存泄漏，要理解 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 的基础概念，下面通过一个倒计时的实现的 &lt;code&gt;demo&lt;/code&gt; 进入正题。
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之iconfont实战</title>
    <link href="https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/</id>
    <published>2017-08-08T07:45:34.000Z</published>
    <updated>2017-08-08T08:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了<code>APP Slicing</code>功能，我司项目在itunes store下载的IPA体积大约在44M。</p><p>把我司iPA解压之后里面的<code>Assert.car</code>资源包的体积大约在22.1M，使用软件导出内部的资源文件发现3X系列的图片大小约为13.1M，2X系列的图片大小约为9.4M，两份加起来大于22.1M，所以可以看出我们的图片还是有很大的优化空间的。</p><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>技术的主要目的是为减少应用体积而生。首先<code>icon</code>代表图标<code>font</code>代表字体。此技术便是将图标转化为字体，从而达到减小应用体积的目的(这样避免了@2X图和@3X图的使用，只需要一个字体图标就可搞定)。如需在项目中使用iconfont技术，图标矢量图一开始都应合并转化为字体库，只需要在项目中引入字体库就可以了。</p><p>优点:</p><ul><li>减小应用体积，字体文件比图片要小；</li><li>图标保真缩放，解决2x/3x乃至将来nx图问题；</li><li>方便更改图标颜色大小，图片复用；</li><li>一套图标资源可以在不用平台上使用(android、iOS、web)；</li></ul><p>缺点:</p><ul><li>只适用于纯色的icon；</li></ul><h4 id="iconfont实战"><a href="#iconfont实战" class="headerlink" title="iconfont实战"></a>iconfont实战</h4><ul><li><p>获取<code>.ttf</code>文件<br>登录<a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>，创建一个项目，设计师做好图标，把<code>.ttf</code>文件下载下来。<br>iconfont中的图标是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/588630-fff854d89142120b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>字体注册<br>iOS中使用自定义字体，将字体加入项目后，还需要注册字体。<br>注册的方式有两种：<br>－ 在Info.plist中声明”Fonts provided by application”</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b6a5790bed65a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>－ 调用API来注册。考虑到需要支持独立版和插件版，调用API注册更加方便。字体注册和获取的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)registerFontWithURL:(NSURL *)url &#123;</span><br><span class="line">    NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&#39;t exist&quot;);</span><br><span class="line">    CGDataProviderRef fontDataProvider &#x3D; CGDataProviderCreateWithURL((__bridge CFURLRef)url);</span><br><span class="line">    CGFontRef newFont &#x3D; CGFontCreateWithDataProvider(fontDataProvider);</span><br><span class="line">    CGDataProviderRelease(fontDataProvider);</span><br><span class="line">    CTFontManagerRegisterGraphicsFont(newFont, nil);</span><br><span class="line">    CGFontRelease(newFont);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (UIFont *)fontWithSize:(CGFloat)size &#123;</span><br><span class="line">    UIFont *font &#x3D; [UIFont fontWithName:[self fontName] size:size];</span><br><span class="line">    if (font &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        [self registerFontWithURL: [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;]];</span><br><span class="line">        font &#x3D; [UIFont fontWithName:[self fontName] size:size];</span><br><span class="line">        NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&#39;re using the correct font name.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return font;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字体应用方式<br>可能的应用方式：<ul><li>UILabel作为Icon</li><li>UIButton的titleLabel作为Icon</li><li>根据字体生成UIImage</li></ul></li></ul><p>在实际项目中，鉴于将我们本来的icon当作字体使用，会让我们在项目中添加的控件方式有所变化，而且不容易控制颜色和图标大小，所以我这里推荐第三种方案，根据图片大小、颜色和Unicode码来生成并返回图片。</p><ul><li>应用到项目中<br>将<code>.ttf</code>文件引入到自己的工程中</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-b463acca775cd8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>目前我司项目重构之后的图标为IconFont，新需求用到的图标也会优先采用IconFont。</p><p><a href="https://github.com/sunjinshuai/MYUtils" target="_blank" rel="noopener">demo地址</a></p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="noopener">使用IconFont减小iOS应用体积</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了&lt;code&gt;APP Slicing&lt;/code&gt;功能，我司项目在i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 中 Label 的抗拉伸和抗压缩</title>
    <link href="https://sunjinshuai.github.io/2017/07/18/%E6%B5%85%E8%B0%88%20iOS%20AutoLayout%20%E4%B8%AD%20Label%20%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/"/>
    <id>https://sunjinshuai.github.io/2017/07/18/%E6%B5%85%E8%B0%88%20iOS%20AutoLayout%20%E4%B8%AD%20Label%20%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/</id>
    <published>2017-07-17T16:42:23.000Z</published>
    <updated>2018-09-12T13:27:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIView</code> 中关于 <code>Content Hugging</code> 和 <code>Content Compression Resistance</code> 的方法有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br><span class="line">- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br><span class="line"></span><br><span class="line">- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br><span class="line">- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</span><br></pre></td></tr></table></figure><p>在 <code>Autolayout</code> 优先级的范围是 <code>1 ~ 1000</code>，创建一个约束，默认的优先级是最高的 <code>1000</code>。</p><h4 id="Content-Hugging-Priority"><a href="#Content-Hugging-Priority" class="headerlink" title="Content Hugging Priority"></a>Content Hugging Priority</h4><p>Content Hugging Priority: 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是251。</p><p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，子视图的总和，不够填充父视图区域时，此属性可以控制优先拉伸哪个视图内容。</p><h4 id="Content-Compression-Resistance-Priority"><a href="#Content-Compression-Resistance-Priority" class="headerlink" title="Content Compression Resistance Priority"></a>Content Compression Resistance Priority</h4><p>Content Compression Resistance Priority: 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750。</p><p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，并且子控件可能会超出父视图的区域时，此属性可控制哪些视图被内容被优先压缩，使其不超出父视图区域。</p><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>Content Compression Resistance Priority</p><p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *yellowLabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">yellowLabel.text &#x3D; @&quot;我是黄色Label,我是黄色Label,我是黄色Label,我是黄色Label&quot;;</span><br><span class="line">yellowLabel.backgroundColor &#x3D; [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:yellowLabel];</span><br><span class="line"></span><br><span class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100);</span><br><span class="line">make.right.equalTo(self.view).offset(-100);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-76c5062f92a502d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从最后的显示效果来看，中间的 <code>Label</code> 被压缩了。因为左右约束的优先级比固有内容相关的优先级要高，所以 <code>Autolayout</code> 布局的时候会优先满足左右两个约束。这时候：<strong>左边约束宽度 + 右边约束宽度 +  <code>Label</code> 的固有内容宽度 &gt; 屏幕宽度</strong>。所以最后只能压缩 <code>Label</code> 显示的宽度。</p><p>修改 <code>View</code> 左边约束和右边约束的优先级，或者只修改左(右)边约束优先级，然后设置 <code>Label</code> 抗压缩的优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo1 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *yellowLabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">yellowLabel.text &#x3D; @&quot;我是黄色Label,我是黄色Label&quot;;</span><br><span class="line">yellowLabel.backgroundColor &#x3D; [UIColor yellowColor];</span><br><span class="line">[self.view addSubview:yellowLabel];</span><br><span class="line">[yellowLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100).priority(250);</span><br><span class="line">make.right.equalTo(self.view).offset(-100).priority(250);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-457044f53dc6af44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这时候 <code>Label</code> 控件的抗压缩约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗压缩特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被压缩的就是左边和右边的约束。</p><p>Content Hugging Priority</p><p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *bluelabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">bluelabel.text &#x3D; @&quot;我是蓝色Label&quot;;</span><br><span class="line">bluelabel.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">[self.view addSubview:bluelabel];</span><br><span class="line"></span><br><span class="line">[bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100);</span><br><span class="line">make.right.equalTo(self.view).offset(-100);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-a81805a367faf561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>拉伸和压缩的时候类似，左右约束优先级比 <code>Label</code> 的 <code>Content Hugging Priority</code> 优先级高，并且此时：<strong>左边约束宽度 + 右边约束宽度+ <code>Label</code> 的固有内容宽度 &lt; 屏幕宽度</strong>。为了满足左右两个约束，就只有拉伸 <code>Label</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)demo2 &#123;</span><br><span class="line"></span><br><span class="line">UILabel *bluelabel &#x3D; [[UILabel alloc] init];</span><br><span class="line">bluelabel.text &#x3D; @&quot;我是蓝色Label&quot;;</span><br><span class="line">bluelabel.backgroundColor &#x3D; [UIColor blueColor];</span><br><span class="line">[self.view addSubview:bluelabel];</span><br><span class="line">[bluelabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line">[bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.center.equalTo(self.view);</span><br><span class="line">make.left.equalTo(self.view).offset(100).priority(250);</span><br><span class="line">make.right.equalTo(self.view).offset(-100).priority(250);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/588630-556aa245eb387eae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这时候 <code>Label</code> 控件的抗拉伸约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗拉伸特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被拉伸的就是左边和右边的约束。</p><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/Label%26Compress%26Hugging" target="_blank" rel="noopener">Label 的抗拉伸和抗压缩</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;UIView&lt;/code&gt; 中关于 &lt;code&gt;Content Hugging&lt;/code&gt; 和 &lt;code&gt;Content Compression Resistance&lt;/code&gt; 的方法有：&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mac iterm2 配色方案</title>
    <link href="https://sunjinshuai.github.io/2017/06/12/Mac-iterm2-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://sunjinshuai.github.io/2017/06/12/Mac-iterm2-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/</id>
    <published>2017-06-12T13:44:57.000Z</published>
    <updated>2018-09-12T13:45:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装</strong></p><p>首先我们下载的 iTem2 这个软件，比 Mac 自带的终端更加强大。直接官网 <a href="http://iterm2.com/" target="_blank" rel="noopener">http://iterm2.com/</a> 下载并安装即可。</p><p><strong>配色方案</strong></p><p>我选用的是 <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">solarized</a>，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors，或者在 github 上下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;altercation&#x2F;solarized.git</span><br></pre></td></tr></table></figure><p>但是打开 iterm2 发现灰蒙蒙的，就像下面这样：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-79f94acb51b5baf8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>打开 iTerm2 - Preferences - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉，彩色的世界就回来了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-721e68e0e940bd75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们下载的 iTem2 这个软件，比 Mac 自带的终端更加强大。直接官网 &lt;a href=&quot;http://iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ite
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 Zombie Objects</title>
    <link href="https://sunjinshuai.github.io/2017/05/10/%E6%B5%85%E8%B0%88-Zombie-Objects/"/>
    <id>https://sunjinshuai.github.io/2017/05/10/%E6%B5%85%E8%B0%88-Zombie-Objects/</id>
    <published>2017-05-10T14:49:17.000Z</published>
    <updated>2018-09-12T14:50:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p><h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li></ul><p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p><h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p><p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#x2F;&#x2F; Do any additional setup after loading the view, typically from a nib.</span><br><span class="line"></span><br><span class="line">    __unsafe_unretained NSMutableArray *array &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    [array addObject:@&quot;1&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：</p><ul><li>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针。<code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</li><li><code>assign</code>仅用于修饰<code>NSInteger</code>等OC基础类型，以及<code>short</code>、<code>int</code>、<code>double</code>、结构体等C数据类型，不修饰对象指针。</li><li>如果需要弱引用OC对象，建议使用<code>weak</code>关键字，因为被<code>weak</code>指针所引用的对象被回收后，<code>weak</code>指针会被赋为<code>nil</code>（空指针），给<code>nil</code>发任何消息都不会出问题。使用<code>weak</code>修饰代理对象属性就是很好的例子。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;僵尸对象（Zombie-Objects）&quot;&gt;&lt;a href=&quot;#僵尸对象（Zombie-Objects）&quot; class=&quot;headerlink&quot; title=&quot;僵尸对象（Zombie Objects）&quot;&gt;&lt;/a&gt;僵尸对象（Zombie Objects）&lt;/h4&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/05/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/05/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2017-05-08T10:31:52.000Z</published>
    <updated>2020-01-10T01:22:41.846Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p><p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p><ul><li><p><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</p></li><li><p>查看现有的<code>podspec</code>源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul><li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li><li>创建pod私有库所需要的项目工程文件，并上传到私有库</li><li>创建pod所对应的podspec文件，并进行验证／测试</li><li>向私有的Spec Repo中提交podspec</li><li>使用pod库</li></ul><h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul><li><p>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</p></li><li><p>将私有Spec Repo关联到本地</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add FXSpesc http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git</span><br></pre></td></tr></table></figure><p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p></li><li><p>执行命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p><h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul><li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>手动创建Xcode工程(过于简单)</p></li></ul><h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul><li>如果用<code>pod</code>命令创建，</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 你项目工程文件</span><br><span class="line">pod spec create FXKit.podspec</span><br></pre></td></tr></table></figure></li><li><p>修改<code>podspec</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.name         &#x3D; &quot;FXKit&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;FXKit，繁星优选私有库&quot;</span><br><span class="line">  s.description  &#x3D; &lt;&lt;-DESC</span><br><span class="line">   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  s.homepage     &#x3D; &quot;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git&quot;</span><br><span class="line"></span><br><span class="line">  # s.license    &#x3D; &quot;MIT (example)&quot;</span><br><span class="line">  s.license      &#x3D; &#123; :type &#x3D;&gt; &quot;MIT&quot;, :file &#x3D;&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line">  s.author       &#x3D; &#123; &quot;孙金帅&quot; &#x3D;&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</span><br><span class="line">  s.platform     &#x3D; :ios</span><br><span class="line">  s.source       &#x3D; &#123;</span><br><span class="line">:git &#x3D;&gt; &quot;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git&quot;,</span><br><span class="line">:tag &#x3D;&gt; &quot;#&#123;s.version&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s.source_files &#x3D; &#39;FXKit&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;</span><br><span class="line"></span><br><span class="line">  # s.resource_bundles &#x3D; &#123;</span><br><span class="line">  #   &#39;FXKit&#39; &#x3D;&gt; [&#39;FXKit&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">  # &#125;</span><br><span class="line"></span><br><span class="line">  s.public_header_files &#x3D; &#39;FXKit&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;</span><br><span class="line">  # s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure></li><li><p>commit项目工程的源文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint FXKit.podspec --sources&#x3D;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p><h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</span><br><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push FXSpesc NAME.podspec --sources&#x3D;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings --use-libraries</span><br></pre></td></tr></table></figure><h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>神器 iTools 的巧妙使用</title>
    <link href="https://sunjinshuai.github.io/2017/04/12/%E7%A5%9E%E5%99%A8-iTools-%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2017/04/12/%E7%A5%9E%E5%99%A8-iTools-%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/</id>
    <published>2017-04-12T13:41:29.000Z</published>
    <updated>2018-09-12T13:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天，公司项目不怎么忙，然后利用些业余的时间，想仿一个 app。下面介绍一下如果获取其他 app 的图片资源：</p><ul><li>在 MacX 下载 iTools 软件，并安装，直接在百度上搜也能找到。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-9d8944eded38ceaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><ul><li>双击安装 iTools，安装陈宫之后，在 iTools 中点击资源库，如果你连接上你的 iPhone，这个按钮就在右上角，若没有连接 iPhone，该按钮就在坐下角。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-245e9c5096661c18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-265d9ffa8e090bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><ul><li>左边有网络资源和手机资源，点击网络资源下的苹果应用，在右上角搜索你要仿写的 app，点击下载，此时如果你连着 iPhone 显示的就不是下载而是安装，此时会提示你输入 apple id。这里以闲鱼为例：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-823b3dde37b838b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-66e188b3358e55fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><ul><li>选中下载的软件，然后点击上面的那一排按钮中的导出，保存到桌面上。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-908292ff4068a664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>在桌面上找到下载好的 ipa 文件，右键该文件，选择一个解压软件打开该文件，切记不要使用 iTunes 打开，此时该路径下便会有个文件夹名为项目名称的文件夹。可以导出到桌面然后结归档就好了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-166baccabd38113c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><ul><li>把解归档的文件夹进行打开就好了，资源都在里面，随便拿，有时候是乱的需要自己整理。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-b28a8ed864cc4de3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>以上就是总结好的，神器 iTools 的巧妙使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天，公司项目不怎么忙，然后利用些业余的时间，想仿一个 app。下面介绍一下如果获取其他 app 的图片资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 MacX 下载 iTools 软件，并安装，直接在百度上搜也能找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http:/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Charles 之 http、https 配置</title>
    <link href="https://sunjinshuai.github.io/2017/04/12/Charles-%E4%B9%8B-http%E3%80%81https-%E9%85%8D%E7%BD%AE/"/>
    <id>https://sunjinshuai.github.io/2017/04/12/Charles-%E4%B9%8B-http%E3%80%81https-%E9%85%8D%E7%BD%AE/</id>
    <published>2017-04-12T08:43:51.000Z</published>
    <updated>2018-09-12T13:44:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/588630-5c8a2583d88afd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h3 id="Charles安装"><a href="#Charles安装" class="headerlink" title="Charles安装"></a>Charles安装</h3><p>官网下载安装<a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles</a></p><h3 id="http-配置"><a href="#http-配置" class="headerlink" title="http 配置"></a>http 配置</h3><ul><li>查看电脑 IP 地址<br>在终端上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig en4</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-89950831b7209779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>或者</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-0a774d1072f66794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h3 id="配置手机-http-代理"><a href="#配置手机-http-代理" class="headerlink" title="配置手机 http 代理"></a>配置手机 <code>http</code> 代理</h3><p>手机必须和电脑连接同一个局域网，点击“设置-&gt;无线局域网-&gt;选择连接的WiFi”，设置 <code>http</code> 代理：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-180b24c2da236bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>端口号：8888，端口号随便写。</p><h3 id="Charles-进行-http-配置"><a href="#Charles-进行-http-配置" class="headerlink" title="Charles 进行 http 配置"></a><code>Charles</code> 进行 <code>http</code> 配置</h3><p><img src="http://upload-images.jianshu.io/upload_images/588630-408a9827a4b106ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-8804c3edf00e8d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>以美团返回的数据为例：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-23f8f4c75256768d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h3 id="https-代理配置"><a href="#https-代理配置" class="headerlink" title="https 代理配置"></a>https 代理配置</h3><p>https 代理配置必须要安装 SSL 证书</p><ul><li>在手机上安装 SSL 证书<br>点击 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-3f06155569d7e898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>点击安装，得到 SSL 证书安装的地址</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-afbf08a0e9a92e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>在手机 Safari 浏览器输入地址 chls.pro/ssl，出现证书安装页面，点击安装</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-aced7f7c60e025de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-239ad1c85aa702d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><ul><li>Charles 进行 https 配置</li></ul><p>点击 Proxy -&gt; SSL Proxying Settings…</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-8303a9574e6e5276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>勾选 Enable SSL Proxying，点击 Add。以<a href="https://api.weibo.cn/" target="_blank" rel="noopener">https://api.weibo.cn</a>为例，端口号填写443</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-57107c6cfd7da1c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e4cb9ec7e55199fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/588630-5c8a2583d88afd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MarkDown 语法</title>
    <link href="https://sunjinshuai.github.io/2017/01/09/MarkDown-%E8%AF%AD%E6%B3%95/"/>
    <id>https://sunjinshuai.github.io/2017/01/09/MarkDown-%E8%AF%AD%E6%B3%95/</id>
    <published>2017-01-09T14:06:33.000Z</published>
    <updated>2018-06-09T14:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># This is an H1</span><br><span class="line">## This is an H2</span><br><span class="line">###### This is an H6</span><br></pre></td></tr></table></figure><h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>使用一对各三个的反引号(```)，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是文本块</span><br><span class="line">我是文本块</span><br><span class="line">我是文本块</span><br></pre></td></tr></table></figure><h4 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h4><p>文字高亮功能能使行内部分文字高亮，使用一对反引号(`)，例如：</p><p><code>文字高亮</code></p><h4 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="line">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="line">Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</span><br><span class="line"></span><br><span class="line">&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="line">id sem consectetuer libero luctus adipiscing.</span><br></pre></td></tr></table></figure><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>直接回车不能换行，<br>可以在上一行文本后面补两个空格，<br>这样下一行的文本就换行了，或者就是在两行文本直接加一个空行，也能实现换行效果，但是这个行间距有点大。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Red</span><br><span class="line">* Green</span><br><span class="line">* Blue</span><br></pre></td></tr></table></figure><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Bird</span><br><span class="line">2. McHale</span><br><span class="line">3. Parish</span><br></pre></td></tr></table></figure><h4 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h4><p>下面每一行都会得到一个水平线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">___</span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr><hr><hr><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个 [连接显示文字](http:&#x2F;&#x2F;example.com&#x2F; &quot;Title&quot;) 行内链接。</span><br><span class="line">[连接显示文字](http:&#x2F;&#x2F;example.net&#x2F;) 没有title属性。</span><br><span class="line">&lt;http:&#x2F;&#x2F;example.com&#x2F;&gt; 自动链接</span><br></pre></td></tr></table></figure><h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*single asterisks*</span><br><span class="line">_single underscores_</span><br><span class="line">**double asterisks**</span><br><span class="line">__double underscores__</span><br></pre></td></tr></table></figure><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><h5 id="行内图片"><a href="#行内图片" class="headerlink" title="行内图片"></a>行内图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![Alt text](&#x2F;path&#x2F;to&#x2F;img.jpg)</span><br><span class="line">![Alt text](&#x2F;path&#x2F;to&#x2F;img.jpg &quot;Optional title&quot;)</span><br></pre></td></tr></table></figure><h5 id="引用图片"><a href="#引用图片" class="headerlink" title="引用图片"></a>引用图片</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![Alt text][id]</span><br></pre></td></tr></table></figure><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Left-Aligned | Center Aligned | Right Aligned |</span><br><span class="line">| :------------ |:---------------:| -----:|</span><br><span class="line">| col 3 is | some wordy text | $1600 |</span><br><span class="line">| col 2 is | centered | $12 |</span><br><span class="line">| zebra stripes | are neat | $1 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">Left-Aligned</th><th align="center">Center Aligned</th><th align="right">Right Aligned</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="center">some wordy text</td><td align="right">$1600</td></tr><tr><td align="left">col 2 is</td><td align="center">centered</td><td align="right">$12</td></tr><tr><td align="left">zebra stripes</td><td align="center">are neat</td><td align="right">$1</td></tr></tbody></table><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>文本两端加上两个~~即可，例如：</p><p><del>删除我</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除我~~</span><br></pre></td></tr></table></figure><h3 id="github-特有的特性"><a href="#github-特有的特性" class="headerlink" title="github 特有的特性"></a>github 特有的特性</h3><p>复选框列表<br>在列表符号后面加上 <code>[]</code> 或者 <code>[x]</code> 代表选中或者未选中情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* [x] C</span><br><span class="line">* [x] C++</span><br><span class="line">* [x] Java</span><br><span class="line">* [x] Qt</span><br><span class="line">* [x] Android</span><br><span class="line">* [ ] C#</span><br><span class="line">* [ ] .NET</span><br></pre></td></tr></table></figure><ul><li><input checked="" disabled="" type="checkbox"> C</li><li><input checked="" disabled="" type="checkbox"> C++</li><li><input checked="" disabled="" type="checkbox"> Java</li><li><input checked="" disabled="" type="checkbox"> Qt</li><li><input checked="" disabled="" type="checkbox"> Android</li><li><input disabled="" type="checkbox"> C#</li><li><input disabled="" type="checkbox"> .NET</li></ul><h4 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h4><p>github 的 Markdown 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><p>比如，:blush:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:blush:</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>Markdown官网：<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">http://daringfireball.net/projects/markdown/</a></li><li>中文参考：<a href="http://markdown.tw/" target="_blank" rel="noopener">http://markdown.tw/</a></li></ul><h4 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h4><ul><li><a href="http://marxi.co/" target="_blank" rel="noopener">http://marxi.co/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS多线程之二：NSThread的使用</title>
    <link href="https://sunjinshuai.github.io/2016/11/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ANSThread%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/11/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ANSThread%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2016-11-18T14:00:52.000Z</published>
    <updated>2017-12-18T14:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>NSThread<br>NSThread封装性最差，最偏向于底层，主要基于thread使用，生命周期需要手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。</p><p>一、线程创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建并自动启动</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(threadAlloc:) toTarget:self withObject:nil];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先创建线程，再启动</span><br><span class="line">NSThread *newThread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:obj];</span><br><span class="line">[newThread run];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ios(10.0)，线程的创建，线程创建后直接运行</span><br><span class="line">[NSThread detachNewThreadWithBlock:^&#123;</span><br><span class="line">[do something];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:obj];</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2017/10/23/b99d29bda1bf4201f75954bb76d32fbc" alt="Paste_Image.png"></p><p>二、线程之间的通讯</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在主线程中运行方法，wait表示是否阻塞这个方法的调用，如果为YES则等待主线程中运行方法结束，一般可用于在子线程中调用UI方法。</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐含产生新线程</span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在指定线程中执行，但该线程必须具备run loop。</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br></pre></td></tr></table></figure><p>三、NSThread的其它一些常用的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (NSThread *)currentThread;                     &#x2F;&#x2F; 获得当前线程</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti; &#x2F;&#x2F; 线程休眠</span><br><span class="line">+ (NSThread *)mainThread;                        &#x2F;&#x2F; 主线程，亦即UI线程了</span><br><span class="line">+ (BOOL)isMainThread;                            &#x2F;&#x2F; 判断当前线程是否是主线程</span><br><span class="line">+ (BOOL)isMultiThreaded;                         &#x2F;&#x2F; 判断当前线程是否是多线程</span><br><span class="line">+ (void)sleepUntilDate:(NSDate *)date;           &#x2F;&#x2F; 当前线程休眠到指定日期</span><br><span class="line">+ (void)exit;                                    &#x2F;&#x2F; 强行退出当前线程</span><br><span class="line">+ (double)threadPriority;                        &#x2F;&#x2F; 获取当前线程线程优先级</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p;             &#x2F;&#x2F; 给当前线程设定优先级，调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高。</span><br><span class="line">+ (NSArray *)callStackReturnAddresses            &#x2F;&#x2F; 线程的调用都会有函数的调用函数的调用就会有栈返回地址的记录，在这里返回的是函 数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组</span><br><span class="line">+ (NSArray *)callStackSymbols                    &#x2F;&#x2F; 同上面的方法一样，只不过返回的是该线程调用函数的名字数字</span><br><span class="line">+ (BOOL)isMainThread;                            &#x2F;&#x2F; 当前线程是否主线程</span><br><span class="line">- (BOOL)isMainThread;</span><br><span class="line">- (BOOL)isExecuting;                             &#x2F;&#x2F; 线程是否正在运行</span><br><span class="line">- (BOOL)isFinished;                              &#x2F;&#x2F; 线程是否已结束</span><br><span class="line">- (void)cancel                                   &#x2F;&#x2F; 终止线程循环</span><br><span class="line">- (void)start                                    &#x2F;&#x2F; 开启线程循环</span><br><span class="line">- (void)isCancelled;                             &#x2F;&#x2F; 判断线程是否撤销</span><br><span class="line">- (void)setName:(NSString *)n;                   &#x2F;&#x2F; 设置线程名称</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NSThread&lt;br&gt;NSThread封装性最差，最偏向于底层，主要基于thread使用，生命周期需要手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。&lt;/p
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS多线程之一：基本概念</title>
    <link href="https://sunjinshuai.github.io/2016/11/17/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sunjinshuai.github.io/2016/11/17/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2016-11-17T15:00:10.000Z</published>
    <updated>2017-12-18T14:19:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>计算机操作系统都有的基本概念，以下概念简单方式来描述。</p><p><code>进程</code>：就是一个正在执行的程序。<br><code>线程</code>：是执行程序最基本的单元，它有自己栈和寄存器。</p><blockquote><p>进程和线程的区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p></blockquote><p><code>并发</code>：多个任务同时发生，需要被处理。比如，田径赛场上的起跑线上有多个运动员等待起跑。<br><code>并行</code>：在某一个时间能够同时处理多个任务。比如，火车站开放了多个检票口，同一时间能够服务多个旅客。<br><code>串行</code>：线程执行只能依次逐一先后有序的执行，串行中，一个任务的执行必须以上一个任务执行结束为前提。</p><blockquote><p>串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提，并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来，串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。</p></blockquote><p><code>同步</code>：就是顺序往下执行。举例：烧完水后泡茶<br><code>异步</code>：就是几件事情同时在执行。烧水的时候拿出茶具，洗茶具，然后泡茶。其中烧水和拿茶具，洗茶具是同时进行的。</p><p>二、iOS多线程方案</p><p>在<code>iOS</code>中其实目前有4套多线程方案，他们分别是：<br>1、pthreads<br>2、NSThread<br>3、GCD<br>4、NSOperation &amp; NSOperationQueue</p><p>参考：(<a href="http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="noopener">http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机操作系统都有的基本概念，以下概念简单方式来描述。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;进程&lt;/code&gt;：就是一个正在执行的程序。&lt;br&gt;&lt;code&gt;线程&lt;/code&gt;：是执行程序最基本的单元，它有自己栈和寄存器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程和线程的区别&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
