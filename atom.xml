<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2017-11-29T15:34:51.742Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac安装Jenkins系列/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:34:51.742Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="external">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>持续的软件版本发布/测试项目。</li>
<li>监控外部调用执行的工作。</li>
</ul>
<p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="external">Jenkins官网</a>下载Jenkins；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击Download：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p>
<p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a></p>
<ul>
<li>在Safari浏览器上，会出现Safari不能连接到服务器。</li>
<li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li>
</ul>
<p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="external">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以通过下面两种方式获取初始化密码：</p>
<ul>
<li>打开terminal，执行cat命令即可(需要管理员权限)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>输入用户名和密码之后，Jenkins就彻底安装好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p>
<h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Application Support/Jenkins/Uninstall.command</div></pre></td></tr></table></figure>
<h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist    </div><div class="line">sudo rm !$    </div><div class="line">sudo rm -rf /Applications/Jenkins &quot;/Library/Application Support/Jenkins&quot; /Library/Documentation/Jenkins    </div><div class="line">sudo rm -rf /Users/Shared/Jenkins    </div><div class="line"># if you want to get rid of all the jobs and builds:    </div><div class="line">sudo dscl . -delete /Users/jenkins    </div><div class="line"># delete the jenkins user and group (if you chose to use them):    </div><div class="line">sudo dscl . -delete /Groups/jenkins</div></pre></td></tr></table></figure>
<h4 id="为什么我的Jenkins会报“dial-tcp-1-8080-getsockopt-connection-refused”"><a href="#为什么我的Jenkins会报“dial-tcp-1-8080-getsockopt-connection-refused”" class="headerlink" title="为什么我的Jenkins会报“dial tcp [::1]:8080: getsockopt: connection refused”"></a>为什么我的Jenkins会报“dial tcp [::1]:8080: getsockopt: connection refused”</h4><p>然后在浏览器中输入localhost:8080，结果报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dial tcp [::1]:8080: getsockopt: connection refused</div></pre></td></tr></table></figure></p>
<p>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="external">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS面试题--如何在项目中处理页面中的多个网络请求</title>
    <link href="https://sunjinshuai.github.io/2017/10/24/iOS%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A4%84%E7%90%86%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"/>
    <id>https://sunjinshuai.github.io/2017/10/24/iOS面试题-如何在项目中处理页面中的多个网络请求/</id>
    <published>2017-10-24T06:23:13.000Z</published>
    <updated>2017-10-25T11:34:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试题：<br>如何在项目中处理页面中的多个网络请求。<br>在开发中很多时候会有这样的场景，同一个界面有多个请求，而且要在这几个请求都成功返回的时候再去进行下一操作，对于这种场景，如何来设计请求操作呢？今天我们就来讨论一下有哪几种方案。</p>
<p>分析：<br>在网络请求的开发中，经常会遇到两种情况，一种是多个请求结束后统一操作，在一个界面需要同时请求多种数据，比如列表数据、广告数据等，全部请求到后再一起刷新界面。另一种是多个请求顺序执行，比如必须先请求个人信息，然后根据个人信息请求相关内容。这些要求对于普通的操作是可以做到并发控制和依赖操作的，但是对于网络请求这种需要时间的请求来说，效果往往与预期的不一样。因为网络请求是异步的，并不知道什么时候网络请求。很多开发人员为了省事，对于网络请求必须满足一定顺序这种情况，一般都是嵌套网络请求，即一个网络请求成功之后再请求另一个网络请求，总觉得这么不做不是一个好的解决方案，来看一下下面几种方案：</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一个整数，在创建的时候会有一个初始值，这个初始值往往代表我要控制的同时操作的并发数。在操作中，对信号量会有两种操作：信号通知与等待。信号通知时，信号量会+1，等待时，如果信号量大于0，则会将信号量-1，否则，会等待直到信号量大于0。什么时候会大于零呢？往往是在之前某个操作结束后，我们发出信号通知，让信号量+1。</p>
<ul>
<li>dispatch_semaphore_create：创建一个信号量（semaphore）</li>
<li>dispatch_semaphore_signal：信号通知，即让信号量+1</li>
<li>dispatch_semaphore_wait：等待，直到信号量大于0时，即可操作，同时将信号量-1</li>
</ul>
<p>在使用的时候，往往会创建一个信号量，然后进行多个操作，每次操作都等待信号量大于0再操作，同时信号量-1，操作完后将信号量+1。当信号量就减小到0了，这时候wait操作会起作用，<code>DISPATCH_TIME_FOREVER</code>表示会永远等待，一直等到信号量大于0，也就是有操作完成了，将信号量+1了，这时候才可以结束等待，进行操作，并且将信号量-1，这样新的任务又要等待。</p>
<h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p><code>NSOperationQueue</code>只有两种队列，即主队列和并行队列。通过<code>[[NSOperationQueue alloc] init];</code>创建的队列都是并行队列，并且可以将一个或多个NSOperation对象放到队列中去执行，而且是异步执行的，一个NSOperation对象可以通过调用start方法来执行任务，但是默认是同步执行的。则主队列通过<code>[NSOperationQueue mainQueue];</code>获得，而且其中所有<code>NSOperation</code>都会在主线程中执行。</p>
<p>当然也可以利用<code>NSOperationQueue</code>的线程依赖，当某个<code>NSOperation</code>对象依赖于其它<code>NSOperation</code>对象的完成时，就可以通过<code>addDependency</code>方法添加一个或者多个依赖的对象，只有所有依赖的对象都已经完成操作，当前<code>NSOperation</code>对象才会开始执行操作。需要先添加依赖关系,再将操作添加到队列中。另外，通过<code>removeDependency</code>方法来删除依赖对象。</p>
<h4 id="dispatch-group-t"><a href="#dispatch-group-t" class="headerlink" title="dispatch_group_t"></a>dispatch_group_t</h4><p>可以使用<code>dispatch_group_async</code>函数将多个任务关联到一个<code>dispatch_group</code>和相应的<code>queue</code>中，<code>dispatch_group</code>会并发地同时执行这些任务。而且<code>dispatch_group</code>可以用来阻塞一个线程，直到<code>dispatch_group</code>关联的所有的任务完成执行。有时候必须等待任务完成的结果，然后才能继续后面的处理。</p>
<p>多个请求结束后统一操作，最优方案：</p>
<p>假设我们一个页面需要同时进行多个请求，他们之间倒是不要求顺序关系，但是要求等他们都请求完毕了再进行界面刷新或者其他什么操作。</p>
<p>一、dispatch_group_t</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/24/31fc78f8d611c8cd0bcaf26b659cd614" alt="image.png"></p>
<p><code>dispatch_group</code>会等和它关联的所有的<code>dispatch_queue_t</code>上的任务都执行完毕才会发出同步信号，<code>dispathc_group_notify</code>的代码块block会被执行。从控制台的打印结构可以看出，如果将上面三个操作改成真实的网络操作后，这个简单的做法会变得无效，因为网络请求需要时间，而线程的执行并不会等待请求完成后才真正算作完成，而是只负责将请求发出去，线程就认为自己的任务算完成了，当三个请求都发送出去，就会执行<code>dispathc_group_notify</code>中的内容，但请求结果返回的时间是不一定的，也就导致界面都刷新了，请求才返回，这就是无效的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/24/c4843f20f4cfe0604209c58a4d436b33" alt="image.png"></p>
<p><code>notify</code>的作用就是在<code>group</code>中的其他操作全部完成后，再操作自己的内容，所以我们会看到上面事件A、B、C执行之后，才执行事件E。<br>和<code>dispatch_async</code>相比，当我们调用<code>n</code>次<code>dispatch_group_enter</code>后再调用<code>n</code>次<code>dispatch_group_level</code>时，<code>dispatch_group_notify</code>和<code>dispatch_group_wait</code>会收到同步信号；这个特点使得它非常适合处理异步任务的同步当异步任务开始前调用<code>dispatch_group_enter</code>异步任务结束后调用<code>dispatch_group_leve</code>；</p>
<p>二、dispatch_semaphore_t</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/24/9ab683a05139e6c125718f62d4f5cf00" alt="image.png"></p>
<p>在每个请求开始之前，我们创建一个信号量，初始为0，在请求操作之后，我们设一个<code>dispatch_semaphore_wait</code>，在请求到结果之后，再将信号量+1，也即是<code>dispatch_semaphore_signal</code>。这样做的目的是保证在请求结果没有返回之前，一直让线程等待在那里，这样一个线程的任务一直在等待，就不会算作完成，<code>notify</code>的内容也就不会执行了，直到每个请求的结果都返回了，线程任务才能够结束，这时候<code>notify</code>也才能够执行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题：&lt;br&gt;如何在项目中处理页面中的多个网络请求。&lt;br&gt;在开发中很多时候会有这样的场景，同一个界面有多个请求，而且要在这几个请求都成功返回的时候再去进行下一操作，对于这种场景，如何来设计请求操作呢？今天我们就来讨论一下有哪几种方案。&lt;/p&gt;
&lt;p&gt;分析：&lt;br&gt;在网络
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTPS的工作原理</title>
    <link href="https://sunjinshuai.github.io/2017/10/13/HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/10/13/HTTPS的工作原理/</id>
    <published>2017-10-13T15:23:54.000Z</published>
    <updated>2017-10-23T01:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p>
<ul>
<li><p>客户端发起HTTPS请求</p>
</li>
<li><p>服务端的配置<br>采用HTTPS协议的服务器必须要有自己制作或者CA证书，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p>
</li>
<li><p>传送证书<br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。</p>
</li>
<li><p>客户端解析证书<br>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机数，然后用证书对该随机数进行加密。</p>
</li>
<li><p>传送加密信息<br>这部分传送的是用证书加密后的随机数，目的就是让服务端得到这个随机数，以后客户端和服务端的通信就可以通过这个随机数来进行加密解密了。</p>
</li>
<li><p>服务段解密信息<br>服务端用私钥解密后，得到了客户端传过来的随机数(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>
</li>
<li><p>传输加密后的信息<br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>
</li>
<li><p>客户端解密信息<br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/22/7c798128543df40434986cc27fd4a761" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTPS在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;客户端发起HTTPS请求&lt;/p&gt;
&lt;/li&gt;
&lt;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="https://sunjinshuai.github.io/2017/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://sunjinshuai.github.io/2017/09/23/对称加密与非对称加密/</id>
    <published>2017-09-23T14:21:21.000Z</published>
    <updated>2017-10-23T01:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>对称加密：<br>加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），对称加密是最快速、最简单的一种加密方式。<br>加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。</p>
<p>对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<p>对称加密通常使用的是相对较小的密钥，一般小于256bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。</p>
<p>比如常见的DES/AES都是属于对称加密算法。</p>
<p>优点：算法公开、计算量小、加密速度快、加密效率高。<br>缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。</p>
<p>另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p>非对称加密：<br>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。</p>
<p>私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。</p>
<p>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p>
<p>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。</p>
<p>与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。<br>比如RSA就是最常用的非对称加密算法。</p>
<p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<p>优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。<br>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p>
<p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p>
<p>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对称加密：&lt;br&gt;加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），对称加密是最快速、最简单的一种加密方式。&lt;br&gt;加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之iconfont实战</title>
    <link href="https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2017/08/08/iOS之iconfont实战/</id>
    <published>2017-08-08T07:45:34.000Z</published>
    <updated>2017-08-08T08:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了<code>APP Slicing</code>功能，我司项目在itunes store下载的IPA体积大约在44M。</p>
<p>把我司iPA解压之后里面的<code>Assert.car</code>资源包的体积大约在22.1M，使用软件导出内部的资源文件发现3X系列的图片大小约为13.1M，2X系列的图片大小约为9.4M，两份加起来大于22.1M，所以可以看出我们的图片还是有很大的优化空间的。</p>
<p><a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>技术的主要目的是为减少应用体积而生。首先<code>icon</code>代表图标<code>font</code>代表字体。此技术便是将图标转化为字体，从而达到减小应用体积的目的(这样避免了@2X图和@3X图的使用，只需要一个字体图标就可搞定)。如需在项目中使用iconfont技术，图标矢量图一开始都应合并转化为字体库，只需要在项目中引入字体库就可以了。</p>
<p>优点:</p>
<ul>
<li>减小应用体积，字体文件比图片要小；</li>
<li>图标保真缩放，解决2x/3x乃至将来nx图问题；</li>
<li>方便更改图标颜色大小，图片复用；</li>
<li>一套图标资源可以在不用平台上使用(android、iOS、web)；</li>
</ul>
<p>缺点:</p>
<ul>
<li>只适用于纯色的icon；</li>
</ul>
<h4 id="iconfont实战"><a href="#iconfont实战" class="headerlink" title="iconfont实战"></a>iconfont实战</h4><ul>
<li><p>获取<code>.ttf</code>文件<br>登录<a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>，创建一个项目，设计师做好图标，把<code>.ttf</code>文件下载下来。<br>iconfont中的图标是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/588630-fff854d89142120b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>字体注册<br>iOS中使用自定义字体，将字体加入项目后，还需要注册字体。<br>注册的方式有两种：<br>－ 在Info.plist中声明”Fonts provided by application”</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b6a5790bed65a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>－ 调用API来注册。考虑到需要支持独立版和插件版，调用API注册更加方便。字体注册和获取的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)registerFontWithURL:(NSURL *)url &#123;</div><div class="line">    NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&apos;t exist&quot;);</div><div class="line">    CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)url);</div><div class="line">    CGFontRef newFont = CGFontCreateWithDataProvider(fontDataProvider);</div><div class="line">    CGDataProviderRelease(fontDataProvider);</div><div class="line">    CTFontManagerRegisterGraphicsFont(newFont, nil);</div><div class="line">    CGFontRelease(newFont);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIFont *)fontWithSize:(CGFloat)size &#123;</div><div class="line">    UIFont *font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">    if (font == nil) &#123;</div><div class="line">        [self registerFontWithURL: [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;]];</div><div class="line">        font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">        NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&apos;re using the correct font name.&quot;);</div><div class="line">    &#125;</div><div class="line">    return font;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>字体应用方式<br>可能的应用方式：<ul>
<li>UILabel作为Icon</li>
<li>UIButton的titleLabel作为Icon</li>
<li>根据字体生成UIImage</li>
</ul>
</li>
</ul>
<p>在实际项目中，鉴于将我们本来的icon当作字体使用，会让我们在项目中添加的控件方式有所变化，而且不容易控制颜色和图标大小，所以我这里推荐第三种方案，根据图片大小、颜色和Unicode码来生成并返回图片。</p>
<ul>
<li>应用到项目中<br>将<code>.ttf</code>文件引入到自己的工程中</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b463acca775cd8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>目前我司项目重构之后的图标为IconFont，新需求用到的图标也会优先采用IconFont。</p>
<p><a href="https://github.com/sunjinshuai/MYUtils" target="_blank" rel="external">demo地址</a></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="external">使用IconFont减小iOS应用体积</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了&lt;code&gt;APP Slicing&lt;/code&gt;功能，我司项目在i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第4期(2017.05.03)</title>
    <link href="https://sunjinshuai.github.io/2017/05/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E6%9C%9F-2017-05-03/"/>
    <id>https://sunjinshuai.github.io/2017/05/03/iOS学习笔记-第4期-2017-05-03/</id>
    <published>2017-05-03T03:20:08.000Z</published>
    <updated>2017-08-16T07:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>僵尸对象（Zombie Objects）</li>
<li>使用Instruments检测僵尸对象</li>
<li>iOS11适配之UITableview、UICollectionView下拉刷新错乱</li>
<li>@WeakObj和@StrongObj的宏定义</li>
</ul>
<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p>
<h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li>
</ul>
<p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p>
<h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p>
<p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    __unsafe_unretained NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">    [array addObject:@&quot;1&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：</p>
<ul>
<li>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针。<code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</li>
<li><code>assign</code>仅用于修饰<code>NSInteger</code>等OC基础类型，以及<code>short</code>、<code>int</code>、<code>double</code>、结构体等C数据类型，不修饰对象指针。</li>
<li>如果需要弱引用OC对象，建议使用<code>weak</code>关键字，因为被<code>weak</code>指针所引用的对象被回收后，<code>weak</code>指针会被赋为<code>nil</code>（空指针），给<code>nil</code>发任何消息都不会出问题。使用<code>weak</code>修饰代理对象属性就是很好的例子。</li>
</ul>
<h4 id="iOS11适配之UITableview、UICollectionView下拉刷新错乱"><a href="#iOS11适配之UITableview、UICollectionView下拉刷新错乱" class="headerlink" title="iOS11适配之UITableview、UICollectionView下拉刷新错乱"></a>iOS11适配之UITableview、UICollectionView下拉刷新错乱</h4><p>升级<code>Xcode 9</code>之后，在<code>iOS11</code>的环境下，发现原本没问题的<code>collectionView</code>和<code>tableView</code>像是中了风一样，头部刷新UI出现了错乱。</p>
<p>于是谷歌了一下发现<code>iOS11</code>弃用了<code>automaticallyAdjustsScrollViewInsets</code>属性，新增<code>contentInsetAdjustmentBehavior</code>来替代它。</p>
<p>关于<code>contentInsetAdjustmentBehavior</code>，<br>swift语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@available(iOS 11.0, *)</div><div class="line">public enum UIScrollViewContentInsetAdjustmentBehavior : Int &#123;</div><div class="line"></div><div class="line">    case automatic // Similar to .scrollableAxes, but will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewContentInset = YES inside a navigation controller, regardless of whether the scroll view is scrollable</div><div class="line"></div><div class="line">    case scrollableAxes // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)</div><div class="line"></div><div class="line">    case never // contentInset is not adjusted</div><div class="line"></div><div class="line">    case always // contentInset is always adjusted by the scroll view&apos;s safeAreaInsets</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种:</p>
<ul>
<li><code>automatic</code>和<code>scrollableAxes</code>一样，<code>scrollView</code>会自动计算和适应顶部和底部的内边距并且在<code>scrollView</code>不可滚动时，也会设置内边距。</li>
<li><code>scrollableAxes</code>自动计算内边距。</li>
<li><code>never</code>不计算内边距。</li>
<li><code>always</code>根据<code>safeAreaInsets</code>计算内边距。<br>很显然，在适配<code>iOS11</code>的时候我们这里要设置为<code>never</code>。</li>
</ul>
<p>OC语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明tableView的位置 添加下面代码</div><div class="line">if (@available(iOS 11.0, *)) &#123;</div><div class="line">    _tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明tableView的位置 添加下面代码</div><div class="line">if #available(iOS 11.0, *) &#123;</div><div class="line">    tableView.contentInsetAdjustmentBehavior = .never</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="WeakObj和-StrongObj的宏定义"><a href="#WeakObj和-StrongObj的宏定义" class="headerlink" title="@WeakObj和@StrongObj的宏定义"></a>@WeakObj和@StrongObj的宏定义</h4><p>我们都知道在防止如<code>block</code>的循环引用时，会使用<code>__weak</code>关键字做如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div></pre></td></tr></table></figure>
<p>后来，为了方便，不用每次都要写这样一句固定代码，我们定义了宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WeakSelf __weak typeof(self) weakSelf = self;</div></pre></td></tr></table></figure>
<p>之后，我们可以比较方便的在需要的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[weakSelf doSomething];</div></pre></td></tr></table></figure>
<p>再后来，我们发现不止<code>self</code>需要使用<code>weak</code>，可能有部分变量也需要<code>weak</code>，于是我们的宏继续进化，不仅仅只支持<code>self</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WeakObj(o) __weak typeof(o) o##Weak = o;</div></pre></td></tr></table></figure>
<p>这样，后续对需要使用<code>weak</code>的对象，只要写一句<code>WeakObj(obj)</code>即可使用<code>objWeak</code>变量。</p>
<p>再后来，我们发现了一些小技巧，可以让我们的这个宏看起来更原生一些，我们添加了@符号在前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define WeakObj(o) autoreleasepool&#123;&#125; __weak typeof(o) o##Weak = o;</div><div class="line">#define StrongObj(o) autoreleasepool&#123;&#125; __strong typeof(o) o = o##Weak;</div></pre></td></tr></table></figure>
<p>使用上看起来是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@WeakObj(self);</div><div class="line">[var setBlock:^&#123;</div><div class="line">    @StrongObj(self);</div><div class="line">    [self doSomething];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;僵尸对象（Zombie Objects）&lt;/li&gt;
&lt;li&gt;使用Instruments检测僵尸对象&lt;/li&gt;
&lt;li&gt;iOS11适配之UITableview、UICollectionView下拉刷新错乱&lt;/li&gt;
&lt;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/03/18/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/03/18/iOS之使用Cocoapods创建私有仓库/</id>
    <published>2017-03-18T10:31:52.000Z</published>
    <updated>2017-07-19T02:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
<p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p>
<ul>
<li><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</li>
<li><p>查看现有的<code>podspec</code>源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul>
<li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li>
<li>创建pod私有库所需要的项目工程文件，并上传到私有库</li>
<li>创建pod所对应的podspec文件，并进行验证／测试</li>
<li>向私有的Spec Repo中提交podspec</li>
<li>使用pod库</li>
</ul>
<h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul>
<li>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</li>
<li><p>将私有Spec Repo关联到本地</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add FXSpesc http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git</div></pre></td></tr></table></figure>
<p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p>
<h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul>
<li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>手动创建Xcode工程(过于简单)</p>
</li>
</ul>
<h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul>
<li>如果用<code>pod</code>命令创建，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你项目工程文件</div><div class="line">pod spec create FXKit.podspec</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  s.name         = &quot;FXKit&quot;</div><div class="line">  s.version      = &quot;0.0.1&quot;</div><div class="line">  s.summary      = &quot;FXKit，繁星优选私有库&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">		   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</div><div class="line">                   DESC</div><div class="line"></div><div class="line">  s.homepage     = &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;</div><div class="line"></div><div class="line">  # s.license    = &quot;MIT (example)&quot;</div><div class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line">  s.author       = &#123; &quot;孙金帅&quot; =&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</div><div class="line">  s.platform     = :ios</div><div class="line">  s.source       = &#123;</div><div class="line">	:git =&gt; &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;,</div><div class="line">	:tag =&gt; &quot;#&#123;s.version&#125;&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.source_files = &apos;FXKit/**/*.&#123;h,m&#125;&apos;</div><div class="line"></div><div class="line">  # s.resource_bundles = &#123;</div><div class="line">  #   &apos;FXKit&apos; =&gt; [&apos;FXKit/Assets/*.png&apos;]</div><div class="line">  # &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;FXKit/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;</div><div class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">s.name：私有库的名称，`pod search`搜索的关键词，注意这里一定要和`.podspec`的名称一样，否则报错。</div><div class="line">s.version：私有库的版本。</div><div class="line">s.ios.deployment_target：支持的pod最低版本。</div><div class="line">s.summary：私有库简介。</div><div class="line">s.description：私有库详细介绍。</div><div class="line">s.homepage：私有库在GitHub上的地址。</div><div class="line">s.license：开源协议。</div><div class="line">s.author：作者。</div><div class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</div><div class="line">s.source：私有库在GitHub上的地址和版本号。</div><div class="line">s.source_files：私有库对外共享的.h和.m文件。</div><div class="line">s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<ul>
<li>commit项目工程的源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git</div><div class="line">git push -u origin master</div><div class="line">git tag -m &quot;first release&quot; 0.0.1</div><div class="line">git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<ul>
<li>验证</li>
</ul>
<p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint FXKit.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p>
<h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</div><div class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</div><div class="line">pod repo push FXSpesc NAME.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings --use-libraries</div></pre></td></tr></table></figure>
<h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库踩坑记</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库踩坑记/</id>
    <published>2016-12-08T14:01:03.000Z</published>
    <updated>2017-08-08T07:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即上一篇<a href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/">iOS之使用Cocoapods创建公有仓库</a>，本文就<code>CocoaPods</code>创建公有库踩到的坑做一下分享：</p>
<h4 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h4><ul>
<li>本地的公有仓库验证通过，但是远程仓库上的公有仓库验证不通过，路经不对。<br><img src="http://upload-images.jianshu.io/upload_images/588630-4a5138f97c4c6d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>重新打开<code>xxx.podspec</code>文件编辑一下，确定共享文件路径没有错误，然后再上传到<code>github</code>上验证。<br><code>source_files</code>文件格式有几种设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.source_files  = &apos;Classes/*.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes/publicClass.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes&apos;</div><div class="line">s.source_files  = &apos;Classes/**/*.&#123;h,m&#125;&apos;</div></pre></td></tr></table></figure>
<ul>
<li>执行<code>pod trunk push TestCocoaPods.podspec</code>时，报<code>[!] {&quot;name&quot;=&gt;[&quot;is already taken&quot;]}</code><br><img src="http://upload-images.jianshu.io/upload_images/588630-2a2f1d0e9d5c0864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>执行<code>pod search TestCocoaPods</code>，会发现有一个重名的公有库存在，重新创建一个公有库，<code>CocoaPods</code>不允许有重名的公有库存在。</p>
<ul>
<li>最后所有的验证都通过了也上传成功了，结果使用<code>pod search</code>仍然搜索不到。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7076e838dbb41cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>解决办法：<br>1、执行<code>pod setup</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fd244d2a25ef7af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果最底下会输出<code>setup completed</code>。说明执行<code>pod setup</code>成功。<br>2、如果<code>pod search</code>操作还是搜索失败，删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure></p>
<p>3、执行<code>pod search</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be3fa814cb06d76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即上一篇&lt;a href=&quot;https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%9
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库/</id>
    <published>2016-12-08T05:45:50.000Z</published>
    <updated>2017-08-08T06:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在开发过程中，经常会使用到第三框架，我们通过一个<code>pod install</code>命令，很方便的就将第三方框架加到我们自己的项目中。</p>
<p>如果我们也想将自己写的组件或库开源出去，让别人也可以通过<code>pod install</code>命令安装自己的框架该怎么做呢？下面，我就教大家一步一步的将自己的<code>pods</code>发布到<code>CocoaPods</code>中。如果你现在对<code>CocoaPods</code>还不太了解，推荐你看一看这篇文章：<a href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">CocoaPods的安装与使用</a></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1、注册<code>CocoaPods</code>账户信息<br>2、创建共享库文件并上传到公有仓库<br>3、编辑<code>.podspec</code>文件<br>4、打<code>tag</code>, 发布一个<code>release</code>版本<br>5、发布自己的库描述文件<code>podspec</code>给<code>cocoapods</code><br>6、关于查找和使用新创建的库<br>7、更新维护<code>podspec</code></p>
<p>下面就创建<code>CocoaPods</code>公有库做一下分享：</p>
<p>一、在github上创建项目，复制项目的链接路径，例如：<a href="https://github.com/sunjinshuai/MYSementManager" target="_blank" rel="external">https://github.com/sunjinshuai/MYSementManager</a>;</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-18287791668c31f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br>1、<code>GitHub</code>仓库的名称，不允许重名。<br>2、开源协议，一般都选择<code>MIT</code>。</p>
<p>二、使用命令行、<code>sourceTree</code>或者<code>GitHub Mac</code>版将项目克隆到本地新建的一个文件夹中;</p>
<p>三、cd进入本地该文件夹，将自己之前的工程文件(demo)以及共享文件(共享库Lib)拖入其中，并创建公有仓库，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create cocoaPodsName;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e67a3ac9fd6604f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br>1、自己的工程文件(demo)以及共享文件(共享库Lib)。<br>2、<code>MYSementManager.podspec</code>创建的公有库名称。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-20364e263a61e972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当<code>Specification created at MYSementManager.podspec</code>说明创建公有库成功。</p>
<p>四、使用文本编辑器或者<code>sublime</code>等编辑公有仓库信息(注意：引号不能搞错了，是英文格式的””,不是中文格式“”)，默认选择文本编辑器。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ae92088a994e1ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1、s.name：公有库的名称。</div><div class="line">2、s.version：公有库的版本。</div><div class="line">3、s.summary：公有库简短介绍。</div><div class="line">4、s.description：公有库详细介绍。</div><div class="line">5、s.homepage：公有库在GitHub上的地址。</div><div class="line">6、s.license：开源协议。</div><div class="line">7、s.author：作者。</div><div class="line">8、s.source：公有库在GitHub上的地址和版本号。</div><div class="line">9、s.source_files：公有库对外共享的.h和.m文件。</div><div class="line">10、s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<p>没有涉及到的字段可以去<a href="http://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="external">官方文档</a>查阅。</p>
<p>五、编辑结束保存，并验证本地的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint cocoaPodsName.podspec</div></pre></td></tr></table></figure>
<p>六、验证有效后，然后再将本地该文件夹中所有的文件<code>push</code>到<code>github</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin https://github.com/sunjinshuai/test.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>使用<code>git tag</code>(此方法操作后再<code>push</code>上传一次)或者直接在<code>github</code>上点击<code>release</code>进入后创建<code>release</code>并给公有仓库打上<code>tag</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -m &quot;first release&quot; 0.0.1</div><div class="line">$ git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<p>七、注册<code>trunk</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk register 邮箱 ‘用户名’ --description=‘描述’</div></pre></td></tr></table></figure>
<p>注意：<br>邮箱为<code>github</code>上的登录邮箱、用户名为<code>github</code>上的用户名。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e5852a3ef0d784db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>接收发送到邮箱的链接，点击进入后注册成功。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-31ebbd1972d0b840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>查看注册的个人信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk me</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1c00ba7b4cc7dee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>验证上传到<code>github</code>上的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec lint cocoaPodsName.podspec</div></pre></td></tr></table></figure>
<p>八、将公有仓库推送到<code>CocoaPods</code>上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk push cocoaPodsName.podspec</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3b58f26ecefe1456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>大功告成，使用<code>pod search cocoaPodsName</code>搜索即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ebd6b6df003a75e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在开发过程中，经常会使用到第三框架，我们通过一个&lt;code&gt;pod install&lt;/code&gt;命令，很方便的就将第三方框架加到我们自己的项
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AutoreleasePool的实现原理</title>
    <link href="https://sunjinshuai.github.io/2016/10/06/AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2016/10/06/AutoreleasePool的实现原理/</id>
    <published>2016-10-06T06:32:16.000Z</published>
    <updated>2017-07-06T08:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题：autorelease对象什么时候释放。"><a href="#面试题：autorelease对象什么时候释放。" class="headerlink" title="面试题：autorelease对象什么时候释放。"></a>面试题：autorelease对象什么时候释放。</h4><p>autorelease的本质就是延迟调用<code>release</code>方法，在MRC的环境下，可以通过调用<code>[obj autorelease]</code>来延迟释放内存，在ARC的环境下，当我们创建一个对象，会将对象添加到当前的<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时，会对<code>autoreleasepool</code>里面的所有对象做一次<code>release</code>操作。在没有手动加入<code>autoreleasepool</code>的情况下，<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池<code>push</code>和<code>pop</code>。</p>
<p>当<code>autoreleasepool</code>销毁时，在调用堆栈中可以发现，系统调用了<code>-[NSAutoreleasePool release]</code>方法，这个方法最终通过调用<code>AutoreleasePoolPage::pop(void *)</code>函数来负责对<code>autoreleasepool</code>中的<code>autorelease</code>对象执行<code>release</code>操作。</p>
<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>我们打开<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a> 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到<code>autoreleasepool</code>的实现源码。其实，<code>autoreleasepool</code>是没有单独的内存结构的，它是通过以<code>AutoreleasePoolPage</code>为结点的双向链表来实现的。</p>
<ul>
<li>每一个线程的<code>autoreleasepool</code>其实就是一个指针的堆栈，结构中的thread指针指向当前线程；</li>
<li>每一个指针代表一个需要<code>release</code>的对象或者<code>POOL_SENTINEL</code>（哨兵对象，代表一个<code>autoreleasepool</code>的边界）；</li>
<li>一个<code>pool token</code>指向<code>autoreleasepool</code>所对应的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>；</li>
</ul>
<p>一个空的<code>AutoreleasePoolPage</code>的内存结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/588630-f64cda7c9112e5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><code>magic</code>用来校验<code>AutoreleasePoolPage</code>的结构是否完整；</li>
<li><code>next</code>指向最新添加的<code>autorelease</code>对象的下一个位置，初始化时指向 begin() ；</li>
<li><code>thread</code>指向当前线程；</li>
<li><code>parent</code>指向父结点，第一个结点的 parent 值为 nil ；</li>
<li><code>child</code>指向子结点，最后一个结点的 child 值为 nil ；</li>
<li><code>depth</code>代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code>代表 high water mark 。</li>
</ul>
<p>当<code>AutoreleasePoolPage</code>里面的<code>autorelease</code>对象满了，也就是next指针指向了栈顶，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>AutoreleasePoolPage</code>加入，新<code>AutoreleasePoolPage</code>的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。<br>另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。<br>所以，向一个对象发送<code>release</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶next指针指向的位置。</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a><code>autoreleasepool</code></h4><p>使用<code>clang -rewrite-objc</code>命令将下面的 Objective-C 代码重写成 C++ 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</div><div class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</div><div class="line"></div><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个<code>__AtAutoreleasePool</code>类型的局部变量<code>__autoreleasepool</code>来实现<code>@autoreleasepool {}</code>。当声明<code>__autoreleasepool</code>变量时，构造函数<code>__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p>当出了当前作用域时，析构函数<code>~__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure></p>
<p>也就是说<code>@autoreleasepool {}</code>的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line">    void *atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">    // 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</div><div class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code>、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a>objc_autoreleasePoolPush()</h4><p>上面提到的<code>objc_autoreleasePoolPush()</code>函数本质上就是调用的<code>AutoreleasePoolPage</code>的<code>push</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return nil;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据源码得出，每次执行<code>objc_autoreleasePoolPush</code>其实就是创建了一个新的<code>autoreleasepool</code>，对应<code>AutoreleasePoolPage</code>的具体实现就是往<code>AutoreleasePoolPage</code>中的<code>next</code>位置插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>的内存地址。并且把<code>pool token</code>指针指向这个地址，在执行<code>pop</code>操作的时候作为函数的入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline void *push()</div><div class="line">&#123;</div><div class="line">    id *dest = autoreleaseFast(POOL_SENTINEL);</div><div class="line">    assert(*dest == POOL_SENTINEL);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>push</code>函数通过调用<code>autoreleaseFast</code>函数来执行具体的插入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>autoreleaseFast</code>函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前<code>page</code>存在且没有满时，直接将对象添加到当前<code>page</code>中，即<code>next</code>指向的位置；</li>
<li>当前<code>page</code>存在且已满时，创建一个新的<code>page</code> ，并将对象添加到新创建的<code>page</code>中；</li>
<li>当前<code>page</code>不存在时，即还没有<code>page</code>时，创建第一个<code>page</code>，并将对象添加到新创建的<code>page</code>中。<br>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。</li>
</ul>
<h4 id="objc-autoreleasePoolPop-void"><a href="#objc-autoreleasePoolPop-void" class="headerlink" title="objc_autoreleasePoolPop(void *)"></a>objc_autoreleasePoolPop(void *)</h4><p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return;</div><div class="line"></div><div class="line">    // fixme rdar://9167170</div><div class="line">    if (!ctxt) return;</div><div class="line"></div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pop</code>函数的入参就是<code>push</code>函数的返回值，也就是<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>，直到<code>pool token</code>所在<code>page</code>的<code>next</code>指向<code>pool token</code>为止。</p>
<h4 id="autorelease对象释放原理"><a href="#autorelease对象释放原理" class="headerlink" title="autorelease对象释放原理"></a>autorelease对象释放原理</h4><p>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，在执行<code>objc_autoreleasePoolPop(void *)</code>操作的时候作为函数的入参。<br><img src="http://upload-images.jianshu.io/upload_images/588630-cf6a8a8bd44f721c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前<code>AutoreleasePoolPage</code>中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次<code>release</code>消息，并向回移动next指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个<code>AutoreleasePoolPage</code>，直到哨兵所在的<code>AutoreleasePoolPage</code>。</li>
</ul>
<p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数，当执行<code>pop</code>操作后，<br><img src="http://upload-images.jianshu.io/upload_images/588630-ee6388ccaec8b86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;a href=&quot;#面试题：autorelease对象什么时候释放。&quot; class=&quot;headerlink&quot; title=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;/a&gt;面试题：autoreleas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Load&amp;Initialize</title>
    <link href="https://sunjinshuai.github.io/2016/09/19/Load-Initialize/"/>
    <id>https://sunjinshuai.github.io/2016/09/19/Load-Initialize/</id>
    <published>2016-09-19T15:20:55.000Z</published>
    <updated>2017-11-29T15:22:09.163Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (void)load;</div><div class="line">+ (void)initialize;</div></pre></td></tr></table></figure>
<h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><p>如果你实现了 <code>+ load</code> 方法，那么当类被加载到内存时，它会自动被调用，并且是在 <code>main</code> 函数调用之前被调用。</p>
<h4 id="load-方法的调用栈"><a href="#load-方法的调用栈" class="headerlink" title="load 方法的调用栈"></a>load 方法的调用栈</h4><p>首先分析一下 <code>load</code> 方法是如何被调用的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-79f9a27a6fad634c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从控制台的打印可以看出，运行之后，依然打印了 <code>XXXX load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p><code>load</code> 方法的调用顺序其实有迹可循，我们看到 <code>demo</code> 的项目设置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-578317d4cc2d9920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在 <code>TARGETS -&gt; Build Phases -&gt; Compile Sources</code>中调整一下文件的加载顺序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-0bdb3567814e7f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果发现：</p>
<ul>
<li>在 <code>load</code> 方法的调用中会自动调用父类的方法，即<strong>父类先于子类调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>文件的加载顺序靠前的类优先调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>类先于分类调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>文件的加载顺序靠前的分类优先调用</strong>。</li>
</ul>
<h4 id="load方法如何加载到内存中"><a href="#load方法如何加载到内存中" class="headerlink" title="load方法如何加载到内存中"></a><code>load</code>方法如何加载到内存中</h4><p>使用 <code>Xcode</code> 添加一个符号断点 <code>+[Parent load]</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fc3a92e363d99516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p>
<p>重新运行程序。这时，代码会停在 <code>NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</code> 这一行的实现上：</p>
<p>左侧的调用栈很清楚的展示哪些方法被调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[Parent load]</div><div class="line">1  call_load_methods</div><div class="line">2  load_images</div><div class="line">3  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">...</div><div class="line">13 _dyld_start</div></pre></td></tr></table></figure>
<p>从runtime初始化开始</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9494f2a6913b9e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当 <code>Objective-C</code> 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入运行时的时候，进行回调。</p>
<ul>
<li><code>map_images</code> 主要是在 <code>image</code> 加载进内容后对其二进制内容进行解析，初始化里面的类的结构等。</li>
<li><code>load_images</code> 主要是调用 <code>call_load_methods</code>。按照继承层次依次调用 <code>Class</code> 的 <code>+load</code> 方法然后再是 <code>Category</code> 的 <code>+load</code> 方法。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ab9a17fe1c457f6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ec529c4bedd7e4ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从源码中可以看出，</p>
<ul>
<li>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> 递归把当前类和没有调用 <code>+ load</code> 方法的父类，通过 <code>add_class_to_loadable_list(cls)</code> 方法添加到 <code>loadable_classes</code> 列表中，<strong>保证父类在子类前调用 <code>+load</code> 方法</strong>。</li>
<li>通过 <code>_getObjc2NonlazyCategoryList</code> 获取所有的分类的列表之后，会通过 <code>remapClass</code> 获取分类对应的指针，然后调用<code>add_category_to_loadable_list</code> 把当前分类添加到 <code>loadable_categories</code> 列表中。</li>
</ul>
<p>在将镜像加载到运行时、对 <code>+load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>+load</code> 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-908e53a2462438c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>不停调用类的 <code>+load</code> 方法，直到 <code>loadable_classes</code> 为空。</li>
<li>然后调用一次 <code>call_category_loads</code> 加载分类。</li>
<li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>+load</code> 方法。</li>
<li><strong>类先于分类调用</strong>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5c3408d006682624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后通过对应的 <code>SEL</code> ，找到 <code>IMP</code> 的实现并执行。</p>
<h4 id="load-方法的应用"><a href="#load-方法的应用" class="headerlink" title="load 方法的应用"></a>load 方法的应用</h4><p>由于调用 <code>+load</code> 方法运行时间过早，环境很不安全，我们应该尽量减少 <code>+load</code> 方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在 <code>+load</code> 方法中。不过在这个时间点，所有的 <code>framework</code> 都已经加载到了运行时中，所以调用 <code>framework</code> 中的方法都是安全的。</p>
<h2 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h2><ul>
<li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用。</li>
<li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都已经加载到了内存中。</li>
<li><code>initialize</code> 的运行是线程安全的。</li>
<li>子类会继承父类的 <code>initialize</code> 方法。</li>
</ul>
<h4 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>在项目中没有引用任何文件，当我们运行项目，会发现与 <code>load</code> 方法不同的是，虽然我们在 <code>initialize</code> 方法中调用了 <code>NSLog</code>。但是程序运行之后没有任何输出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1ed8f3a5cc66ad20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果发现：<br>没有直接调用 <code>initialize</code> 方法。但是，这里也打印出了 <code>XXXX initialize</code> 字符串。</p>
<p><strong> <code>initialize</code> 只会在对应类的方法第一次被调用时，才会调用。</strong></p>
<p>由于子类会继承父类的 <code>initialize</code> 方法，即使子类没有实现 <code>initialize</code> 方法，也会调用父类的方法，这会导致一个很严重的问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e7b192de1527d86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>运行后发现父类的 <code>initialize</code> 方法竟然调用了两次：</p>
<p>虽然 <code>initialize</code> 方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// In Parent.m</div><div class="line">+ (void)initialize &#123;</div><div class="line">if (self == [Parent class]) &#123;</div><div class="line">NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加上判断后，就不会因为子类而调用到自己的 <code>initialize</code> 方法了。</p>
<p><strong> 如果在分类中也实现了 <code>initialize</code>  方法，则会出现方法”覆盖”</strong>。</p>
<p>在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4b45dbbbeceffd7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从runtime初始化开始</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9eca14718fb589ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>lookUpImpOrForward</code> 方法只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时才会调用。</p>
<h4 id="Initialize-方法的应用"><a href="#Initialize-方法的应用" class="headerlink" title="Initialize 方法的应用"></a>Initialize 方法的应用</h4><p>由于 <code>initialize</code> 作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装与使用</title>
    <link href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/08/08/CocoaPods的安装与使用/</id>
    <published>2016-08-08T03:16:06.000Z</published>
    <updated>2017-08-08T04:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Cocoapods</code>是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。</p>
<p>当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当前的步伐，而应该不断进取，要做到能想<code>Cocoapods</code>提交项目，并且在自己项目中熟练应用该工具的程度。特别是如果一个大的公司来说的话,就有可能进行模块化开发了。对于国内很多公司还是在用OC来说的话，<code>Cocoapods</code>应该还是一个不错的模块管理的工具。</p>
<h4 id="升级ruby源"><a href="#升级ruby源" class="headerlink" title="升级ruby源"></a>升级ruby源</h4><p>安装<code>Cocoapods</code>需要用到<code>ruby</code>，Mac系统自带<code>ruby</code>，但如果不是最新的系统，最好更新一下。</p>
<p>注意：<br><code>ruby</code>的软件源<code>rubygems.org</code>被墙了，所以先换一下源。</p>
<ul>
<li>首先，执行以下命令删除原来的ruby源：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources --remove https://rubygems.org/</div></pre></td></tr></table></figure>
<p>注意：<br>执行命令后可在终端看见以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://rubygems.org/ removed from sources</div></pre></td></tr></table></figure>
<ul>
<li>然后下一步添加你找到的可用的镜像源(这里我没有用淘宝的源：<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -a https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<ul>
<li>验证新源是否替换成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure>
<p>终端输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line">https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<p>到此<code>ruby</code>源替已经换成国内的源。</p>
<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p>问题1、<code>While executing gem ... (Errno::EPERM)  Operation not permitted - /usr/bin/fuzzy_match</code>错误</p>
<p>解决方法:</p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure></p>
<p>然后提示<code>gems installed</code>即可。</p>
<p>问题2、<code>Error installing pods:active support requires Ruby version &gt;= 2.2.2</code><br>解决方案:</p>
<p>查看<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure>
<p>终端会输出你的<code>ruby</code>版本信息</p>
<p>查看目前的所有<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm list known</div></pre></td></tr></table></figure>
<p>如果提示<code>command not found</code>请先安装<code>rvm</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L get.rvm.io | bash -s stable</div></pre></td></tr></table></figure>
<p>如果已安装会列出所有的<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># MRI Rubies</div><div class="line">[ruby-]1.8.6[-p420]</div><div class="line">[ruby-]1.8.7[-head] # security released on head</div><div class="line">[ruby-]1.9.1[-p431]</div><div class="line">[ruby-]1.9.2[-p330]</div><div class="line">[ruby-]1.9.3[-p551]</div><div class="line">[ruby-]2.0.0[-p648]</div><div class="line">[ruby-]2.1[.10]</div><div class="line">[ruby-]2.2[.6]</div><div class="line">[ruby-]2.3[.3]</div><div class="line">[ruby-]2.4[.0]</div><div class="line">ruby-head</div><div class="line"></div><div class="line"># for forks use: rvm install ruby-head-&lt;name&gt; --url https://github.com/github/ruby.git --branch 2.2</div><div class="line"></div><div class="line"># JRuby</div><div class="line">jruby-1.6[.8]</div><div class="line">jruby-1.7[.26]</div><div class="line">jruby[-9.1.7.0]</div><div class="line">jruby-head</div><div class="line"></div><div class="line"># Rubinius</div><div class="line">rbx-1[.4.3]</div></pre></td></tr></table></figure>
<p>然后安装最新的<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h4 id="CocoaPods的使用"><a href="#CocoaPods的使用" class="headerlink" title="CocoaPods的使用"></a>CocoaPods的使用</h4><ul>
<li>查找第三方库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search AFNetworking</div></pre></td></tr></table></figure>
<ul>
<li>创建Podfile文件</li>
</ul>
<p>在终端使用cd ＋路径切换到项目所在文件下，然后输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch Podfile</div></pre></td></tr></table></figure>
<p>就可以在项目目录里看到<code>Podfile</code>文件。也可以使用<code>pod init</code>来创建，<code>Podfile</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod init</div></pre></td></tr></table></figure>
<p>打开Podfile文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open Podfile</div></pre></td></tr></table></figure>
<p>然后<code>pod install</code>就可以了</p>
<h4 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h4><p>由于有<code>Podfile.lock</code>文件的保护下，在没有执行<code>pod update</code>命令的情况下，是不会将已有的第三方库进行升级的。所以运行<code>pod install</code>的情况下还是能编译通过的。</p>
<ul>
<li>pod</li>
</ul>
<p>一般在<code>Podfile</code>里面如果引入第三方库，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div></pre></td></tr></table></figure>
<p>可以看出<code>pod</code>关键字后面可以跟参数:</p>
<p>参数一： 版本号<br>从上面可以看得出<code>AFNetworking</code>后面跟了参数版本号。<br>不过版本号可以是大于、小于、等于等。当然具体的可以是’&gt; 3.1.0’, ‘&gt;= 3.1.0’, ‘&lt; 3.1.0’, ‘3.1.0’以及’~&gt; 3.1.0’。关于普通的就没什么好说了，最后一个~&gt;指的是正对最后一位来说。如使用’~&gt; 3.1.0’,意味着’&gt;= 3.1.0’并且’&lt; 3.2.0’的意思。</p>
<p>参数二：地址<br><code>Cocoapods</code>可以指定某一个<code>git</code>的目录或者是本地的目录。有的时候我们希望一直用某一个版本最新的版本，即使没有打版本的话，我们可以直接后面接上:<code>git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;</code>。<br>当然除了这种情况外，还有可能是如果是我们自己开发的私有库，并且在开发阶段的情况下，可能就希望开发模式进行引用，则可以使用path参数:<code>:path =&gt; &#39;~/Documents/AFNetworking</code>。</p>
<p>参数三：tag、branche、commit<br>有的时候我们希望引用有一个<code>tag</code>，<code>branch</code>或者是<code>comit</code>的内容的话可以使用这个参数，分别用<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</p>
<ul>
<li>platform</li>
</ul>
<p>这个参数是只依赖的库希望在哪个平台被编译，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;7.0&apos;</div></pre></td></tr></table></figure>
<ul>
<li>target</li>
</ul>
<p>这个是指定具体的配置是适配在哪个target，这里的target值得就是Xcode中的target。如果对于一些项目中你的不同target引用的框架不同的话，可以采用这个进行区分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">target &quot;ShowsApp&quot; do  </div><div class="line">  pod &apos;ShowsKit&apos;</div><div class="line">  target &quot;ShowsTV&quot; do</div><div class="line">    pod &quot;ShowTVAuth&quot;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<ul>
<li>use_frameworks!</li>
</ul>
<p>这个指明编译成动态库，而不是静态库，特别是在使用Swift库的过程中，特别需要使用这句。不过他会把所有项目的编译动态库，这一点有点不好。不过在使用Swift库的过程中就没办法了。</p>
<ul>
<li>source</li>
</ul>
<p>这个参数是指Cocoapods从哪些仓库(Spec)中获得框架的源代码，如果在结合使用开源库以及自己私有库的情况下，这个参数还是非常有意义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source &apos;https://github.com/artsy/Specs.git&apos;  </div><div class="line">source &apos;https://192.168.0.90:8888/MySepcs/Specs.git&apos;</div></pre></td></tr></table></figure>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod install --verbose --no-repo-update</div><div class="line">pod update --verbose --no-repo-update</div></pre></td></tr></table></figure>
<p>pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是pod update会更新所有的类库，获取最新版本的类库。每次用pod update就行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Cocoapods&lt;/code&gt;是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。&lt;/p&gt;
&lt;p&gt;当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git中merge、rebase的区别</title>
    <link href="https://sunjinshuai.github.io/2016/08/04/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2016/08/04/源码管理工具之git中merge、rebase的区别/</id>
    <published>2016-08-04T06:15:32.000Z</published>
    <updated>2017-08-04T07:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般在公司git整合分支一般有两种方法——快速向前合并<code>git rebase</code>和三路合并<code>git merge</code>。其实在开发中，<code>git rebase</code>和<code>git merge</code>表达都是一个意思，即，将一个分支合并到另一个分支。</p>
<p>当开发一个新功能，一般我们会在<code>develop</code>分支上创建<code>featrue</code>分支：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b6359864017521dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当我们这个新功能开发测试完毕之后，首先要把<code>featrue</code>分支合并到<code>develop</code>分支上，一般会根据实际情况选择是否使用<code>git merge</code>还是<code>git rebase</code>。</p>
<p><strong><code>git merge</code></strong><br>根据分支合并的原则，<code>git</code>会自动根据两个分支的共同祖和两个分支的最新提交<code>commit</code>记录进行一个三方合并，然后将合并中修改的内容生成一个新的<code>commit</code>记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git merge master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2fb4e523cea0a269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git merge</code>是一个安全的操作</strong></p>
<p><strong><code>git rebase</code></strong></p>
<p>它会把整个<code>feature</code>分支移动到<code>develop</code>分支的后面，有效地把所有<code>develop</code>分支上新的提交并入过来。但是，<code>git rebase</code>为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git rebase master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93bdffa37317c083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git rebase</code>最大的特点就是让你的项目历史提交记录会非常整洁。</strong><br>首先，它不像<code>git merge</code>那样引入不必要的合并提交。其次，如上图所示，<code>git rebase</code>使项目历史提交记录呈现出一条直线。你可以从项目终点到起点浏览而不需要任何的分叉，可以让你更容易的使用<code>git log</code>查看项目的提交记录。</p>
<p><strong><code>git rebase</code>缺点就是安全性和可跟踪性。</strong></p>
<p><code>git rebase</code>的黄金法则：绝对不要在公共的分支上使用。如果你把<code>master</code>分支<code>rebase</code>到你的<code>feature</code>分支上：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aa37afc6fe4ff411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这次<code>rebase</code>将<code>master</code>分支上的所有提交都移到了<code>feature</code>分支后面。<br>问题是它只发生在你的代码仓库中，而其他所有的开发者还在原来的<code>master</code>上工作。因为<code>rebase</code>引起了新的提交，所以<code>git</code>会认为你的<code>master</code>分支和其他人的<code>master</code>已经分叉了。</p>
<p>同步两个<code>master</code>分支的唯一办法是把它们<code>merge</code>到一起，导致一个额外的合并提交和两堆包含同样更改的提交。</p>
<p><strong><code>git rebase</code>不适用于公共的分支上。</strong></p>
<p>总结：选择<code>git merge</code>还是<code>git rebase</code>？</p>
<ul>
<li><p><code>git merge</code>是一个合并操作，会采用三路合并的方式将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容，生成一个新的<code>commit</code>记录。</p>
</li>
<li><p><code>git rebase</code>并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面，为原分支上每一个提交创建一个新的提交。</p>
</li>
<li><p><code>git merge</code>与<code>git rebase</code>都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般在公司git整合分支一般有两种方法——快速向前合并&lt;code&gt;git rebase&lt;/code&gt;和三路合并&lt;code&gt;git merge&lt;/code&gt;。其实在开发中，&lt;code&gt;git rebase&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;表达都是一个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第3期(2016.08.03)</title>
    <link href="https://sunjinshuai.github.io/2016/08/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E6%9C%9F-2016-08-03/"/>
    <id>https://sunjinshuai.github.io/2016/08/03/iOS学习笔记-第3期-2016-08-03/</id>
    <published>2016-08-03T02:25:15.000Z</published>
    <updated>2017-08-19T05:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>数组容错处理</li>
<li>Foundation中的断言处理</li>
<li>文本计算的坑</li>
<li>UITableview的headerView和footerView高度的设置</li>
<li>UIWebView底部的黑条</li>
</ul>
<h4 id="数组容错处理"><a href="#数组容错处理" class="headerlink" title="数组容错处理"></a>数组容错处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> @method objectAtIndexCheck:</div><div class="line"> @abstract 检查是否越界和NSNull如果是返回nil</div><div class="line"> @result 返回对象</div><div class="line"> */</div><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &gt;= [self count]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id value = [self objectAtIndex:index];</div><div class="line">    if (value == [NSNull null]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h4><p><code>Foundation</code>中定义了两组断言相关的宏，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure></p>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ul>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ul>
<p>当断言失败时，通常是会抛出一个如下所示的异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure></p>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。每个线程都有自己的<code>NSAssertionHandler</code>对象。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure></p>
<p>另外，还定义了一个常量字符串，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure></p>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p><code>Xcode</code>已经默认将<code>release</code>环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. 所以不用担心在开发时候大胆使用。</p>
<p>自定义<code>NSAssertionHandler</code><br><code>NSAssertionHandler</code>实例是自动创建的，用于处理错误断言。如果<code>NSAssert</code>和<code>NSCAssert</code>条件评估为错误，会向<code>NSAssertionHandler</code>实例发送一个表示错误的字符串。每个线程都有它自己的<code>NSAssertionHandler</code>实例。<br>我们可以自定义处理方法，从而使用断言的时候，控制台输出错误，但是程序不会直接崩溃。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyAssertHandler.h&quot;</div><div class="line"></div><div class="line">@implementation MyAssertHandler</div><div class="line"></div><div class="line">//处理Objective-C的断言</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%li&quot;, NSStringFromSelector(selector), object, fileName, (long)line);</div><div class="line">&#125;</div><div class="line">//处理C的断言</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%li&quot;, functionName, fileName, (long)line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>给线程添加处理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义<code>NSAssertionHandler</code>后,程序能够获得断言失败后的信息,但是程序可以继续运行,不会强制退出程序。</p>
<h4 id="文本计算的坑"><a href="#文本计算的坑" class="headerlink" title="文本计算的坑"></a>文本计算的坑</h4><p>一般在开发的时候，很多时候需要先计算出文本在某字体下的宽高，再设置控件的frame。有时候文本计算得到的width和height是小数，有可能最后得到的结果不准确，那么控件的frame也不准确。所以我们经常做的一件事就是<code>Category</code>，即给<code>NSString</code>扩展方法，使用新增的方法统一计算文本的大小，在这些方法中使用ceil()将小数点后数据除去，使得计算的结果小数点后都是0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 单行的</div><div class="line">- (CGSize)textSizeWithFont:(UIFont *)font &#123;</div><div class="line">   CGSize textSize = [self sizeWithAttributes:@&#123;NSFontAttributeName:font&#125;];</div><div class="line">   textSize = CGSizeMake((int)ceil(textSize.width), (int)ceil(textSize.height));</div><div class="line">   return textSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根据字体、行数、行间距和constrainedWidth计算多行文本占据的size</div><div class="line">- (CGSize)textSizeWithFont:(UIFont*)font</div><div class="line">             numberOfLines:(NSInteger)numberOfLines</div><div class="line">               lineSpacing:(CGFloat)lineSpacing</div><div class="line">          constrainedWidth:(CGFloat)constrainedWidth</div><div class="line">          isLimitedToLines:(BOOL *)isLimitedToLines &#123;</div><div class="line"></div><div class="line">    if (self.length == 0) &#123;</div><div class="line">        return CGSizeZero;</div><div class="line">    &#125;</div><div class="line">    CGFloat oneLineHeight = font.lineHeight;</div><div class="line">    CGSize textSize = [self boundingRectWithSize:CGSizeMake(constrainedWidth, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size;</div><div class="line"></div><div class="line">    CGFloat rows = textSize.height / oneLineHeight;</div><div class="line">    CGFloat realHeight = oneLineHeight;</div><div class="line">    // 0 不限制行数</div><div class="line">    if (numberOfLines == 0) &#123;</div><div class="line">        if (rows &gt;= 1) &#123;</div><div class="line">            realHeight = (rows * oneLineHeight) + (rows - 1) * lineSpacing;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (rows &gt; numberOfLines) &#123;</div><div class="line">            rows = numberOfLines;</div><div class="line">            if (isLimitedToLines) &#123;</div><div class="line">                *isLimitedToLines = YES;  //被限制</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        realHeight = (rows * oneLineHeight) + (rows - 1) * lineSpacing;</div><div class="line">    &#125;</div><div class="line">    return CGSizeMake(ceil(constrainedWidth),ceil(realHeight));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UITableview的headerView和footerView高度的设置"><a href="#UITableview的headerView和footerView高度的设置" class="headerlink" title="UITableview的headerView和footerView高度的设置"></a>UITableview的headerView和footerView高度的设置</h4><p>一般在项目中使用<code>UITableview</code>的<code>headerView</code>和<code>footerView</code>的时候都会遇到一个问题，即给<code>headerView</code>和<code>footerView</code>高度设置0的时候，发现不好使。经过查阅资料得知如果给<code>headerView</code>和<code>footerView</code>高度设置0，则会被设置成为默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123;</div><div class="line">    return CGFLOAT_MIN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123;</div><div class="line">    return CGFLOAT_MIN;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIWebView底部的黑条"><a href="#UIWebView底部的黑条" class="headerlink" title="UIWebView底部的黑条"></a>UIWebView底部的黑条</h4><p>一般我使用<code>UIWebView</code>的时候会发现，<code>UIWebView</code>底部的黑条很难看，特别是在底部还有透明控件的时候，隐藏的做法其实很简单，只需要将<code>opaque</code>设为NO，背景色设为<code>clearColor</code>即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组容错处理&lt;/li&gt;
&lt;li&gt;Foundation中的断言处理&lt;/li&gt;
&lt;li&gt;文本计算的坑&lt;/li&gt;
&lt;li&gt;UITableview的headerView和footerView高度的设置&lt;/li&gt;
&lt;li&gt;UIW
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之实战及应用</title>
    <link href="https://sunjinshuai.github.io/2016/07/17/iOS-RunTime%E4%B9%8B%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2016/07/17/iOS-RunTime之实战/</id>
    <published>2016-07-17T08:02:33.000Z</published>
    <updated>2017-08-17T09:01:24.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之六：Category</title>
    <link href="https://sunjinshuai.github.io/2016/06/22/iOS-RunTime%E4%B9%8B%E5%85%AD%EF%BC%9ACategory/"/>
    <id>https://sunjinshuai.github.io/2016/06/22/iOS-RunTime之六：Category/</id>
    <published>2016-06-22T15:32:02.000Z</published>
    <updated>2017-08-17T06:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Category</code>是<code>Objective-C 2.0</code>之后添加的特性，一般我们使用<code>Category</code>的场景主要可以动态地为已经存在的类扩展新的方法。这样做的好处就是：</p>
<ul>
<li>可以减少臃肿的代码。</li>
<li>可以把不同的功能拆开，方便以后的维护。</li>
</ul>
<p>在<strong>runtime.h</strong>中查看定义中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_category *Category;</div></pre></td></tr></table></figure>
<p>同样也是一个<code>objc_category</code>结构体，定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct objc_category &#123;</div><div class="line">    char *category_name                                      OBJC2_UNAVAILABLE;</div><div class="line">    char *class_name                                         OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list *instance_methods                OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_method_list *class_methods                   OBJC2_UNAVAILABLE;</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</div><div class="line">&#125;                                                            OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>打开<code>objc</code>源代码，在<strong>objc-runtime-new.h</strong>中我们可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct category_t &#123;</div><div class="line">    const char *name;</div><div class="line">    classref_t cls;</div><div class="line">    struct method_list_t *instanceMethods;</div><div class="line">    struct method_list_t *classMethods;</div><div class="line">    struct protocol_list_t *protocols;</div><div class="line">    struct property_list_t *instanceProperties;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">name：是指 class_name 而不是 category_name。</div><div class="line">cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象。</div><div class="line">instanceMethods：category中所有给类添加的实例方法的列表。</div><div class="line">classMethods：category中所有添加的类方法的列表。</div><div class="line">protocols：category实现的所有协议的列表。</div><div class="line">instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p><code>OBJC2_UNAVAILABLE</code>之类的宏定义是苹果在<code>Objc</code>中对系统运行版本进行约束的黑魔法，为的是兼容非<code>Objective-C 2.0</code>的遗留逻辑，但我们仍能从中获得一些有价值的信息，有兴趣的可以查看源代码。</p>
</li>
<li><p><strong>从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。</strong></p>
</li>
</ul>
<p>下面看一个例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b79de8f37a29383b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>使用<code>clang</code>的命令去看看<code>category</code>到底会变成什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc Person+Student.m</div></pre></td></tr></table></figure>
<p>注意：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9618ff0da52a5af1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>解决方法<br>在终端中输入下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-0bc396608d4ad9d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>然后打开文件目录，会发现多了一个<code>10w</code>多行的<code>.cpp</code>文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4b3c8af00700356c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>通过.cpp文件中红我们可以看到：</p>
<ul>
<li>首先编译器生成了实例方法列表<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Student</code><br>和属性列表<code>_OBJC_$_PROP_LIST_Person_$_Student</code>，两者的命名都遵循了<strong>公共前缀+类名+category名字的命名方式</strong>。</li>
<li>而且实例方法列表里面填充的正是我们在<code>Student</code>这个<code>category</code>里面写的方法<code>study</code>，而属性列表里面填充的也正是我们在<code>Student</code>里添加的<code>age</code>属性。</li>
<li>还有一个需要注意到的事实就是<code>category</code>的名字用来给各种列表以及后面的<code>category</code>结构体本身命名，而且有<code>static</code>来修饰，所以在同一个编译单元里我们的<code>category</code>名不能重复，否则会出现编译错误。</li>
<li>其次，编译器生成了<code>category</code>本身<code>_OBJC_$_CATEGORY_Person_$_Student</code>，并用前面生成的列表来初始化<code>category</code>本身。</li>
</ul>
<h4 id="Category和Extension的区别"><a href="#Category和Extension的区别" class="headerlink" title="Category和Extension的区别"></a><strong>Category和Extension的区别</strong></h4><ul>
<li><code>Extension</code>在编译期决议，它就是类的一部分，在编译期和头文件里的<code>@interface</code>以及实现文件里的<code>@implement</code>一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。<code>Extension</code>一般用来隐藏类的私有信息，你必须有一个类才能为这个类添加<code>Extension</code>，所以你无法为系统的类比如<code>NSString</code>添加<code>Extension</code>。</li>
<li><code>Category</code>则完全不一样，它是在运行期决议的。</li>
<li><code>Extension</code>可以添加属性、成员变量，而<code>Category</code>一般不可以。</li>
</ul>
<p>总之，就<code>Category</code>和<code>Extension</code>的区别来看，<code>Extension</code>可以添加实例变量，而<code>Category</code>是无法添加实例变量的。因为<code>Category</code>在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的。</p>
<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a><strong>面试题</strong></h5><p>一般面试官有时候会问到这样的问题：<br>在类和<code>Category</code>中都可以有<code>study</code>方法，那么有两个问题：</p>
<ul>
<li>在类的<code>study</code>方法调用的时候，我们可以调用<code>Category</code>中声明的<code>study</code>方法么？</li>
<li>如果一个类有多个分类的时候<code>study</code>方法，调用顺序是咋样的呢？</li>
</ul>
<p>解决方法：<br><a href="https://sunjinshuai.github.io/2016/08/16/iOS%E4%B9%8B-load%E5%92%8C-initialize%E7%9A%84%E5%8C%BA%E5%88%AB/">iOS之+load和+initialize的区别</a></p>
<h4 id="Category的原理"><a href="#Category的原理" class="headerlink" title="Category的原理"></a><strong>Category的原理</strong></h4><p>想深入了解<code>Category</code>的原理，请查看苹果的源码，这里是<a href="http://opensource.apple.com//source/objc4/objc4-680/" target="_blank" rel="external">objc4-680/</a><br>我们知道，<code>Objective-C</code>的运行是依赖<code>runtime</code>，而<code>runtime</code>则依赖于<code>dyld</code>动态加载，在 <code>objc-os.mm</code>文件中可以找到入口，它的调用栈简单整理如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ffaecffeddac7a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><code>Category</code>被附加到类上面是在<code>map_images</code>的时候发生的，在<code>new-ABI</code>的标准下，<code>_objc_init</code>里面的调用的<code>map_images</code>最终会调用<code>objc-runtime-new.mm</code>里面的<code>_read_images</code>方法，而在<code>_read_images</code>方法的结尾，有以下的代码片段：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ec13eaa495018252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-92a60d017d02fe88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从上面的代码中可以看出：</p>
<ul>
<li>将<code>Category</code>和它的主类（或元类）注册到哈希表中；</li>
<li>如果主类（或元类）已实现，那么重建它的方法列表。</li>
</ul>
<p>在这里分了两种情况进行处理：<code>Category</code>中的实例方法和属性被整合到主类中；而类方法则被整合到元类中。另外，对协议的处理比较特殊，<code>Category</code>中的协议被同时整合到了主类和元类中。</p>
<p>值得注意的是，在代码中有一小段注释<code>/* || cat-&gt;classProperties */</code>，根据注释可见苹果曾经计划利用<code>Category</code>来添加属性。<code>addUnattachedCategoryForClass</code>只是把类和<code>category</code>做一个关联映射，然后在<code>remethodizeClass</code>真正的去做处理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1f455346fe641685.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>通过<code>remethodizeClass</code>这个函数的主要作用是将<code>Category</code>中的方法、属性和协议整合到类（主类或元类）中，查看<code>attachCategories</code>这个函数：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-94cc3e2ef272a1fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>首先，通过<code>while</code>循环，遍历所有的<code>Category</code>，也就是参数<code>cats</code>中的<code>list</code>属性。对于每一个<code>Category</code>，得到它的方法列表<code>mlist</code>、<code>proplist</code>和<code>protolist</code>并存入<code>mlists</code>、<code>proplists</code>和<code>protolists</code>中。换句话说，它的主要作用就是将<code>Category</code>中的方法、属性和协议拼接到类（主类或元类）中，更新类的数据字段<code>data()</code>中<code>mlist</code>、<code>proplist</code>和<code>protolist</code>的值。</p>
<p>通过以上可以看出：</p>
<ul>
<li><code>Category</code>的方法没有“完全替换掉”原来类已经有的方法，也就是说如果<code>Category</code>和原来类都有<code>methodA</code>，那么<code>category</code>附加完成之后，类的方法列表里会有两个<code>methodA</code>。</li>
<li><code>Category</code>的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的<code>Category</code>的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Category&lt;/code&gt;是&lt;code&gt;Objective-C 2.0&lt;/code&gt;之后添加的特性，一般我们使用&lt;code&gt;Category&lt;/code&gt;的场景主要可以动态地为已经存在的类扩展新的方法。这样做的好处就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以减少臃
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之五：Category不能动态添加成员变量</title>
    <link href="https://sunjinshuai.github.io/2016/06/20/iOS-RunTime%E4%B9%8B%E4%BA%94%EF%BC%9ACategory%E4%B8%8D%E8%83%BD%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>https://sunjinshuai.github.io/2016/06/20/iOS-RunTime之五：Category不能动态添加成员变量/</id>
    <published>2016-06-20T14:32:02.000Z</published>
    <updated>2017-08-17T03:59:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>面试题：为什么<code>Category</code>中不能动态添加成员变量？</p>
<p>解答：</p>
<p>很多人在面试的时候都会被问到<code>Category</code>，既然允许用<code>Category</code>给类增加方法和属性，那为什么不允许增加成员变量？</p>
<p>在<code>Objective-C</code>提供的<code>runtime</code>函数中，确实有一个<code>class_addIvar()</code>函数用于给类添加成员变量，但是阅读过苹果的官方文档的人应该会看到：</p>
<blockquote>
<p>This function may only be called after objc_allocateClassPair and before objc_registerClassPair. Adding an instance variable to an existing class is not supported.</p>
</blockquote>
<p>大概的意思说，这个函数只能在“构建一个类的过程中”调用。一旦完成类定义，就不能再添加成员变量了。经过编译的类在程序启动后就被<code>runtime</code>加载，没有机会调用<code>addIvar</code>。程序在运行时动态构建的类需要在调用<code>objc_registerClassPair</code>之后才可以被使用，同样没有机会再添加成员变量。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3e956669e49c0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从运行结果中看出，<strong>你不能为一个类动态的添加成员变量，可以给类动态增加方法和属性。</strong></p>
<p><strong>因为方法和属性并不“属于”类实例，而成员变量“属于”类实例。</strong> 我们所说的“类实例”概念，指的是一块内存区域，包含了<code>isa</code>指针和所有的成员变量。所以假如允许动态修改类成员变量布局，已经创建出的类实例就不符合类定义了，变成了无效对象。但方法定义是在<code>objc_class</code>中管理的，不管如何增删类方法，都不影响类实例的内存布局，已经创建出的类实例仍然可正常使用。</p>
<p>同理：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6594de971343a76f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>某一个类的分类是在<code>runTime</code>时，被动态的添加到类的结构中。<br>想了解分类是如何加载的请看<a href="https://sunjinshuai.github.io/2016/09/21/iOS-RunTime%E4%B9%8B%E5%85%AD%EF%BC%9ACategory/">iOS RunTime之六：Category</a></p>
<p>如果有觉得上述我讲的不对的地方欢迎指出，大家多多交流沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题：为什么&lt;code&gt;Category&lt;/code&gt;中不能动态添加成员变量？&lt;/p&gt;
&lt;p&gt;解答：&lt;/p&gt;
&lt;p&gt;很多人在面试的时候都会被问到&lt;code&gt;Category&lt;/code&gt;，既然允许用&lt;code&gt;Category&lt;/code&gt;给类增加方法和属性，那为什么不允
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之四：消息转发</title>
    <link href="https://sunjinshuai.github.io/2016/06/14/iOS-RunTime%E4%B9%8B%E5%9B%9B%EF%BC%9A%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>https://sunjinshuai.github.io/2016/06/14/iOS-RunTime之四：消息转发/</id>
    <published>2016-06-14T12:32:02.000Z</published>
    <updated>2017-08-17T03:54:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>消息发送和消息转发流程可以概括为：</p>
<ul>
<li>消息发送是<code>Runtime</code>通过<code>selector</code>快速查找<code>IMP</code>的过程，有了函数指针就可以执行对应的方法实现；</li>
<li>消息转发是在查找<code>IMP</code>失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。</li>
</ul>
<p>首先，了解一下下面的几个词：</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>一般我们写代码的时候有可能会用到<code>@dynamic</code>，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@dynamic propertyName;</div></pre></td></tr></table></figure></p>
<p>这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成<code>set</code>和<code>get</code>方法，而需要我们动态提供。我们可以通过分别重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现。</p>
<p>因为当<code>Runtime</code>系统在<code>Cache</code>和方法分发表中找不到要执行的方法时，<code>Runtime</code>会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会。</p>
<p>我们需要用<code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</div><div class="line">    // implementation ....</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</div><div class="line">&#123;</div><div class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</div><div class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</div><div class="line">          return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:aSEL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="external">v@:</a>表示每一个方法会默认隐藏两个参数，<code>self</code>、<code>_cmd</code>，<code>self</code>代表方法调用者，<code>_cmd</code>代表这个方法的<code>SEL</code>，签名类型就是用来描述这个方法的返回值、参数的，<code>v</code>代表返回值为<code>void</code>，<code>@</code>表示<code>self</code>，<code>:</code>表示<code>_cmd</code>。</p>
</li>
<li><p>动态方法解析会在消息转发机制浸入前执行。如果<code>respondsToSelector:</code>或<code>instancesRespondToSelector:</code>方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的<code>IMP</code>的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code>返回<code>NO</code>。</p>
</li>
</ul>
<h4 id="self和-cmd"><a href="#self和-cmd" class="headerlink" title="self和_cmd"></a>self和_cmd</h4><p>我们经常在方法中使用<code>self</code>关键字来引用实例本身，但从没有想过为什么<code>self</code>就能取到调用当前方法的对象吧。其实<code>self</code>的内容是在方法运行时被偷偷的动态传入的。</p>
<p>在讲消息发送的时候，我们知道当<code>objc_msgSend</code>找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p>
<ul>
<li>接收消息的对象（也就是<code>self</code>指向的内容）</li>
<li>方法选择器（<code>_cmd</code>指向的内容）</li>
</ul>
<p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在这两个参数中，<code>self</code>更有用。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>而当方法中的<code>super</code>关键字接收到消息时，编译器会创建一个<code>objc_super</code>结构体：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-a6558105047e321a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><strong>这个结构体指明了消息应该被传递给特定超类的定义。</strong><br>但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>接下来，我们要通过一个小例子来简单、通俗的理解一下什么是消息转发以及如何消息转发，希望看完这篇文章时大家会彻底的明白<code>OC</code>的消息。</p>
<p>上一篇<a href="https://sunjinshuai.github.io/2016/09/20/iOS-RunTime%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/">消息发送</a>，我们知道<code>Objective-C</code>语言动态语言。比如<code>Car</code>这个对象里面只声明没有实现函数名为<code>fly</code>的函数，编译器编译的时候会不会通过呢。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-d0dcfa5deda2eb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>通过运行程序，可以看出在语言中<code>Objective-C</code>只声明并且没有实现方法编译器依然能够通过，但是运行期间则会因为获取不到实际执行的方法而抛出异常。</p>
<ul>
<li>动态方法解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel</div></pre></td></tr></table></figure>
<ul>
<li>重定向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div></pre></td></tr></table></figure>
<p>在消息转发机制执行前，<code>Runtime</code>系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    if(aSelector == @selector(mysteriousMethod:))&#123;</div><div class="line">        return alternateObject;</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>转发</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</div><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</div></pre></td></tr></table></figure>
<p>当动态方法解析不作处理返回<code>NO</code>时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行。</p>
<p>该消息的唯一参数是个<code>NSInvocation</code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>这里需要注意的是参数<code>anInvocation</code>是从哪的来的呢？其实在<code>forwardInvocation:</code>消息发送前，<code>Runtime</code>系统会向对象发送<code>methodSignatureForSelector:</code>消息，并取到返回的方法签名用于生成<code>NSInvocation</code>对象。所以我们在重写<code>forwardInvocation:</code>的同时也要重写<code>methodSignatureForSelector:</code>方法，否则会抛异常。</p>
<p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过<code>forwardInvocation:</code>消息通知该对象。每个对象都从<code>NSObject</code>类中继承了<code>forwardInvocation:</code>方法。然而，<code>NSObject</code>中的方法实现只是简单地调用了<code>doesNotRecognizeSelector:</code>。通过实现我们自己的<code>forwardInvocation:</code>方法，我们可以在该方法实现中将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。</p>
<p><code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>注意：<br><code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将<code>negotiate</code>消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9fb706d219d3b412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h4 id="消息转发验证"><a href="#消息转发验证" class="headerlink" title="消息转发验证"></a>消息转发验证</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-d0dcfa5deda2eb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>1、动态解析<br>我们在<code>Car</code>类的<code>.m</code>文件里面，通过上面介绍<strong>动态解析</strong>可以知道，可以重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现。因为当<code>Runtime</code>系统在<code>Cache</code>和方法分发表中找不到要执行的方法时，<code>Runtime</code>会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-99c60c3aca2ed76e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>2、重定向<br>我们新建一个<code>Person</code>类，为了让运行时系统能够运行到<code>forwardingTargetForSelector:</code>方法，我们先在<code>resolveInstanceMethod:</code>中返回<code>NO</code>，代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8bd42146a3282f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4b2354c9f3aee51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从运行结果中看出，我们执行<code>[person fly]</code>方法，控制台中打出<code>Car</code>的<code>run</code>方法，最终也实现了消息的转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person *person = [[Person alloc] init];</div><div class="line">[person fly];</div></pre></td></tr></table></figure>
<p>3、转发<br>如果我们都不实现<code>forwardingTargetForSelector</code>，系统就会方法<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>来实现转发，代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f758b33e20dff7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从运行结果中看出，我们执行<code>[person fly]</code>方法，控制台中打出<code>Car</code>的<code>run</code>方法，最终也实现了消息的转发。</p>
<p>注意：</p>
<ul>
<li><code>methodSignatureForSelector</code>用来生成方法签名，这个签名就是给<code>forwardInvocation</code>中的参数<code>NSInvocation</code>调用的。</li>
<li><code>unrecognized selector sent to instance</code>，原来就是因为<code>methodSignatureForSelector</code>这个方法中，由于没有找到<code>fly</code>对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。</li>
</ul>
<p>以上就是消息的转发，如果有觉得上述我讲的不对的地方欢迎指出，大家多多交流沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息发送和消息转发流程可以概括为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息发送是&lt;code&gt;Runtime&lt;/code&gt;通过&lt;code&gt;selector&lt;/code&gt;快速查找&lt;code&gt;IMP&lt;/code&gt;的过程，有了函数指针就可以执行对应的方法实现；&lt;/li&gt;
&lt;li&gt;消息转发是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之三：消息发送</title>
    <link href="https://sunjinshuai.github.io/2016/06/12/iOS-RunTime%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <id>https://sunjinshuai.github.io/2016/06/12/iOS-RunTime之三：消息发送/</id>
    <published>2016-06-12T12:32:02.000Z</published>
    <updated>2017-08-17T08:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>由上面一章中，我们了解了什么是<a href="https://sunjinshuai.github.io/2016/06/11/iOS-RunTime%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">RunTime的数据结构</a>，下面了解一下<code>Runtime</code>的消息发送。</p>
<p>我们知道<code>[object doSomething]</code>被编译器转化为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend(id self, SEL op, ...) &#123;</div><div class="line">    if (!self) return nil;</div><div class="line">	IMP imp = class_getMethodImplementation(self-&gt;isa, SEL op);</div><div class="line">	imp(self, op, ...); //调用这个函数，伪代码...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 查找IMP</div><div class="line">IMP class_getMethodImplementation(Class cls, SEL sel) &#123;</div><div class="line">    if (!cls || !sel) return nil;</div><div class="line">    IMP imp = lookUpImpOrNil(cls, sel);</div><div class="line">    if (!imp) return _objc_msgForward; //这个是用于消息转发的</div><div class="line">    return imp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">IMP lookUpImpOrNil(Class cls, SEL sel) &#123;</div><div class="line">    if (!cls-&gt;initialize()) &#123;</div><div class="line">        _class_initialize(cls);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Class curClass = cls;</div><div class="line">    IMP imp = nil;</div><div class="line">    do &#123; //先查缓存,缓存没有时重建,仍旧没有则向父类查询</div><div class="line">        if (!curClass) break;</div><div class="line">        if (!curClass-&gt;cache) fill_cache(cls, curClass);</div><div class="line">        imp = cache_getImp(curClass, sel);</div><div class="line">        if (imp) break;</div><div class="line">    &#125; while (curClass = curClass-&gt;superclass);</div><div class="line"></div><div class="line">    return imp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Objective-C</code>中，消息直到运行时才会绑定到方法的实现上。编译器会把代码中<code>[object doSomething]</code>转换成<code>objc_msgSend</code>消息函数，这个函数完成了动态绑定的所有事情，它的运行流程如下:</p>
<ul>
<li>检查<code>selector</code>是否需要忽略。</li>
<li>检查<code>target</code>是否为<code>nil</code>。如果为<code>nil</code>，直接<code>cleanup</code>，然后<code>return</code>。(这就是我们可以向<code>nil</code>发送消息的原因。)</li>
<li>然后在<code>target</code>的<code>Class</code>中根据<code>Selector</code>去找<code>IMP</code>。</li>
</ul>
<p>寻找<code>IMP</code>的过程:</p>
<ul>
<li>先从当前<code>class</code>的<code>cache</code>方法列表（<code>cache methodLists</code>）里去找。</li>
<li>如果找到了，跳到对应函数实现。</li>
<li>如果没找到，就从<code>class</code>的方法列表（<code>methodLists</code>）里找。</li>
<li>如果还找不到，就到<code>super class</code>的方法列表里找，直到找到基类（<code>NSObject</code>）为止。</li>
<li>最后再找不到，就会进入动态方法解析和消息转发的机制。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-695c1539e166418f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意:</p>
<ul>
<li>这里说的分发表其实就是<code>Class</code>中的方法列表，它将方法选择器和方法实现地质联系起来。</li>
<li>消息的发送其实就是先确定<code>object</code>接受者对象，然后根据<code>isa</code>指针查找其方法然后跳转过去并执行。</li>
<li>但是编译期间，是无法确定<code>object</code>接受者对象。<strong>只有在程序运行期间，<code>object</code>接受者对象才能得到确定</strong>。这种在运行期间才确定<code>object</code>接受者对象，<code>Objective-C</code>称为动态绑定。</li>
<li>消息发送这种工作机制明显区别另一著名面向对象编程语言——<code>C++</code>或者<code>Java</code>。<code>C++</code>或者<code>Java</code>调用对象的函数，<strong>函数与对象之间的关系，在编译期间就必须严格确定</strong>。比如<code>Car</code>这个对象里面没有定义函数名为<code>fly</code>的函数，编译器不会通过，而是会报错。<code>Objective-C</code>如果向<code>Car</code>这个对象发送字符串为<code>fly</code>的<code>selector</code>，即使<code>car</code>没有实现<code>fly</code>方法，编译器依然能够通过，但是运行期间则会因为获取不到实际执行的方法而抛出异常。</li>
<li>消息发送的设计使得编译期间<code>Objective-C</code>非常包容对象所属的类。在<code>Objective-C</code>语言中你可以向任何包括空指针<code>nil</code>在内的对象发你想发的消息。</li>
<li>消息发送的机制使得在不重新编译的情况下，<strong>在运行期间，干预或者说<code>hook</code>原来的<code>target</code>（方法、变量等）变得更易于实现，更有实际应用价值</strong>，这个是需要依赖于消息发送和动态绑定的实现机制——<code>Runtime</code>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由上面一章中，我们了解了什么是&lt;a href=&quot;https://sunjinshuai.github.io/2016/06/11/iOS-RunTime%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之二：数据结构</title>
    <link href="https://sunjinshuai.github.io/2016/06/11/iOS-RunTime%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://sunjinshuai.github.io/2016/06/11/iOS-RunTime之二：数据结构/</id>
    <published>2016-06-11T14:56:47.000Z</published>
    <updated>2017-08-17T02:20:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>由上面一章中,我们了解了什么是<a href="https://sunjinshuai.github.io/2016/06/10/iOS-RunTime%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%AE%80%E4%BB%8B/">RunTime</a>，<code>RunTime</code>用来做什么，下面了解一下<code>Runtime</code>数据结构。</p>
<p>我们知道在<code>Objective-C</code>中，使用<code>[object doSomething]</code>语法并不会马上执行<code>object</code>接受者对象的<code>doSomething</code>方法的代码，而是向<code>object</code>接受者对发送一条<code>doSomething</code>消息，这条消息可能由<code>object</code>接受者对来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。</p>
<p>其实<code>[object doSomething]</code>被编译器转化为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id objc_msgSend ( id self, SEL op, ... );</div></pre></td></tr></table></figure>
<p>下面从两个数据结构<code>id</code>和<code>SEL</code>来逐步分析和理解<code>Runtime</code>有哪些重要的数据结构。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a><strong>id</strong></h4><p><code>objc_msgSend</code>方法里面的第一个参数的数据类型<code>id</code>，通用类型指针，能够表示任何对象。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f1fa24b64e56b099.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>查看源文件，可以看出<code>id</code>其实就是一个指向<code>objc_object</code>结构体指针，它包含一个<code>Class isa</code>成员，根据<code>Class isa</code>指针就可以找到对象所属的类。</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a><strong>Class</strong></h4><p>从源文件看出，<code>Objective-C</code>的对象就是一个包含<code>isa</code>指针的数据结构，而<code>isa</code>指针的数据类型是<code>Class</code>，<code>Class</code>表示对象所属的类。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b56425997d122083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从源文件看出，<code>Class</code>其实就是一个<code>objc_class</code>结构体指针。<code>objc_class</code>结构体定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">isa：在Objective-C中，所有的类自身也是一个对象，即类对象。在这个类对象里面也有一个isa指针，它指向metaClass(元类)。</div><div class="line">super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject)，则super_class为NULL。</div><div class="line">name：这个类的类名。</div><div class="line">version：提供类的版本信息，这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</div><div class="line">info：类信息，供运行期使用的一些位标识。</div><div class="line">instance_size：该类的实例变量大小。</div><div class="line">ivars：该类的成员变量链表。</div><div class="line">methodLists：方法定义的链表。</div><div class="line">protocols：协议链表。</div><div class="line">cache：一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>在面向对象设计中，一切都是对象，<code>Class</code>在设计中本身也是一个对象。</li>
<li>由此可见，结构体<code>objc_class</code>也是继承<code>objc_object</code>，说明<code>Class</code>在设计中本身也是一个对象。</li>
</ul>
<h4 id="元类（Meta-Class）"><a href="#元类（Meta-Class）" class="headerlink" title="元类（Meta Class）"></a><strong>元类（Meta Class）</strong></h4><p>在<code>Objective-C</code>中，所有的类自身也是一个对象，这个对象里面也有一个<code>isa</code>指针，它指向<code>metaClass</code>(元类)，向这个对象发送消息（即调用类方法）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-05d97aac774b34a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从图中看出：</p>
<ul>
<li>当我们向一个对象发送消息时，<code>isa</code>指针会在这个对象所属的这个类的方法列表中查找方法；</li>
<li>向一个类发送消息时，<code>isa</code>指针会在这个类的<code>meta-class</code>的方法列表中查找。<code>meta-class</code>之所以重要，是因为它存储着一个类的所有类方法。</li>
<li>每个类都会有一个单独的<code>meta-class</code>，因为每个类的类方法基本不可能完全相同。</li>
</ul>
<blockquote>
<p>Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己，这样就形成了一个完美的闭环。</p>
</blockquote>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><strong>SEL</strong></h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在<code>Objc</code>中的表示类型（<code>Swift</code>中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的<code>id</code>，而这个<code>id</code>的数据结构是<code>SEL</code>，即表示一个方法的<code>selector</code>的指针。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f1c54b79137a3a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>方法的<code>selector</code>用于表示运行时方法的名字，<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>int</code>类型的地址)，这个标识就是<code>SEL</code>。</li>
<li>在<code>Objective-C</code>中，只要方法名相同，那么方法的<code>SEL</code>就是一样的，每一个方法都对应着一个<code>SEL</code>，所以在<code>Objective-C</code>中，同一个类中或者这个类的继承体系中，不能存在2个同名的方法，不同的类可以拥有相同的<code>selector</code>，不同的类的实例对象执行相同的<code>selector</code>，会在各自的方法列表中根据<code>selector</code>去寻找对应的<code>IMP</code>。</li>
<li>在本质上，<code>SEL</code>只是一个指向方法的指针（被<code>hash</code>化得<code>KEY</code>值），能提高方法的查询速度。</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><strong>IMP</strong></h4><p><code>IMP</code>就是<code>implementation</code>的缩写，本质就是一个函数指针，这个被指向的函数包含一个接收消息的对象<code>id</code>，调用方法的<code>SEL</code>，以及一些方法参数，并返回一个<code>id</code>。因此我们可以通过<code>SEL</code>获得它所对应的<code>IMP</code>，在取得了函数指针之后，也就意味着我们取得了需要执行方法的代码入口，这样我们就可以像普通的<code>C</code>语言函数调用一样使用这个函数指针。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-36d603b62e4690d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的，由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><strong>Method</strong></h4><p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c75430d85b645678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-382fc04a120fc065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意：</p>
<ul>
<li>方法名类型为<code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li>
<li>方法类型<code>method_types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>
<li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针。</li>
</ul>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a><strong>Ivar</strong></h4><p><code>Ivar</code>是一种代表类中实例变量的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-dcb54cf3c9cc43ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4f01a318d7041fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a><strong>Cache</strong></h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-72e7a54f147a8948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><strong><code>Cache</code>其实就是一个存储<code>Method</code>的链表，主要是为了优化方法调用的性能。</strong></p>
<p>当对象<code>receiver</code>调用方法<code>message</code>时，首先根据对象<code>receiver</code>的<code>isa</code>指针查找到它对应的类，然后在类的<code>methodLists</code>中搜索方法，如果没有找到，就使用<code>super_class</code>指针到父类中的<code>methodLists</code>查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用<code>Cache</code>来缓存经常调用的方法，当调用方法时，优先在<code>Cache</code>查找，如果没有找到，再到<code>methodLists</code>查找。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由上面一章中,我们了解了什么是&lt;a href=&quot;https://sunjinshuai.github.io/2016/06/10/iOS-RunTime%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%AE%80%E4%BB%8B/&quot;&gt;RunTime&lt;/a&gt;，&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
