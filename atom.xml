<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2018-08-25T03:10:44.342Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动实现 KVO</title>
    <link href="https://sunjinshuai.github.io/2018/08/25/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0-KVO/"/>
    <id>https://sunjinshuai.github.io/2018/08/25/手动实现-KVO/</id>
    <published>2018-08-25T03:10:20.000Z</published>
    <updated>2018-08-25T03:10:44.342Z</updated>
    
    <content type="html"><![CDATA[<p><code>KVO</code> 全称 <code>KeyValueObserving</code> 是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，指定一个被观察对象，当被观察对象的某个属性发生更改时，监听对象会获得通知，并作出相应处理；</p>
<p>在 <code>MVC</code> 设计架构下的项目，<code>KVO</code> 机制很适合实现 <code>Mode</code> 模型和 <code>View</code> 视图之间的通讯。</p>
<p><code>KVO</code> 和通知都是 <code>iOS</code> 中观察者模式的一种实现；<br>区别在于，相对于被观察者和观察者之间的关系，<code>KVO</code> 是一对一的，而通知一对多的。</p>
<h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul>
<li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li>
<li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li>
<li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li>
</ul>
<p><code>KVO</code> 的实现也依赖于 <code>Objective-C</code> 强大的 <code>Runtime</code> ，<code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>
</blockquote>
<h4 id="简单概述下-KVO-的实现："><a href="#简单概述下-KVO-的实现：" class="headerlink" title="简单概述下 KVO 的实现："></a>简单概述下 <code>KVO</code> 的实现：</h4><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。自然，重写的 <code>setter</code> 方法会负责在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针 ( <code>isa</code> 指针告诉 <code>Runtime</code> 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例，被观察对象的 <code>isa</code> 指针会指向一个中间类，而不是原来真正的类。</p>
<h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a><code>KVO</code> 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface TestKVOViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) Message *message;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestKVOViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor whiteColor];</div><div class="line">    </div><div class="line">    Message *message = [[Message alloc] init];</div><div class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div><div class="line">    </div><div class="line">    message.text = @&quot;hello object-c&quot;;</div><div class="line">    self.message = message;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, change);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</div><div class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</div><div class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">	0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</div><div class="line">	1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</div><div class="line">	2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</div><div class="line">	3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</div><div class="line">	4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</div><div class="line">	5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</div><div class="line">	6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</div><div class="line">	7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</div><div class="line">	8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</div><div class="line">	9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</div><div class="line">	10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</div><div class="line">	11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</div><div class="line">	12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</div><div class="line">	13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</div><div class="line">	14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</div><div class="line">	15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</div><div class="line">	16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</div><div class="line">	17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</div><div class="line">	18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</div><div class="line">	19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</div><div class="line">	20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</div><div class="line">	21  ImplementKVO                        0x000000010dd2dfef main + 111</div><div class="line">	22  libdyld.dylib                       0x00000001129fe955 start + 1</div><div class="line">	23  ???                                 0x0000000000000001 0x0 + 1</div><div class="line">)</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div></pre></td></tr></table></figure>
<h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</div><div class="line"></div><div class="line">@interface NSObject (KVO)</div><div class="line"></div><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">forKey:(NSString *)key</div><div class="line">withBlock:(ObservingBlock)block;</div><div class="line"></div><div class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p>
<ul>
<li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li>
<li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li>
<li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li>
<li>添加这个观察者；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</div><div class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</div><div class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</div><div class="line"> 4. 将调用对象添加到数组中。</div><div class="line"> */</div><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">             forKey:(NSString *)key</div><div class="line">          withBlock:(ObservingBlock)block &#123;</div><div class="line">    </div><div class="line">    SEL setterSelector = NSSelectorFromString(setterForGetter(key));</div><div class="line">    Method setterMethod = class_getInstanceMethod([self class], setterSelector);</div><div class="line">    if (!setterMethod) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Class clazz = object_getClass(self);</div><div class="line">    NSString *clazzName = NSStringFromClass(clazz);</div><div class="line">    </div><div class="line">    // if not an KVO class yet</div><div class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</div><div class="line">        clazz = [self makeKvoClassWithOriginalClassName:clazzName];</div><div class="line">        object_setClass(self, clazz);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // add our kvo setter if this class (not superclasses) doesn&apos;t implement the setter?</div><div class="line">    if (![self hasSelector:setterSelector]) &#123;</div><div class="line">        const char *types = method_getTypeEncoding(setterMethod);</div><div class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ObservationInfo *info = [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</div><div class="line">    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</div><div class="line">    if (!observers) &#123;</div><div class="line">        observers = [NSMutableArray array];</div><div class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    [observers addObject:info];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p>
<p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 1. 判断是否存在KVO类，如果存在则返回。</div><div class="line"> 2. 如果不存在，则创建KVO类。</div><div class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</div><div class="line"> */</div><div class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</div><div class="line">    NSString *kvoClazzName = [kKVOClassPrefix stringByAppendingString:originalClazzName];</div><div class="line">    Class clazz = NSClassFromString(kvoClazzName);</div><div class="line">    </div><div class="line">    if (clazz) &#123;</div><div class="line">        return clazz;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // class doesn&apos;t exist yet, make it</div><div class="line">    Class originalClazz = object_getClass(self);</div><div class="line">    Class kvoClazz = objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</div><div class="line">    </div><div class="line">    // grab class method&apos;s signature so we can borrow it</div><div class="line">    Method clazzMethod = class_getInstanceMethod(originalClazz, @selector(class));</div><div class="line">    const char *types = method_getTypeEncoding(clazzMethod);</div><div class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</div><div class="line">    </div><div class="line">    objc_registerClassPair(kvoClazz);</div><div class="line">    </div><div class="line">    return kvoClazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p>
<p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</div><div class="line">    NSString *setterName = NSStringFromSelector(_cmd);</div><div class="line">    NSString *getterName = getterForSetter(setterName);</div><div class="line">    </div><div class="line">    if (!getterName) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id oldValue = [self valueForKey:getterName];</div><div class="line">    </div><div class="line">    struct objc_super superclazz = &#123;</div><div class="line">        .receiver = self,</div><div class="line">        .super_class = class_getSuperclass(object_getClass(self))</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    // cast our pointer so the compiler won&apos;t complain</div><div class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;</div><div class="line">    </div><div class="line">    // call super&apos;s setter, which is original class&apos;s setter method</div><div class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</div><div class="line">    </div><div class="line">    // look up observers and call the blocks</div><div class="line">    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</div><div class="line">    for (ObservationInfo *each in observers) &#123;</div><div class="line">        if ([each.key isEqualToString:getterName]) &#123;</div><div class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                each.block(self, getterName, oldValue, newValue);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p>
<p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface ObservationInfo : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) NSObject *observer;</div><div class="line">@property (nonatomic, copy) NSString *key;</div><div class="line">@property (nonatomic, copy) ObservingBlock block;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ObservationInfo</div><div class="line"></div><div class="line">- (instancetype)initWithObserver:(NSObject *)observer</div><div class="line">                             Key:(NSString *)key</div><div class="line">                           block:(ObservingBlock)block &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _observer = observer;</div><div class="line">        _key = key;</div><div class="line">        _block = block;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 全称 &lt;code&gt;KeyValueObserving&lt;/code&gt; 是 &lt;code&gt;Objective-C&lt;/code&gt; 对观察者模式&lt;code&gt;(Observer Pattern)&lt;/code&gt;的实现；&lt;code&gt;KVO&lt;/code&gt; 提
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈 Autolayout</title>
    <link href="https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/"/>
    <id>https://sunjinshuai.github.io/2017/12/18/谈谈 Autolayout/</id>
    <published>2017-12-18T14:16:11.000Z</published>
    <updated>2018-08-25T02:51:53.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Unable to simultaneously satisfy constraints.</div><div class="line">Probably at least one of the constraints in the following list is one you don&apos;t want.</div><div class="line">Try this:</div><div class="line"></div><div class="line">(1) look at each constraint and try to figure out which you don&apos;t expect;</div><div class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</div><div class="line">(Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(...........)</div><div class="line"></div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure></p>
<p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p>
<p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p>
<ul>
<li>打开断点导航（cmd+7）</li>
<li>点击左下角的+按钮</li>
<li>选择Add Symbolic Breakpoint</li>
<li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p>
<p>所以交给你一个小技巧，添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">po [[UIWindow keyWindow] _autolayoutTrace] // OC项目</div><div class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] // Swift项目</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样就可以直接看到输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</div><div class="line">UIWindow:0x7f9481c93360</div><div class="line">|   •UIView:0x7f9481c9d680</div><div class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</div><div class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</div><div class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</div></pre></td></tr></table></figure></p>
<p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p>
<p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) po 0x7f9481c9d990</div><div class="line">&lt;UIView: 0x7f9481c9d990; frame = (0 0; 768 359); autoresize = RM+BM; layer = &lt;CALayer: 0x7fc82d338960&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>改变颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor = [UIColor redColor]</div><div class="line">(UICachedDeviceRGBColor *) $4 = 0x0000000174469cc0</div></pre></td></tr></table></figure></p>
<p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p>
<h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p>
<ul>
<li>layoutSubViews：</li>
</ul>
<p>当 <code>View</code> 及其所有子视图的 <code>frame</code> 发生改变的时候，会调用 <code>layoutSubviews</code>，所以在需要更新 frame 来重新定位或更改大小时重载它。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。注意：<strong>最好不要在代码中手动调用 <code>layoutSubviews</code> 方法</strong>。当 <code>layoutSubviews</code> 完成后，在 <code>view</code> 的所有者 <code>view controller</code> 上，会触发  <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 <code>view</code> 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。</p>
<p>触发 <code>layoutSubviews</code> 的时机：</p>
<ul>
<li><code>addSubview</code> 方法会触发 <code>layoutSubviews</code>。</li>
<li>当 <code>view</code> 的 <code>Frame</code> 发生变化也会触发<code>layoutSubviews</code>。</li>
<li>滚动一个 <code>UIScrollView</code> 会触发 <code>layoutSubviews</code>。</li>
<li>旋转屏幕会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</li>
<li><p>改变一个 <code>View</code> 大小的时候也会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p>
</li>
<li><p>setNeedsLayout<br>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法，表示视图的布局需要重新计算。告知页面需要更新，但是不会立刻开始更新视图，视图会在下一个 <code>runloop</code> 中更新，调用 <code>setNeedsLaylout</code> 方法视图被重新绘制并布局之间会有一段任意时间的间隔。</p>
</li>
<li><p>layoutIfNeeded<br>调用 <code>layoutIfNeeded</code> 会触发 <code>layoutSubviews</code>，告知页面布局立刻更新，所以一般都会和 <code>setNeedsLayout</code> 一起使用。如果希望立刻生成新的 <code>frame</code> 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p>
</li>
<li><p>setNeedsUpdateConstraints<br>告知需要更新约束，但是不会立刻开始，在下一次 <code>runloop</code> 中更新约束，通过标记 <code>update constraints</code> 来触发 <code>updateConstraints</code>。</p>
</li>
<li><p>updateConstraintsIfNeeded<br>告知立刻更新约束，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 <code>update constraints</code> 标记。如果认为这些约束需要被更新，它会立即触发 <code>updateConstraints</code>，而不会等到 <code>run loop</code> 的末尾。</p>
</li>
<li><p>updateConstraints<br>系统更新约束，注意：<strong>最好不要在代码中手动调用 <code>updateConstraints</code> 方法</strong>。通常在 <code>updateConstraints</code> 方法中实现必须要更新的约束，在设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 <code>update constarints</code>，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。</p>
</li>
</ul>
<p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p>
<h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.bounds = CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</div></pre></td></tr></table></figure></p>
<p>那么很可能拿到 layer 的宽度是0。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">UIView *redView = [[UIView alloc] init];</div><div class="line">redView.backgroundColor = [UIColor redColor];</div><div class="line">[self.view addSubview:redView];</div><div class="line">self.redView = redView;</div><div class="line">    </div><div class="line">// 设置约束</div><div class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">  make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">  make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame = (0 0; 0 0); layer = &lt;CALayer: 0x6040002274a0&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p>
<p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p>
<p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLayoutSubviews &#123;</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">    </div><div class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame = (132 328; 150 80); layer = &lt;CALayer: 0x60000003c460&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">    [redView setNeedsLayout];</div><div class="line">    [redView layoutIfNeeded];</div><div class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">&#125;</div><div class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame = (-75 -40; 150 80); layer = &lt;CALayer: 0x6040004207a0&gt;&gt;</div></pre></td></tr></table></figure>
<p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">   </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame = (132 328; 150 80); layer = &lt;CALayer: 0x600000233540&gt;&gt;</div></pre></td></tr></table></figure>
<p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关于Autolayout的调试&quot;&gt;&lt;a href=&quot;#关于Autolayout的调试&quot; class=&quot;headerlink&quot; title=&quot;关于Autolayout的调试&quot;&gt;&lt;/a&gt;关于Autolayout的调试&lt;/h4&gt;&lt;p&gt;刚开始使用 Autolayout 遇
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac安装Jenkins系列/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:37:01.651Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="external">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>持续的软件版本发布/测试项目。</li>
<li>监控外部调用执行的工作。</li>
</ul>
<p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="external">Jenkins官网</a>下载Jenkins；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击Download：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p>
<p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a></p>
<ul>
<li>在Safari浏览器上，会出现Safari不能连接到服务器。</li>
<li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li>
</ul>
<p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="external">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以通过下面两种方式获取初始化密码：</p>
<ul>
<li>打开terminal，执行cat命令即可(需要管理员权限)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>输入用户名和密码之后，Jenkins就彻底安装好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p>
<h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Application Support/Jenkins/Uninstall.command</div></pre></td></tr></table></figure>
<h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist    </div><div class="line">sudo rm !$    </div><div class="line">sudo rm -rf /Applications/Jenkins &quot;/Library/Application Support/Jenkins&quot; /Library/Documentation/Jenkins    </div><div class="line">sudo rm -rf /Users/Shared/Jenkins    </div><div class="line"># if you want to get rid of all the jobs and builds:    </div><div class="line">sudo dscl . -delete /Users/jenkins    </div><div class="line"># delete the jenkins user and group (if you chose to use them):    </div><div class="line">sudo dscl . -delete /Groups/jenkins</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App的生命周期</title>
    <link href="https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://sunjinshuai.github.io/2017/11/18/App的生命周期/</id>
    <published>2017-11-17T16:02:28.000Z</published>
    <updated>2018-08-25T02:52:55.604Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS程序的启动执行顺序"><a href="#iOS程序的启动执行顺序" class="headerlink" title="iOS程序的启动执行顺序"></a>iOS程序的启动执行顺序</h4><p>程序启动顺序图<br><img src="http://upload-images.jianshu.io/upload_images/588630-5837771421fe9e63?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS启动原理图"></p>
<p>具体执行流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);//__func__打印方法名</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</div><div class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</div><div class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</div><div class="line">  NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123;</div><div class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动 <code>APP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:] </div><div class="line">-[AppDelegate applicationDidBecomeActive:]</div></pre></td></tr></table></figure></p>
<p>按下 <code>Home</code> 键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationWillResignActive:]</div><div class="line">-[AppDelegate applicationDidEnterBackground:]</div></pre></td></tr></table></figure></p>
<p>返回 <code>APP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationWillEnterForeground:]</div><div class="line">-[AppDelegate applicationDidBecomeActive:]</div></pre></td></tr></table></figure></p>
<p>内存警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationDidReceiveMemoryWarning:]</div></pre></td></tr></table></figure></p>
<p>注意：<br><code>application:didFinishLaunchingWithOptions:</code>： <code>App</code> 首次启动时调用，一般在这个函数里创建 <code>window</code> 对象，初始化 <code>App</code> 可能用到的第三方 <code>SDK</code> 等。<br><code>applicationWillResignActive:</code>：<code>App</code> 将要进入后台时调用，比如有电话进来或者按下 <code>Home</code> 键。<br>该函数里面主要执行操作:</p>
<ul>
<li>暂停正在执行的任务</li>
<li>停止计时器</li>
<li>减少OpenGL ES帧率</li>
</ul>
<p><code>applicationDidEnterBackground:</code>：<code>App</code> 已经进入后台，一般该方法用来:</p>
<ul>
<li>释放共享资源</li>
<li>保存用户数据(写到硬盘)</li>
<li>销毁计时器</li>
</ul>
<p><code>applicationWillEnterForeground:</code>：<code>App</code> 即将进入前台，一般该方法用来撤销 <code>applicationWillResignActive:</code> 中做的改变。<br><code>applicationDidBecomeActive:</code>：<code>App</code> 已经进入前台，若 <code>App</code> 之前在后台，在此方法内刷新用户界面。</p>
<h4 id="UIViewController-的生命周期"><a href="#UIViewController-的生命周期" class="headerlink" title="UIViewController 的生命周期"></a><code>UIViewController</code> 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">// 非storyBoard(xib或非xib)都走这个方法</div><div class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// storyBoard走这个方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// xib 加载 完成</div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 加载视图(默认从nib)</div><div class="line">- (void)loadView &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">    self.view.backgroundColor = [UIColor redColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图控制器中的视图加载完成，viewController自带的view加载完成</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidLoad];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图将要出现</div><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// view 即将布局其 Subviews</div><div class="line">- (void)viewWillLayoutSubviews &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillLayoutSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// view 已经布局其 Subviews</div><div class="line">- (void)viewDidLayoutSubviews &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图已经出现</div><div class="line">- (void)viewDidAppear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图将要消失</div><div class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图已经消失</div><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 出现内存警告 </div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图被销毁</div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析 </p>
<ul>
<li><p><code>initWithNibName:bundle:</code><br>初始化<code>UIViewController</code>，执行关键数据初始化操作，非<code>StoryBoard</code>创建<code>UIViewController</code>都会调用这个方法。<br><strong>注意: 不要在这里做<code>View</code>相关操作，<code>View</code>在<code>loadView</code>方法中才初始化。</strong></p>
</li>
<li><p><code>initWithCoder:</code><br>如果使用<code>StoryBoard</code>进行视图管理，程序不会直接初始化一个<code>UIViewController</code>，<code>StoryBoard</code>会自动初始化或在<code>segue</code>被触发时自动初始化，因此方法<code>initWithNibName:bundle</code>不会被调用，但是<code>initWithCoder</code>会被调用。</p>
</li>
<li><p><code>awakeFromNib</code><br>当<code>awakeFromNib</code>方法被调用时，所有视图的<code>outlet</code>和<code>action</code>已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在<code>storyBoard</code>或<code>xib</code>中，所以可以在<code>awakeFromNib</code>方法中被加载进来。</p>
</li>
<li><p><code>loadView</code><br>当执行到<code>loadView</code>方法时，如果视图控制器是通过<code>nib</code>创建，那么视图控制器已经从<code>nib</code>文件中被解档并创建好了，接下来任务就是对<code>view</code>进行初始化。<br><code>loadView</code>方法在<code>UIViewController</code>对象的<code>view</code>被访问且为空的时候调用。这是它与<code>awakeFromNib</code>方法的一个区别。<br>假设我们在处理内存警告时释放<code>view</code>属性：<code>self.view = nil</code>。因此<code>loadView</code>方法在视图控制器的生命周期内可能被调用多次。<br><code>loadView</code>方法不应该直接被调用，而是由系统调用，它会加载或创建一个<code>view</code>并把它赋值给<code>UIViewController</code>的<code>view</code>属性。<br>在创建<code>view</code>的过程中，首先会根据<code>nibName</code>去找对应的<code>nib</code>文件然后加载。如果<code>nibName</code>为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码)<br><strong>注意:在重写loadView方法的时候，不要调用父类的方法。</strong></p>
</li>
<li><p><code>viewDidLoad</code><br>当<code>loadView</code>将<code>view</code>载入内存中，会进一步调用<code>viewDidLoad</code>方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。</p>
</li>
<li><p><code>viewWillAppear</code><br>系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。<br>另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。</p>
</li>
<li><p><code>viewWillLayoutSubviews</code><br><code>view</code>即将布局其<code>Subviews</code>。 比如<code>view</code>的<code>bounds</code>改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整<code>Subviews</code>的位置，在调整之前要做的工作可以放在该方法中实现</p>
</li>
<li><p><code>viewDidLayoutSubviews</code><br><code>view</code>已经布局其<code>Subviews</code>，这里可以放置调整完成之后需要做的工作。</p>
</li>
<li><p><code>viewDidAppear</code><br>在<code>view</code>被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。</p>
</li>
<li><p><code>viewWillDisappear</code><br>在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用<code>removeFromSuperview</code>。</p>
</li>
<li><p><code>viewDidDisappear</code><br><code>view</code>已经消失或被覆盖，此时已经调用<code>removeFromSuperView</code>;</p>
</li>
<li><p><code>dealloc</code><br>视图被销毁，此次需要对你在<code>init</code>和<code>viewDidLoad</code>中创建的对象进行释放。</p>
</li>
<li><p><code>didReceiveMemoryWarning</code><br>在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。</p>
</li>
</ul>
<h4 id="UIView-的生命周期"><a href="#UIView-的生命周期" class="headerlink" title="UIView 的生命周期"></a>UIView 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过代码创建控件就会调用这个方法</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</div><div class="line">    if (self = [super initWithFrame:frame]) &#123;</div><div class="line">        NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过storyboared或者xib中创建控件就会调用这个方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line">        NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果在initWithFrame中添加子视图会调用两次</div><div class="line">- (void)layoutSubviews &#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didAddSubview:(UIView *)subview &#123;</div><div class="line">    [super didAddSubview:subview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)willRemoveSubview:(UIView *)subview &#123;</div><div class="line">    [super willRemoveSubview:subview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview &#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didMoveToSuperview &#123;</div><div class="line">    [super didMoveToSuperview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow &#123;</div><div class="line">    [super willMoveToWindow:newWindow];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didMoveToWindow &#123;</div><div class="line">    [super didMoveToWindow];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFromSuperview &#123;</div><div class="line">    [super removeFromSuperview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>view</code> 创建时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View initWithFrame:]</div><div class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View init]</div><div class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:35:12.353483+0800 iOSLife[7587:2353869] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:35:12.353644+0800 iOSLife[7587:2353869] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:35:12.363861+0800 iOSLife[7587:2353869] -[View layoutSubviews]</div></pre></td></tr></table></figure>
<p>当 <code>view</code> 销毁时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:41:28.152448+0800 iOSLife[7607:2356750] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:41:28.152693+0800 iOSLife[7607:2356750] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:41:28.155160+0800 iOSLife[7607:2356750] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:41:28.155281+0800 iOSLife[7607:2356750] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:41:28.155336+0800 iOSLife[7607:2356750] -[View removeFromSuperview]</div><div class="line">2017-11-06 10:41:28.155399+0800 iOSLife[7607:2356750] -[View dealloc]</div></pre></td></tr></table></figure>
<p>注意：<br>可以看出上面方法中只会执行一次的方法有 <code>removeFromSuperview</code>、<code>dealloc</code> 两个方法，<code>layoutSubviews</code> 在子视图布局变动时会多次调用，所以可以在 <code>removeFromSuperview</code>、<code>dealloc</code> 这两个方法中执行释放内存等操作，比如移除观察者，定时器等。</p>
<p>给 <code>view</code> 添加子视图时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View initWithFrame:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View init]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView initWithFrame:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView init]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didAddSubview:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView layoutSubviews]</div></pre></td></tr></table></figure>
<p>注意：<code>didAddSubview:</code> 和 <code>willRemoveSubview:</code> 需要有子视图才能执行。</p>
<p>此时再销毁该 <code>view</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View removeFromSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View dealloc]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willRemoveSubview:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView removeFromSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView dealloc]</div></pre></td></tr></table></figure>
<p><code>willRemoveSubview</code> 是在 <code>dealloc</code> 后面执行的。如果有多个子视图，<code>willRemoveSubview</code> 会循环执行，直到移除所有子视图。</p>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview;</div><div class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow;</div></pre></td></tr></table></figure></p>
<p>这俩个方法可以根据参数判断，<code>nil</code> 则为销毁，否则为创建；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)didMoveToSuperview;</div><div class="line">- (void)didMoveToWindow;</div></pre></td></tr></table></figure></p>
<p>这个方法可以根据 <code>self.superview</code> 判断，<code>nil</code> 则为销毁，否则为创建。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;a href=&quot;#iOS程序的启动执行顺序&quot; class=&quot;headerlink&quot; title=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;/a&gt;iOS程序的启动执行顺序&lt;/h4&gt;&lt;p&gt;程序启动顺序图&lt;br&gt;&lt;img src=&quot;http://up
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之iconfont实战</title>
    <link href="https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2017/08/08/iOS之iconfont实战/</id>
    <published>2017-08-08T07:45:34.000Z</published>
    <updated>2017-08-08T08:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了<code>APP Slicing</code>功能，我司项目在itunes store下载的IPA体积大约在44M。</p>
<p>把我司iPA解压之后里面的<code>Assert.car</code>资源包的体积大约在22.1M，使用软件导出内部的资源文件发现3X系列的图片大小约为13.1M，2X系列的图片大小约为9.4M，两份加起来大于22.1M，所以可以看出我们的图片还是有很大的优化空间的。</p>
<p><a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>技术的主要目的是为减少应用体积而生。首先<code>icon</code>代表图标<code>font</code>代表字体。此技术便是将图标转化为字体，从而达到减小应用体积的目的(这样避免了@2X图和@3X图的使用，只需要一个字体图标就可搞定)。如需在项目中使用iconfont技术，图标矢量图一开始都应合并转化为字体库，只需要在项目中引入字体库就可以了。</p>
<p>优点:</p>
<ul>
<li>减小应用体积，字体文件比图片要小；</li>
<li>图标保真缩放，解决2x/3x乃至将来nx图问题；</li>
<li>方便更改图标颜色大小，图片复用；</li>
<li>一套图标资源可以在不用平台上使用(android、iOS、web)；</li>
</ul>
<p>缺点:</p>
<ul>
<li>只适用于纯色的icon；</li>
</ul>
<h4 id="iconfont实战"><a href="#iconfont实战" class="headerlink" title="iconfont实战"></a>iconfont实战</h4><ul>
<li><p>获取<code>.ttf</code>文件<br>登录<a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>，创建一个项目，设计师做好图标，把<code>.ttf</code>文件下载下来。<br>iconfont中的图标是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/588630-fff854d89142120b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>字体注册<br>iOS中使用自定义字体，将字体加入项目后，还需要注册字体。<br>注册的方式有两种：<br>－ 在Info.plist中声明”Fonts provided by application”</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b6a5790bed65a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>－ 调用API来注册。考虑到需要支持独立版和插件版，调用API注册更加方便。字体注册和获取的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)registerFontWithURL:(NSURL *)url &#123;</div><div class="line">    NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&apos;t exist&quot;);</div><div class="line">    CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)url);</div><div class="line">    CGFontRef newFont = CGFontCreateWithDataProvider(fontDataProvider);</div><div class="line">    CGDataProviderRelease(fontDataProvider);</div><div class="line">    CTFontManagerRegisterGraphicsFont(newFont, nil);</div><div class="line">    CGFontRelease(newFont);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIFont *)fontWithSize:(CGFloat)size &#123;</div><div class="line">    UIFont *font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">    if (font == nil) &#123;</div><div class="line">        [self registerFontWithURL: [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;]];</div><div class="line">        font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">        NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&apos;re using the correct font name.&quot;);</div><div class="line">    &#125;</div><div class="line">    return font;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>字体应用方式<br>可能的应用方式：<ul>
<li>UILabel作为Icon</li>
<li>UIButton的titleLabel作为Icon</li>
<li>根据字体生成UIImage</li>
</ul>
</li>
</ul>
<p>在实际项目中，鉴于将我们本来的icon当作字体使用，会让我们在项目中添加的控件方式有所变化，而且不容易控制颜色和图标大小，所以我这里推荐第三种方案，根据图片大小、颜色和Unicode码来生成并返回图片。</p>
<ul>
<li>应用到项目中<br>将<code>.ttf</code>文件引入到自己的工程中</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b463acca775cd8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>目前我司项目重构之后的图标为IconFont，新需求用到的图标也会优先采用IconFont。</p>
<p><a href="https://github.com/sunjinshuai/MYUtils" target="_blank" rel="external">demo地址</a></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="external">使用IconFont减小iOS应用体积</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了&lt;code&gt;APP Slicing&lt;/code&gt;功能，我司项目在i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 中 Label 的抗拉伸和抗压缩</title>
    <link href="https://sunjinshuai.github.io/2017/07/18/%E6%B5%85%E8%B0%88%20iOS%20AutoLayout%20%E4%B8%AD%20Label%20%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/"/>
    <id>https://sunjinshuai.github.io/2017/07/18/浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩/</id>
    <published>2017-07-17T16:42:23.000Z</published>
    <updated>2018-08-25T02:49:56.261Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIView</code> 中关于 <code>Content Hugging</code> 和 <code>Content Compression Resistance</code> 的方法有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line">- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line"></div><div class="line">- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line">- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div></pre></td></tr></table></figure>
<p>在 <code>Autolayout</code> 优先级的范围是 <code>1 ~ 1000</code>，创建一个约束，默认的优先级是最高的 <code>1000</code>。</p>
<h4 id="Content-Hugging-Priority"><a href="#Content-Hugging-Priority" class="headerlink" title="Content Hugging Priority"></a>Content Hugging Priority</h4><p>Content Hugging Priority: 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是251。</p>
<p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，子视图的总和，不够填充父视图区域时，此属性可以控制优先拉伸哪个视图内容。</p>
<h4 id="Content-Compression-Resistance-Priority"><a href="#Content-Compression-Resistance-Priority" class="headerlink" title="Content Compression Resistance Priority"></a>Content Compression Resistance Priority</h4><p>Content Compression Resistance Priority: 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750。</p>
<p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，并且子控件可能会超出父视图的区域时，此属性可控制哪些视图被内容被优先压缩，使其不超出父视图区域。</p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>Content Compression Resistance Priority </p>
<p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)demo1 &#123;</div><div class="line">    </div><div class="line">    UILabel *yellowLabel = [[UILabel alloc] init];</div><div class="line">    yellowLabel.text = @&quot;我是黄色Label,我是黄色Label,我是黄色Label,我是黄色Label&quot;;</div><div class="line">    yellowLabel.backgroundColor = [UIColor yellowColor];</div><div class="line">    [self.view addSubview:yellowLabel];</div><div class="line">    </div><div class="line">    [yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.center.equalTo(self.view);</div><div class="line">        make.left.equalTo(self.view).offset(100);</div><div class="line">        make.right.equalTo(self.view).offset(-100);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-76c5062f92a502d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从最后的显示效果来看，中间的 <code>Label</code> 被压缩了。因为左右约束的优先级比固有内容相关的优先级要高，所以 <code>Autolayout</code> 布局的时候会优先满足左右两个约束。这时候：<strong>左边约束宽度 + 右边约束宽度 +  <code>Label</code> 的固有内容宽度 &gt; 屏幕宽度</strong>。所以最后只能压缩 <code>Label</code> 显示的宽度。</p>
<p>修改 <code>View</code> 左边约束和右边约束的优先级，或者只修改左(右)边约束优先级，然后设置 <code>Label</code> 抗压缩的优先级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)demo1 &#123;</div><div class="line">    </div><div class="line">    UILabel *yellowLabel = [[UILabel alloc] init];</div><div class="line">    yellowLabel.text = @&quot;我是黄色Label,我是黄色Label&quot;;</div><div class="line">    yellowLabel.backgroundColor = [UIColor yellowColor];</div><div class="line">    [self.view addSubview:yellowLabel];</div><div class="line">    [yellowLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</div><div class="line">    [yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.center.equalTo(self.view);</div><div class="line">        make.left.equalTo(self.view).offset(100).priority(250);</div><div class="line">        make.right.equalTo(self.view).offset(-100).priority(250);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-457044f53dc6af44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这时候 <code>Label</code> 控件的抗压缩约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗压缩特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被压缩的就是左边和右边的约束。</p>
<p>Content Hugging Priority </p>
<p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)demo2 &#123;</div><div class="line">    </div><div class="line">    UILabel *bluelabel = [[UILabel alloc] init];</div><div class="line">    bluelabel.text = @&quot;我是蓝色Label&quot;;</div><div class="line">    bluelabel.backgroundColor = [UIColor blueColor];</div><div class="line">    [self.view addSubview:bluelabel];</div><div class="line">    </div><div class="line">    [bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.center.equalTo(self.view);</div><div class="line">        make.left.equalTo(self.view).offset(100);</div><div class="line">        make.right.equalTo(self.view).offset(-100);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-a81805a367faf561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>拉伸和压缩的时候类似，左右约束优先级比 <code>Label</code> 的 <code>Content Hugging Priority</code> 优先级高，并且此时：<strong>左边约束宽度 + 右边约束宽度+ <code>Label</code> 的固有内容宽度 &lt; 屏幕宽度</strong>。为了满足左右两个约束，就只有拉伸 <code>Label</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)demo2 &#123;</div><div class="line">    </div><div class="line">    UILabel *bluelabel = [[UILabel alloc] init];</div><div class="line">    bluelabel.text = @&quot;我是蓝色Label&quot;;</div><div class="line">    bluelabel.backgroundColor = [UIColor blueColor];</div><div class="line">    [self.view addSubview:bluelabel];</div><div class="line">    [bluelabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</div><div class="line">    [bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.center.equalTo(self.view);</div><div class="line">        make.left.equalTo(self.view).offset(100).priority(250);</div><div class="line">        make.right.equalTo(self.view).offset(-100).priority(250);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-556aa245eb387eae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这时候 <code>Label</code> 控件的抗拉伸约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗拉伸特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被拉伸的就是左边和右边的约束。</p>
<p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/Label%26Compress%26Hugging" target="_blank" rel="external">Label 的抗拉伸和抗压缩</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UIView&lt;/code&gt; 中关于 &lt;code&gt;Content Hugging&lt;/code&gt; 和 &lt;code&gt;Content Compression Resistance&lt;/code&gt; 的方法有：&lt;/p&gt;
&lt;figure class=&quot;highlight pla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第4期(2017.05.03)</title>
    <link href="https://sunjinshuai.github.io/2017/05/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E6%9C%9F-2017-05-03/"/>
    <id>https://sunjinshuai.github.io/2017/05/03/iOS学习笔记-第4期-2017-05-03/</id>
    <published>2017-05-03T03:20:08.000Z</published>
    <updated>2017-08-16T07:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>僵尸对象（Zombie Objects）</li>
<li>使用Instruments检测僵尸对象</li>
<li>iOS11适配之UITableview、UICollectionView下拉刷新错乱</li>
<li>@WeakObj和@StrongObj的宏定义</li>
</ul>
<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p>
<h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li>
</ul>
<p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p>
<h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p>
<p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    __unsafe_unretained NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">    [array addObject:@&quot;1&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：</p>
<ul>
<li>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针。<code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</li>
<li><code>assign</code>仅用于修饰<code>NSInteger</code>等OC基础类型，以及<code>short</code>、<code>int</code>、<code>double</code>、结构体等C数据类型，不修饰对象指针。</li>
<li>如果需要弱引用OC对象，建议使用<code>weak</code>关键字，因为被<code>weak</code>指针所引用的对象被回收后，<code>weak</code>指针会被赋为<code>nil</code>（空指针），给<code>nil</code>发任何消息都不会出问题。使用<code>weak</code>修饰代理对象属性就是很好的例子。</li>
</ul>
<h4 id="iOS11适配之UITableview、UICollectionView下拉刷新错乱"><a href="#iOS11适配之UITableview、UICollectionView下拉刷新错乱" class="headerlink" title="iOS11适配之UITableview、UICollectionView下拉刷新错乱"></a>iOS11适配之UITableview、UICollectionView下拉刷新错乱</h4><p>升级<code>Xcode 9</code>之后，在<code>iOS11</code>的环境下，发现原本没问题的<code>collectionView</code>和<code>tableView</code>像是中了风一样，头部刷新UI出现了错乱。</p>
<p>于是谷歌了一下发现<code>iOS11</code>弃用了<code>automaticallyAdjustsScrollViewInsets</code>属性，新增<code>contentInsetAdjustmentBehavior</code>来替代它。</p>
<p>关于<code>contentInsetAdjustmentBehavior</code>，<br>swift语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@available(iOS 11.0, *)</div><div class="line">public enum UIScrollViewContentInsetAdjustmentBehavior : Int &#123;</div><div class="line"></div><div class="line">    case automatic // Similar to .scrollableAxes, but will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewContentInset = YES inside a navigation controller, regardless of whether the scroll view is scrollable</div><div class="line"></div><div class="line">    case scrollableAxes // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)</div><div class="line"></div><div class="line">    case never // contentInset is not adjusted</div><div class="line"></div><div class="line">    case always // contentInset is always adjusted by the scroll view&apos;s safeAreaInsets</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种:</p>
<ul>
<li><code>automatic</code>和<code>scrollableAxes</code>一样，<code>scrollView</code>会自动计算和适应顶部和底部的内边距并且在<code>scrollView</code>不可滚动时，也会设置内边距。</li>
<li><code>scrollableAxes</code>自动计算内边距。</li>
<li><code>never</code>不计算内边距。</li>
<li><code>always</code>根据<code>safeAreaInsets</code>计算内边距。<br>很显然，在适配<code>iOS11</code>的时候我们这里要设置为<code>never</code>。</li>
</ul>
<p>OC语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明tableView的位置 添加下面代码</div><div class="line">if (@available(iOS 11.0, *)) &#123;</div><div class="line">    _tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明tableView的位置 添加下面代码</div><div class="line">if #available(iOS 11.0, *) &#123;</div><div class="line">    tableView.contentInsetAdjustmentBehavior = .never</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="WeakObj和-StrongObj的宏定义"><a href="#WeakObj和-StrongObj的宏定义" class="headerlink" title="@WeakObj和@StrongObj的宏定义"></a>@WeakObj和@StrongObj的宏定义</h4><p>我们都知道在防止如<code>block</code>的循环引用时，会使用<code>__weak</code>关键字做如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div></pre></td></tr></table></figure>
<p>后来，为了方便，不用每次都要写这样一句固定代码，我们定义了宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WeakSelf __weak typeof(self) weakSelf = self;</div></pre></td></tr></table></figure>
<p>之后，我们可以比较方便的在需要的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[weakSelf doSomething];</div></pre></td></tr></table></figure>
<p>再后来，我们发现不止<code>self</code>需要使用<code>weak</code>，可能有部分变量也需要<code>weak</code>，于是我们的宏继续进化，不仅仅只支持<code>self</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WeakObj(o) __weak typeof(o) o##Weak = o;</div></pre></td></tr></table></figure>
<p>这样，后续对需要使用<code>weak</code>的对象，只要写一句<code>WeakObj(obj)</code>即可使用<code>objWeak</code>变量。</p>
<p>再后来，我们发现了一些小技巧，可以让我们的这个宏看起来更原生一些，我们添加了@符号在前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define WeakObj(o) autoreleasepool&#123;&#125; __weak typeof(o) o##Weak = o;</div><div class="line">#define StrongObj(o) autoreleasepool&#123;&#125; __strong typeof(o) o = o##Weak;</div></pre></td></tr></table></figure>
<p>使用上看起来是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@WeakObj(self);</div><div class="line">[var setBlock:^&#123;</div><div class="line">    @StrongObj(self);</div><div class="line">    [self doSomething];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;僵尸对象（Zombie Objects）&lt;/li&gt;
&lt;li&gt;使用Instruments检测僵尸对象&lt;/li&gt;
&lt;li&gt;iOS11适配之UITableview、UICollectionView下拉刷新错乱&lt;/li&gt;
&lt;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/03/18/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/03/18/iOS之使用Cocoapods创建私有仓库/</id>
    <published>2017-03-18T10:31:52.000Z</published>
    <updated>2017-07-19T02:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
<p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p>
<ul>
<li><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</li>
<li><p>查看现有的<code>podspec</code>源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul>
<li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li>
<li>创建pod私有库所需要的项目工程文件，并上传到私有库</li>
<li>创建pod所对应的podspec文件，并进行验证／测试</li>
<li>向私有的Spec Repo中提交podspec</li>
<li>使用pod库</li>
</ul>
<h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul>
<li>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</li>
<li><p>将私有Spec Repo关联到本地</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add FXSpesc http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git</div></pre></td></tr></table></figure>
<p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p>
<h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul>
<li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>手动创建Xcode工程(过于简单)</p>
</li>
</ul>
<h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul>
<li>如果用<code>pod</code>命令创建，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你项目工程文件</div><div class="line">pod spec create FXKit.podspec</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  s.name         = &quot;FXKit&quot;</div><div class="line">  s.version      = &quot;0.0.1&quot;</div><div class="line">  s.summary      = &quot;FXKit，繁星优选私有库&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">		   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</div><div class="line">                   DESC</div><div class="line"></div><div class="line">  s.homepage     = &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;</div><div class="line"></div><div class="line">  # s.license    = &quot;MIT (example)&quot;</div><div class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line">  s.author       = &#123; &quot;孙金帅&quot; =&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</div><div class="line">  s.platform     = :ios</div><div class="line">  s.source       = &#123;</div><div class="line">	:git =&gt; &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;,</div><div class="line">	:tag =&gt; &quot;#&#123;s.version&#125;&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.source_files = &apos;FXKit/**/*.&#123;h,m&#125;&apos;</div><div class="line"></div><div class="line">  # s.resource_bundles = &#123;</div><div class="line">  #   &apos;FXKit&apos; =&gt; [&apos;FXKit/Assets/*.png&apos;]</div><div class="line">  # &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;FXKit/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;</div><div class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">s.name：私有库的名称，`pod search`搜索的关键词，注意这里一定要和`.podspec`的名称一样，否则报错。</div><div class="line">s.version：私有库的版本。</div><div class="line">s.ios.deployment_target：支持的pod最低版本。</div><div class="line">s.summary：私有库简介。</div><div class="line">s.description：私有库详细介绍。</div><div class="line">s.homepage：私有库在GitHub上的地址。</div><div class="line">s.license：开源协议。</div><div class="line">s.author：作者。</div><div class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</div><div class="line">s.source：私有库在GitHub上的地址和版本号。</div><div class="line">s.source_files：私有库对外共享的.h和.m文件。</div><div class="line">s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<ul>
<li>commit项目工程的源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git</div><div class="line">git push -u origin master</div><div class="line">git tag -m &quot;first release&quot; 0.0.1</div><div class="line">git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<ul>
<li>验证</li>
</ul>
<p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint FXKit.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p>
<h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</div><div class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</div><div class="line">pod repo push FXSpesc NAME.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings --use-libraries</div></pre></td></tr></table></figure>
<h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MarkDown 语法</title>
    <link href="https://sunjinshuai.github.io/2017/01/09/MarkDown-%E8%AF%AD%E6%B3%95/"/>
    <id>https://sunjinshuai.github.io/2017/01/09/MarkDown-语法/</id>
    <published>2017-01-09T14:06:33.000Z</published>
    <updated>2018-06-09T14:08:52.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># This is an H1</div><div class="line">## This is an H2</div><div class="line">###### This is an H6</div></pre></td></tr></table></figure>
<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>使用一对各三个的反引号(<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>我是文本块<br>我是文本块<br>我是文本块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 文字高亮</div><div class="line">文字高亮功能能使行内部分文字高亮，使用一对反引号(`)，例如：</div><div class="line"></div><div class="line">`文字高亮`</div><div class="line"></div><div class="line">#### 引用块</div></pre></td></tr></table></figure></p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 换行</div><div class="line"></div><div class="line">直接回车不能换行，</div><div class="line">可以在上一行文本后面补两个空格，</div><div class="line">这样下一行的文本就换行了，或者就是在两行文本直接加一个空行，也能实现换行效果，但是这个行间距有点大。</div><div class="line"></div><div class="line">#### 列表</div><div class="line">##### 无序列表</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">##### 有序列表</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 横线</div><div class="line">下面每一行都会得到一个水平线</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id=""><a href="#" class="headerlink" title="___"></a>___</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">***</div><div class="line">___</div><div class="line">---</div><div class="line"></div><div class="line">#### 链接</div></pre></td></tr></table></figure>
<p>这是一个 <a href="http://example.com/" title="Title" target="_blank" rel="external">连接显示文字</a> 行内链接。<br><a href="http://example.net/" target="_blank" rel="external">连接显示文字</a> 没有title属性。<br><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a> 自动链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 强调</div></pre></td></tr></table></figure></p>
<p><em>single asterisks</em><br><em>single underscores</em><br><strong>double asterisks</strong><br><strong>double underscores</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 图片</div><div class="line">##### 行内图片</div></pre></td></tr></table></figure></p>
<p><img src="/path/to/img.jpg" alt="Alt text"><br><img src="/path/to/img.jpg" alt="Alt text" title="Optional title"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 引用图片</div></pre></td></tr></table></figure></p>
<p>![Alt text][id]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 表格</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">Left-Aligned</th>
<th style="text-align:center">Center Aligned</th>
<th style="text-align:right">Right Aligned</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">some wordy text</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">| Left-Aligned | Center Aligned | Right Aligned |</div><div class="line">| :------------ |:---------------:| -----:|</div><div class="line">| col 3 is | some wordy text | $1600 |</div><div class="line">| col 2 is | centered | $12 |</div><div class="line">| zebra stripes | are neat | $1 |</div><div class="line"></div><div class="line">#### 删除线</div><div class="line"></div><div class="line">文本两端加上两个~~即可，例如：</div><div class="line"></div><div class="line">~~删除我~~</div></pre></td></tr></table></figure>
<p><del>删除我</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### github 特有的特性</div><div class="line"></div><div class="line">复选框列表</div><div class="line">在列表符号后面加上 `[]` 或者 `[x]` 代表选中或者未选中情况</div></pre></td></tr></table></figure></p>
<ul>
<li>[x] C</li>
<li>[x] C++</li>
<li>[x] Java</li>
<li>[x] Qt</li>
<li>[x] Android</li>
<li>[ ] C#</li>
<li>[ ] .NET<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* [x] C</div><div class="line">* [x] C++</div><div class="line">* [x] Java</div><div class="line">* [x] Qt</div><div class="line">* [x] Android</div><div class="line">* [ ] C#</div><div class="line">* [ ] .NET</div><div class="line"></div><div class="line">#### emoji表情</div><div class="line"></div><div class="line">github 的 Markdown 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</div><div class="line"></div><div class="line">比如，:blush:</div></pre></td></tr></table></figure>
</li>
</ul>
<p>:blush:<br>```</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>Markdown官网：<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">http://daringfireball.net/projects/markdown/</a></li>
<li>中文参考：<a href="http://markdown.tw/" target="_blank" rel="external">http://markdown.tw/</a></li>
</ul>
<h4 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h4><ul>
<li><a href="http://marxi.co/" target="_blank" rel="external">http://marxi.co/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库踩坑记</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库踩坑记/</id>
    <published>2016-12-08T14:01:03.000Z</published>
    <updated>2017-08-08T07:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即上一篇<a href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/">iOS之使用Cocoapods创建公有仓库</a>，本文就<code>CocoaPods</code>创建公有库踩到的坑做一下分享：</p>
<h4 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h4><ul>
<li>本地的公有仓库验证通过，但是远程仓库上的公有仓库验证不通过，路经不对。<br><img src="http://upload-images.jianshu.io/upload_images/588630-4a5138f97c4c6d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>重新打开<code>xxx.podspec</code>文件编辑一下，确定共享文件路径没有错误，然后再上传到<code>github</code>上验证。<br><code>source_files</code>文件格式有几种设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.source_files  = &apos;Classes/*.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes/publicClass.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes&apos;</div><div class="line">s.source_files  = &apos;Classes/**/*.&#123;h,m&#125;&apos;</div></pre></td></tr></table></figure>
<ul>
<li>执行<code>pod trunk push TestCocoaPods.podspec</code>时，报<code>[!] {&quot;name&quot;=&gt;[&quot;is already taken&quot;]}</code><br><img src="http://upload-images.jianshu.io/upload_images/588630-2a2f1d0e9d5c0864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>执行<code>pod search TestCocoaPods</code>，会发现有一个重名的公有库存在，重新创建一个公有库，<code>CocoaPods</code>不允许有重名的公有库存在。</p>
<ul>
<li>最后所有的验证都通过了也上传成功了，结果使用<code>pod search</code>仍然搜索不到。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7076e838dbb41cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>解决办法：<br>1、执行<code>pod setup</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fd244d2a25ef7af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果最底下会输出<code>setup completed</code>。说明执行<code>pod setup</code>成功。<br>2、如果<code>pod search</code>操作还是搜索失败，删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure></p>
<p>3、执行<code>pod search</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be3fa814cb06d76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即上一篇&lt;a href=&quot;https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%9
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库/</id>
    <published>2016-12-08T05:45:50.000Z</published>
    <updated>2017-08-08T06:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在开发过程中，经常会使用到第三框架，我们通过一个<code>pod install</code>命令，很方便的就将第三方框架加到我们自己的项目中。</p>
<p>如果我们也想将自己写的组件或库开源出去，让别人也可以通过<code>pod install</code>命令安装自己的框架该怎么做呢？下面，我就教大家一步一步的将自己的<code>pods</code>发布到<code>CocoaPods</code>中。如果你现在对<code>CocoaPods</code>还不太了解，推荐你看一看这篇文章：<a href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">CocoaPods的安装与使用</a></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1、注册<code>CocoaPods</code>账户信息<br>2、创建共享库文件并上传到公有仓库<br>3、编辑<code>.podspec</code>文件<br>4、打<code>tag</code>, 发布一个<code>release</code>版本<br>5、发布自己的库描述文件<code>podspec</code>给<code>cocoapods</code><br>6、关于查找和使用新创建的库<br>7、更新维护<code>podspec</code></p>
<p>下面就创建<code>CocoaPods</code>公有库做一下分享：</p>
<p>一、在github上创建项目，复制项目的链接路径，例如：<a href="https://github.com/sunjinshuai/MYSementManager" target="_blank" rel="external">https://github.com/sunjinshuai/MYSementManager</a>;</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-18287791668c31f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br>1、<code>GitHub</code>仓库的名称，不允许重名。<br>2、开源协议，一般都选择<code>MIT</code>。</p>
<p>二、使用命令行、<code>sourceTree</code>或者<code>GitHub Mac</code>版将项目克隆到本地新建的一个文件夹中;</p>
<p>三、cd进入本地该文件夹，将自己之前的工程文件(demo)以及共享文件(共享库Lib)拖入其中，并创建公有仓库，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create cocoaPodsName;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e67a3ac9fd6604f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br>1、自己的工程文件(demo)以及共享文件(共享库Lib)。<br>2、<code>MYSementManager.podspec</code>创建的公有库名称。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-20364e263a61e972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当<code>Specification created at MYSementManager.podspec</code>说明创建公有库成功。</p>
<p>四、使用文本编辑器或者<code>sublime</code>等编辑公有仓库信息(注意：引号不能搞错了，是英文格式的””,不是中文格式“”)，默认选择文本编辑器。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ae92088a994e1ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1、s.name：公有库的名称。</div><div class="line">2、s.version：公有库的版本。</div><div class="line">3、s.summary：公有库简短介绍。</div><div class="line">4、s.description：公有库详细介绍。</div><div class="line">5、s.homepage：公有库在GitHub上的地址。</div><div class="line">6、s.license：开源协议。</div><div class="line">7、s.author：作者。</div><div class="line">8、s.source：公有库在GitHub上的地址和版本号。</div><div class="line">9、s.source_files：公有库对外共享的.h和.m文件。</div><div class="line">10、s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<p>没有涉及到的字段可以去<a href="http://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="external">官方文档</a>查阅。</p>
<p>五、编辑结束保存，并验证本地的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint cocoaPodsName.podspec</div></pre></td></tr></table></figure>
<p>六、验证有效后，然后再将本地该文件夹中所有的文件<code>push</code>到<code>github</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin https://github.com/sunjinshuai/test.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>使用<code>git tag</code>(此方法操作后再<code>push</code>上传一次)或者直接在<code>github</code>上点击<code>release</code>进入后创建<code>release</code>并给公有仓库打上<code>tag</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -m &quot;first release&quot; 0.0.1</div><div class="line">$ git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<p>七、注册<code>trunk</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk register 邮箱 ‘用户名’ --description=‘描述’</div></pre></td></tr></table></figure>
<p>注意：<br>邮箱为<code>github</code>上的登录邮箱、用户名为<code>github</code>上的用户名。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e5852a3ef0d784db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>接收发送到邮箱的链接，点击进入后注册成功。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-31ebbd1972d0b840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>查看注册的个人信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk me</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1c00ba7b4cc7dee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>验证上传到<code>github</code>上的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec lint cocoaPodsName.podspec</div></pre></td></tr></table></figure>
<p>八、将公有仓库推送到<code>CocoaPods</code>上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk push cocoaPodsName.podspec</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3b58f26ecefe1456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>大功告成，使用<code>pod search cocoaPodsName</code>搜索即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ebd6b6df003a75e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在开发过程中，经常会使用到第三框架，我们通过一个&lt;code&gt;pod install&lt;/code&gt;命令，很方便的就将第三方框架加到我们自己的项
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程之二：NSThread的使用</title>
    <link href="https://sunjinshuai.github.io/2016/11/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ANSThread%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/11/18/iOS多线程之二：NSThread的使用/</id>
    <published>2016-11-18T14:00:52.000Z</published>
    <updated>2017-12-18T14:19:04.298Z</updated>
    
    <content type="html"><![CDATA[<p>NSThread<br>NSThread封装性最差，最偏向于底层，主要基于thread使用，生命周期需要手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。</p>
<p>一、线程创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建并自动启动</div><div class="line">[NSThread detachNewThreadSelector:@selector(threadAlloc:) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">// 先创建线程，再启动</div><div class="line">NSThread *newThread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:obj];</div><div class="line">[newThread run];</div><div class="line"></div><div class="line">// ios(10.0)，线程的创建，线程创建后直接运行</div><div class="line">[NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">[do something];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:obj];</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/23/b99d29bda1bf4201f75954bb76d32fbc" alt="Paste_Image.png"></p>
<p>二、线程之间的通讯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 在主线程中运行方法，wait表示是否阻塞这个方法的调用，如果为YES则等待主线程中运行方法结束，一般可用于在子线程中调用UI方法。</div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div><div class="line"></div><div class="line">// 隐含产生新线程</div><div class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</div><div class="line"></div><div class="line">// 在指定线程中执行，但该线程必须具备run loop。</div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div></pre></td></tr></table></figure>
<p>三、NSThread的其它一些常用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (NSThread *)currentThread;                     // 获得当前线程</div><div class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti; // 线程休眠</div><div class="line">+ (NSThread *)mainThread;                        // 主线程，亦即UI线程了</div><div class="line">+ (BOOL)isMainThread;                            // 判断当前线程是否是主线程</div><div class="line">+ (BOOL)isMultiThreaded;                         // 判断当前线程是否是多线程</div><div class="line">+ (void)sleepUntilDate:(NSDate *)date;           // 当前线程休眠到指定日期</div><div class="line">+ (void)exit;                                    // 强行退出当前线程</div><div class="line">+ (double)threadPriority;                        // 获取当前线程线程优先级</div><div class="line">+ (BOOL)setThreadPriority:(double)p;             // 给当前线程设定优先级，调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高。</div><div class="line">+ (NSArray *)callStackReturnAddresses            // 线程的调用都会有函数的调用函数的调用就会有栈返回地址的记录，在这里返回的是函 数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组</div><div class="line">+ (NSArray *)callStackSymbols                    // 同上面的方法一样，只不过返回的是该线程调用函数的名字数字</div><div class="line">+ (BOOL)isMainThread;                            // 当前线程是否主线程</div><div class="line">- (BOOL)isMainThread;</div><div class="line">- (BOOL)isExecuting;                             // 线程是否正在运行</div><div class="line">- (BOOL)isFinished;                              // 线程是否已结束</div><div class="line">- (void)cancel                                   // 终止线程循环</div><div class="line">- (void)start                                    // 开启线程循环</div><div class="line">- (void)isCancelled;                             // 判断线程是否撤销</div><div class="line">- (void)setName:(NSString *)n;                   // 设置线程名称</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSThread&lt;br&gt;NSThread封装性最差，最偏向于底层，主要基于thread使用，生命周期需要手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程之一：基本概念</title>
    <link href="https://sunjinshuai.github.io/2016/11/17/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sunjinshuai.github.io/2016/11/17/iOS多线程之一：基本概念/</id>
    <published>2016-11-17T15:00:10.000Z</published>
    <updated>2017-12-18T14:19:19.346Z</updated>
    
    <content type="html"><![CDATA[<p>计算机操作系统都有的基本概念，以下概念简单方式来描述。</p>
<p><code>进程</code>：就是一个正在执行的程序。<br><code>线程</code>：是执行程序最基本的单元，它有自己栈和寄存器。</p>
<blockquote>
<p>进程和线程的区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
</blockquote>
<p><code>并发</code>：多个任务同时发生，需要被处理。比如，田径赛场上的起跑线上有多个运动员等待起跑。<br><code>并行</code>：在某一个时间能够同时处理多个任务。比如，火车站开放了多个检票口，同一时间能够服务多个旅客。<br><code>串行</code>：线程执行只能依次逐一先后有序的执行，串行中，一个任务的执行必须以上一个任务执行结束为前提。</p>
<blockquote>
<p>串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提，并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来，串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。</p>
</blockquote>
<p><code>同步</code>：就是顺序往下执行。举例：烧完水后泡茶<br><code>异步</code>：就是几件事情同时在执行。烧水的时候拿出茶具，洗茶具，然后泡茶。其中烧水和拿茶具，洗茶具是同时进行的。</p>
<p>二、iOS多线程方案</p>
<p>在<code>iOS</code>中其实目前有4套多线程方案，他们分别是：<br>1、pthreads<br>2、NSThread<br>3、GCD<br>4、NSOperation &amp; NSOperationQueue</p>
<p>参考：(<a href="http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="external">http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机操作系统都有的基本概念，以下概念简单方式来描述。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;进程&lt;/code&gt;：就是一个正在执行的程序。&lt;br&gt;&lt;code&gt;线程&lt;/code&gt;：是执行程序最基本的单元，它有自己栈和寄存器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程和线程的区别&lt;br
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>探索通知的原理</title>
    <link href="https://sunjinshuai.github.io/2016/10/17/%E6%8E%A2%E7%B4%A2%E9%80%9A%E7%9F%A5%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2016/10/17/探索通知的原理/</id>
    <published>2016-10-17T06:54:58.000Z</published>
    <updated>2018-06-09T12:42:44.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NSNotification解决的问题"><a href="#NSNotification解决的问题" class="headerlink" title="NSNotification解决的问题"></a>NSNotification解决的问题</h4><ul>
<li>可以实现跨层的传递，例如A页面跳转到B页面，B页面再跳转到C页面，这时候如果我们通过委托回调的模式让A知道C的一些修改，那么实现起来就会很麻烦。</li>
<li>可以实现一对多，<code>NSNotification</code> 的实际是一种观察者模式。</li>
</ul>
<h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><p><code>NSNotificationCenter</code> 就相当于一个广播站，使用 <code>[NSNotificationCenter defaultCenter]</code> 来获取，<code>NSNotificationCenter</code> 实际上是 <code>iOS</code> 程序内部之间的一种消息广播机制，主要为了解决应用程序内部不同对象之间解耦而设计。<br><code>NSNotificationCenter</code> 是整个通知机制的关键所在，它管理着监听者的注册和注销，通知的发送和接收。<code>NSNotificationCenter</code> 维护着一个通知的分发表，把所有通知发送者发送的通知，转发给对应的监听者们。每一个 <code>iOS</code> 程序都有一个唯一的通知中心，不必自己去创建一个，它是一个单例，通过 <code>[NSNotificationCenter defaultCenter]</code> 方法获取。<br><code>NSNotificationCenter</code> 是基于观察者模式设计的，不能跨应用程序进程通信，当 <code>NSNotificationCenter</code> 接收到消息之后会根据内部的消息转发表，将消息发送给订阅者；它可以向应用任何地方发送和接收通知。<br>在 <code>NSNotificationCenter</code> 注册观察者，发送者使用通知中心广播时，以 <code>NSNotification</code> 的 <code>name</code> 和 <code>object</code> 来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</p>
<h4 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h4><p><code>NSNotification</code> 是 <code>NSNotificationCenter</code> 接收到消息之后根据内部的消息转发表，将消息发送给订阅者封装的对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</div><div class="line"></div><div class="line">//这个成员变量是这个消息对象的唯一标识，用于辨别消息对象</div><div class="line">@property (readonly, copy) NSString *name;</div><div class="line">// 这个成员变量定义一个对象，可以理解为针对某一个对象的消息，代表通知的发送者</div><div class="line">@property (nullable, readonly, retain) id object;</div><div class="line">//这个成员变量是一个字典，可以用其来进行传值</div><div class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</div><div class="line">// 初始化方法</div><div class="line">- (instancetype)initWithName:(NSString *)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo NS_AVAILABLE(10_6, 4_0) NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>由于 <code>NSNotification</code> 属性都是只读的，如果要创建通知则要用下面 <code>NSNotification(NSNotificationCreation)</code> 分类相应的方法进行初始化；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface NSNotification (NSNotificationCreation)</div><div class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject;</div><div class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</div><div class="line">- (instancetype)init /*NS_UNAVAILABLE*/;    /* do not invoke; not a valid initializer for this class */</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>注意：<br>如果 <code>NSNotification</code> 对象中的 <code>notificationName</code> 为 <code>nil</code>，则会接收所有的通知。通知中心是以 <code>NSNotification</code> 的 <code>name</code> 和 <code>object</code> 来确定需要发送给哪个观察者。监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的，所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</p>
<p>通知中心默认是以同步的方式发送通知的，也就是说，当一个对象发送了一个通知，<strong>只有当该通知的所有接受者都接受到了通知中心分发的通知消息并且处理完成后，发送通知的对象才能继续执行接下来的方法。</strong></p>
<h3 id="iOS-9-NSNotificationCenter-无需手动移除观察者"><a href="#iOS-9-NSNotificationCenter-无需手动移除观察者" class="headerlink" title="iOS 9 NSNotificationCenter 无需手动移除观察者"></a>iOS 9 NSNotificationCenter 无需手动移除观察者</h3><p>众所周知，在观察者对象释放之前，需要调用 <code>removeObserver</code> 方法，将观察者从通知中心移除，否则程序可能会出现崩溃。其实，从 <code>iOS 9</code> 开始，即使不移除观察者对象，程序也不会出现异常。这是为什么呢？我们先了解一下，为什么 <code>iOS 9</code> 之前需要手动移除观察者对象。</p>
<p>在 <code>MRC</code> 时代，观察者注册时，通知中心并不会对观察者对象做 <code>retain</code> 操作，而是对观察者对象进行 <code>unsafe_unretained</code> 引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// for attribute</div><div class="line">@property (unsafe_unretained) NSObject *unsafeProperty;</div><div class="line">// for variables</div><div class="line">NSObject *__unsafe_unretained unsafeReference;</div></pre></td></tr></table></figure>
<p>不安全引用（<code>unsafe reference</code>）和弱引用 (<code>weak reference</code>) 类似，它并不会让被引用的对象保持存活，但是和弱引用不同的是，当被引用的对象释放的时，不安全引用并不会自动被置为 <code>nil</code>，这就意味着它变成了野指针，而对野指针发送消息会导致程序崩溃。</p>
<blockquote>
<p>If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method.</p>
</blockquote>
<p>而在 <code>iOS 9</code> 以后，通知中心持有的是注册者的 <code>weak</code> 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。但是，通过 <code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock]</code> 方法注册的观察者依然需要手动的释放，因为通知中心对它们持有的是强引用。</p>
<h4 id="NSNotification在多线程中使用"><a href="#NSNotification在多线程中使用" class="headerlink" title="NSNotification在多线程中使用"></a>NSNotification在多线程中使用</h4><p>在主线程中注册观察者，在子线程中发送通知，是发送通知的线程处理的通知事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 往通知中心添加观察者</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                         selector:@selector(handleNotification:)</div><div class="line">                                             name:@&quot;MyNAME&quot;</div><div class="line">                                           object:nil];</div><div class="line">NSLog(@&quot;register notifcation thread = %@&quot;, [NSThread currentThread]);</div><div class="line">// 创建子线程，在子线程中发送通知</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">	NSLog(@&quot;post notification thread = %@&quot;, [NSThread currentThread]);</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;MyNAME&quot; object:nil userInfo:nil];</div><div class="line">&#125;);</div><div class="line"></div><div class="line">- (void)handleNotification:(NSNotification *)notification &#123;</div><div class="line">    //打印处理通知方法的线程</div><div class="line">    NSLog(@&quot;handle notification thread = %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5eda51fb29c68b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在主线程中注册观察者，主线程中发送通知，是发送通知的线程处理的通知事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 往通知中心添加观察者</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self</div><div class="line">                                         selector:@selector(handleNotification:)</div><div class="line">                                             name:@&quot;MyNAME&quot;</div><div class="line">                                           object:nil];</div><div class="line">    </div><div class="line">NSLog(@&quot;register notifcation thread = %@&quot;, [NSThread currentThread]);</div><div class="line">    </div><div class="line">// 创建子线程，在子线程中发送通知</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">	NSLog(@&quot;post notification thread = %@&quot;, [NSThread currentThread]);</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;MyNAME&quot; object:nil userInfo:nil];</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">- (void)handleNotification:(NSNotification *)notification &#123;</div><div class="line">    //打印处理通知方法的线程</div><div class="line">    NSLog(@&quot;handle notification thread = %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-dee057a3614a9d88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>在一个多线程的程序中，发送方发送通知的线程通常就是监听者接受通知的线程，这可能和监听者注册时的线程不一样。</p>
<h4 id="通知的原理："><a href="#通知的原理：" class="headerlink" title="通知的原理："></a>通知的原理：</h4><p>在发送通知的子线程处理通知的事件时，将 <code>NSNotification</code> 暂存，然后通过 <code>MachPort</code> 往相应线程的 <code>RunLoop</code> 中发送事件。相应的线程收到该事件后，取出在队列中暂存的 <code>NSNotification</code> , 然后在当前线程中调用处理通知的方法。<br><img src="http://upload-images.jianshu.io/upload_images/588630-7ddc2c7fab912f4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;NSNotification解决的问题&quot;&gt;&lt;a href=&quot;#NSNotification解决的问题&quot; class=&quot;headerlink&quot; title=&quot;NSNotification解决的问题&quot;&gt;&lt;/a&gt;NSNotification解决的问题&lt;/h4&gt;&lt;ul&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AutoreleasePool的实现原理</title>
    <link href="https://sunjinshuai.github.io/2016/10/06/AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2016/10/06/AutoreleasePool的实现原理/</id>
    <published>2016-10-06T06:32:16.000Z</published>
    <updated>2017-07-06T08:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题：autorelease对象什么时候释放。"><a href="#面试题：autorelease对象什么时候释放。" class="headerlink" title="面试题：autorelease对象什么时候释放。"></a>面试题：autorelease对象什么时候释放。</h4><p>autorelease的本质就是延迟调用<code>release</code>方法，在MRC的环境下，可以通过调用<code>[obj autorelease]</code>来延迟释放内存，在ARC的环境下，当我们创建一个对象，会将对象添加到当前的<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时，会对<code>autoreleasepool</code>里面的所有对象做一次<code>release</code>操作。在没有手动加入<code>autoreleasepool</code>的情况下，<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池<code>push</code>和<code>pop</code>。</p>
<p>当<code>autoreleasepool</code>销毁时，在调用堆栈中可以发现，系统调用了<code>-[NSAutoreleasePool release]</code>方法，这个方法最终通过调用<code>AutoreleasePoolPage::pop(void *)</code>函数来负责对<code>autoreleasepool</code>中的<code>autorelease</code>对象执行<code>release</code>操作。</p>
<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>我们打开<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a> 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到<code>autoreleasepool</code>的实现源码。其实，<code>autoreleasepool</code>是没有单独的内存结构的，它是通过以<code>AutoreleasePoolPage</code>为结点的双向链表来实现的。</p>
<ul>
<li>每一个线程的<code>autoreleasepool</code>其实就是一个指针的堆栈，结构中的thread指针指向当前线程；</li>
<li>每一个指针代表一个需要<code>release</code>的对象或者<code>POOL_SENTINEL</code>（哨兵对象，代表一个<code>autoreleasepool</code>的边界）；</li>
<li>一个<code>pool token</code>指向<code>autoreleasepool</code>所对应的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>；</li>
</ul>
<p>一个空的<code>AutoreleasePoolPage</code>的内存结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/588630-f64cda7c9112e5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><code>magic</code>用来校验<code>AutoreleasePoolPage</code>的结构是否完整；</li>
<li><code>next</code>指向最新添加的<code>autorelease</code>对象的下一个位置，初始化时指向 begin() ；</li>
<li><code>thread</code>指向当前线程；</li>
<li><code>parent</code>指向父结点，第一个结点的 parent 值为 nil ；</li>
<li><code>child</code>指向子结点，最后一个结点的 child 值为 nil ；</li>
<li><code>depth</code>代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code>代表 high water mark 。</li>
</ul>
<p>当<code>AutoreleasePoolPage</code>里面的<code>autorelease</code>对象满了，也就是next指针指向了栈顶，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>AutoreleasePoolPage</code>加入，新<code>AutoreleasePoolPage</code>的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。<br>另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。<br>所以，向一个对象发送<code>release</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶next指针指向的位置。</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a><code>autoreleasepool</code></h4><p>使用<code>clang -rewrite-objc</code>命令将下面的 Objective-C 代码重写成 C++ 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</div><div class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</div><div class="line"></div><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个<code>__AtAutoreleasePool</code>类型的局部变量<code>__autoreleasepool</code>来实现<code>@autoreleasepool {}</code>。当声明<code>__autoreleasepool</code>变量时，构造函数<code>__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p>当出了当前作用域时，析构函数<code>~__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure></p>
<p>也就是说<code>@autoreleasepool {}</code>的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line">    void *atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">    // 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</div><div class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code>、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a>objc_autoreleasePoolPush()</h4><p>上面提到的<code>objc_autoreleasePoolPush()</code>函数本质上就是调用的<code>AutoreleasePoolPage</code>的<code>push</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return nil;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据源码得出，每次执行<code>objc_autoreleasePoolPush</code>其实就是创建了一个新的<code>autoreleasepool</code>，对应<code>AutoreleasePoolPage</code>的具体实现就是往<code>AutoreleasePoolPage</code>中的<code>next</code>位置插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>的内存地址。并且把<code>pool token</code>指针指向这个地址，在执行<code>pop</code>操作的时候作为函数的入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline void *push()</div><div class="line">&#123;</div><div class="line">    id *dest = autoreleaseFast(POOL_SENTINEL);</div><div class="line">    assert(*dest == POOL_SENTINEL);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>push</code>函数通过调用<code>autoreleaseFast</code>函数来执行具体的插入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>autoreleaseFast</code>函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前<code>page</code>存在且没有满时，直接将对象添加到当前<code>page</code>中，即<code>next</code>指向的位置；</li>
<li>当前<code>page</code>存在且已满时，创建一个新的<code>page</code> ，并将对象添加到新创建的<code>page</code>中；</li>
<li>当前<code>page</code>不存在时，即还没有<code>page</code>时，创建第一个<code>page</code>，并将对象添加到新创建的<code>page</code>中。<br>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。</li>
</ul>
<h4 id="objc-autoreleasePoolPop-void"><a href="#objc-autoreleasePoolPop-void" class="headerlink" title="objc_autoreleasePoolPop(void *)"></a>objc_autoreleasePoolPop(void *)</h4><p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return;</div><div class="line"></div><div class="line">    // fixme rdar://9167170</div><div class="line">    if (!ctxt) return;</div><div class="line"></div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pop</code>函数的入参就是<code>push</code>函数的返回值，也就是<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>，直到<code>pool token</code>所在<code>page</code>的<code>next</code>指向<code>pool token</code>为止。</p>
<h4 id="autorelease对象释放原理"><a href="#autorelease对象释放原理" class="headerlink" title="autorelease对象释放原理"></a>autorelease对象释放原理</h4><p>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，在执行<code>objc_autoreleasePoolPop(void *)</code>操作的时候作为函数的入参。<br><img src="http://upload-images.jianshu.io/upload_images/588630-cf6a8a8bd44f721c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前<code>AutoreleasePoolPage</code>中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次<code>release</code>消息，并向回移动next指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个<code>AutoreleasePoolPage</code>，直到哨兵所在的<code>AutoreleasePoolPage</code>。</li>
</ul>
<p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数，当执行<code>pop</code>操作后，<br><img src="http://upload-images.jianshu.io/upload_images/588630-ee6388ccaec8b86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;a href=&quot;#面试题：autorelease对象什么时候释放。&quot; class=&quot;headerlink&quot; title=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;/a&gt;面试题：autoreleas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://sunjinshuai.github.io/2016/09/23/对称加密与非对称加密/</id>
    <published>2016-09-23T14:21:21.000Z</published>
    <updated>2018-06-09T07:17:45.018Z</updated>
    
    <content type="html"><![CDATA[<p>对称加密：<br>加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），对称加密是最快速、最简单的一种加密方式。<br>加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。</p>
<p>对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<p>对称加密通常使用的是相对较小的密钥，一般小于256bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。</p>
<p>比如常见的DES/AES都是属于对称加密算法。</p>
<p>优点：算法公开、计算量小、加密速度快、加密效率高。<br>缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。</p>
<p>另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p>非对称加密：<br>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。</p>
<p>私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。</p>
<p>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p>
<p>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。</p>
<p>与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。<br>比如RSA就是最常用的非对称加密算法。</p>
<p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<p>优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。<br>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p>
<p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p>
<p>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对称加密：&lt;br&gt;加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），对称加密是最快速、最简单的一种加密方式。&lt;br&gt;加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Load&amp;Initialize</title>
    <link href="https://sunjinshuai.github.io/2016/09/19/Load-Initialize/"/>
    <id>https://sunjinshuai.github.io/2016/09/19/Load-Initialize/</id>
    <published>2016-09-19T15:20:55.000Z</published>
    <updated>2017-11-29T15:22:09.163Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (void)load;</div><div class="line">+ (void)initialize;</div></pre></td></tr></table></figure>
<h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><p>如果你实现了 <code>+ load</code> 方法，那么当类被加载到内存时，它会自动被调用，并且是在 <code>main</code> 函数调用之前被调用。</p>
<h4 id="load-方法的调用栈"><a href="#load-方法的调用栈" class="headerlink" title="load 方法的调用栈"></a>load 方法的调用栈</h4><p>首先分析一下 <code>load</code> 方法是如何被调用的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-79f9a27a6fad634c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从控制台的打印可以看出，运行之后，依然打印了 <code>XXXX load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p><code>load</code> 方法的调用顺序其实有迹可循，我们看到 <code>demo</code> 的项目设置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-578317d4cc2d9920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在 <code>TARGETS -&gt; Build Phases -&gt; Compile Sources</code>中调整一下文件的加载顺序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-0bdb3567814e7f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果发现：</p>
<ul>
<li>在 <code>load</code> 方法的调用中会自动调用父类的方法，即<strong>父类先于子类调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>文件的加载顺序靠前的类优先调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>类先于分类调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>文件的加载顺序靠前的分类优先调用</strong>。</li>
</ul>
<h4 id="load方法如何加载到内存中"><a href="#load方法如何加载到内存中" class="headerlink" title="load方法如何加载到内存中"></a><code>load</code>方法如何加载到内存中</h4><p>使用 <code>Xcode</code> 添加一个符号断点 <code>+[Parent load]</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fc3a92e363d99516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p>
<p>重新运行程序。这时，代码会停在 <code>NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</code> 这一行的实现上：</p>
<p>左侧的调用栈很清楚的展示哪些方法被调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[Parent load]</div><div class="line">1  call_load_methods</div><div class="line">2  load_images</div><div class="line">3  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">...</div><div class="line">13 _dyld_start</div></pre></td></tr></table></figure>
<p>从runtime初始化开始</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9494f2a6913b9e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当 <code>Objective-C</code> 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入运行时的时候，进行回调。</p>
<ul>
<li><code>map_images</code> 主要是在 <code>image</code> 加载进内容后对其二进制内容进行解析，初始化里面的类的结构等。</li>
<li><code>load_images</code> 主要是调用 <code>call_load_methods</code>。按照继承层次依次调用 <code>Class</code> 的 <code>+load</code> 方法然后再是 <code>Category</code> 的 <code>+load</code> 方法。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ab9a17fe1c457f6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ec529c4bedd7e4ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从源码中可以看出，</p>
<ul>
<li>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> 递归把当前类和没有调用 <code>+ load</code> 方法的父类，通过 <code>add_class_to_loadable_list(cls)</code> 方法添加到 <code>loadable_classes</code> 列表中，<strong>保证父类在子类前调用 <code>+load</code> 方法</strong>。</li>
<li>通过 <code>_getObjc2NonlazyCategoryList</code> 获取所有的分类的列表之后，会通过 <code>remapClass</code> 获取分类对应的指针，然后调用<code>add_category_to_loadable_list</code> 把当前分类添加到 <code>loadable_categories</code> 列表中。</li>
</ul>
<p>在将镜像加载到运行时、对 <code>+load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>+load</code> 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-908e53a2462438c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>不停调用类的 <code>+load</code> 方法，直到 <code>loadable_classes</code> 为空。</li>
<li>然后调用一次 <code>call_category_loads</code> 加载分类。</li>
<li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>+load</code> 方法。</li>
<li><strong>类先于分类调用</strong>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5c3408d006682624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后通过对应的 <code>SEL</code> ，找到 <code>IMP</code> 的实现并执行。</p>
<h4 id="load-方法的应用"><a href="#load-方法的应用" class="headerlink" title="load 方法的应用"></a>load 方法的应用</h4><p>由于调用 <code>+load</code> 方法运行时间过早，环境很不安全，我们应该尽量减少 <code>+load</code> 方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在 <code>+load</code> 方法中。不过在这个时间点，所有的 <code>framework</code> 都已经加载到了运行时中，所以调用 <code>framework</code> 中的方法都是安全的。</p>
<h2 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h2><ul>
<li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用。</li>
<li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都已经加载到了内存中。</li>
<li><code>initialize</code> 的运行是线程安全的。</li>
<li>子类会继承父类的 <code>initialize</code> 方法。</li>
</ul>
<h4 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>在项目中没有引用任何文件，当我们运行项目，会发现与 <code>load</code> 方法不同的是，虽然我们在 <code>initialize</code> 方法中调用了 <code>NSLog</code>。但是程序运行之后没有任何输出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1ed8f3a5cc66ad20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果发现：<br>没有直接调用 <code>initialize</code> 方法。但是，这里也打印出了 <code>XXXX initialize</code> 字符串。</p>
<p><strong> <code>initialize</code> 只会在对应类的方法第一次被调用时，才会调用。</strong></p>
<p>由于子类会继承父类的 <code>initialize</code> 方法，即使子类没有实现 <code>initialize</code> 方法，也会调用父类的方法，这会导致一个很严重的问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e7b192de1527d86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>运行后发现父类的 <code>initialize</code> 方法竟然调用了两次：</p>
<p>虽然 <code>initialize</code> 方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// In Parent.m</div><div class="line">+ (void)initialize &#123;</div><div class="line">if (self == [Parent class]) &#123;</div><div class="line">NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加上判断后，就不会因为子类而调用到自己的 <code>initialize</code> 方法了。</p>
<p><strong> 如果在分类中也实现了 <code>initialize</code>  方法，则会出现方法”覆盖”</strong>。</p>
<p>在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4b45dbbbeceffd7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从runtime初始化开始</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9eca14718fb589ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>lookUpImpOrForward</code> 方法只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时才会调用。</p>
<h4 id="Initialize-方法的应用"><a href="#Initialize-方法的应用" class="headerlink" title="Initialize 方法的应用"></a>Initialize 方法的应用</h4><p>由于 <code>initialize</code> 作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装与使用</title>
    <link href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/08/08/CocoaPods的安装与使用/</id>
    <published>2016-08-08T03:16:06.000Z</published>
    <updated>2017-08-08T04:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Cocoapods</code>是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。</p>
<p>当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当前的步伐，而应该不断进取，要做到能想<code>Cocoapods</code>提交项目，并且在自己项目中熟练应用该工具的程度。特别是如果一个大的公司来说的话,就有可能进行模块化开发了。对于国内很多公司还是在用OC来说的话，<code>Cocoapods</code>应该还是一个不错的模块管理的工具。</p>
<h4 id="升级ruby源"><a href="#升级ruby源" class="headerlink" title="升级ruby源"></a>升级ruby源</h4><p>安装<code>Cocoapods</code>需要用到<code>ruby</code>，Mac系统自带<code>ruby</code>，但如果不是最新的系统，最好更新一下。</p>
<p>注意：<br><code>ruby</code>的软件源<code>rubygems.org</code>被墙了，所以先换一下源。</p>
<ul>
<li>首先，执行以下命令删除原来的ruby源：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources --remove https://rubygems.org/</div></pre></td></tr></table></figure>
<p>注意：<br>执行命令后可在终端看见以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://rubygems.org/ removed from sources</div></pre></td></tr></table></figure>
<ul>
<li>然后下一步添加你找到的可用的镜像源(这里我没有用淘宝的源：<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -a https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<ul>
<li>验证新源是否替换成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure>
<p>终端输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line">https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<p>到此<code>ruby</code>源替已经换成国内的源。</p>
<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p>问题1、<code>While executing gem ... (Errno::EPERM)  Operation not permitted - /usr/bin/fuzzy_match</code>错误</p>
<p>解决方法:</p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure></p>
<p>然后提示<code>gems installed</code>即可。</p>
<p>问题2、<code>Error installing pods:active support requires Ruby version &gt;= 2.2.2</code><br>解决方案:</p>
<p>查看<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure>
<p>终端会输出你的<code>ruby</code>版本信息</p>
<p>查看目前的所有<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm list known</div></pre></td></tr></table></figure>
<p>如果提示<code>command not found</code>请先安装<code>rvm</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L get.rvm.io | bash -s stable</div></pre></td></tr></table></figure>
<p>如果已安装会列出所有的<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># MRI Rubies</div><div class="line">[ruby-]1.8.6[-p420]</div><div class="line">[ruby-]1.8.7[-head] # security released on head</div><div class="line">[ruby-]1.9.1[-p431]</div><div class="line">[ruby-]1.9.2[-p330]</div><div class="line">[ruby-]1.9.3[-p551]</div><div class="line">[ruby-]2.0.0[-p648]</div><div class="line">[ruby-]2.1[.10]</div><div class="line">[ruby-]2.2[.6]</div><div class="line">[ruby-]2.3[.3]</div><div class="line">[ruby-]2.4[.0]</div><div class="line">ruby-head</div><div class="line"></div><div class="line"># for forks use: rvm install ruby-head-&lt;name&gt; --url https://github.com/github/ruby.git --branch 2.2</div><div class="line"></div><div class="line"># JRuby</div><div class="line">jruby-1.6[.8]</div><div class="line">jruby-1.7[.26]</div><div class="line">jruby[-9.1.7.0]</div><div class="line">jruby-head</div><div class="line"></div><div class="line"># Rubinius</div><div class="line">rbx-1[.4.3]</div></pre></td></tr></table></figure>
<p>然后安装最新的<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h4 id="CocoaPods的使用"><a href="#CocoaPods的使用" class="headerlink" title="CocoaPods的使用"></a>CocoaPods的使用</h4><ul>
<li>查找第三方库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search AFNetworking</div></pre></td></tr></table></figure>
<ul>
<li>创建Podfile文件</li>
</ul>
<p>在终端使用cd ＋路径切换到项目所在文件下，然后输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch Podfile</div></pre></td></tr></table></figure>
<p>就可以在项目目录里看到<code>Podfile</code>文件。也可以使用<code>pod init</code>来创建，<code>Podfile</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod init</div></pre></td></tr></table></figure>
<p>打开Podfile文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open Podfile</div></pre></td></tr></table></figure>
<p>然后<code>pod install</code>就可以了</p>
<h4 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h4><p>由于有<code>Podfile.lock</code>文件的保护下，在没有执行<code>pod update</code>命令的情况下，是不会将已有的第三方库进行升级的。所以运行<code>pod install</code>的情况下还是能编译通过的。</p>
<ul>
<li>pod</li>
</ul>
<p>一般在<code>Podfile</code>里面如果引入第三方库，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div></pre></td></tr></table></figure>
<p>可以看出<code>pod</code>关键字后面可以跟参数:</p>
<p>参数一： 版本号<br>从上面可以看得出<code>AFNetworking</code>后面跟了参数版本号。<br>不过版本号可以是大于、小于、等于等。当然具体的可以是’&gt; 3.1.0’, ‘&gt;= 3.1.0’, ‘&lt; 3.1.0’, ‘3.1.0’以及’~&gt; 3.1.0’。关于普通的就没什么好说了，最后一个~&gt;指的是正对最后一位来说。如使用’~&gt; 3.1.0’,意味着’&gt;= 3.1.0’并且’&lt; 3.2.0’的意思。</p>
<p>参数二：地址<br><code>Cocoapods</code>可以指定某一个<code>git</code>的目录或者是本地的目录。有的时候我们希望一直用某一个版本最新的版本，即使没有打版本的话，我们可以直接后面接上:<code>git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;</code>。<br>当然除了这种情况外，还有可能是如果是我们自己开发的私有库，并且在开发阶段的情况下，可能就希望开发模式进行引用，则可以使用path参数:<code>:path =&gt; &#39;~/Documents/AFNetworking</code>。</p>
<p>参数三：tag、branche、commit<br>有的时候我们希望引用有一个<code>tag</code>，<code>branch</code>或者是<code>comit</code>的内容的话可以使用这个参数，分别用<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</p>
<ul>
<li>platform</li>
</ul>
<p>这个参数是只依赖的库希望在哪个平台被编译，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;7.0&apos;</div></pre></td></tr></table></figure>
<ul>
<li>target</li>
</ul>
<p>这个是指定具体的配置是适配在哪个target，这里的target值得就是Xcode中的target。如果对于一些项目中你的不同target引用的框架不同的话，可以采用这个进行区分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">target &quot;ShowsApp&quot; do  </div><div class="line">  pod &apos;ShowsKit&apos;</div><div class="line">  target &quot;ShowsTV&quot; do</div><div class="line">    pod &quot;ShowTVAuth&quot;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<ul>
<li>use_frameworks!</li>
</ul>
<p>这个指明编译成动态库，而不是静态库，特别是在使用Swift库的过程中，特别需要使用这句。不过他会把所有项目的编译动态库，这一点有点不好。不过在使用Swift库的过程中就没办法了。</p>
<ul>
<li>source</li>
</ul>
<p>这个参数是指Cocoapods从哪些仓库(Spec)中获得框架的源代码，如果在结合使用开源库以及自己私有库的情况下，这个参数还是非常有意义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source &apos;https://github.com/artsy/Specs.git&apos;  </div><div class="line">source &apos;https://192.168.0.90:8888/MySepcs/Specs.git&apos;</div></pre></td></tr></table></figure>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod install --verbose --no-repo-update</div><div class="line">pod update --verbose --no-repo-update</div></pre></td></tr></table></figure>
<p>pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是pod update会更新所有的类库，获取最新版本的类库。每次用pod update就行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Cocoapods&lt;/code&gt;是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。&lt;/p&gt;
&lt;p&gt;当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git中merge、rebase的区别</title>
    <link href="https://sunjinshuai.github.io/2016/08/04/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2016/08/04/源码管理工具之git中merge、rebase的区别/</id>
    <published>2016-08-04T06:15:32.000Z</published>
    <updated>2017-08-04T07:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般在公司git整合分支一般有两种方法——快速向前合并<code>git rebase</code>和三路合并<code>git merge</code>。其实在开发中，<code>git rebase</code>和<code>git merge</code>表达都是一个意思，即，将一个分支合并到另一个分支。</p>
<p>当开发一个新功能，一般我们会在<code>develop</code>分支上创建<code>featrue</code>分支：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b6359864017521dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当我们这个新功能开发测试完毕之后，首先要把<code>featrue</code>分支合并到<code>develop</code>分支上，一般会根据实际情况选择是否使用<code>git merge</code>还是<code>git rebase</code>。</p>
<p><strong><code>git merge</code></strong><br>根据分支合并的原则，<code>git</code>会自动根据两个分支的共同祖和两个分支的最新提交<code>commit</code>记录进行一个三方合并，然后将合并中修改的内容生成一个新的<code>commit</code>记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git merge master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2fb4e523cea0a269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git merge</code>是一个安全的操作</strong></p>
<p><strong><code>git rebase</code></strong></p>
<p>它会把整个<code>feature</code>分支移动到<code>develop</code>分支的后面，有效地把所有<code>develop</code>分支上新的提交并入过来。但是，<code>git rebase</code>为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git rebase master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93bdffa37317c083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git rebase</code>最大的特点就是让你的项目历史提交记录会非常整洁。</strong><br>首先，它不像<code>git merge</code>那样引入不必要的合并提交。其次，如上图所示，<code>git rebase</code>使项目历史提交记录呈现出一条直线。你可以从项目终点到起点浏览而不需要任何的分叉，可以让你更容易的使用<code>git log</code>查看项目的提交记录。</p>
<p><strong><code>git rebase</code>缺点就是安全性和可跟踪性。</strong></p>
<p><code>git rebase</code>的黄金法则：绝对不要在公共的分支上使用。如果你把<code>master</code>分支<code>rebase</code>到你的<code>feature</code>分支上：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aa37afc6fe4ff411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这次<code>rebase</code>将<code>master</code>分支上的所有提交都移到了<code>feature</code>分支后面。<br>问题是它只发生在你的代码仓库中，而其他所有的开发者还在原来的<code>master</code>上工作。因为<code>rebase</code>引起了新的提交，所以<code>git</code>会认为你的<code>master</code>分支和其他人的<code>master</code>已经分叉了。</p>
<p>同步两个<code>master</code>分支的唯一办法是把它们<code>merge</code>到一起，导致一个额外的合并提交和两堆包含同样更改的提交。</p>
<p><strong><code>git rebase</code>不适用于公共的分支上。</strong></p>
<p>总结：选择<code>git merge</code>还是<code>git rebase</code>？</p>
<ul>
<li><p><code>git merge</code>是一个合并操作，会采用三路合并的方式将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容，生成一个新的<code>commit</code>记录。</p>
</li>
<li><p><code>git rebase</code>并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面，为原分支上每一个提交创建一个新的提交。</p>
</li>
<li><p><code>git merge</code>与<code>git rebase</code>都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般在公司git整合分支一般有两种方法——快速向前合并&lt;code&gt;git rebase&lt;/code&gt;和三路合并&lt;code&gt;git merge&lt;/code&gt;。其实在开发中，&lt;code&gt;git rebase&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;表达都是一个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第3期(2016.08.03)</title>
    <link href="https://sunjinshuai.github.io/2016/08/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E6%9C%9F-2016-08-03/"/>
    <id>https://sunjinshuai.github.io/2016/08/03/iOS学习笔记-第3期-2016-08-03/</id>
    <published>2016-08-03T02:25:15.000Z</published>
    <updated>2017-08-19T05:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>数组容错处理</li>
<li>Foundation中的断言处理</li>
<li>文本计算的坑</li>
<li>UITableview的headerView和footerView高度的设置</li>
<li>UIWebView底部的黑条</li>
</ul>
<h4 id="数组容错处理"><a href="#数组容错处理" class="headerlink" title="数组容错处理"></a>数组容错处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> @method objectAtIndexCheck:</div><div class="line"> @abstract 检查是否越界和NSNull如果是返回nil</div><div class="line"> @result 返回对象</div><div class="line"> */</div><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &gt;= [self count]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id value = [self objectAtIndex:index];</div><div class="line">    if (value == [NSNull null]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h4><p><code>Foundation</code>中定义了两组断言相关的宏，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure></p>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ul>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ul>
<p>当断言失败时，通常是会抛出一个如下所示的异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure></p>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。每个线程都有自己的<code>NSAssertionHandler</code>对象。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure></p>
<p>另外，还定义了一个常量字符串，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure></p>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p><code>Xcode</code>已经默认将<code>release</code>环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. 所以不用担心在开发时候大胆使用。</p>
<p>自定义<code>NSAssertionHandler</code><br><code>NSAssertionHandler</code>实例是自动创建的，用于处理错误断言。如果<code>NSAssert</code>和<code>NSCAssert</code>条件评估为错误，会向<code>NSAssertionHandler</code>实例发送一个表示错误的字符串。每个线程都有它自己的<code>NSAssertionHandler</code>实例。<br>我们可以自定义处理方法，从而使用断言的时候，控制台输出错误，但是程序不会直接崩溃。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyAssertHandler.h&quot;</div><div class="line"></div><div class="line">@implementation MyAssertHandler</div><div class="line"></div><div class="line">//处理Objective-C的断言</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%li&quot;, NSStringFromSelector(selector), object, fileName, (long)line);</div><div class="line">&#125;</div><div class="line">//处理C的断言</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%li&quot;, functionName, fileName, (long)line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>给线程添加处理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义<code>NSAssertionHandler</code>后,程序能够获得断言失败后的信息,但是程序可以继续运行,不会强制退出程序。</p>
<h4 id="文本计算的坑"><a href="#文本计算的坑" class="headerlink" title="文本计算的坑"></a>文本计算的坑</h4><p>一般在开发的时候，很多时候需要先计算出文本在某字体下的宽高，再设置控件的frame。有时候文本计算得到的width和height是小数，有可能最后得到的结果不准确，那么控件的frame也不准确。所以我们经常做的一件事就是<code>Category</code>，即给<code>NSString</code>扩展方法，使用新增的方法统一计算文本的大小，在这些方法中使用ceil()将小数点后数据除去，使得计算的结果小数点后都是0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 单行的</div><div class="line">- (CGSize)textSizeWithFont:(UIFont *)font &#123;</div><div class="line">   CGSize textSize = [self sizeWithAttributes:@&#123;NSFontAttributeName:font&#125;];</div><div class="line">   textSize = CGSizeMake((int)ceil(textSize.width), (int)ceil(textSize.height));</div><div class="line">   return textSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根据字体、行数、行间距和constrainedWidth计算多行文本占据的size</div><div class="line">- (CGSize)textSizeWithFont:(UIFont*)font</div><div class="line">             numberOfLines:(NSInteger)numberOfLines</div><div class="line">               lineSpacing:(CGFloat)lineSpacing</div><div class="line">          constrainedWidth:(CGFloat)constrainedWidth</div><div class="line">          isLimitedToLines:(BOOL *)isLimitedToLines &#123;</div><div class="line"></div><div class="line">    if (self.length == 0) &#123;</div><div class="line">        return CGSizeZero;</div><div class="line">    &#125;</div><div class="line">    CGFloat oneLineHeight = font.lineHeight;</div><div class="line">    CGSize textSize = [self boundingRectWithSize:CGSizeMake(constrainedWidth, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size;</div><div class="line"></div><div class="line">    CGFloat rows = textSize.height / oneLineHeight;</div><div class="line">    CGFloat realHeight = oneLineHeight;</div><div class="line">    // 0 不限制行数</div><div class="line">    if (numberOfLines == 0) &#123;</div><div class="line">        if (rows &gt;= 1) &#123;</div><div class="line">            realHeight = (rows * oneLineHeight) + (rows - 1) * lineSpacing;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (rows &gt; numberOfLines) &#123;</div><div class="line">            rows = numberOfLines;</div><div class="line">            if (isLimitedToLines) &#123;</div><div class="line">                *isLimitedToLines = YES;  //被限制</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        realHeight = (rows * oneLineHeight) + (rows - 1) * lineSpacing;</div><div class="line">    &#125;</div><div class="line">    return CGSizeMake(ceil(constrainedWidth),ceil(realHeight));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UITableview的headerView和footerView高度的设置"><a href="#UITableview的headerView和footerView高度的设置" class="headerlink" title="UITableview的headerView和footerView高度的设置"></a>UITableview的headerView和footerView高度的设置</h4><p>一般在项目中使用<code>UITableview</code>的<code>headerView</code>和<code>footerView</code>的时候都会遇到一个问题，即给<code>headerView</code>和<code>footerView</code>高度设置0的时候，发现不好使。经过查阅资料得知如果给<code>headerView</code>和<code>footerView</code>高度设置0，则会被设置成为默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123;</div><div class="line">    return CGFLOAT_MIN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123;</div><div class="line">    return CGFLOAT_MIN;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIWebView底部的黑条"><a href="#UIWebView底部的黑条" class="headerlink" title="UIWebView底部的黑条"></a>UIWebView底部的黑条</h4><p>一般我使用<code>UIWebView</code>的时候会发现，<code>UIWebView</code>底部的黑条很难看，特别是在底部还有透明控件的时候，隐藏的做法其实很简单，只需要将<code>opaque</code>设为NO，背景色设为<code>clearColor</code>即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组容错处理&lt;/li&gt;
&lt;li&gt;Foundation中的断言处理&lt;/li&gt;
&lt;li&gt;文本计算的坑&lt;/li&gt;
&lt;li&gt;UITableview的headerView和footerView高度的设置&lt;/li&gt;
&lt;li&gt;UIW
    
    </summary>
    
    
  </entry>
  
</feed>
