<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅析 NSTimer 和 CADisplayLink 内存泄漏 · 孙金帅的技术博客</title><meta name="description" content="浅析 NSTimer 和 CADisplayLink 内存泄漏 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunjinshuai" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅析 NSTimer 和 CADisplayLink 内存泄漏</h1><div class="post-info">2018年10月12日</div><div class="post-content"><p>谈论 <code>NSTimer &amp; CADisplayLink</code> 内存泄漏，要理解 <code>NSTimer &amp; CADisplayLink</code> 的基础概念，下面通过一个倒计时的实现的 <code>demo</code> 进入正题。</p>
<ul>
<li>第一种就是直接在 <code>TableView</code> 的 <code>Cell</code> 上使用 <code>NSTimer</code>，然后添加到当前线程所对应的 <code>RunLoop</code> 中的 <code>commonModes</code> 中。</li>
<li>第二种是通过 <code>Dispatch</code> 中的 <code>TimerSource</code> 来实现定时器。</li>
<li>第三种是使用 <code>CADisplayLink</code> 来实现。</li>
</ul>
<p>以 <code>UITableViewCell</code> 为例：</p>
<h3 id="一、在-Cell-中直接使用-NSTimer"><a href="#一、在-Cell-中直接使用-NSTimer" class="headerlink" title="一、在 Cell 中直接使用 NSTimer"></a>一、在 <code>Cell</code> 中直接使用 <code>NSTimer</code></h3><p>首先我们按照常规做法，直接在 <code>UITableView</code> 的 <code>Cell</code> 上添加相应的 <code>NSTimer</code>, 并使用 <code>scheduledTimer</code> 执行相应的代码块。<br>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(countDown:) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown:(NSTimer *)timer &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.textLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时:%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:36:11.981473+0800 NSTimer&amp;CADisplayLink[24050:457782] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure>

<h3 id="二、DispatchTimerSource"><a href="#二、DispatchTimerSource" class="headerlink" title="二、DispatchTimerSource"></a>二、DispatchTimerSource</h3><p>接下来我们就在 <code>TableView</code> 的 <code>Cell</code> 上添加 <code>DispatchTimerSource</code>，然后看一下运行效果。当然下方代码片段我们是在全局队列中添加的 <code>DispatchTimerSource</code>，在主线程中进行更新。当然我们也可以在 <code>mainQueue</code> 中添加 <code>DispatchTimerSource</code>，这样也是可以正常工作的。当然我们不建议在 <code>MainQueue</code> 中做，因为在编程时尽量的把一些和主线程关联不太大的操作放到子线程中去做。<br>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        [self countDown];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    &#x2F;&#x2F; 倒计时时间</span><br><span class="line">    __block NSInteger timeOut &#x3D; 60.0f;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    &#x2F;&#x2F; 每秒执行一次</span><br><span class="line">    dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</span><br><span class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 倒计时结束，关闭</span><br><span class="line">        if (timeOut &lt;&#x3D; 0) &#123;</span><br><span class="line">            dispatch_source_cancel(_timer);</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                self.detailTextLabel.text &#x3D; @&quot;倒计时结束&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">                dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">                self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">            &#125;);</span><br><span class="line">            timeOut--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure>

<h3 id="三、CADisplayLink"><a href="#三、CADisplayLink" class="headerlink" title="三、CADisplayLink"></a>三、CADisplayLink</h3><p>接下来我们来使用 <code>CADisplayLink</code> 来实现定时器功能，<code>CADisplayLink</code> 可以添加到 <code>RunLoop</code> 中，每当屏幕需要刷新的时候，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，这时 <code>target</code> 可以读到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。</p>
<p>可以设想一下，我们在动画的过程中，<code>runloop</code> 被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行  <code>CADisplayLink</code> 的调用，从而造成动画过程的卡顿，使动画不流畅。</p>
<p>下方代码，为了不让屏幕的卡顿等引起的主线程所对应的 <code>RunLoop</code> 阻塞所造成的定时器不精确的问题。我们开启了一个新的线程，并且将 <code>CADisplayLink</code> 对象添加到这个子线程的 <code>RunLoop</code> 中，然后在主线程中更新UI即可。<br>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        dispatch_queue_t disqueue &#x3D;  dispatch_queue_create(&quot;com.countdown&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        dispatch_group_t disgroup &#x3D; dispatch_group_create();</span><br><span class="line">        dispatch_group_async(disgroup, disqueue, ^&#123;</span><br><span class="line">            self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">            [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.link invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure>

<h2 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h2><p>从上面的三种 <code>demo</code> 可以看出 <code>UITableViewCell</code> 没有被释放，由此得出结论，当 <code>UITableViewCell</code> 里面强引用了定时器，定时器又强引用了 <code>UITableViewCell</code>，这样两者的 <code>retainCount</code> 值一直都无法为0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>定时器的运行需要结合一个 <code>NSRunLoop</code>，同时 <code>NSRunLoop</code> 对该定时器会有一个强引用，这也是为什么我们不能对 <code>NSRunLoop</code> 中的定时器进行强引的原因。</p>
<p>由于 <code>NSRunLoop</code> 对定时器有引用，定时器怎样才能被释放掉。</p>
<blockquote>
<p>Removes the object from all runloop modes (releasing the receiver if it has been implicitly retained) and releases the target object.</p>
</blockquote>
<p>据官方介绍可知，<code>- invalidate</code> 做了两件事，首先是把本身（定时器）从 <code>NSRunLoop</code> 中移除，然后就是释放对 <code>target</code> 对象的强引用，从而解决定时器带来的内存泄漏问题。</p>
<p>从上面的 <code>demo</code> 中看出，在 <code>UITableViewCell</code> 的 <code>dealloc</code> 方法中调用 <code>invalidate</code> 方法，并没有解决问题。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里使用下 <code>Xcode8</code> 调试黑科技 <code>Memory Graph</code> 来检测下内存泄漏：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-f2c2468c9ecf756f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中可以看出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop  ---&gt; 定时器 ---&gt; UITableViewCell</span><br></pre></td></tr></table></figure>
<p>导致 <code>UITableViewCell</code> 中没有释放掉定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
<p>从代码中看出，<code>Target</code> 直接设置成 <code>self</code> 会造成内存泄， <code>CADisplayLink</code> 会强引用 <code>Target</code>。当 <code>CADisplayLink</code> 添加到 <code>NSRunLoop</code> 中，<code>NSRunLoop</code> 会强引用 <code>CADisplayLink</code>。如果仅仅在 <code>dealloc</code> 中调用 <code>CADisplayLink</code> 的 <code>invalidate</code> 方法是没用的，因为 <code>NSRunLoop</code> 的存在 <code>CADisplayLink</code> 不会被释放，<code>Target</code> 被强引用，<code>Target</code> 的 <code>dealloc</code> 方法不会被调用，<code>CADisplayLink</code> 的 <code>invalidate</code> 方法也不被调用，<code>CADisplayLink</code> 不会从 <code>NSRunLoop</code> 中移除，从而导致内存泄漏。</p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">NSRunLoop 的问题请查看这里</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、Target"><a href="#1、Target" class="headerlink" title="1、Target"></a>1、Target</h3><p>为了解决定时器与 <code>Target</code> 之间类似死锁的问题，我们会将定时器中的 <code>target</code> 对象替换成定时器自己，采用分类实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+TimerTarget.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSTimer (TimerTarget)</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">					repeat:(BOOL)yesOrNo </span><br><span class="line">					 block:(void (^)(NSTimer *))block &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(startTimer:) userInfo:[block copy] repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)startTimer:(NSTimer *)timer &#123;</span><br><span class="line">    void (^block)(NSTimer *timer) &#x3D; timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="2、Proxy"><a href="#2、Proxy" class="headerlink" title="2、Proxy"></a>2、Proxy</h3><p>这种方式就是创建一个 <code>NSProxy</code> 子类 <code>TimerProxy</code>，<code>TimerProxy</code> 的作用是什么呢？就是什么也不做，可以说只会重载消息转发机制，如果创建一个 <code>TimerProxy</code> 对象将其作为定时器的 <code>target</code>，专门用于转发定时器消息至 <code>Target</code> 对象，那么问题是不是就解决了呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 target:[TimerProxy timerProxyWithTarget:self] selector:@selector(startTimer) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure>

<h3 id="3、NSTimer-Block"><a href="#3、NSTimer-Block" class="headerlink" title="3、NSTimer Block"></a>3、NSTimer Block</h3><p>还有一种方式就是采用Block，iOS 10增加的API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ scheduledTimerWithTimeInterval:repeats:block:</span><br><span class="line"></span><br><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;MYNSTimerTargetController timer start&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure>

<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSTimer%26CADisplayLink" target="_blank" rel="noopener">浅析NSTimer &amp; CADisplayLink内存泄漏</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="prev">上一篇</a><a href="/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2018/10/12/浅析-NSTimer-和-CADisplayLink-内存泄漏/';
var disqus_title = '浅析 NSTimer 和 CADisplayLink 内存泄漏';
var disqus_url = 'https://sunjinshuai.github.io/2018/10/12/浅析-NSTimer-和-CADisplayLink-内存泄漏/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2020 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>