<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS多线程之三：GCD的使用 · 孙金帅的技术博客</title><meta name="description" content="iOS多线程之三：GCD的使用 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS多线程之三：GCD的使用</h1><div class="post-info">2016年10月17日</div><div class="post-content"><p>一、什么是 GCD<br><code>GCD</code> 是 <code>Grand Central Dispatch</code> 的简称，它是基于 <code>C</code> 语言的。如果使用<code>GCD</code> 完全由系统管理线程，不需要编写线程代码。只需定义想要执行的任务，然后添加到适当的调度队列 <code>dispatch queue</code>。<code>GCD</code> 会负责创建线程和调度你的任务，系统直接提供线程管理。</p>
<p>二、GCD 任务和队列<br>首先看下这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure>
<p>上面的这段代码是一个简单的异步任务，通过这段代码，引出了下面的几个名词：<br>1、异步执行（<code>async</code>）与同步执行（<code>sync</code>）:</p>
<ul>
<li><p>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。<br>只能在当前线程中执行任务，不具备开启新线程的能力。</p>
</li>
<li><p>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。<br>可以在新的线程中执行任务，具备开启新线程的能力；</p>
</li>
</ul>
<p><strong>异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。</strong></p>
<p>2、队列<br>队列的基本原理：先进先出（<code>FIFO</code>）的原则，先进队列的元素先出队列。<br>在 <code>GCD</code> 中，常见的两种队列：串行队列和并发队列；</p>
<p>串行队列（Serial Dispatch Queue）：<br>串行队列中，只开启一个线程，一个任务执行完毕之后，在执行下一个任务；<br>并发队列（Concurrent Dispatch Queue）：<br>并发队列中，可以开启多个线程，多个任务同时并发执行；</p>
<p>三、GCD 的使用<br>1、队列的创建方法 / 获取方法<br>串行队列（Serial Dispatch Queue）和并发队列（Concurrent Dispatch Queue）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 串行队列的创建方法</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.serial.testQueue&quot;, DISPATCH_QUEUE_SERIAL); </span><br><span class="line">&#x2F;&#x2F; 并发队列的创建方法 </span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.concurrent.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数表示队列的唯一标识符，用于 DEBUG，可为空。队列的名称推荐使用应用程序 ID 这种逆序全程域名。</li>
<li>第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li>
</ul>
<p>主队列（Main Dispatch Queue）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主队列的获取方法</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>

<p>全局并发队列（Global Dispatch Queue）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局并发队列的获取方法 </span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br></pre></td></tr></table></figure>
<p>通过 <code>dispatch_get_global_queue</code> 方法获取的全局队列都是并行队列，并且队列不能被修改。<br><code>identifier</code>：用以标识队列优先级；<br><code>flags</code>：苹果预留的，第二个参数暂时没用，用 0 即可；</p>
<p>2、任务和队列不同组合方式的区别<br>| 区别 | 并发队列 | 串行队列 | 主队列 |<br>|:——-:|:——-:|:——|:——|<br>| 同步（sync） | 没有开启新线程，串行执行任务 | 没有开启新线程，串行执行任务 | 会发生死锁，造成 crash |<br>| 异步（async） | 有开启新线程，并发执行任务 | 有开启新线程（1条），并发执行任务 | 没有开启新线程，串行执行任务 |</p>
<p>3、主队列同步造成死锁的原因<br><code>dispatch_sync</code> 函数本身是放在主线程中执行的，也就是说他本身也是属于主线程执行任务的一部分。根据主线程的特点：主线程会等主线程上的代码执行完毕之后才会去执行放置到主队列中的 <code>task</code>；再根据 <code>disptach_sync</code> 函数特点， <code>task</code> 不执行完毕，<code>dispatch_sync</code> 函数不返回。这样，<code>dispatch_sync</code> 为了返回会等 <code>task</code> 执行完毕也就是主线程执行完，而 <code>task</code> 执行又等着主线程上的代码执行完，也即主线程上 <code>dispatch_sync</code> 代码执行完。两个任务互相等待，造成死锁；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line">主队列同步 </span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)syncMain &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;\n\n**************主队列同步，放到主线程会死锁***************\n\n&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 主队列</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            NSLog(@&quot;主队列同步1   %@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、同步执行 + 并发队列<br>只会在当前线程中依次执行任务，不会开启新线程，执行完一个任务，再执行下一个任务，按照1&gt;2&gt;3顺序执行，遵循 FIFO 原则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)testConcurrentQueueAsynExecution &#123;</span><br><span class="line">    &#x2F;&#x2F; 并发队列</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.test.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#x2F;&#x2F; 第一个任务</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二个任务</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第三个任务</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;----end-----当前线程---%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然 <code>并发队列</code> 可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（<code>同步任务</code> 不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（<code>同步任务</code> 需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</p>
<p>5、异步执行 + 并发队列<br>可以开启多个线程，任务交替（同时）执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void)testConcurrentQueueSyncExecution &#123;</span><br><span class="line">    &#x2F;&#x2F; dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.test.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 全局并发队列</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第一个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第三个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;----end-----当前线程---%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 log 中可以发现，系统另外开启了3条线程，并且任务是同时执行的，并不是按照1&gt;2&gt;3顺序执行。所以异步+并发队列具备开启新线程的能力，且并发队列可开启多个线程，同时执行多个任务。</p>
<p>6、同步执行 + 串行队列<br>只会在当前线程中依次执行任务，不会开启新线程，执行完一个任务，再执行下一个任务,按照1&gt;2&gt;3顺序执行，遵循 FIFO 原则，并且不会产生新的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSerialQueueAsynExecution &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.test.syncQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务一&quot;);</span><br><span class="line">        NSLog(@&quot;currentThread:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;任务二&quot;);</span><br><span class="line">        NSLog(@&quot;currentThread:%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;任务三&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、异步执行 + 串行队列<br>开启了一条新线程，异步执行具备开启新线程的能力且只开启一个线程，在该线程中执行完一个任务，再执行下一个任务,按照1&gt;2&gt;3顺序执行，遵循 FIFO 原则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)testSerialQueueSyncExecution &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.test.syncQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#x2F;&#x2F; 第一个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第三个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8、同步执行 + 主队列<br>直接crash，这是因为发生了死锁，在 GCD 中，禁止在主队列(串行队列)中再以同步操作执行主队列任务。同理，在同一个同步串行队列中，再使用该队列同步执行任务也是会发生死锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)testMainQueueAsynExecution &#123;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.test.testQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----11111-----当前线程%@&quot;, [NSThread currentThread]);&#x2F;&#x2F;到这里就死锁了</span><br><span class="line">        dispatch_sync(queue, ^&#123;</span><br><span class="line">            [NSThread sleepForTimeInterval:2];</span><br><span class="line">            NSLog(@&quot;----22222---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">        NSLog(@&quot;----333333-----当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;----44444-----当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9、异步执行 + 主队列<br>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）,在主线程中执行完一个任务，再执行下一个任务，按照1&gt;2&gt;3顺序执行，遵循 FIFO 原则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)testMainQueueSyncExecution &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取主队列</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第一个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第一个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第二个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第二个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第三个任务</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 这里线程暂停2秒,模拟一般的任务的耗时操作</span><br><span class="line">        [NSThread sleepForTimeInterval:2];</span><br><span class="line">        NSLog(@&quot;----执行第三个任务---当前线程%@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;----end-----当前线程---%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、GCD 线程之间的通讯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)communication &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取全局并发队列</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    &#x2F;&#x2F; 获取主队列</span><br><span class="line">    dispatch_queue_t mainQueue &#x3D; dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 异步追加任务 1</span><br><span class="line">        [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作</span><br><span class="line">        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]); &#x2F;&#x2F; 打印当前线程</span><br><span class="line">        &#x2F;&#x2F; 回到主线程</span><br><span class="line">        dispatch_async(mainQueue, ^&#123;</span><br><span class="line">            &#x2F;&#x2F; 追加在主线程中执行的任务</span><br><span class="line">            [NSThread sleepForTimeInterval:2]; &#x2F;&#x2F; 模拟耗时操作</span><br><span class="line">            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]); &#x2F;&#x2F; 打印当前线程</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>五、GCD 的其他方法</p>
<p>1、dispatch_after</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，使用 <code>dispatch_after</code> 实现延迟执行某动作，时间并不是很精确，因为 <code>main dishpatch queue</code> 在主线程的 <code>runLoop</code> 中执行，所以比如在每隔1/60秒执行的 <code>RunLoop</code> 中，<code>block</code> 最快在三秒后执行，最慢在3秒+1/60秒后执行，如果在 <code>main dishpatch queue</code> 有大量任务处理会使主线程本身的任务处理有延迟时，这个时间会增加。<br>如果对时间的精确度没有高要求，只是为了推迟执行，那么使用dispatch_after还是很不错的。</p>
<ul>
<li>NSObject中提供的线程延迟方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</span><br></pre></td></tr></table></figure></li>
<li>通过 NSTimer 来延迟线程执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:NO];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2、dispatch_once<br>一般我们会利用 <code>dispatch_once</code> 创建单例<br><img src="http://upload-images.jianshu.io/upload_images/588630-c297cec675a7230b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f27221b67fdf17e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从上面代码中可以看出<br>第一个参数 <code>predicate</code>，该参数是检查后面第二个参数所代表的代码块是否被调用的谓词，<br>第二个参数则是在整个应用程序中只会被调用一次的代码块。<code>dispach_once</code> 函数中的代码块只会被执行一次，而且还是线程安全的。</p>
<p>3、dispatch_apply<br><img src="http://upload-images.jianshu.io/upload_images/588630-6d8260d813d3d0a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从上面代码中可以看出，这些迭代是并发执行的和普通 <code>for</code> 循环一样，<code>dispatch_apply</code> 和 <code>dispatch_apply_f</code> 函数也是在所有迭代完成之后才会返回，因此这两个函数会阻塞当前线程，主线程中调用这两个函数必须小心，可能会阻止事件处理循环并无法响应用户事件。所以如果循环代码需要一定的时间执行，可以考虑在另一个线程中调用这两个函数。如果你传递的参数是串行 <code>queue</code>，而且正是执行当前代码的 <code>queue</code>，就会产生死锁。</p>
<p>4、dispatch_group_t dispatch_group_notify<br>可以使用 <code>dispatch_group_async</code> 函数将多个任务关联到一个 <code>dispatch group</code> 和相应的 <code>queue</code> 中，<code>group</code> 会并发地同时执行这些任务。而且 <code>dispatch group</code> 可以用来阻塞一个线程，直到 <code>group</code> 关联的所有的任务完成执行。有时候你必须等待任务完成的结果,然后才能继续后面的处理。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2d01eeaaf76b3daa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>5、dispatch_barrier_async<br>在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 <code>dispatch_barrier_async</code> 函数将任务加入到并行队列之后，任务会在前面任务全部执行完成之后执行，任务执行过程中，其他任务无法执行，直到 <code>barrier</code> 任务执行完成。</p>
<p>有时候我们会需要这样的一个场景，A任务和B任务执行完毕之后，在执行C任务，需要借助 <code>dispatch_barrier_async</code> 这个函数。<br><img src="http://upload-images.jianshu.io/upload_images/588630-d65ad49c9048928b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3a882a33a36b2f8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>从代码中可以看出确实只有在前面A、B任务完成后，barrier 任务才能执行，最后才能执行C任务。<br>注意：<br>使用<code>dispatch_barrier_async</code>，该函数只能搭配自定义并行队列<code>dispatch_queue_t</code>使用。不能使用:<code>dispatch_get_global_queue</code>，否则<code>dispatch_barrier_async</code>的作用会和<code>dispatch_async</code>的作用一模一样。</p>
<p>6、信号量<br>个人理解，在多线程下使用信号量可以控制多线程的并发数目。<br>创建信号量，可以设置信号量的资源数。0 表示没有资源，调用 <code>dispatch_semaphore_wait</code> 会立即等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(0);</span><br></pre></td></tr></table></figure>

<p>等待信号，可以设置超时参数。该函数返回0表示得到通知，非0表示超时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<p>通知信号，如果等待线程被唤醒则返回非0，否则返回0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure>
<p>比如，执行10个任务，然后等待2秒，然后继续执行。<br><img src="http://upload-images.jianshu.io/upload_images/588630-de6db94b478a1d41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>六、Dispatch Semaphore 线程同步<br>有时候会遇到这样的需求：<br>异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：<code>AFNetworking</code> 中 <code>AFURLSessionManager.m</code> 里面的 <code>tasksForKeyPath:</code> 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 <code>tasks</code>，然后再返回该 <code>tasks</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    __block NSArray *tasks &#x3D; nil;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(0);</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123;</span><br><span class="line">            tasks &#x3D; dataTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123;</span><br><span class="line">            tasks &#x3D; uploadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123;</span><br><span class="line">            tasks &#x3D; downloadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123;</span><br><span class="line">            tasks &#x3D; [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/5c4b8b6aa44f" target="_blank" rel="noopener">利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务；</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/05/Block-%E7%B3%BB%E5%88%97%E4%B9%8B-Block-%E5%9F%BA%E7%A1%80/" class="prev">上一篇</a><a href="/2016/10/15/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ANSThread%E7%9A%84%E4%BD%BF%E7%94%A8/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/10/17/iOS多线程之三：GCD的使用/';
var disqus_title = 'iOS多线程之三：GCD的使用';
var disqus_url = 'https://sunjinshuai.github.io/2016/10/17/iOS多线程之三：GCD的使用/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>