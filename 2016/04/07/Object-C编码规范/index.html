<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Object-C编码规范 · 孙金帅的技术博客</title><meta name="description" content="Object-C编码规范 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Object-C编码规范</h1><div class="post-info">2016年4月7日</div><div class="post-content"><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>1、任意函数长度不得超过50行。<br>2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。</p>
<p>3、在定义函数的行前留白一行。<br>4、功能相近的代码要放在一起。<br>5、使用#pragma来切分不同功能区域的代码。<br>6、二元运算符和参数之间需要放置一个空格，一元运算符、强制类型转换和参数之间不放置空格。关键字之后圆括号之前需要放置一个空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *ptr &#x3D; &amp;value + 10 * 3;</span><br><span class="line">NSString *str1 &#x3D; (NSString *)str2;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">	[self doSomeThing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、长的字面值应被拆分为多行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSArray *theShit &#x3D; @[</span><br><span class="line">    @&quot;Got some long string objects in here.&quot;,</span><br><span class="line">    [AndSomeModelObjects too],</span><br><span class="line">    @&quot;Moar strings.&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">NSDictionary *keyedShit &#x3D; @&#123;</span><br><span class="line">    @&quot;this.key&quot;: @&quot;corresponds to this value&quot;,</span><br><span class="line">    @&quot;otherKey&quot;: @&quot;remoteData.payload&quot;,</span><br><span class="line">    @&quot;some&quot;: @&quot;more&quot;,</span><br><span class="line">    @&quot;JSON&quot;: @&quot;keys&quot;,</span><br><span class="line">    @&quot;and&quot;: @&quot;stuff&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名是编程中最基本的技能，我们给变量、函数、类、包等等命名。给他们以名字，让他们有意义，既能表示他们到底是做什么的，也能将其与其他变量区别开来。像人一样娶一个好名字至关重要，“丁当”总比“狗蛋”来的好听。 为什么要命名？ <strong>命名一定要“名副其实”，尽可能使用有意的名称，而且这个意义和指称的变量真实意义相关。</strong><br>1、基本原则<br>尽量不要出现没有任何意义的命名类似于下述形式的命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 3;</span><br><span class="line">CGPoint point &#x3D; CGPointMake(a,b);</span><br></pre></td></tr></table></figure>
<p>如果换成下面的形式是不是可读性强了很多：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int startX &#x3D; 1;</span><br><span class="line">int startY &#x3D; 3;</span><br><span class="line">CGPoint startPoint &#x3D; CGPointMake(startX,startY);</span><br></pre></td></tr></table></figure>
<p>命名首字母大写，其他命名首字母小写。并且采用驼峰格式分割单词。 例如：<code>FXTest</code><br>仿照 Cocoa 风格来，使用长命名风格。<br>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern ushort APIDefaultPageSize;        &#x2F;&#x2F; 还行，能明白意思了</span><br><span class="line">extern ushort APIDefaultFetchPageSize;   &#x2F;&#x2F; 加上些限定更好一些</span><br><span class="line">extern ushort APIFetchPageSizeDefault;   &#x2F;&#x2F; 再好些，把重要的往前放</span><br><span class="line">FXToolbarComment    &#x2F;&#x2F; 不推荐</span><br><span class="line">FXCommentToolbar    &#x2F;&#x2F; OK，把类型（toolbar）置后</span><br></pre></td></tr></table></figure>
<p>2、类别的扩展名以“被扩展的类名+自定义命名部分组成” 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSSstring+Utils.h</span><br></pre></td></tr></table></figure>
<p>3、通知命名<br>基本命名格式是：<code>与通知相关的类名</code> + <code>Did | Will</code> + <code>UniquePartOfName</code> + <code>Notification</code>，例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSApplicationDidBecomeActiveNotification</span><br><span class="line">NSWindowDidMiniaturizeNotification</span><br><span class="line">NSTextViewDidChangeSelectionNotification</span><br><span class="line">NSColorPanelColorDidChangeNotification</span><br></pre></td></tr></table></figure>
<p>4、宏定义，全部字母大写，例如: <code>#define BW_DEBUG 1</code><br>5、常量定义，字符串定义以小写字母k开头，随后首字母大写，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static NSString* const kBWBarTitle &#x3D; @&quot;动态&quot;;</span><br></pre></td></tr></table></figure>
<p>ps：如果要定义常量使用static const优于宏定义，前者会进行类型检查。<br>6、缩略词，以下是一些常用的首字母缩略词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASCII,PDF,XML,HTML,URL,RTF,HTTP,TIFF,JPG,PNG,GIF,LZW,ROM,RGB,CMYK,MIDI,FTP</span><br></pre></td></tr></table></figure>
<p>7、命名空间，因为OC没有命名空间的概念，所以使用前两个或者多个字母来表示命名空间，例如<code>&quot;NSObject中的NS&quot;</code>，我们也使用自己的命名空间。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发现模块：DiscoverController，模块里面其他的控件或者model，DCModel，DCView</span><br><span class="line">个人中心模块：PersonalCenterViewController，模块里面其他的控件或者model，PCModel，PCView</span><br></pre></td></tr></table></figure>
<h4 id="点标记语法"><a href="#点标记语法" class="headerlink" title="点标记语法"></a>点标记语法</h4><p>推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.backgroundColor &#x3D; [UIColor orangeColor];</span><br><span class="line">[UIApplication sharedApplication].delegate;</span><br></pre></td></tr></table></figure>
<p>不推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setBackgroundColor:[UIColor orangeColor]];</span><br><span class="line">UIApplication.sharedApplication.delegate;</span><br></pre></td></tr></table></figure>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>1、方法命名尽可能清晰<br>推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insertObject:atIndex:</span><br><span class="line">removeObjectAtIndex:</span><br><span class="line">removeObject:</span><br></pre></td></tr></table></figure>
<p>不推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert:at:</span><br><span class="line">remove:</span><br></pre></td></tr></table></figure>
<p>2、类方法声明在方法类型与返回类型之间要有空格。<br>推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)methodName:(NSString *)string;</span><br></pre></td></tr></table></figure>
<p>不推荐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)methodName:(NSString *)string;</span><br></pre></td></tr></table></figure>
<p>3、函数<br>(1)、调用时所有参数应该在同一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</span><br></pre></td></tr></table></figure>
<p>(2)、或者每行一个参数，以冒号对齐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1</span><br><span class="line">                   name:arg2</span><br><span class="line">                   error:arg3];</span><br></pre></td></tr></table></figure>
<p>对于参数过多的函数，尽量使用后面一种对其方式。<br>(3)、不要使用下面的缩进风格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2  &#x2F;&#x2F; some lines with &gt;1 arg</span><br><span class="line">              error:arg3];</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">               name:arg2 error:arg3];</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">          name:arg2  &#x2F;&#x2F; aligning keywords instead of colons</span><br><span class="line">          error:arg3];</span><br></pre></td></tr></table></figure>
<p>(4)、如果对传入参数进行数据保护尽量不要用<code>if(!objc)</code>，使用断言来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendArgs:(NSDictionary*)args &#123;</span><br><span class="line">	NSAssert(args, @&quot;args is nil&quot;);</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)、方法参数名前一般使用的前缀包括“the”、“an”、“new”。示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTitle:(NSString *)aTitle;</span><br><span class="line">- (void)setName:(NSString *)newName;</span><br><span class="line">- (id)keyForOption:(CDCOption *)anOption</span><br><span class="line">- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;</span><br><span class="line">- (CDCEmail *)emailForRecipients: (NSArray *)theRecipients;</span><br></pre></td></tr></table></figure>
<p>4、方法名<br>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。<br>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。</p>
<ul>
<li><code>set</code> 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li>
<li><code>get</code> 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。<br>例：<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)name;</span><br><span class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</span><br><span class="line">- (NSSize)cellSize;</span><br><span class="line">- (void)setupControllerObservers;</span><br><span class="line">- (void)setupController;</span><br></pre></td></tr></table></figure>
不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">- (NSSize)calcCellSize;</span><br><span class="line">- (void)setController;</span><br></pre></td></tr></table></figure>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4>长的三元运算符应使用圆括号括起来。三元运算符仅用于赋值和做参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *gender &#x3D; (stuff &#x3D;&#x3D; thing ? @&quot;男&quot; : @&quot;女&quot;);</span><br></pre></td></tr></table></figure>
当有nil时的三元运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; thingThatCouldBeNil ? defaultValue : @&quot;&quot;;</span><br></pre></td></tr></table></figure>
不推荐<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; thingThatCouldBeNil ?: defaultValue;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4>当使用<code>enum</code>关键字时，推荐使用苹果最新引入的固定基础类型语法，因为这将获得强类型检查与代码完成功能。SDK现在包含了一个固定基础类型的宏—<code>NS_ENUM()</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, CertifiedModifyPassWordType)</span><br><span class="line">&#123;</span><br><span class="line">    CertifiedModifyPassWordTypeWithdrawals &#x3D; 1,  &#x2F;&#x2F; 提现</span><br><span class="line">    CertifiedModifyPassWordTypePaymentFail,  &#x2F;&#x2F; 支付失败</span><br><span class="line">    CertifiedModifyPassWordTypePayment, &#x2F;&#x2F; 支付</span><br><span class="line">    CertifiedModifyPassWordTypeOther</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4>因为nil被解析为了NO，所以和nil作比较没有任何的必要。不要将变量和YES直接比较，因为YES被定义为1而BOOL类型是8位的unsigned int，即BOOL的值不仅仅是1或0。<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!someObject) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (someObject &#x3D;&#x3D; nil) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isAwesome)</span><br><span class="line">if (![someObject boolValue])</span><br></pre></td></tr></table></figure>
不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ([someObject boolValue] &#x3D;&#x3D; NO)</span><br><span class="line">if (isAwesome &#x3D;&#x3D; YES) &#x2F;&#x2F; Never do this.</span><br></pre></td></tr></table></figure>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4>应该使用线程安全的模式创建共享的单例实例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">   static id sharedInstance &#x3D; nil;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">      sharedInstance &#x3D; [[self alloc] init];</span><br><span class="line">   &#125;);</span><br><span class="line">   return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
单例的另一种做法，利用+ initialize方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static JSONAPI* sharedInstance &#x3D; nil;</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        sharedInstance &#x3D; [[JSONAPI alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Block相关"><a href="#Block相关" class="headerlink" title="Block相关"></a>Block相关</h4>在block中使用到self变量的时候，一定要先weak再strong。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">[self doABlockOperation:^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf &#x3D; weakSelf;</span><br><span class="line">    if (strongSelf) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4>代理协议名，常用delegate、dateSource做结尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br></pre></td></tr></table></figure>
以<code>did</code>、<code>will</code>、<code>should</code>等形容词，代表Event事件的Delegate<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)windowShouldClose:(id)sender;</span><br><span class="line">- (void)browserDidScroll:(NSBrowser *)sender;</span><br><span class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;</span><br></pre></td></tr></table></figure>
<h4 id="控制结构，if-else"><a href="#控制结构，if-else" class="headerlink" title="控制结构，if-else"></a>控制结构，if-else</h4>1、方法的花括号推荐另起一行。方法内部需要写在一行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)methodName:(NSString *)string &#123;</span><br><span class="line">    if () &#123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
2、条件判断的括号内侧不应有空格。<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a &lt; b) &#123;</span><br><span class="line">    &#x2F;&#x2F; something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( a &lt; b ) &#123;</span><br><span class="line">    &#x2F;&#x2F; something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
3、关系运算符（如<code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如<code>&amp;&amp;</code>、<code>||</code>）两边要有空格。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(someValue &gt; 100) ? YES : NO</span><br></pre></td></tr></table></figure>
二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。<br>多个参数逗号后留一个空格（这也符合正常的西文语法）。<br>4、当需要满足一定条件时才执行某项操作时，使用return是正常合理的。<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethod &#123;</span><br><span class="line">  if (![someOther boolValue]) &#123;</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;Do something important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!error) &#123;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethod &#123;</span><br><span class="line">  if ([someOther boolValue]) &#123;</span><br><span class="line">      &#x2F;&#x2F;Do something important</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!error)</span><br><span class="line">    return success;</span><br><span class="line">...</span><br><span class="line">if (!error) return success;</span><br></pre></td></tr></table></figure>
<h4 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h4>UIView的子类初始化的时候，不要进行任何布局操作。布局操作在LayoutSubViews里面做。<br>UIView的子类布局必须在layoutSubViews里面进行，需要布局的时候调用setNeedLayout来告诉系统，需要重新布局该View，不要直接调用layoutSubViews。<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4>在类定义中使用到自己定义的类的时候，尽量不要在头文件中引入自己定义的类的同文件，使用@class替换。在实现文件中引入相应头文件。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BWTest.h</span><br><span class="line">@class BWDataCenter;</span><br><span class="line">@interface BWTest : NSObject</span><br><span class="line">@property (nonatomic, strong) BWDataCenter* dataCenter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; BWTest.m</span><br><span class="line">#import &quot;BWDataCenter.h&quot;</span><br><span class="line">@implementation BWTest</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="项目工程文件"><a href="#项目工程文件" class="headerlink" title="项目工程文件"></a>项目工程文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - init Method</span><br><span class="line">填入init,initWithFrame等方法</span><br><span class="line">#pragma mark- View Life Cycle</span><br><span class="line">填入viewdidload,viewdidappear等方法</span><br><span class="line">#pragma mark- Delegate，DataSource, Callback Method</span><br><span class="line">填入tableview，scrollview等代理方法</span><br><span class="line">#pragma mark- Override Parent Methods</span><br><span class="line">填入updateViewConstraints,updateConstraint, prepareForSegue等方法</span><br><span class="line">#pragma mark- SubViews Configuration</span><br><span class="line">填入configureSubViews，configureTableView等方法，这里的方法在init方法或view life cycle被调用</span><br><span class="line">#pragma mark- Actions</span><br><span class="line">填入-(IBAction)action:(id)sender和[self addtarget:self action:@selector(action:)]动作指向的方法</span><br><span class="line">#pragma mark- Public Methods</span><br><span class="line">填入在.h外暴露的方法</span><br><span class="line">#pragma mark- Private Methods</span><br><span class="line">填入.m文件内部调用的方法</span><br><span class="line">#pragma mark- Getter Setter</span><br><span class="line">填入对@property初始化的方法</span><br></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/10/iOS-%E4%B8%AD-NSString-%E5%B1%9E%E6%80%A7%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-copy%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-strong/" class="prev">上一篇</a><a href="/2016/03/10/Bitcode-%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/04/07/Object-C编码规范/';
var disqus_title = 'Object-C编码规范';
var disqus_url = 'https://sunjinshuai.github.io/2016/04/07/Object-C编码规范/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>