<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Block 系列之 Block 的实现原理 · 孙金帅的技术博客</title><meta name="description" content="Block 系列之 Block 的实现原理 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Block 系列之 Block 的实现原理</h1><div class="post-info">2016年12月12日</div><div class="post-content"><p>通过下面几个例子，探讨block是如何实现的：</p>
<h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了研究编译器是如何实现 <code>block</code> 的，我们需要使用 <code>clang</code>。<code>clang</code> 提供一个命令，可以将 <code>Objetive-C</code> 的源码改写成 <code>c</code> 语言的，借此可以研究 <code>block</code> 具体的源码实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc block.c</span><br></pre></td></tr></table></figure>

<p>转化之后，生成block.app：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从结构体的命名可以看出这是 <code>block</code> 的实现，<code>block</code> 在 <code>clang</code> 编译器编译之后，生成了一个 <code>__block_impl</code> 结构体，<code>isa</code> 指针表明了 <code>block</code> 可以是一个对象，而 <code>FuncPtr</code> 指针显然是 <code>block</code> 对应的函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们就具体看一下是如何实现的，<code>__main_block_impl_0</code> 就是该 <code>block</code> 的实现，从中我们可以看出：</p>
<ul>
<li><code>__main_block_impl_0</code> 中包含了两个成员变量和一个构造函数，成员变量分别是 <code>__block_impl</code> 结构体和描述信息 <code>__main_block_desc_0</code>，之后在构造函数中初始化 <code>block</code> 的类型信息和函数指针等信息。</li>
<li><code>__main_block_func_0</code> 函数，即 <code>block</code> 对应的函数体。该函数接受一个 <code>__cself</code> 参数，即对应的 <code>block</code> 自身。</li>
<li><code>__main_block_desc_0</code> 结构体，其中 <code>Block_size</code> 存储 <code>block</code> 大小。</li>
</ul>
<p>从上面代码，<strong>可以看出执行 <code>block</code>  就是调用一个以 <code>block</code>  自身作为参数的函数，这个函数对应着 <code>block</code>  的执行体</strong>。</p>
<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><p>block如何捕获变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i &#x3D; 1024;</span><br><span class="line">  void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;%d&quot;,i);</span><br><span class="line">  &#125;;</span><br><span class="line">  blk();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int i;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags&#x3D;0) : i(_i) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line">  printf(&quot;%d&quot;,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 1024;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看出这次的 <code>block</code> 结构体 <code>__main_block_impl_0</code> 多了个成员变量 <code>i</code> ，用来存储使用到的局部变量 <code>i</code>，此时可以看到 <code>__cself</code> 参数的作用，类似 <code>C++</code> 中的 <code>this</code> 和 <code>Objective-C</code> 的 <code>self</code> 当在 <code>block</code> 中引用的变量 <code>i</code> 的时候，实际是在声明 <code>block</code> 时，被 <code>copy</code> 到 <code>__main_block_impl_0</code> 结构体中的那个成员变量 <code>i</code>，并且把 <code>__cself</code> 指针指向成员变量 <code>i</code>。</p>
<p>如果尝试修改局部变量，编译会报错：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-121cf0b90c682d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p><strong>错误原因告诉我们变量不可赋值，也提醒我们要使用__block类型标识符。</strong></p>
<p>因为 <code>main</code> 函数中的局部变量 <code>i</code> 和函数 <code>__main_block_func_0</code> 不在同一个作用域中，调用过程中只是进行了值传递。当然，在上面代码中，我们可以通过指针来实现局部变量的修改。不过这是由于在调用 <code>__main_block_func_0</code> 时，<code>main</code> 函数栈还没展开完成，变量 <code>i</code> 还在栈中。但是在很多情况下，<code>block</code> 是作为参数传递以供后续回调执行的。通常在这些情况下，<code>block</code> 被执行时，定义时所在的函数栈已经被展开，局部变量已经不在栈中了已经被销毁了，再用指针访问就会报常见的<strong>坏内存访问</strong>。</p>
<h4 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h4><p>静态局部变量是如何在 <code>__block</code> 执行体中被修改的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    static int i &#x3D; 10;</span><br><span class="line">    void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">        i &#x3D; 30;</span><br><span class="line">        printf(&quot;%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int *i;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_i, int flags&#x3D;0) : i(_i) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">        (*i) &#x3D; 30;</span><br><span class="line">        printf(&quot;%d&quot;, (*i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    static int i &#x3D; 10;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;i));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为静态局部变量存在于数据段中，不存在栈展开后非法访存的风险。<br>上面中间代码片段与前一个片段的差别主要在于 <code>main</code> 函数里传递的是 <code>i</code> 的地址(<code>&amp;i</code>)，以及 <code>__main_block_impl_0</code> 结构体中成员 <code>i</code> 变成指针类型(<code>int *</code>)。<br>然后在执行block时，通过指针修改值。</p>
<p>当然，全局变量、静态全局变量都可以在 <code>block</code> 执行体内被修改。更准确地讲，<code>block</code> 可以修改它被调用(这里是 <code>__main_block_func_0</code> )时所处作用域内的变量。比如一个 <code>block</code> 作为成员变量时，它也可以访问同一个对象里的其它成员变量。</p>
<h4 id="例子4："><a href="#例子4：" class="headerlink" title="例子4："></a>例子4：</h4><p><code>__block</code> 类型变量是如何支持修改。<br><code>int</code> 类型变量加上<code>__block</code>指示符，使得变量 <code>i</code> 可以在 <code>block</code> 函数体中被修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __block int i &#x3D; 1024;</span><br><span class="line">    void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">        i &#x3D; 1023;</span><br><span class="line">        printf(&quot;%d&quot;,i);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>clang</code> 编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags&#x3D;0) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by ref</span><br><span class="line">  (i-&gt;__forwarding-&gt;i) &#x3D; 1023;</span><br><span class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i &#x3D; &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看出，多出了一个 <code>__Block_byref_i_0</code> 的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__isa</code> 指针也可以知道 <code>__Block_byref_i_0</code> 也可以是对象。</li>
<li><code>__forwarding</code> 指针指向 <code>__Block_byref_i_0</code> </li>
<li>成员变量 <code>i</code>，用来存储使用到的局部变量 <code>i</code>。</li>
</ul>
<p><code>__main_block_impl_0</code> 对应的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags&#x3D;0) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by ref</span><br><span class="line">  (i-&gt;__forwarding-&gt;i) &#x3D; 1023;</span><br><span class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__main_block_impl_0</code> 的成员变量 <code>i</code> 变成了 <code>__Block_byref_i_0*</code> 指针类型。</li>
<li><code>__Block_byref_i_0</code> 指针类型变量 <code>i</code>，通过其成员变量 <code>__forwarding</code> 指针来操作另一个成员变量。</li>
</ul>
<p>注意：<br><code>__Block_byref_i_0</code> 类型变量i仍然处于栈上，当 <code>block</code> 被回调执行时，变量 <code>i</code> 所在的栈已经被展开。<br>查看 <code>__main_block_desc_0</code> 结构体，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>

<p>此时，<code>__main_block_desc_0</code> 多了两个成员函数：<code>copy</code> 和 <code>dispose</code>，分别指向 <code>__main_block_copy_0</code>和 <code>__main_block_dispose_0</code>。</p>
<p>当 <code>block</code> 从栈上被 <code>copy</code> 到堆上时，会调用 <code>__main_block_copy_0</code> 将 <code>__block</code> 类型的成员变量 <code>i</code> 从栈上复制到堆上；而当 <code>block</code> 被释放时，相应地会调用 <code>__main_block_dispose_0</code> 来释放 <code>__block</code> 类型的成员变量 <code>i</code>。如果栈上和堆上同时对该变量进行操作，<code>__forwarding</code> 的作用就体现出来了，当一个 <code>__block</code> 变量从栈上被复制到堆上时，栈上的那个 <code>__Block_byref_i_0</code> 结构体中的 <code>__forwarding</code> 指针也会指向堆上的结构。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/12/17/Block-%E7%B3%BB%E5%88%97%E4%B9%8B-Block-%E7%9A%84%E5%AD%98%E5%82%A8%E5%9F%9F/" class="prev">上一篇</a><a href="/2016/12/05/Block-%E7%B3%BB%E5%88%97%E4%B9%8B-Block-%E5%9F%BA%E7%A1%80/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/12/12/Block-系列之-Block-的实现原理/';
var disqus_title = 'Block 系列之 Block 的实现原理';
var disqus_url = 'https://sunjinshuai.github.io/2016/12/12/Block-系列之-Block-的实现原理/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2020 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>