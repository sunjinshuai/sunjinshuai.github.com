<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2022-05-31T09:00:47.934Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Block 的基本认识</title>
    <link href="https://sunjinshuai.github.io/2022/05/31/Block-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/"/>
    <id>https://sunjinshuai.github.io/2022/05/31/Block-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86/</id>
    <published>2022-05-31T08:18:40.000Z</published>
    <updated>2022-05-31T09:00:47.934Z</updated>
    
    <content type="html"><![CDATA[<p><code>block</code> 是 <code>C</code> 语言的扩充功能，本质上也是一个 <code>OC</code> 对象，它内部也有个 <code>isa</code> 指针，<code>block</code> 是封装了函数调用以及函数调用环境的 <code>OC</code> 对象。下面就来一步步的探索它的由来和使用方法。</p><h4 id="block由来"><a href="#block由来" class="headerlink" title="block由来"></a>block由来</h4><p>先来看看 <code>C</code> 语言中标准的函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int func(int count);</span><br></pre></td></tr></table></figure><p>它声明了名称为 <code>func</code> 的函数。下面看看怎么调用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result &#x3D; func(10);</span><br></pre></td></tr></table></figure><p>如果你知道函数指针，那么应该熟悉下面这个式子，它不用知道函数名也能够使用函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int result &#x3D; （*funcptr）(10);</span><br></pre></td></tr></table></figure><p>但是，实际上仍然需要知道函数的名称。在赋值函数指针时还是需要知道函数名称的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *funcptr (int)&#x3D; &amp;func;</span><br></pre></td></tr></table></figure><p>为什么需要函数指针呢？<br>函数指针是为了获取函数的地址方便将函数作为参数时的调用.<br>为什么会出现匿名函数？<br>是为了代替函数指针，简化函数的书写。<br><code>block</code> 可以真正的实现不需要函数名称的函数，方便了函数的调用。通俗的讲 <code>block</code> 就是一段匿名代码块。</p><p>完整的 <code>block</code> 语法是如下形式：<br><code>block</code> 的声明格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^blockName)(参数列表);</span><br><span class="line">&#x2F;&#x2F; block的声明</span><br><span class="line">int (^sumblock)(int arg1, int arg2);</span><br><span class="line">void (^blockName)(int arg1, int arg2)</span><br></pre></td></tr></table></figure><p><code>block</code> 的定义格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^block变量名)(形参列表) &#x3D; ^(形参列表) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明并使用 <code>block</code><br>开发者使用 <code>^</code> 操作符声明 <code>block</code> 变量，<code>^</code> 表示是一个 <code>block</code> 的开始。<code>block</code> 的 <code>body</code> 体在 <code>{ }</code> 之内。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int multiplier &#x3D; 7;</span><br><span class="line">int (^myblock)(int) &#x3D; ^(int num) &#123;</span><br><span class="line">  return num * multiplier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="588630-08c2619e323632fa.png" alt="image.png"></p><p><code>block</code> 可以使用“在其定义作用范围内的”变量；如果你声明了一个 <code>block</code>变量，可以像函数一样使用它。</p><h4 id="block的用法"><a href="#block的用法" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)() &#x3D; ^&#123;</span><br><span class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">blockName();</span><br></pre></td></tr></table></figure><p>有参数无返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)(int a, int b) &#x3D; ^(int a, int b) &#123;</span><br><span class="line">  NSLog(@&quot;%d + %d &#x3D; %d&quot;,a,b,a+b);</span><br><span class="line">&#125;;</span><br><span class="line">blockName(10,10);</span><br></pre></td></tr></table></figure><p>有参数有返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (^sumblock)(int a, int b) &#x3D; ^(int a, int b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">int sum &#x3D; sumblock(10,10);</span><br><span class="line">NSLog(@&quot;sum &#x3D; %d&quot;,sum);</span><br></pre></td></tr></table></figure><p><code>block</code> 结合 <code>typedef</code> 使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^sumblock)(int, int);</span><br><span class="line"></span><br><span class="line">interface ViewController ()</span><br><span class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  self.sumblock &#x3D; ^(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  NSLog(@&quot;sum &#x3D; %d&quot;,self.sumblock(10,10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>block</code> 作为函数参数<br><code>block</code> 作为 <code>C</code> 函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的C函数</span><br><span class="line">void useblockForC(int(^ablock)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">useblockForC(addblock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">useblockForC(^(int x, int y) &#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>block</code> 作为 <code>OC</code> 函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的OC函数</span><br><span class="line">- (void)useblockForOC:(int(^)(int, int))ablock</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">[self useblockForOC:addblock];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">[self useblockForOC:^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;block&lt;/code&gt; 是 &lt;code&gt;C&lt;/code&gt; 语言的扩充功能，本质上也是一个 &lt;code&gt;OC&lt;/code&gt; 对象，它内部也有个 &lt;code&gt;isa&lt;/code&gt; 指针，&lt;code&gt;block&lt;/code&gt; 是封装了函数调用以及函数调用环境的 &lt;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 AssociatedObject 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2022/05/28/%E6%B5%85%E8%B0%88-AssociatedObject-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2022/05/28/%E6%B5%85%E8%B0%88-AssociatedObject-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-28T08:55:27.000Z</published>
    <updated>2022-05-28T14:09:51.268Z</updated>
    
    <content type="html"><![CDATA[<p>思考，如何给动态添加属性和方法？<br>答案：可以使用 <code>@property</code> 给分类添加属性和方法；</p><p><code>@property</code> 会做三件事：</p><ul><li>生成实例变量 <code>_property</code></li><li>生成 <code>getter</code> 方法 <code>- property</code></li><li>生成 <code>setter</code> 方法 <code>- setProperty:</code></li></ul><p>创建一个 <code>NSObject</code> 的分类 <code>Category</code>，并添加一个属性 <code>name</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (Category)</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MJPerson (Test)</span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(name));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><img src="66ee0244-4780-490d-8de1-f223dee02725.png" alt="image.png"></p><p>发现编译器报错了，</p><p><strong>在这里的警告告诉我们 name 属性的存取方法需要自己手动去实现，或者使用 @dynamic 在运行时实现这些方法。</strong><br><strong>换句话说，分类中的 @property 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。</strong><br>在分类中，因为类的实例变量的布局已经固定，使用 <code>@property</code> 已经无法向固定的布局中添加新的实例变量。</p><h3 id="Associated-Object"><a href="#Associated-Object" class="headerlink" title="Associated Object"></a>Associated Object</h3><p>关联对象是 <code>Objective-C 2.0</code> 运行时的一个特性，最早开始使用是在 <code>OS X Snow Leopard</code> 和 <code>iOS 4</code> 中。在 <code>&lt;objc/runtime.h&gt;</code> 中定义的三个方法，关联对象允许开发者对已经存在的类在扩展中添加自定义的属性，这几乎弥补了 <code>Objective-C</code> 最大的缺点；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Sets an associated value for a given object using a given key and association policy.</span><br><span class="line"> * 使用给定的键和关联策略为给定的对象设置关联的值。</span><br><span class="line"> * </span><br><span class="line"> * @param object The source object for the association.</span><br><span class="line"> * 关联的源对象</span><br><span class="line"> *</span><br><span class="line"> * @param key The key for the association.</span><br><span class="line"> * 关联的 key</span><br><span class="line"> * @param value The value to associate with the key key for object. </span><br><span class="line"> * Pass nil to clear an existing association.</span><br><span class="line"> * 与对象的键相关联的值。传递 nil 以清除现有的关联。</span><br><span class="line"> *</span><br><span class="line"> * @param policy The policy for the association. For possible values, see “Associative Object Behaviors.”</span><br><span class="line"> * 关联策略</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> * @see objc_removeAssociatedObjects</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Returns the value associated with a given object for a given key.</span><br><span class="line"> * 返回与给定键的给定对象关联的值</span><br><span class="line"> * </span><br><span class="line"> * @param object The source object for the association.</span><br><span class="line"> * 关联的源对象</span><br><span class="line"> * @param key The key for the association.</span><br><span class="line"> * 关联的 key</span><br><span class="line"> * </span><br><span class="line"> * @return The value associated with the key \e key for \e object.</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * Removes all associations for a given object.</span><br><span class="line"> * 删除给定对象的所有关联</span><br><span class="line"> * </span><br><span class="line"> * @param object An object that maintains associated objects.</span><br><span class="line"> * </span><br><span class="line"> * @note The main purpose of this function is to make it easy to return an object</span><br><span class="line"> * to a &quot;pristine state”. You should not use this function for general removal of</span><br><span class="line"> * associations from objects, since it also removes associations that other clients</span><br><span class="line"> * may have added to the object. Typically you should use \c objc_setAssociatedObject</span><br><span class="line"> * with a nil value to clear an association.</span><br><span class="line"> *</span><br><span class="line"> * 意指此函数会一下删除对象全部的关联对象，如果我们想要删除指定的关联对象，</span><br><span class="line"> * 应该使用 objc_setAssociatedObject 函数把 value 参数传递 nil 即可。</span><br><span class="line"> *</span><br><span class="line"> * 此功能的主要目的是使对象轻松返回“原始状态”，因此不应从该对象中普遍删除关联，</span><br><span class="line"> * 因为它还会删除其他 clients 可能已添加到该对象的关联。</span><br><span class="line"> * 通常，您应该将 objc_setAssociatedObject 与 nil 一起使用以清除指定关联。</span><br><span class="line"> * </span><br><span class="line"> * @see objc_setAssociatedObject</span><br><span class="line"> * @see objc_getAssociatedObject</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_removeAssociatedObjects(id _Nonnull object)</span><br><span class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure><p><code>const void *key</code>：存取函数中的参数 <code>key</code> 我们都使用了 <code>@selector(name)</code>，其实也可以使用静态指针 <code>static void *</code> 类型的参数来代替，不过这里强烈建议使用 <code>@selector(name)</code> 作为 <code>key</code> 传入，因为这种方法省略了声明参数的代码，并且能很好地保证 <code>key</code> 的唯一性。<br><strong>关联对象存储在全局的统一的一个 <code>AssociationsManager</code> 中。</strong></p><h3 id="关联策略"><a href="#关联策略" class="headerlink" title="关联策略"></a>关联策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN &#x3D; 0,           &#x2F;&#x2F; 指定一个弱引用相关联的对象</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC &#x3D; 1, &#x2F;&#x2F; 指定相关对象的强引用，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC &#x3D; 3,   &#x2F;&#x2F; 指定相关的对象被复制，非原子性</span><br><span class="line">    OBJC_ASSOCIATION_RETAIN &#x3D; 01401,       &#x2F;&#x2F; 指定相关对象的强引用，原子性</span><br><span class="line">    OBJC_ASSOCIATION_COPY &#x3D; 01403          &#x2F;&#x2F; 指定相关的对象被复制，原子性   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">    _object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    &#x2F;&#x2F; retain the new value (if any) outside the lock.</span><br><span class="line">    &#x2F;&#x2F; 创建一个ObjcAssociation对象</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通过policy为value创建对应属性，如果policy不存在，则默认为assign</span><br><span class="line">    id new_value &#x3D; value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建AssociationsManager对象</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 在manager取_map成员，其实是一个map类型的映射</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 创建指针指向即将拥有成员的Class</span><br><span class="line">&#x2F;&#x2F; 至此该类已经包含这个关联对象</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        </span><br><span class="line">         &#x2F;&#x2F; 以下是记录强引用类型成员的过程</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            &#x2F;&#x2F; break any existing association.</span><br><span class="line">            &#x2F;&#x2F; 在即将拥有成员的Class中查找是否已经存在改关联属性</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; secondary table exists</span><br><span class="line">                &#x2F;&#x2F; 当存在时候，访问这个空间的map</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                &#x2F;&#x2F; 遍历其成员对应的key</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果存在key，重新更改Key的指向到新关联属性</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    j-&gt;second &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 否则以新的key创建一个关联</span><br><span class="line">                    (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; create the new association (first time).</span><br><span class="line">                &#x2F;&#x2F; key不存在的时候，直接创建关联</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] &#x3D; refs;</span><br><span class="line">                (*refs)[key] &#x3D; ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; setting the association to nil breaks the association.</span><br><span class="line">            &#x2F;&#x2F; 这种情况是policy不存在或者为assign的时候</span><br><span class="line">            &#x2F;&#x2F; 在即将拥有的Class中查找是否已经存在Class</span><br><span class="line">            &#x2F;&#x2F; 其实这里的意思就是如果之前有这个关联对象，并且是非assign形的，直接erase</span><br><span class="line">            AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">            if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果有该类型成员检查是否有key</span><br><span class="line">                ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">                if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果有key，记录旧对象，释放</span><br><span class="line">                    old_association &#x3D; j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; release the old value (outside of the lock).</span><br><span class="line">    &#x2F;&#x2F; 如果存在旧对象，则将其释放</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数执行过程中有两种情况：</p><ul><li><code>value != nil</code> 新增/更新关联对象的值；</li><li><code>value == nil</code> 删除一个关联对象；</li></ul><p>初始化一个 <code>AssociationsManager</code> 对象，然后获取一个 <code>AssociationsHashMap</code> 哈希表，然后通过 <code>DISGUISE</code> 方法作为去哈希表查找的 <code>key</code>。这里的 <code>DISGUISE</code> 其实进行了按位取反的操作。</p><ul><li>通过上一步按位取反之后的结果，在 <code>AssociationsHashMap</code> 哈希表中查询，这里是通过迭代器的方式进行查询，查询的结果是 <code>ObjcAssociation</code> 对象，这个结构也是一个哈希表，其内部存储的是 <code>_object_set_associative_reference</code> 方法传入的 <code>key</code> 为键，<code>ObjcAssociation</code> 对象为值的键值对。</li><li>如果没有查询到，说明之前在当前类上没有设置过关联对象。则需要初始化一个 <code>ObjectAssociationMap</code> 出来，然后通过 <code>setHasAssociatedObjects</code> 设置当前对象的 <code>isa</code> 的 <code>has_assoc</code> 属性为 <code>true</code>。</li><li>如果查询到了，说明之前在当前类上设置过关联对象，接着需要看 <code>key</code> 是否存在，如果 <code>key</code> 存在，那么就需要<strong>覆盖原有的关联对象</strong>；如果 <code>key</code> 不存在，则需要新增一个关联对象。</li></ul><p>最后会判断 <code>old_association</code> 是否有值，如果有的话就释放掉，当然前提是旧的关联对象的策略是 <code>OBJC_ASSOCIATION_SETTER_RETAIN</code>。</p><h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">id objc_getAssociatedObject_non_gc(id object, const void *key) &#123;</span><br><span class="line">    return _object_get_associative_reference(object, (void *)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id _object_get_associative_reference(id object, void *key) &#123;</span><br><span class="line">    id value &#x3D; nil;</span><br><span class="line">    uintptr_t policy &#x3D; OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">        if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j &#x3D; refs-&gt;find(key);</span><br><span class="line">            if (j !&#x3D; refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation &amp;entry &#x3D; j-&gt;second;</span><br><span class="line">                value &#x3D; entry.value();</span><br><span class="line">                policy &#x3D; entry.policy();</span><br><span class="line">                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">    &#125;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，跟 <code>objc_setAssociatedObject</code> 一样，<code>objc_getAssociatedObject</code> 这里又包裹了一层，其实现为 <code>_object_get_associative_reference</code>，而这个方法相比于上一节的 <code>_object_set_associative_reference</code> 要简单一些；</p><ul><li>先初始化一个空的 <code>value</code>，以及一个策略为 <code>OBJC_ASSOCIATION_ASSIGN</code> 的 <code>policy</code>。</li><li>初始化一个 <code>AssociationsManager</code> 关联对象管理类。</li><li>然后以 <code>DISGUISE(object)</code> 按位取反之后的结果为键去查询 <code>AssociationsHashMap</code>。</li><li>如果在 <code>AssociationsHashMap</code> 中找到了，接着以 <code>key</code> 为键去 <code>ObjectAssociationMap</code> 中查询 <code>ObjcAssociation</code><br>如果在 <code>ObjectAssociationMap</code> 中查询到了 <code>ObjcAssociation</code>，则把值和策略赋值给方法入口声明的两个临时变量，然后判断获取到的关联对象的策略是否为 <code>OBJC_ASSOCIATION_GETTER_RETAIN</code>，如果是的话，需要对关联值进行 <code>retain</code> 操作。</li><li>最后判断如果关联值是否存在且策略为 <code>OBJC_ASSOCIATION_GETTER_AUTORELEASE</code>，是的话就需要调用 <code>objc_autorelease</code> 来释放关联值。</li><li>最后返回关联值。</li></ul><h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object) </span><br><span class="line">&#123;</span><br><span class="line">    if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        if (associations.size() &#x3D;&#x3D; 0) return;</span><br><span class="line">        disguised_ptr_t disguised_object &#x3D; DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i &#x3D; associations.find(disguised_object);</span><br><span class="line">        if (i !&#x3D; associations.end()) &#123;</span><br><span class="line">            &#x2F;&#x2F; copy all of the associations that need to be removed.</span><br><span class="line">            ObjectAssociationMap *refs &#x3D; i-&gt;second;</span><br><span class="line">            for (ObjectAssociationMap::iterator j &#x3D; refs-&gt;begin(), end &#x3D; refs-&gt;end(); j !&#x3D; end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; remove the secondary table.</span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; the calls to releaseValue() happen outside of the lock.</span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_removeAssociatedObjects</code> 方法我们平时可能用的不多，从字面含义来看，这个方法应该是用来删除关联对象。<br>这里会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p><h3 id="关联对象原理"><a href="#关联对象原理" class="headerlink" title="关联对象原理"></a>关联对象原理</h3><p>实现关联对象技术的核心对象有</p><ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul><h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static spinlock_t _lock;</span><br><span class="line">    static AssociationsHashMap *_map;               &#x2F;&#x2F; associative references:  object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; _lock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; _lock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map &#x3D;&#x3D; NULL)</span><br><span class="line">            _map &#x3D; new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它维护了 <code>spinlock_t</code> 和 <code>AssociationsHashMap</code> 的单例，初始化它的时候会调用 <code>lock.lock()</code> 方法，在析构时会调用 <code>lock.unlock()</code>，而 <code>associations</code> 方法用于取得一个全局的 <code>AssociationsHashMap</code> 单例。</p><p>也就是说 <code>AssociationsManager</code> 通过持有一个自旋锁 <code>spinlock_t</code> 保证对 <code>AssociationsHashMap</code> 的操作是线程安全的，即每次只会有一个线程对 <code>AssociationsHashMap</code> 进行操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void *operator new(size_t n) &#123; return ::malloc(n); &#125;</span><br><span class="line">    void operator delete(void *ptr) &#123; ::free(ptr); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ObjcAssociation &#123;</span><br><span class="line">    uintptr_t _policy;</span><br><span class="line">    id _value;</span><br><span class="line">public:</span><br><span class="line">    ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(0), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    uintptr_t policy() const &#123; return _policy; &#125;</span><br><span class="line">    id value() const &#123; return _value; &#125;</span><br><span class="line">    </span><br><span class="line">    bool hasValue() &#123; return _value !&#x3D; nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先，<code>AssociationsHashMap</code> 用与保存从对象的 <code>disguised_ptr_t</code> 到 <code>ObjectAssociationMap</code> 的映射；<br><code>ObjectAssociationMap</code> 则保存了从 <code>key</code> 到关联对象 <code>ObjcAssociation</code> 的映射，这个数据结构保存了当前对象对应的所有关联对象；<br>最关键的 <code>ObjcAssociation</code> 包含了 <code>policy</code> 以及 <code>value</code>。而这两个值我们可以发现正是我们调用 <code>objc_setAssociatedObject</code> 函数传入的值，也就是说我们在调用 <code>objc_setAssociatedObject</code> 函数中传入的 <code>value</code> 和 <code>policy</code> 这两个值最终是存储在 <code>ObjcAssociation</code> 中的。</p><p><img src="e5392d89-02bd-459d-aeda-bd59e0a71fd6.png" alt="image.png"></p><p>通过上图我们可以总结为：一个实例对象就对应一个 <code>ObjectAssociationMap</code>，而 <code>ObjectAssociationMap</code> 中存储着多个此实例对象的关联对象的 <code>key</code> 以及 <code>ObjcAssociation</code>，为 <code>ObjcAssociation</code> 中存储着关联对象的 <code>value</code> 和 <code>policy</code> 策略，关联对象由  <code>AssociationsManager</code> 管理并在  <code>AssociationsHashMap</code> 存储。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果 <code>category</code> 中的一个关联对象与 <code>Class</code> 中的某个成员同名，虽然 <code>key</code> 值不一定相同，自身的 <code>Class</code> 不一定相同，<code>policy</code> 也不一定相同，但是这样做会直接覆盖之前的成员，造成无法访问，但是其内部所有信息及数据全部存在。<br>例如我们对 <code>ViewController</code> 做一个 <code>Category</code>，来创建一个叫做 <code>view</code> 的成员，我们会发现在运行工程的时候，模拟器直接黑屏。<br>在 <code>viewDidLoad</code> 中下断点，甚至无法进入 <code>debug</code> 模式。因为 <code>view</code> 属性已经被覆盖，所以不会继续进行 <code>viewController</code> 的生命周期。<br>这一点很危险，所以我们要杜绝覆盖 <code>Class</code> 原来的属性，这会破坏 <code>Class</code> 原有的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;思考，如何给动态添加属性和方法？&lt;br&gt;答案：可以使用 &lt;code&gt;@property&lt;/code&gt; 给分类添加属性和方法；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@property&lt;/code&gt; 会做三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成实例变量 &lt;code&gt;_property&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS load 和 initialize 方法的区别</title>
    <link href="https://sunjinshuai.github.io/2022/05/23/iOS-load-%E5%92%8Cinitialize-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2022/05/23/iOS-load-%E5%92%8Cinitialize-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-05-23T04:40:42.000Z</published>
    <updated>2022-05-28T02:08:02.669Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load;</span><br><span class="line">+ (void)initialize;</span><br></pre></td></tr></table></figure><h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><p>如果你实现了 <code>+ load</code> 方法，那么当类被加载到内存时，它会自动被调用，并且是在 <code>main</code> 函数调用之前被调用。</p><h4 id="load-方法的调用栈"><a href="#load-方法的调用栈" class="headerlink" title="load 方法的调用栈"></a>load 方法的调用栈</h4><p>首先分析一下 <code>load</code> 方法是如何被调用的</p><p><img src="588630-79f9a27a6fad634c.png" alt="image.png"></p><p>从控制台的打印可以看出，运行之后，依然打印了 <code>XXXX load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p><code>load</code> 方法的调用顺序其实有迹可循，我们看到 <code>demo</code> 的项目设置如下：</p><p><img src="588630-578317d4cc2d9920.png" alt="image.png"></p><p>在 <code>TARGETS -&gt; Build Phases -&gt; Compile Sources</code>中调整一下文件的加载顺序：</p><p><img src="588630-0bdb3567814e7f69.png" alt="image.png"></p><p>结果发现：</p><p><code>+load</code> 方法会在 <code>runtime</code> 加载类、分类时调用；<br>每个类、分类的 <code>+load</code> 方法，在程序运行过程中只调用一次；</p><h4 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h4><p>1、先调用类的 <code>+load</code> 方法，<strong>类先于分类调用</strong>。</p><ul><li>按照编译先后顺序调用（先编译，先调用），<strong>文件的加载顺序靠前的类优先调用</strong>。</li><li>调用子类的 <code>+load</code> 方法之前会先调用父类的 <code>+load</code> 方法，即<strong>父类先于子类调用</strong>。<br>2、再调用分类的 <code>+load</code> 方法；</li><li>按照编译先后顺序调用（先编译，先调用），<strong>文件的加载顺序靠前的分类优先调用</strong>。</li></ul><h4 id="load方法如何加载到内存中"><a href="#load方法如何加载到内存中" class="headerlink" title="load方法如何加载到内存中"></a><code>load</code>方法如何加载到内存中</h4><p>使用 <code>Xcode</code> 添加一个符号断点 <code>+[Parent load]</code>：</p><p><img src="588630-fc3a92e363d99516.png" alt="image.png"></p><p>注意：<br>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p><p>重新运行程序。这时，代码会停在 <code>NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</code> 这一行的实现上：</p><p>左侧的调用栈很清楚的展示哪些方法被调用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0  +[Parent load]</span><br><span class="line">1  call_load_methods</span><br><span class="line">2  load_images</span><br><span class="line">3  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</span><br><span class="line">...</span><br><span class="line">13 _dyld_start</span><br></pre></td></tr></table></figure><p>从 <code>runtime</code> 初始化开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized &#x3D; false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    runtime_init();</span><br><span class="line">    exception_init();</span><br><span class="line">#if __OBJC2__</span><br><span class="line">    cache_t::init();</span><br><span class="line">#endif</span><br><span class="line">    _imp_implementationWithBlock_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line"></span><br><span class="line">#if __OBJC2__</span><br><span class="line">    didCallDyldNotifyRegister &#x3D; true;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先类的加载会先进行 <code>_objc_init</code> 函数的调用，最后来到 <code>_dyld_objc_notify_register</code> 函数，传入 <code>load_images</code>；</p><ul><li><code>map_images</code> 主要是在 <code>image</code> 加载进内容后对其二进制内容进行解析，初始化里面的类的结构等。</li><li><code>load_images</code> 主要是调用 <code>call_load_methods</code>。按照继承层次依次调用 <code>Class</code> 的 <code>+load</code> 方法然后再是 <code>Category</code> 的 <code>+load</code> 方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; didInitialAttachCategories 标记加载分类的，默认值为 false，</span><br><span class="line">    &#x2F;&#x2F; didCallDyldNotifyRegister 标记 _dyld_objc_notify_register 是否调用完成，</span><br><span class="line">    &#x2F;&#x2F; 此时为 false，所以暂时此 if 内部不会执行。</span><br><span class="line">    if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories &#x3D; true;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    &#x2F;&#x2F; 如果 mh 中不包含 +load 就直接不加锁 return（且 without taking locks）</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; hasLoadMethods 函数是根据 &#96;headerType *mhdr&#96; 的 &#96;__objc_nlclslist&#96; 区和 &#96;__objc_nlcatlist&#96; 区中是否有数据，</span><br><span class="line">    &#x2F;&#x2F; 来判断是否有 +load 函数要执行。(即是否包含非懒加载类和非懒加载分类) </span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line">    &#x2F;&#x2F; loadMethodLock 是一把递归互斥锁（加锁）</span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; runtimeLock 加锁</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        &#x2F;&#x2F; 获取所有要调用的 +load 方法</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    &#x2F;&#x2F; 调用获取到的所有 +load 方法</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括的说 <code>load_images</code> 函数就是用来调用类以及分类中的 <code>+load</code> 函数的；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span><br><span class="line">    &#x2F;&#x2F; 获取所有 __objc_nlclslist 区的数据（所有非懒加载类） </span><br><span class="line">    </span><br><span class="line">    classref_t const *classlist &#x3D; _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class +load has been called</span><br><span class="line">    &#x2F;&#x2F; #define RW_LOADED (1&lt;&lt;23)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; List of classes that need +load called (pending superclass +load)</span><br><span class="line">    &#x2F;&#x2F; This list always has superclasses first because of the way it is constructed</span><br><span class="line">    &#x2F;&#x2F; 由于其构造方式，此列表始终首先处理 superclasses 的 +load 函数</span><br><span class="line">    &#x2F;&#x2F; 需要调用 +load 的 classes 列表</span><br><span class="line">    &#x2F;&#x2F; static struct loadable_class *loadable_classes &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历这些非懒加载类，并将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法，</span><br><span class="line">    &#x2F;&#x2F; 用于下面 call_load_methods 函数调用 </span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span><br><span class="line">    &#x2F;&#x2F; 获取所有 __objc_nlcatlist 区的数据（所有非懒加载分类）</span><br><span class="line">    </span><br><span class="line">    category_t * const *categorylist &#x3D; _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历这些分类</span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat &#x3D; categorylist[i];</span><br><span class="line">        Class cls &#x3D; remapClass(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果没有找到分类所属的类就跳出当前循环，处理数组中的下一个分类</span><br><span class="line">        if (!cls) continue;  &#x2F;&#x2F; category for ignored weak-linked class</span><br><span class="line">        </span><br><span class="line">        if (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(&quot;Swift class extensions and categories on Swift &quot;</span><br><span class="line">                        &quot;classes are not allowed to have +load methods&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果分类所属的类没有实现就先去实现</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 断言</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; List of categories that need +load called (pending parent class +load)</span><br><span class="line">        &#x2F;&#x2F; 需要调用 +load 的 categories 列表</span><br><span class="line">        &#x2F;&#x2F; static struct loadable_category *loadable_categories &#x3D; nil;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 遍历这些分类，并将其 +load 方法添加到 loadable_categories 数组中保存</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prepare_load_methods</code> 用来获取所有要调用的 <code>+load</code> 方法（父类、子类、分类）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">&#x2F;&#x2F; cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 cls 不存在则 return（下面有一个针对 superclass 的递归调用）</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; DEBUG 模式下的断言，cls 必须是实现过的（这个在 _read_images 中已经实现了）</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class +load has been called</span><br><span class="line">    &#x2F;&#x2F; #define RW_LOADED (1&lt;&lt;23)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; RW_LOADED 是 class +load 已被调用的掩码</span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    &#x2F;&#x2F; 优先处理 superclass 的 +load 函数</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; static struct loadable_class *loadable_classes &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F; struct loadable_class &#123;</span><br><span class="line">    &#x2F;&#x2F;    Class cls;  &#x2F;&#x2F; may be nil</span><br><span class="line">    &#x2F;&#x2F;    IMP method;</span><br><span class="line">    &#x2F;&#x2F; &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将 cls 的 +load 函数添加到全局的 loadable_class 数组 loadable_classes 中，</span><br><span class="line">    &#x2F;&#x2F; loadable_class 结构体是用来保存类的 +load 函数的一个数据结构，其中 cls 是该类，method 则是 +load 函数的 IMP，</span><br><span class="line">    &#x2F;&#x2F; 这里也能看出 +load 函数是不走 OC 的消息转发机制的，它是直接通过 +load 函数的地址调用的！</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将 RW_LOADED 设置到类的 Flags 中</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>schedule_class_load</code> 将其 <code>+load</code> 方法添加到 <code>loadable_classes</code> 数组中；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule_class_load(cls-&gt;superclass);</span><br></pre></td></tr></table></figure><p>优先添加其父类的 <code>+load</code> 方法。（用于后续的 <code>call_load_methods</code> 函数调用。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading &#x3D; NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 加锁</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    &#x2F;&#x2F; 重入调用什么都不做；最外层的调用将完成工作。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果正在 loading 则 return，</span><br><span class="line">    &#x2F;&#x2F; 保证当前 +load 方法同时只有一次被调用</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建自动释放池</span><br><span class="line">    void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 循环调用</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. Repeatedly call class +loads until there aren&#39;t any more</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 调用类中的 +load 函数</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 loadable_classes 中的的类的 +load 函数，并且把 loadable_classes_used 置为 0</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. Call category +loads ONCE</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 调用 分类中的 +load 函数， 只调用一次 call_category_loads，因为上面的 call_class_loads 函数内部，</span><br><span class="line">        &#x2F;&#x2F; 已经把 loadable_classes_used 置为 0，所以除非有新的分类需要 +load，即 call_category_loads 返回 true，</span><br><span class="line">        &#x2F;&#x2F; 否则循环就结束了。 </span><br><span class="line">        more_categories &#x3D; call_category_loads();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line">    &#x2F;&#x2F; 如果 loadable_classes_used 大于 0，或者有更多分类需要调用 +load，则循环继续。（一般 loadable_classes_used 到这里基本就是 0 了）</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 自动释放池进行 pop</span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记处理完成了，可以进行下一个了</span><br><span class="line">    loading &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>call_load_methods</code>，开始调用 <code>+load</code> 方法，在 <code>while</code> 循环中，先循环遍历类、父类的 <code>+load</code> 方法，然后遍历分类的 <code>+load</code> 方法，然后找到 <code>@selector(load)</code> 的实现并执行。<br><code>(*load_method)(cls, SEL_load)</code> 代码就会调用 <code>+[XXObject load]</code> 方法。</p><h4 id="load-方法是如何被调用的？"><a href="#load-方法是如何被调用的？" class="headerlink" title="load 方法是如何被调用的？"></a>load 方法是如何被调用的？</h4><p>当 <code>Objective-C</code> 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入运行时的时候，进行回调。传入 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code>，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; GETSECT(_getObjc2NonlazyClassList, classref_t const, &quot;__objc_nlclslist&quot;);</span><br><span class="line">    &#x2F;&#x2F; 获取所有 __objc_nlclslist 区的数据（所有非懒加载类） </span><br><span class="line">    </span><br><span class="line">    classref_t const *classlist &#x3D; _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class +load has been called</span><br><span class="line">    &#x2F;&#x2F; #define RW_LOADED (1&lt;&lt;23)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; List of classes that need +load called (pending superclass +load)</span><br><span class="line">    &#x2F;&#x2F; This list always has superclasses first because of the way it is constructed</span><br><span class="line">    &#x2F;&#x2F; 由于其构造方式，此列表始终首先处理 superclasses 的 +load 函数</span><br><span class="line">    &#x2F;&#x2F; 需要调用 +load 的 classes 列表</span><br><span class="line">    &#x2F;&#x2F; static struct loadable_class *loadable_classes &#x3D; nil;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 遍历这些非懒加载类，并将其 +load 函数添加到 loadable_classes 数组中，优先添加其父类的 +load 方法，</span><br><span class="line">    &#x2F;&#x2F; 用于下面 call_load_methods 函数调用 </span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; GETSECT(_getObjc2NonlazyCategoryList, category_t * const, &quot;__objc_nlcatlist&quot;);</span><br><span class="line">    &#x2F;&#x2F; 获取所有 __objc_nlcatlist 区的数据（所有非懒加载分类）</span><br><span class="line">    </span><br><span class="line">    category_t * const *categorylist &#x3D; _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历这些分类</span><br><span class="line">    for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat &#x3D; categorylist[i];</span><br><span class="line">        Class cls &#x3D; remapClass(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果没有找到分类所属的类就跳出当前循环，处理数组中的下一个分类</span><br><span class="line">        if (!cls) continue;  &#x2F;&#x2F; category for ignored weak-linked class</span><br><span class="line">        </span><br><span class="line">        if (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(&quot;Swift class extensions and categories on Swift &quot;</span><br><span class="line">                        &quot;classes are not allowed to have +load methods&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果分类所属的类没有实现就先去实现</span><br><span class="line">        realizeClassWithoutSwift(cls, nil);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 断言</span><br><span class="line">        ASSERT(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; List of categories that need +load called (pending parent class +load)</span><br><span class="line">        &#x2F;&#x2F; 需要调用 +load 的 categories 列表</span><br><span class="line">        &#x2F;&#x2F; static struct loadable_category *loadable_categories &#x3D; nil;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 遍历这些分类，并将其 +load 方法添加到 loadable_categories 数组中保存</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">&#x2F;&#x2F; cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 cls 不存在则 return（下面有一个针对 superclass 的递归调用）</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; DEBUG 模式下的断言，cls 必须是实现过的（这个在 _read_images 中已经实现了）</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class +load has been called</span><br><span class="line">    &#x2F;&#x2F; #define RW_LOADED (1&lt;&lt;23)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; RW_LOADED 是 class +load 已被调用的掩码</span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    &#x2F;&#x2F; 优先处理 superclass 的 +load 函数</span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; static struct loadable_class *loadable_classes &#x3D; nil;</span><br><span class="line">    &#x2F;&#x2F; struct loadable_class &#123;</span><br><span class="line">    &#x2F;&#x2F;    Class cls;  &#x2F;&#x2F; may be nil</span><br><span class="line">    &#x2F;&#x2F;    IMP method;</span><br><span class="line">    &#x2F;&#x2F; &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将 cls 的 +load 函数添加到全局的 loadable_class 数组 loadable_classes 中，</span><br><span class="line">    &#x2F;&#x2F; loadable_class 结构体是用来保存类的 +load 函数的一个数据结构，其中 cls 是该类，method 则是 +load 函数的 IMP，</span><br><span class="line">    &#x2F;&#x2F; 这里也能看出 +load 函数是不走 OC 的消息转发机制的，它是直接通过 +load 函数的地址调用的！</span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 将 RW_LOADED 设置到类的 Flags 中</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，</p><ul><li>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> 递归把当前类和没有调用 <code>+ load</code> 方法的父类，通过 <code>add_class_to_loadable_list(cls)</code> 方法添加到 <code>loadable_classes</code> 列表中，<strong>保证父类在子类前调用 <code>+load</code> 方法</strong>。</li><li>通过 <code>_getObjc2NonlazyCategoryList</code> 获取所有的分类的列表之后，会通过 <code>remapClass</code> 获取分类对应的指针，然后调用<code>add_category_to_loadable_list</code> 把当前分类添加到 <code>loadable_categories</code> 列表中。</li></ul><p>在将镜像加载到运行时、对 <code>+load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>+load</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool loading &#x3D; NO;</span><br><span class="line">    bool more_categories;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 加锁</span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-entrant calls do nothing; the outermost call will finish the job.</span><br><span class="line">    &#x2F;&#x2F; 重入调用什么都不做；最外层的调用将完成工作。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果正在 loading 则 return，</span><br><span class="line">    &#x2F;&#x2F; 保证当前 +load 方法同时只有一次被调用</span><br><span class="line">    if (loading) return;</span><br><span class="line">    loading &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建自动释放池</span><br><span class="line">    void *pool &#x3D; objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 循环调用</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. Repeatedly call class +loads until there aren&#39;t any more</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 调用类中的 +load 函数</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 loadable_classes 中的的类的 +load 函数，并且把 loadable_classes_used 置为 0</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. Call category +loads ONCE</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 调用 分类中的 +load 函数， 只调用一次 call_category_loads，因为上面的 call_class_loads 函数内部，</span><br><span class="line">        &#x2F;&#x2F; 已经把 loadable_classes_used 置为 0，所以除非有新的分类需要 +load，即 call_category_loads 返回 true，</span><br><span class="line">        &#x2F;&#x2F; 否则循环就结束了。 </span><br><span class="line">        more_categories &#x3D; call_category_loads();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line">    &#x2F;&#x2F; 如果 loadable_classes_used 大于 0，或者有更多分类需要调用 +load，则循环继续。（一般 loadable_classes_used 到这里基本就是 0 了）</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 自动释放池进行 pop</span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记处理完成了，可以进行下一个了</span><br><span class="line">    loading &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不停调用类的 <code>+load</code> 方法，直到 <code>loadable_classes</code> 为空。</li><li>然后调用一次 <code>call_category_loads</code> 加载分类。</li><li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>+load</code> 方法。</li><li><strong>类先于分类调用</strong>。</li></ul><p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后通过对应的 <code>SEL</code> ，找到 <code>IMP</code> 的实现并执行。</p><h4 id="load-方法的应用"><a href="#load-方法的应用" class="headerlink" title="load 方法的应用"></a>load 方法的应用</h4><p>由于调用 <code>+load</code> 方法运行时间过早，环境很不安全，我们应该尽量减少 <code>+load</code> 方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在 <code>+load</code> 方法中。不过在这个时间点，所有的 <code>framework</code> 都已经加载到了运行时中，所以调用 <code>framework</code> 中的方法都是安全的。</p><h2 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h2><p><code>+initialize</code> 方法会在类第一次接收到消息时调用。</p><h4 id="调用顺序-1"><a href="#调用顺序-1" class="headerlink" title="调用顺序"></a>调用顺序</h4><p>先调用父类的 <code>+initialize</code> 方法，再调用子类的 <code>+initialize</code> 方法；<br>(先初始化父类，再初始化子类，每个类只会初始化1次)</p><h4 id="For-Example"><a href="#For-Example" class="headerlink" title="For Example"></a>For Example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject @end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123; &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行之后控制台没有任何输出；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Person : NSObject @end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">        [Person alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行之后没有直接调用 <code>+initialize</code> 方法。但是，这里也打印出了 <code>Person initialize</code> 字符串；<br>因此得出结论：<strong><code>+initialize</code> 只会在对应类的方法第一次被调用时，才会调用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Student : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">        [Student alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+[Person initialize]</span><br><span class="line">+[Student initialize]</span><br></pre></td></tr></table></figure><p>因此得出结论：<br><strong>先调用父类的 <code>+initialize</code> 方法，再调用子类的 <code>+initialize</code> 方法；</strong>(先初始化父类，再初始化子类，每个类只会初始化1次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person (Test1)</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Student : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student (Test1)</span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">        [Student alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+[Person(Test1) initialize]</span><br><span class="line">+[Student(Test1) initialize]</span><br></pre></td></tr></table></figure><p>因此得出结论：<br><strong><code>+initialize方法</code> 是通过 <code>objc_msgSend</code> 进行调用的，分类的加载顺序取决于编译的顺序，最后面参与编译的分类优先调用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Student : Person</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123; </span><br><span class="line">        [Student alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+[MJPerson initialize]</span><br><span class="line">+[MJPerson initialize]</span><br></pre></td></tr></table></figure><p>可见当子类未实现 <code>initialize</code> 方法，会调用父类 <code>initialize</code> 方法.<br>由于子类会继承父类的 <code>initialize</code> 方法，即使子类没有实现 <code>initialize</code> 方法，也会调用父类的方法，这会导致一个很严重的问题：<br>运行后发现父类的 <code>initialize</code> 方法竟然调用了两次：</p><p>虽然 <code>initialize</code> 方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; In Parent.m</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">if (self &#x3D;&#x3D; [Parent class]) &#123;</span><br><span class="line">    NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加上判断后，就不会因为子类而调用到自己的 <code>initialize</code> 方法了。</p><h4 id="底层原理分析"><a href="#底层原理分析" class="headerlink" title="底层原理分析"></a>底层原理分析</h4><p>在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p><p><img src="1d103c8c-f795-49e3-9f91-f4f456552aa7.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* The standard IMP lookup. </span><br><span class="line">* Without LOOKUP_INITIALIZE: tries to avoid +initialize (but sometimes fails)</span><br><span class="line">* Without LOOKUP_CACHE: skips optimistic unlocked lookup (but uses cache elsewhere)</span><br><span class="line">* Most callers should use LOOKUP_INITIALIZE and LOOKUP_CACHE</span><br><span class="line">* inst is an instance of cls or a subclass thereof, or nil if none is known.</span><br><span class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">*   If you don&#39;t want forwarding at all, use LOOKUP_NIL.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    Class curClass;</span><br><span class="line">    IMP methodPC &#x3D; nil;</span><br><span class="line">    Method meth;</span><br><span class="line">    bool triedResolver &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    methodListLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (behavior &amp; LOOKUP_CACHE) &#123;</span><br><span class="line">        methodPC &#x3D; _cache_getImp(cls, sel);</span><br><span class="line">        if (methodPC) goto out_nolock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check for freed class</span><br><span class="line">    if (cls &#x3D;&#x3D; _class_getFreedObjectClass())</span><br><span class="line">        return (IMP) _freedHandler;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Check for +initialize</span><br><span class="line">    if ((behavior &amp; LOOKUP_INITIALIZE)  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        initializeNonMetaClass (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, initializeNonMetaClass will send +initialize </span><br><span class="line">        &#x2F;&#x2F; and then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; The lock is held to make method-lookup + cache-fill atomic </span><br><span class="line">    &#x2F;&#x2F; with respect to method addition. Otherwise, a category could </span><br><span class="line">    &#x2F;&#x2F; be added but ignored indefinitely because the cache was re-filled </span><br><span class="line">    &#x2F;&#x2F; with the old value after the cache flush on behalf of the category.</span><br><span class="line"> retry:</span><br><span class="line">    methodListLock.lock();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try this class&#39;s cache.</span><br><span class="line"></span><br><span class="line">    methodPC &#x3D; _cache_getImp(cls, sel);</span><br><span class="line">    if (methodPC) goto done;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try this class&#39;s method lists.</span><br><span class="line"></span><br><span class="line">    meth &#x3D; _class_getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    if (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, cls, meth, sel);</span><br><span class="line">        methodPC &#x3D; method_getImplementation(meth);</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line"></span><br><span class="line">    curClass &#x3D; cls;</span><br><span class="line">    while ((curClass &#x3D; curClass-&gt;superclass)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        meth &#x3D; _cache_getMethod(curClass, sel, _objc_msgForward_impcache);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            if (meth !&#x3D; (Method)1) &#123;</span><br><span class="line">                &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">                log_and_fill_cache(cls, curClass, meth, sel);</span><br><span class="line">                methodPC &#x3D; method_getImplementation(meth);</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass method list.</span><br><span class="line">        meth &#x3D; _class_getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, curClass, meth, sel);</span><br><span class="line">            methodPC &#x3D; method_getImplementation(meth);</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">    if ((behavior &amp; LOOKUP_RESOLVER)  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        methodListLock.unlock();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        triedResolver &#x3D; YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help. </span><br><span class="line">    &#x2F;&#x2F; Use forwarding.</span><br><span class="line"></span><br><span class="line">    _cache_addForwardEntry(cls, sel);</span><br><span class="line">    methodPC &#x3D; _objc_msgForward_impcache;</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    methodListLock.unlock();</span><br><span class="line"></span><br><span class="line"> out_nolock:</span><br><span class="line">    if ((behavior &amp; LOOKUP_NIL) &amp;&amp; methodPC &#x3D;&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return methodPC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)</code> 实现了一套查找 <code>IMP</code> 的标准路径，也就是在消息转发<code>（Forward）</code>之前的逻辑。</p><p><code>lookUpImpOrForward</code> 接着做了如下两件事：</p><p>如果使用缓存（<code>cache</code> 参数为 <code>YES</code>），那就调用 <code>cache_getImp</code> 方法从缓存查找 <code>IMP</code>。<code>cache_getImp</code> 是用汇编语言写的，也可以在 <code>objc-msg-x86_64.s</code> 找到。<br>如果是第一次用到这个类且 <code>initialize</code> 参数为 <code>YES</code>（initialize &amp;&amp; !cls-&gt;isInitialized()），来判断当前类是否初始化过，如果存在父类，并且父类没有初始化，通过递归初始化父类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* class_initialize.  Send the &#39;+initialize&#39; message on demand to any</span><br><span class="line">* uninitialized class. Force initialization of superclasses first.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">void initializeNonMetaClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    bool reallyInitialize &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure super is done initializing BEFORE beginning to initialize cls.</span><br><span class="line">    &#x2F;&#x2F; See note about deadlock above.</span><br><span class="line">    supercls &#x3D; cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        initializeNonMetaClass(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Try to atomically set CLS_INITIALIZING.</span><br><span class="line">    SmallVector&lt;_objc_willInitializeClassCallback, 1&gt; localWillInitializeFuncs;</span><br><span class="line">    &#123;</span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">            cls-&gt;setInitializing();</span><br><span class="line">            reallyInitialize &#x3D; YES;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Grab a copy of the will-initialize funcs with the lock held.</span><br><span class="line">            localWillInitializeFuncs.initFrom(willInitializeFuncs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (reallyInitialize) &#123;</span><br><span class="line">        &#x2F;&#x2F; We successfully set the CLS_INITIALIZING bit. Initialize the class.</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Record that we&#39;re initializing this class so we can message it.</span><br><span class="line">        _setThisThreadIsInitializingClass(cls);</span><br><span class="line"></span><br><span class="line">        if (MultithreadedForkChild) &#123;</span><br><span class="line">            &#x2F;&#x2F; LOL JK we don&#39;t really call +initialize methods after fork().</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (auto callback : localWillInitializeFuncs)</span><br><span class="line">            callback.f(callback.context, cls);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Send the +initialize message.</span><br><span class="line">        &#x2F;&#x2F; Note that +initialize is sent to the superclass (again) if </span><br><span class="line">        &#x2F;&#x2F; this class doesn&#39;t implement +initialize. 2157218</span><br><span class="line">        if (PrintInitializing) &#123;</span><br><span class="line">            _objc_inform(&quot;INITIALIZE: thread %p: calling +[%s initialize]&quot;,</span><br><span class="line">                         objc_thread_self(), cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Exceptions: A +initialize call that throws an exception </span><br><span class="line">        &#x2F;&#x2F; is deemed to be a complete and successful +initialize.</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; Only __OBJC2__ adds these handlers. !__OBJC2__ has a</span><br><span class="line">        &#x2F;&#x2F; bootstrapping problem of this versus CF&#39;s call to</span><br><span class="line">        &#x2F;&#x2F; objc_exception_set_functions().</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @try</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             objc_thread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">#if __OBJC2__</span><br><span class="line">        @catch (...) &#123;</span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: +[%s initialize] &quot;</span><br><span class="line">                             &quot;threw an exception&quot;,</span><br><span class="line">                             objc_thread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            @throw;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Done initializing.</span><br><span class="line">            lockAndFinishInitializing(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else if (cls-&gt;isInitializing()) &#123;</span><br><span class="line">        &#x2F;&#x2F; We couldn&#39;t set INITIALIZING because INITIALIZING was already set.</span><br><span class="line">        &#x2F;&#x2F; If this thread set it earlier, continue normally.</span><br><span class="line">        &#x2F;&#x2F; If some other thread set it, block until initialize is done.</span><br><span class="line">        &#x2F;&#x2F; It&#39;s ok if INITIALIZING changes to INITIALIZED while we&#39;re here, </span><br><span class="line">        &#x2F;&#x2F;   because we safely check for INITIALIZED inside the lock </span><br><span class="line">        &#x2F;&#x2F;   before blocking.</span><br><span class="line">        if (_thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (!MultithreadedForkChild) &#123;</span><br><span class="line">            waitForInitializeToComplete(cls);</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; We&#39;re on the child side of fork(), facing a class that</span><br><span class="line">            &#x2F;&#x2F; was initializing by some other thread when fork() was called.</span><br><span class="line">            _setThisThreadIsInitializingClass(cls);</span><br><span class="line">            performForkChildInitialize(cls, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else if (cls-&gt;isInitialized()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Set CLS_INITIALIZING failed because someone else already </span><br><span class="line">        &#x2F;&#x2F;   initialized the class. Continue normally.</span><br><span class="line">        &#x2F;&#x2F; NOTE this check must come AFTER the ISINITIALIZING case.</span><br><span class="line">        &#x2F;&#x2F; Otherwise: Another thread is initializing this class. ISINITIALIZED </span><br><span class="line">        &#x2F;&#x2F;   is false. Skip this clause. Then the other thread finishes </span><br><span class="line">        &#x2F;&#x2F;   initialization and sets INITIALIZING&#x3D;no and INITIALIZED&#x3D;yes. </span><br><span class="line">        &#x2F;&#x2F;   Skip the ISINITIALIZING clause. Die horribly.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; We shouldn&#39;t be here. </span><br><span class="line">        _objc_fatal(&quot;thread-safe class init in objc runtime is buggy!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在父类，并且父类没有初始化，通过递归初始化父类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">supercls &#x3D; cls-&gt;superclass;</span><br><span class="line">if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">    initializeNonMetaClass(supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initializeNonMetaClass</code> 方法的主要作用自然是向未初始化的类发送 <code>+initialize</code> 消息，不过会通过<strong>递归</strong>向父类先发送 <code>+initialize</code> 消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向当前类发送 <code>+initialize</code> 消息。<br>验证结果：<br><strong>先调用父类的 <code>+initialize</code> 方法，再调用子类的 <code>+initialize</code> 方法；</strong>(先初始化父类，再初始化子类，每个类只会初始化1次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">monitor_locker_t lock(classInitLock);</span><br><span class="line">if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123;</span><br><span class="line">    cls-&gt;setInitializing();</span><br><span class="line">    reallyInitialize &#x3D; YES;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Grab a copy of the will-initialize funcs with the lock held.</span><br><span class="line">    localWillInitializeFuncs.initFrom(willInitializeFuncs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过加锁来设置 <code>CLS_INITIALIZING</code> 标志位；</p><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><ul><li>lockAndFinishInitializing</li><li>Mark a class as finished initializing and notify waiters, or queue for later.</li><li>If the superclass is also done initializing, then update </li><li>the info bits and notify waiting threads.</li><li>If not, update them later. (This can happen if this +initialize </li><li>was itself triggered from inside a superclass +initialize.)</li><li><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/<br>static void lockAndFinishInitializing(Class cls, Class supercls)<br>{<br>   monitor_locker_t lock(classInitLock);<br>   if (!supercls  ||  supercls-&gt;isInitialized()) {<pre><code>_finishInitializing(cls, supercls);</code></pre>   } else {<pre><code>_finishInitializingAfter(cls, supercls);</code></pre>   }<br>}</li></ul><p>完成初始化，如果父类已经初始化完成，设置 <code>CLS_INITIALIZING</code> 标志位。否则，在父类初始化完成之后再设置标志位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; We couldn&#39;t set INITIALIZING because INITIALIZING was already set.</span><br><span class="line">&#x2F;&#x2F; If this thread set it earlier, continue normally.</span><br><span class="line">&#x2F;&#x2F; If some other thread set it, block until initialize is done.</span><br><span class="line">&#x2F;&#x2F; It&#39;s ok if INITIALIZING changes to INITIALIZED while we&#39;re here,</span><br><span class="line">&#x2F;&#x2F;   because we safely check for INITIALIZED inside the lock</span><br><span class="line">&#x2F;&#x2F;   before blocking.</span><br><span class="line">if (_thisThreadIsInitializingClass(cls)) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125; else if (!MultithreadedForkChild) &#123;</span><br><span class="line">    waitForInitializeToComplete(cls);</span><br><span class="line">    return;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; We&#39;re on the child side of fork(), facing a class that</span><br><span class="line">    &#x2F;&#x2F; was initializing by some other thread when fork() was called.</span><br><span class="line">    _setThisThreadIsInitializingClass(cls);</span><br><span class="line">    performForkChildInitialize(cls, supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回，保证线程安全。</p><h4 id="Initialize-方法的应用"><a href="#Initialize-方法的应用" class="headerlink" title="Initialize 方法的应用"></a>Initialize 方法的应用</h4><p>由于 <code>initialize</code> 作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p><h4 id="initialize-和-load-的很大区别是"><a href="#initialize-和-load-的很大区别是" class="headerlink" title="+initialize 和 +load 的很大区别是"></a>+initialize 和 +load 的很大区别是</h4><p><code>+initialize</code> 和 <code>+load</code> 的很大区别是，<code>+initialize</code> 是通过 <code>objc_msgSend</code> 进行调用的，所以有以下特点：</p><ul><li><p>如果子类没有实现 <code>+initialize</code>，会调用父类的 <code>+initialize</code>（<strong>注意父类的 <code>+initialize</code> 方法可能会被调用多次，不代表父类初始化多次</strong>）。</p></li><li><p>如果分类实现了 <code>+initialize</code>，就覆盖类本身的 <code>+initialize</code> 调用。</p></li><li><p>调用方式<br>1&gt; <code>+load</code> 是根据函数地址直接调用<br>2&gt; <code>initialize</code> 是通过 <code>objc_msgSend</code> 调用</p></li><li><p>调用时刻<br>1&gt; <code>load</code> 是 <code>runtime</code> 加载类、分类的时候调用（只会调用1次）<br>2&gt; <code>initialize</code> 是类第一次接收到消息的时候调用，每一个类只会 <code>initialize</code> 一次（父类的 <code>initialize</code> 方法可能会被调用多次）</p></li></ul><p>load、initialize的调用顺序？</p><ul><li>load<br>1&gt; 先调用类的 <code>load</code><br>a) 先编译的类，优先调用 <code>load</code><br>b) 调用子类的 <code>load</code> 之前，会先调用父类的 <code>load</code></li></ul><p>2&gt; 再调用分类的 <code>load</code><br>a) 先编译的分类，优先调用 <code>load</code></p><ul><li>initialize<br>1&gt; 先初始化父类<br>2&gt; 再初始化子类（可能最终调用的是父类的 <code>initialize</code> 方法）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 Category 的本质以及加载过程</title>
    <link href="https://sunjinshuai.github.io/2022/05/22/%E6%B5%85%E8%B0%88-Category-%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BB%A5%E5%8F%8A%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://sunjinshuai.github.io/2022/05/22/%E6%B5%85%E8%B0%88-Category-%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%BB%A5%E5%8F%8A%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2022-05-22T07:32:02.000Z</published>
    <updated>2022-05-25T09:47:54.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Category</code> 是 <code>Objective-C 2.0</code> 之后添加的特性，一般我们使用 <code>Category</code> 的场景主要可以动态地为已经存在的类扩展新的属性和方法。这样做的好处就是：</p><ul><li>可以减少臃肿的代码。</li><li>可以把不同的功能拆开，方便以后的维护。</li></ul><p>以下源码来自于<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">opensource.apple.com</a>的<em>objc4-750.tar.gz</em>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Presen类 </span><br><span class="line">&#x2F;&#x2F; Presen.h</span><br><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line">@interface Preson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    int _age;</span><br><span class="line">&#125;</span><br><span class="line">- (void)run;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Presen.m</span><br><span class="line">#import &quot;Preson.h&quot;</span><br><span class="line">@implementation Preson</span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Person - run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Presen扩展1</span><br><span class="line">&#x2F;&#x2F; Presen+Test.h</span><br><span class="line">#import &quot;Preson.h&quot;</span><br><span class="line">@interface Preson (Test) &lt;NSCopying&gt;</span><br><span class="line">- (void)test;</span><br><span class="line">+ (void)abc;</span><br><span class="line">@property (assign, nonatomic) int age;</span><br><span class="line">- (void)setAge:(int)age;</span><br><span class="line">- (int)age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Presen+Test.m</span><br><span class="line">#import &quot;Preson+Test.h&quot;</span><br><span class="line">@implementation Preson (Test)</span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)abc</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setAge:(int)age</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">- (int)age</span><br><span class="line">&#123;</span><br><span class="line">    return 10;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Presen分类2</span><br><span class="line">&#x2F;&#x2F; Preson+Test2.h</span><br><span class="line">#import &quot;Preson.h&quot;</span><br><span class="line">@interface Preson (Test2)</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Preson+Test2.m</span><br><span class="line">#import &quot;Preson+Test2.h&quot;</span><br><span class="line">@implementation Preson (Test2)</span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Person (Test2) - run&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>实例对象的 <code>isa</code> 指针指向类对象，类对象的 <code>isa</code> 指针指向元类对象，当 <code>Preson</code> 对象调用 <code>run</code> 方法时，通过实例对象的 <code>isa</code> 指针找到类对象，然后在类对象中查找对象方法，如果没有找到，就通过类对象的 <code>superclass</code> 指针找到父类对象，接着去寻找 <code>run</code> 方法。</p><p>猜想结论：<br><strong>通过 runtime 机制动态将分类中的对象方法存储在类对象中的；将分类中类方法的话，存储在元类对象中。</strong></p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods; &#x2F;&#x2F; 对象方法</span><br><span class="line">    struct method_list_t *classMethods; &#x2F;&#x2F; 类方法</span><br><span class="line">    struct protocol_list_t *protocols; &#x2F;&#x2F; 协议</span><br><span class="line">    struct property_list_t *instanceProperties; &#x2F;&#x2F; 属性</span><br><span class="line">    &#x2F;&#x2F; Fields below this point are not always present on disk.</span><br><span class="line">    struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">        if (isMeta) return classMethods;</span><br><span class="line">        else return instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>name</code>：是指 <code>class_name</code> 而不是 <code>category_name</code>。</li><li><code>cls</code>：要扩展的类对象，编译期间是不会定义的，而是在运行时通过 * <code>name</code> 对应到对应的类对象。</li><li><code>instanceMethods</code>：category 中所有给类添加的实例方法的列表。</li><li><code>classMethods</code>：category 中所有添加的类方法的列表。 </li><li><code>protocols</code>：category 实现的所有协议的列表。 </li><li><code>instanceProperties</code>：category 中添加的所有属性。</li></ul><p>发现分类结构体中是不存在成员变量的，因此分类中是不允许添加成员变量的。分类中添加的属性并不会帮助我们自动生成成员变量，只会生成 <code>get</code> 和 <code>set</code> 方法的声明，需要自己去实现。</p><p><strong>从 category 的定义也可以看出 category 可以添加实例方法，类方法，甚至可以实现协议，添加属性，无法添加实例变量。</strong></p><h1 id="For-example"><a href="#For-example" class="headerlink" title="For example"></a>For example</h1><p>使用 <code>clang</code> 的命令去看看 <code>category</code> 到底会变成什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct objc_cache _objc_empty_cache;</span><br><span class="line">#pragma warning(disable:4273)</span><br><span class="line"></span><br><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_MJPerson_Test_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;test2&quot;, &quot;v16@0:8&quot;, (void *)_C_MJPerson_Test_test2&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_MJPerson;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_MJPerson_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">&quot;MJPerson&quot;,</span><br><span class="line">0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_MJPerson,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_MJPerson_$_Test(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_MJPerson_$_Test.cls &#x3D; &amp;OBJC_CLASS_$_MJPerson;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] &#x3D; &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_MJPerson_$_Test,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))&#x3D; &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_MJPerson_$_Test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从代码中可以发现：</p><p>编译器生成了 <code>_OBJC_$_CATEGORY_MJPerson_$_Test</code> 的结构体，<code>_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test</code> 对象方法，<br><code>_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test</code> 类方法，并且一一对应为上面结构体内赋值。<br>并且两者的命名格式都遵循了<strong>公共前缀+扩展列表+类名+category</strong>名字的命名方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;test&quot;, &quot;v16@0:8&quot;, (void *)_I_MJPerson_Test_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct &#x2F;*_method_list_t*&#x2F; &#123;</span><br><span class="line">unsigned int entsize;  &#x2F;&#x2F; sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;test2&quot;, &quot;v16@0:8&quot;, (void *)_C_MJPerson_Test_test2&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_MJPerson_$_Test</code> 和 <code>_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test</code> 结构体中可以找到分类中对应的对象方法和类方法。</p><p><code>_OBJC_$_CATEGORY_CLASS_METHODS_MJPerson_$_Test</code> 结构体中名称用 <code>static</code> 来修饰，目的是用来区分可以在不同分类中扩展各种列表以及后面的 <code>category</code> 结构体本身命名，所以在同一个编译单元里我们的 <code>category</code> 名不能重复，否则会出现编译错误。</p><h1 id="Category-的加载处理过程"><a href="#Category-的加载处理过程" class="headerlink" title="Category 的加载处理过程"></a>Category 的加载处理过程</h1><ul><li>通过 <code>Runtime</code> 加载某个类的所有 <code>Category</code> 数据</li><li>把所有 <code>Category</code> 的方法、属性、协议数据，合并到一个大数组中<br>后面参与编译的 <code>Category</code> 数据，会在数组的前面</li><li>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</li></ul><p><code>Category</code> 是依赖于 <code>dyld</code> 动态加载:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized &#x3D; false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized &#x3D; true;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; Register for unmap first, in case some +load unmaps something</span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                             1&#x2F;*batch*&#x2F;, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0&#x2F;*not batch*&#x2F;, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Category</code> 被附加到类上面是在 <code>map_images</code> 的时候发生的，在 <code>new-ABI</code> 的标准下，<code>_objc_init</code> 里面的调用的 <code>map_images</code> 最终会调用 <code>objc-runtime-new.mm</code> 里面的 <code>_read_images</code> 方法，而在 <code>_read_images</code> 方法的结尾，有以下的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _read_images</span><br><span class="line">* Perform initial processing of the headers in the linked </span><br><span class="line">* list beginning with headerList. </span><br><span class="line">*</span><br><span class="line">* Called by: map_images_nolock</span><br><span class="line">*</span><br><span class="line">* Locking: runtimeLock acquired by map_images</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; 读取镜像</span><br><span class="line">void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">        if (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: found %d classes during launch&quot;, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; namedClasses</span><br><span class="line">        &#x2F;&#x2F; Preoptimized classes don&#39;t go in this table.</span><br><span class="line">        &#x2F;&#x2F; 4&#x2F;3 is NXMapTable&#39;s load factor</span><br><span class="line">        int namedClassesSize &#x3D; </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 &#x2F; 3;</span><br><span class="line">        gdb_objc_realized_classes &#x3D;</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        allocatedClasses &#x3D; NXCreateHashTable(NXPtrPrototype, 0, nil);</span><br><span class="line">        </span><br><span class="line">        ts.log(&quot;IMAGE TIMES: first time tasks&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist &#x3D; </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        bool hasClassProperties &#x3D; hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat &#x3D; catlist[i];</span><br><span class="line">            Class cls &#x3D; remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                &#x2F;&#x2F; Category&#39;s target class is missing (probably weak-linked).</span><br><span class="line">                &#x2F;&#x2F; Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] &#x3D; nil;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;, </span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Process this category. </span><br><span class="line">            &#x2F;&#x2F; First, register the category with its target class. </span><br><span class="line">            &#x2F;&#x2F; Then, rebuild the class&#39;s method lists (etc) if </span><br><span class="line">            &#x2F;&#x2F; the class is realized. </span><br><span class="line">            bool classExists &#x3D; NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 重新组织类对象</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists &#x3D; YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                if (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 重新组织元类对象</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中看出，<br>通过 <code>_getObjc2ClassList</code> 方法获取所有的 <code>Category</code> 然后添加到 <code>catlist</code> 数组中；把 <code>Category</code> 的实例方法、协议以及属性添加到类上；把 <code>Category</code> 的类方法和协议添加到类的 <code>metaclass</code> 上。<code>addUnattachedCategoryForClass</code> 方法只是把类和 <code>Category</code> 做一个关联映射。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Re-methodizing: check for more categories</span><br><span class="line">    if ((cats &#x3D; unattachedCategoriesForClass(cls, false&#x2F;*not realizing*&#x2F;))) &#123;</span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &#39;%s&#39; %s&quot;, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 把类对象或者元类对象的分类信息附加到原来的类里面</span><br><span class="line">        attachCategories(cls, cats, true &#x2F;*flush caches*&#x2F;);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remethodizeClass</code> 方法将  <code>Category</code> 合并到类中，然后更新类的方法列表、协议列表和属性列表，更新类以及子类的方法缓存。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategories(Class cls, category_list *cats, bool flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line">    &#x2F;&#x2F; 根据 isMeta 判断是类对象还是元类对象</span><br><span class="line">    bool isMeta &#x3D; cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; fixme rearrange to remove these intermediate allocations</span><br><span class="line">    &#x2F;&#x2F; 方法数组(二位数组)</span><br><span class="line">    method_list_t **mlists &#x3D; (method_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class="line">    &#x2F;&#x2F; 属性数组(二位数组)</span><br><span class="line">    property_list_t **proplists &#x3D; (property_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class="line">    &#x2F;&#x2F; 协议数组(二位数组)</span><br><span class="line">    protocol_list_t **protolists &#x3D; (protocol_list_t **)</span><br><span class="line">        malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount &#x3D; 0;</span><br><span class="line">    int propcount &#x3D; 0;</span><br><span class="line">    int protocount &#x3D; 0;</span><br><span class="line">    int i &#x3D; cats-&gt;count;</span><br><span class="line">    bool fromBundle &#x3D; NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 取出某一个分类</span><br><span class="line">        auto&amp; entry &#x3D; cats-&gt;list[i];</span><br><span class="line">        &#x2F;&#x2F; 将分类中的方法存入 mlist 数组中</span><br><span class="line">        method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] &#x3D; mlist;</span><br><span class="line">            fromBundle |&#x3D; entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将分类中的属性方法存入 mlist 数组中</span><br><span class="line">        property_list_t *proplist &#x3D; </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        if (proplist) &#123;</span><br><span class="line">            proplists[propcount++] &#x3D; proplist;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将分类中的协议存入 mlist 数组中</span><br><span class="line">        protocol_list_t *protolist &#x3D; entry.cat-&gt;protocols;</span><br><span class="line">        if (protolist) &#123;</span><br><span class="line">            protolists[protocount++] &#x3D; protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; class_rw 结构体，用来存储类对象的对象方法，属性方法和协议</span><br><span class="line">    auto rw &#x3D; cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    &#x2F;&#x2F; 将所有分类的对象方法列表附加到类对象的方法列表中</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    free(mlists);</span><br><span class="line">    if (flush_caches  &amp;&amp;  mcount &gt; 0) flushCaches(cls);</span><br><span class="line">    &#x2F;&#x2F; 将所有分类的对象属性方法列表附加到类对象的属性方法列表中</span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    free(proplists);</span><br><span class="line">    &#x2F;&#x2F; 将所有分类的对象协议列表附加到类对象的协议列表中</span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    free(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attachCategories</code> 方法中，将方法列表、属性和协议列表从 <code>Category</code> 合并到类中。<br>综上所述：<br>首先根据方法列表，属性列表，协议列表，<code>malloc</code> 分配内存，根据多少个分类以及每一块方法需要多少内存来分配相应的内存地址。</p><p>通过 <code>while</code> 循环，遍历所有的 <code>Category</code>，得到它的方法列表 <code>mlist</code> 、<code>proplist</code> 和 <code>protolist</code> 并存入 <code>mlists</code> 、<code>proplists</code> 和 <code>protolists</code> 中。换句话说，它的主要作用就是将 <code>Category</code> 中的方法、属性和协议拼接到类（主类或元类）中，更新类的数据字段 <code>data()</code> 中 <code>mlist</code>、<code>proplist</code> 和 <code>protolist</code> 的值。</p><p>之后通过类对象的 <code>data()</code> 方法，拿到类对象的 <code>class_rw_t</code> 结构体 <code>rw</code>，调用方法列表、属性列表、协议列表的 <code>attachList</code> 函数，将所有的分类的方法、属性、协议列表数组传进去，将分类和本类相应的对象方法，属性，和协议进行了合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">        if (addedCount &#x3D;&#x3D; 0) return;</span><br><span class="line">        </span><br><span class="line">        if (hasArray()) &#123;</span><br><span class="line">            &#x2F;&#x2F; many lists -&gt; many lists</span><br><span class="line">            uint32_t oldCount &#x3D; array()-&gt;count;</span><br><span class="line">            uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">            setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">            array()-&gt;count &#x3D; newCount;</span><br><span class="line">            &#x2F;&#x2F; array()-&gt;lists 原来的方法列表</span><br><span class="line">            memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class="line">                    oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">            &#x2F;&#x2F; addedLists 所有分类的方法列表，属性列表，协议列表</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!list  &amp;&amp;  addedCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F; 0 lists -&gt; 1 list</span><br><span class="line">            list &#x3D; addedLists[0];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 1 list -&gt; many lists</span><br><span class="line">            List* oldList &#x3D; list;</span><br><span class="line">            uint32_t oldCount &#x3D; oldList ? 1 : 0;</span><br><span class="line">            uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">            setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">            array()-&gt;count &#x3D; newCount;</span><br><span class="line">            if (oldList) array()-&gt;lists[addedCount] &#x3D; oldList;</span><br><span class="line">            memcpy(array()-&gt;lists, addedLists,</span><br><span class="line">                   addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attachList</code> 函数中 <code>memmove</code> 内存移动和 <code>memcpy</code> 内存拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; memmove ：内存移动。</span><br><span class="line">&#x2F;*  __dst : 移动内存的目的地</span><br><span class="line">*   __src : 被移动的内存首地址</span><br><span class="line">*   __len : 被移动的内存长度</span><br><span class="line">*   将__src的内存移动__len块内存到__dst中</span><br><span class="line">*&#x2F;</span><br><span class="line">void    *memmove(void *__dst, const void *__src, size_t __len);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; memcpy ：内存拷贝。</span><br><span class="line">&#x2F;*  __dst : 拷贝内存的拷贝目的地</span><br><span class="line">*   __src : 被拷贝的内存首地址</span><br><span class="line">*   __n : 被移动的内存长度</span><br><span class="line">*   将__src的内存移动__n块内存到__dst中</span><br><span class="line">*&#x2F;</span><br><span class="line">void    *memcpy(void *__dst, const void *__src, size_t __n);</span><br></pre></td></tr></table></figure><p>经过 <code>memmove</code> 和 <code>memcpy</code> 方法之后，分类的方法，属性，协议列表被放在了类对象中原本存储的方法，属性，协议列表前面。为了保证分类方法优先调用，我们知道当分类重写本类的方法时，会覆盖本类的方法。其实经过上面的分析我们知道本质上并不是覆盖，而是优先调用，本类的方法依然在内存中的。</p><p>通过以上可以看出：</p><ul><li><code>Category</code> 的方法没有“完全替换掉”原来类已经有的方法，也就是说如果 <code>Category</code> 和原来类都有 <code>methodA</code>，那么 <code>category</code> 附加完成之后，类的方法列表里会有两个 <code>methodA</code>。</li><li><code>Category</code> 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的 <code>Category</code> 的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休，殊不知后面可能还有一样名字的方法。</li></ul><p><strong>分类的加载顺序取决于编译的顺序，最后面参与编译的分类优先调用。</strong></p><h1 id="Category和Class-Extension的区别是什么"><a href="#Category和Class-Extension的区别是什么" class="headerlink" title="Category和Class Extension的区别是什么"></a>Category和Class Extension的区别是什么</h1><p><code>Class Extension</code> 在编译的时候，它的数据就已经包含在类信息中。<br><code>Category</code> 是在运行时，才会将数据合并到类信息中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Category&lt;/code&gt; 是 &lt;code&gt;Objective-C 2.0&lt;/code&gt; 之后添加的特性，一般我们使用 &lt;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈-KVC-的实现原理</title>
    <link href="https://sunjinshuai.github.io/2022/05/21/%E6%B5%85%E8%B0%88-KVC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2022/05/21/%E6%B5%85%E8%B0%88-KVC-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-21T13:28:58.000Z</published>
    <updated>2022-05-22T03:51:36.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>KVC</code> 是 <code>KeyValue Coding</code> 的简称，俗称“键值编码”，遵循 <code>NSKeyValueCoding</code> 协议，它是一种可以直接通过字符串的名字 <code>key</code> 来访问类属性的机制，而不是通过调用 <code>setter</code>、<code>getter</code> 方法访问。</p><p>对于 <code>KVC</code>，<code>Cocoa</code> 自动放入和取出基本数据类型放入 <code>NSNumber</code> 或 <code>NSValue</code> 中，当使用 <code>setValue:ForKey:</code> 或者 <code>valueForKey:</code> 时，它自动将基本数据类型从这些对象中取出，仅 <code>KVC</code> 具有这种自动包装功能，常规方法调用和属性语法不具备该功能。</p><h1 id="setValue-forKey-的实现方式："><a href="#setValue-forKey-的实现方式：" class="headerlink" title="setValue:forKey 的实现方式："></a><code>setValue:forKey</code> 的实现方式：</h1><p><img src="7cf60206-2acb-4640-92b9-611ed55d2662.png" alt="image.png"></p><p>以字符串的形式向对象发送消息，如果成员用 <code>@property</code>，因为 <code>@synthsize</code> 告诉编译器自动生成 <code>set&lt;Key&gt;:</code> 格式的 <code>setter</code> 方法，所以这种情况下会直接搜索到。<br>首先查找以 <code>set&lt;Key&gt;</code> 命名的 <code>setter</code> 方法，如果没有找到查找以 <code>_set&lt;Key&gt;</code> 命名的方法；如果上面的方法没有找到，如果类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。如果找到则设置成员的值，如果没有查找调用 <code>setValue:forUndefinedKey:</code>。</p><h1 id="valueForKey-的实现方式："><a href="#valueForKey-的实现方式：" class="headerlink" title="valueForKey: 的实现方式："></a><code>valueForKey:</code> 的实现方式：</h1><p><img src="846ae0ee-7b6e-4a21-848e-605644f7c3e7.png" alt="image.png"></p><ul><li>首先查找以 <code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code>、<code>_Key</code> 的顺序查找方法，找到直接调用。</li><li>若是还没查到，那么如果类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。</li><li>再没查到，调用 <code>valueForUndefinedKey:</code>。</li></ul><p>综上，<strong>使用 KVC 访问属性的代价比直接使用存取方法性能开销要大</strong>。</p><h1 id="值的正确性核查"><a href="#值的正确性核查" class="headerlink" title="值的正确性核查"></a>值的正确性核查</h1><p>KVC 提供属性值确认的 API，它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p><p>实现核查方法，为如下格式：<code>validate&lt;Key&gt;:error:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</span><br><span class="line">    &#x2F;&#x2F; The name must not be nil, and must be at least two characters long.</span><br><span class="line">    if ((*ioValue &#x3D;&#x3D; nil) || ([(NSString *)*ioValue length] &lt; 2]) &#123;</span><br><span class="line">        if (outError !&#x3D; NULL) &#123;</span><br><span class="line">            NSString *errorString &#x3D; NSLocalizedStringFromTable(</span><br><span class="line">                    @&quot;A Person&#39;s name must be at least two characters long&quot;, @&quot;Person&quot;,</span><br><span class="line">                    @&quot;validation: too short name error&quot;);</span><br><span class="line">            NSDictionary *userInfoDict &#x3D;</span><br><span class="line">                [NSDictionary dictionaryWithObject:errorString</span><br><span class="line">                                            forKey:NSLocalizedDescriptionKey];</span><br><span class="line">            *outError &#x3D; [[[NSError alloc] initWithDomain:PERSON_ERROR_DOMAIN</span><br><span class="line">                                                    code:PERSON_INVALID_NAME_CODE</span><br><span class="line">                                                userInfo:userInfoDict] autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用核查方法：<br><code>validateValue:forKey:error:</code>，默认实现会搜索 <code>validate&lt;Key&gt;:error:</code>格式的核查方法，找到则调用，未找到默认返回 <code>YES</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;KVC&lt;/code&gt; 是 &lt;code&gt;KeyValue Coding&lt;/code&gt; 的简称，俗称“键值编码”，遵循 &lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVO 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2022/05/21/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2022/05/21/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-21T09:28:58.000Z</published>
    <updated>2022-05-21T12:51:09.396Z</updated>
    
    <content type="html"><![CDATA[<p><code>KVO</code> 全称 <code>KeyValueObserving</code>，俗称“键值监听”，可以用于监听某个对象属性值的改变；是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，当指定的对象的属性被修改后，则对象就会接受收到通知。简单的说就是每次指定的被观察的对象的属性被修改后，<code>KVO</code> 就会自动通知相应的观察者了。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">    Person *p2 &#x3D; [[Person alloc] init];</span><br><span class="line">    p1.age &#x3D; 10;</span><br><span class="line">    p2.age &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; self 监听 p1的 age属性</span><br><span class="line">    NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">   p1.age &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [p1 removeObserver:self forKeyPath:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;监听到%@的%@改变了%@&quot;, object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印内容</span><br><span class="line">监听到&lt;Person: 0x604000205460&gt;的age改变了&#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 10;</span><br><span class="line">    old &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，在添加监听之后，<code>p1</code> 的 <code>age</code> 属性的值在发生改变时，就会通知到监听者，执行监听者的 <code>observeValueForKeyPath</code> 方法。并且我们知道赋值操作都是调用 <code>set</code> 方法，所以我们可以在 <code>Person</code> 类中重写 <code>age</code> 的 <code>set</code> 方法，观察 <code>KVO</code> 是否是在 <code>set</code> 方法内部做了那些操作来通知监听者。<br>通过代码发现即使重写了 <code>set</code> 方法，<code>p1</code> 对象和 <code>p2</code> 对象调用同样的 <code>set</code> 方法；</p><p><img src="d73f2af1-8e68-4c85-826a-751ad061b768.png" alt="image.png"></p><p>通过上述代码断点可以得知，<code>p1</code> 对象的指针指向 <code>NSKVONotifying_Person</code>，<code>p2</code> 对象的指针指向 <code>Person</code>。<br>得出结论，<strong>如果一个类实现 <code>KVO</code> 的监听，那么他的 isa 指针指向的就不是原来对象自己，而是指向了另外的一个类对象。如果一个类没有实现 <code>KVO</code> 的监听，那么他的 isa 指针指向的还是对象自己。</strong></p><p>未使用 <code>KVO</code> 监听对象的 <code>isa</code> 指针</p><p><img src="7e0c457f-b210-47c0-900d-f4f9fb97298f.png" alt="image.png"></p><p>使用 <code>KVO</code> 监听对象的 <code>isa</code> 指针<br><img src="45ed9bad-047c-467f-b756-cf0bc8e6259e.png" alt="image.png"></p><p><code>NSKVONotifyin_Person</code> 其实是 <code>Person</code> 的子类，是通过 <code>runtime</code> 动态生成的，<code>NSKVONotifyin_Person</code> 的 <code>superclass</code> 指针是指向 <code>Person</code> 类对象。<br>上述，那么 <code>p1</code> 对象在调用 <code>setage</code> 方法的时候，会根据 <code>p1</code> 的 <code>isa</code> 指针找到 <code>NSKVONotifyin_Person</code> 类对象，在 <code>NSKVONotifyin_Person</code> 中找 <code>setage</code> 的方法实现。<code>NSKVONotifyin_Person</code> 中的 <code>setage</code> 方法中其实调用了 <code>Fundation</code> 框架中 <code>C</code> 语言函数 <code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code> 内部的实现，首先调用 <code>willChangeValueForKey</code> 即将要改变某一个属性，之后调用父类的 <code>setage</code> 方法修改成员变量，最后调用 <code>didChangeValueForKey</code>。在 <code>didChangeValueForKey</code> 中会调用监听器的监听属性的值发生了改变，最终执行 <code>observeValueForKeyPath:ofObject:change:context</code>方法。</p><h4 id="验证-KVO-的实现"><a href="#验证-KVO-的实现" class="headerlink" title="验证 KVO 的实现"></a>验证 KVO 的实现</h4><p>验证 <code>p1</code> 对象和 <code>p2</code> 对象的 <code>setage</code> 方法实现的地址在添加 KVO 前后有什么变化。</p><p>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;person1添加KVO监听之前 - %@ %@&quot;,</span><br><span class="line">          object_getClass(self.person1),</span><br><span class="line">          object_getClass(self.person2));</span><br><span class="line">    </span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;person1添加KVO监听之后 - %@ %@&quot;,</span><br><span class="line">          object_getClass(self.person1),</span><br><span class="line">          object_getClass(self.person2));</span><br><span class="line"></span><br><span class="line">2022-05-21 17:31:23.574690+0800 Interview01[13188:7235501] setAge:</span><br><span class="line">2022-05-21 17:31:23.574865+0800 Interview01[13188:7235501] setAge:</span><br><span class="line">2022-05-21 17:31:23.575033+0800 Interview01[13188:7235501] person1添加KVO监听之前 - MJPerson MJPerson</span><br><span class="line">2022-05-21 17:31:23.575488+0800 Interview01[13188:7235501] person1添加KVO监听之后 - NSKVONotifying_MJPerson MJPerson</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;person1添加KVO监听之前 - %p %p&quot;,</span><br><span class="line">          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">          [self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">    </span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;person1添加KVO监听之后 - %p %p&quot;,</span><br><span class="line">          [self.person1 methodForSelector:@selector(setAge:)],</span><br><span class="line">          [self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line"></span><br><span class="line">2022-05-21 17:35:16.211930+0800 Interview01[13890:7253559] setAge:</span><br><span class="line">2022-05-21 17:35:16.212151+0800 Interview01[13890:7253559] setAge:</span><br><span class="line">2022-05-21 17:35:16.212314+0800 Interview01[13890:7253559] person1添加KVO监听之前 - 0x108791510 0x108791510</span><br><span class="line">2022-05-21 17:35:16.212811+0800 Interview01[13890:7253559] person1添加KVO监听之后 - 0x1098c4e53 0x108791510</span><br></pre></td></tr></table></figure><p>通过 lldb 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (IMP)0x108791510</span><br><span class="line">(IMP) $0 &#x3D; 0x0000000108791510 (Interview01&#96;-[MJPerson setAge:] at MJPerson.m:13)</span><br><span class="line">(lldb) p (IMP)0x1098c4e53</span><br><span class="line">(IMP) $1 &#x3D; 0x00000001098c4e53 (Foundation&#96;_NSSetIntValueAndNotify)</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p>在添加 <code>KVO</code> 监听之前，<code>p1</code> 对象和 <code>p2</code> 对象的 <code>setAge</code> 方法实现的地址相同，而在 <code>KVO</code> 监听之后，<code>p1</code> 对象的 <code>setAge</code> 方法实现的地址发生了变化，<code>p1</code> 对象的 <code>setAge</code> 方法的实现由 <code>Person</code> 类方法中的 <code>setAge</code> 方法转换为了 <code>C</code> 语言的 <code>Foundation</code> 框架的 <code>_NSsetIntValueAndNotify</code> 函数。</p><p>验证 <code>_NSsetIntValueAndNotify</code> 的 <code>isa</code> 指针指向哪里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;类对象 - %p %p&quot;,</span><br><span class="line">          object_getClass(self.person1),  &#x2F;&#x2F; self.person1.isa</span><br><span class="line">          object_getClass(self.person2)); &#x2F;&#x2F; self.person2.isa</span><br><span class="line"></span><br><span class="line">2022-05-21 17:52:32.172451+0800 Interview01[16839:7328143] 类对象 - 0x600003094090 0x1050be218</span><br></pre></td></tr></table></figure><p>验证 <code>_NSsetIntValueAndNotify</code> 的 <code>metaclass</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">[p1 addObserver:self forKeyPath:@&quot;age&quot; options:options context:nil];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;元类对象 - %p %p&quot;,</span><br><span class="line">          object_getClass(object_getClass(self.person1)), &#x2F;&#x2F; self.person1.isa.isa</span><br><span class="line">          object_getClass(object_getClass(self.person2))); &#x2F;&#x2F; self.person2.isa.isa</span><br><span class="line"></span><br><span class="line">2022-05-21 17:52:32.172610+0800 Interview01[16839:7328143] 元类对象 - 0x600003094120 0x1050be240</span><br></pre></td></tr></table></figure><p>由此得出，<code>_NSsetIntValueAndNotify</code> 类对象的 <code>isa</code> 指针指向 <code>_NSsetIntValueAndNotify</code> <code>metaclass</code>。</p><h4 id="NSKVONotifyin-Person-的内部实现"><a href="#NSKVONotifyin-Person-的内部实现" class="headerlink" title="NSKVONotifyin_Person 的内部实现"></a><code>NSKVONotifyin_Person</code> 的内部实现</h4><p>在 <code>Person</code> 类中重写 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，模拟他们的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(int)age</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;setAge:&quot;);</span><br><span class="line">    _age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey: - begin&quot;);</span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey: - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey: - begin&quot;);</span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey: - end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2022-05-21 18:13:59.766153+0800 Interview01[16839:7328143] didChangeValueForKey - begin</span><br><span class="line">2022-05-21 18:13:59.766818+0800 Interview01[16839:7328143] 监听到&lt;MJPerson: 0x6000000980a0&gt;的age属性值改变了 - &#123;</span><br><span class="line">    kind &#x3D; 1;</span><br><span class="line">    new &#x3D; 21;</span><br><span class="line">    old &#x3D; 1;</span><br><span class="line">&#125; - 123</span><br><span class="line">2022-05-21 18:13:59.767129+0800 Interview01[16839:7328143] didChangeValueForKey - end</span><br></pre></td></tr></table></figure><p>通过控制图打印内容可以看到，证明了在 <code>didChangeValueForKey</code> 方法内部已经调用了 <code>observer</code> 的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</p><h4 id="自动触发-KVO-的监听方法"><a href="#自动触发-KVO-的监听方法" class="headerlink" title="自动触发 KVO 的监听方法"></a>自动触发 KVO 的监听方法</h4><p>手动调用 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法；</p><h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul><li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li><li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li><li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li></ul><h1 id="KVO-实现原理："><a href="#KVO-实现原理：" class="headerlink" title="KVO 实现原理："></a>KVO 实现原理：</h1><p><code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p></blockquote><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。重写的 <code>setter</code> 方法会在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针指向这个新创建的类，对象变成了新创建的类的实例，而不是原来真正的类。</p><h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a>KVO 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。<br>例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@interface TestKVOViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Message *message;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestKVOViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    </span><br><span class="line">    Message *message &#x3D; [[Message alloc] init];</span><br><span class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    message.text &#x3D; @&quot;hello object-c&quot;;</span><br><span class="line">    self.message &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</span><br><span class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &#39;NSRangeException&#39;, reason: &#39;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&#39;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</span><br><span class="line">1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</span><br><span class="line">2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</span><br><span class="line">3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</span><br><span class="line">4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</span><br><span class="line">5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</span><br><span class="line">6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</span><br><span class="line">7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</span><br><span class="line">8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</span><br><span class="line">9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</span><br><span class="line">10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</span><br><span class="line">11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</span><br><span class="line">12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</span><br><span class="line">14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</span><br><span class="line">16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</span><br><span class="line">17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</span><br><span class="line">18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</span><br><span class="line">19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</span><br><span class="line">20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</span><br><span class="line">21  ImplementKVO                        0x000000010dd2dfef main + 111</span><br><span class="line">22  libdyld.dylib                       0x00000001129fe955 start + 1</span><br><span class="line">23  ???                                 0x0000000000000001 0x0 + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure><h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (KVO)</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">forKey:(NSString *)key</span><br><span class="line">withBlock:(ObservingBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p><ul><li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li><li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li><li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li><li>添加这个观察者；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</span><br><span class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</span><br><span class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</span><br><span class="line"> 4. 将调用对象添加到数组中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">             forKey:(NSString *)key</span><br><span class="line">          withBlock:(ObservingBlock)block &#123;</span><br><span class="line">    </span><br><span class="line">    SEL setterSelector &#x3D; NSSelectorFromString(setterForGetter(key));</span><br><span class="line">    Method setterMethod &#x3D; class_getInstanceMethod([self class], setterSelector);</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class clazz &#x3D; object_getClass(self);</span><br><span class="line">    NSString *clazzName &#x3D; NSStringFromClass(clazz);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; if not an KVO class yet</span><br><span class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</span><br><span class="line">        clazz &#x3D; [self makeKvoClassWithOriginalClassName:clazzName];</span><br><span class="line">        object_setClass(self, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; add our kvo setter if this class (not superclasses) doesn&#39;t implement the setter?</span><br><span class="line">    if (![self hasSelector:setterSelector]) &#123;</span><br><span class="line">        const char *types &#x3D; method_getTypeEncoding(setterMethod);</span><br><span class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ObservationInfo *info &#x3D; [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    if (!observers) &#123;</span><br><span class="line">        observers &#x3D; [NSMutableArray array];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p><p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 判断是否存在KVO类，如果存在则返回。</span><br><span class="line"> 2. 如果不存在，则创建KVO类。</span><br><span class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</span><br><span class="line">    NSString *kvoClazzName &#x3D; [kKVOClassPrefix stringByAppendingString:originalClazzName];</span><br><span class="line">    Class clazz &#x3D; NSClassFromString(kvoClazzName);</span><br><span class="line">    </span><br><span class="line">    if (clazz) &#123;</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class doesn&#39;t exist yet, make it</span><br><span class="line">    Class originalClazz &#x3D; object_getClass(self);</span><br><span class="line">    Class kvoClazz &#x3D; objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; grab class method&#39;s signature so we can borrow it</span><br><span class="line">    Method clazzMethod &#x3D; class_getInstanceMethod(originalClazz, @selector(class));</span><br><span class="line">    const char *types &#x3D; method_getTypeEncoding(clazzMethod);</span><br><span class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</span><br><span class="line">    </span><br><span class="line">    objc_registerClassPair(kvoClazz);</span><br><span class="line">    </span><br><span class="line">    return kvoClazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p><p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSString *setterName &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line">    NSString *getterName &#x3D; getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    if (!getterName) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id oldValue &#x3D; [self valueForKey:getterName];</span><br><span class="line">    </span><br><span class="line">    struct objc_super superclazz &#x3D; &#123;</span><br><span class="line">        .receiver &#x3D; self,</span><br><span class="line">        .super_class &#x3D; class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; cast our pointer so the compiler won&#39;t complain</span><br><span class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) &#x3D; (void *)objc_msgSendSuper;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; call super&#39;s setter, which is original class&#39;s setter method</span><br><span class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; look up observers and call the blocks</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    for (ObservationInfo *each in observers) &#123;</span><br><span class="line">        if ([each.key isEqualToString:getterName]) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                each.block(self, getterName, oldValue, newValue);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p><p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface ObservationInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) NSObject *observer;</span><br><span class="line">@property (nonatomic, copy) NSString *key;</span><br><span class="line">@property (nonatomic, copy) ObservingBlock block;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ObservationInfo</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObserver:(NSObject *)observer</span><br><span class="line">                             Key:(NSString *)key</span><br><span class="line">                           block:(ObservingBlock)block &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _observer &#x3D; observer;</span><br><span class="line">        _key &#x3D; key;</span><br><span class="line">        _block &#x3D; block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Strikers/MYKit" target="_blank" rel="noopener">KVO crash 防护方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 全称 &lt;code&gt;KeyValueObserving&lt;/code&gt;，俗称“键值监听”，可以用于监听某个对象属性值的改变；是 &lt;code&gt;Objective-C&lt;/code&gt; 对观察者模式&lt;code&gt;(Observer Pattern)&lt;/c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之二：数据结构</title>
    <link href="https://sunjinshuai.github.io/2022/05/17/iOS-RunTime%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://sunjinshuai.github.io/2022/05/17/iOS-RunTime%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-05-17T13:01:12.000Z</published>
    <updated>2022-05-17T13:11:47.804Z</updated>
    
    <content type="html"><![CDATA[<p><img src="94c23c27-7848-4abb-b0cd-e6c26f963e64.png" alt="Paste_Image.png"></p><p>通过这张图描述了<a href="https://github.com/iOS-Notes/iOS-Notes/tree/master/sourcecode/ObjectModel" target="_blank" rel="noopener">实例对象，类，元类之间的关系</a>；<br>图中实线是 <code>super_class</code> 指针，虚线是 <code>isa</code> 指针。<br>从图中看出：</p><ul><li>当发送一个实例方法的消息时，<code>isa</code> 指针会在这个类的实例方法列表中查找；</li><li>当发送一个类方法的消息时，<code>isa</code> 指针会在这个类的 <code>meta-class</code> 的方法列表中查找，<code>meta-class</code> 之所以重要，是因为它存储着一个类的所有类方法。</li><li>每个类都会有一个单独的 <code>meta-class</code>，因为每个类的类方法基本不可能完全相同。</li></ul><h4 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure><p>万物皆对象，通过源码分析，<code>NSObject</code> 里面包含一个 <code>objc_class</code> 结构体类型的 <code>isa</code> 指针；</p><h4 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h4><p><img src="%E5%9B%BE%E7%89%873.png" alt="Paste_Image.png"></p><p>通过源码分析：<br><code>objc_class</code> 里面包含一个 <code>objc_class</code> 结构体类型的 <code>superclass</code> 指针，可以通过 <code>superclass</code> 指针，查找到父类；<br><code>cache_t</code> 结构体的 <code>cache</code> 指针，<code>cache</code> 主要用于方法性能优化，对使用过的方法进行缓存，便于第二次查找；<br><code>class_data_bits_t</code> 结构体的 <code>bits</code> 指针，只含有一个 <code>64</code> 位的 <code>bits</code> 用于存储与类有关的信息；</p><p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 <code>rr/alloc</code> 的标志。</p><p>通过将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，返回 <code>class_rw_t *</code> 指针，其中 <code>Objc</code> 的类的属性、方法、以及遵循的协议都放在 <code>class_rw_t</code> 结构体中；</p><h4 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t occupied();</span><br><span class="line">    void incrementOccupied();</span><br><span class="line">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class="line">    void initializeToEmpty();</span><br><span class="line"></span><br><span class="line">    mask_t capacity();</span><br><span class="line">    bool isConstantEmptyCache();</span><br><span class="line">    bool canBeFreed();</span><br><span class="line"></span><br><span class="line">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class="line">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    void expand();</span><br><span class="line">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class="line">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key &#x3D; newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp &#x3D; newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>cache</code> 主要是为了优化方法调用的性能，一个接收者对象接收到一个消息时，它会根据 isa 指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是 <code>methodLists</code> 中遍历一遍，性能势必很差。这时，<code>cache</code> 就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到 <code>cache</code> 列表中，下次调用的时候就会优先去 <code>cache</code> 中查找，才去 <code>methodLists</code> 中查找方法。</p><p>从源码中可以看出，<br><code>_buckets</code> 指针是一个指向 <code>bucket_t</code> 结构体的哈希表，<code>_buckets</code> 哈希表里面包含多个 <code>bucket_t</code>，每个 <code>bucket_t</code> 里面存放着 <code>SEL</code> 和 <code>imp</code> 函数的内存地址的对应关系；<br><code>_mask</code> 是一个 <code>uint32_t</code> 的指针，表示整个 <code>_buckets</code> 哈希表的长度；<br><code>_occupied</code> 也是一个 <code>uint32_t</code> 的指针，在 <code>_buckets</code> 哈希表中已经缓存的方法数量；</p><p>在 <code>bucket_t</code> 结构体中，<code>_key</code> 是一个 <code>unsigned long</code> 的指针，其实是一个被 <code>hash</code> 化的一串数值，就是方法的 <code>sel</code>，也就是方法名；<code>_imp</code> 指针保持着对应的函数地址；</p><h6 id="cache-t-如何缓存-sel"><a href="#cache-t-如何缓存-sel" class="headerlink" title="cache_t 如何缓存 sel"></a>cache_t 如何缓存 sel</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">void cache_fill(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cache_fill_nolock(cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Never cache before +initialize is done</span><br><span class="line">    &#x2F;&#x2F; 系统要求在类初始化完成之前，不能进行方法返回，因此如果类没有完成初始化就 return</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span><br><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">    &#x2F;&#x2F; 因为有可能其他线程已经把该方法缓存起来，如果缓存中已经缓存过了，不用再缓存，直接 return</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache &#x3D; getCache(cls);</span><br><span class="line">    cache_key_t key &#x3D; getKey(sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span><br><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is too full. Expand it.</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span><br><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot because the </span><br><span class="line">    &#x2F;&#x2F; minimum size is 4 and we resized at 3&#x2F;4 full.</span><br><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity &#x3D; capacity();</span><br><span class="line">    uint32_t newCapacity &#x3D; oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    if ((uint32_t)(mask_t)newCapacity !&#x3D; newCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; mask overflow - can&#39;t grow further</span><br><span class="line">        &#x2F;&#x2F; fixme this wastes one bit of mask</span><br><span class="line">        newCapacity &#x3D; oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    bool freeOld &#x3D; canBeFreed();</span><br><span class="line"></span><br><span class="line">    bucket_t *oldBuckets &#x3D; buckets();</span><br><span class="line">    bucket_t *newBuckets &#x3D; allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache&#39;s old contents are not propagated. </span><br><span class="line">    &#x2F;&#x2F; This is thought to save cache memory at the cost of extra cache fills.</span><br><span class="line">    &#x2F;&#x2F; fixme re-measure this</span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; 0);</span><br><span class="line">    assert((uintptr_t)(mask_t)(newCapacity-1) &#x3D;&#x3D; newCapacity-1);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - 1);</span><br><span class="line">    </span><br><span class="line">    if (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先看缓存中是否已经存在了该方法，如果已经存在，直接return掉；</li><li>如果缓存是只读的，则需要重新申请缓存空间；</li><li>如果存入缓存后的大小小于当前大小的 <code>3/4</code>，则当前缓存大小还可以使用，无需扩容；</li><li>如果缓存太满，需要扩容，扩容为原来大小的 <code>2</code> 倍，重新申请缓存空间；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 &#x3D; 2,</span><br><span class="line">    INIT_CACHE_SIZE      &#x3D; (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>如果是首次调用这个函数，会使用一个初始容量值 <code>INIT_CACHE_SIZE</code> 来设定缓存容量；从 <code>INIT_CACHE_SIZE</code> 的定义显示它的值是 <code>4</code>，也就是说苹果给 <code>cache_t</code> 设定的初始容量是 <code>4</code>。</li><li>重新设置哈希表的长度 <code>_mask = newCapacity-1</code>，然后将旧内存释放掉，清空缓存；</li><li>当通过 <code>find()</code> 方法返回的 <code>bucket-&gt;key() == 0</code>，就说明该位置上是空的，没有缓存过方法，因此可以进行插入操作 <code>bucket-&gt;set(key, imp)</code>，也就是将方法缓存到这个位置上。</li></ul><p><strong>注意：传入 <code>cls</code> 得到缓存列表，如果是 <code>instance</code> 对象，返回 <code>class</code> 对象；如果是 <code>class</code> 对象，返回 <code>meta-class</code> 对象；如果是 <code>meta-class</code> 对象，返回 <code>NSObject</code> 的 <code>meta-class</code> 对象；</strong></p><h6 id="cache-t-如何查找-sel"><a href="#cache-t-如何查找-sel" class="headerlink" title="cache_t 如何查找 sel"></a>cache_t 如何查找 sel</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; mask();</span><br><span class="line">    &#x2F;&#x2F; 通过 cache_hash() 计算出 key 值 k 对应的 index 值 begin，用来记录查询起始索引；</span><br><span class="line">    mask_t begin &#x3D; cache_hash(k, m);</span><br><span class="line">    &#x2F;&#x2F; begin 赋值给 i，用于切换索引</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 用这个 i 从哈希表取值，如果取出来的 bucket_t 的 key &#x3D; k，则查询成功，返回该 bucket_t。</span><br><span class="line">        &#x2F;&#x2F; 如果 key &#x3D; 0，说明在索引 i 的位置上还没有缓存过方法，同样需要返回该 bucket_t，用于中止缓存查询。</span><br><span class="line">        if (b[i].key() &#x3D;&#x3D; 0  ||  b[i].key() &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i &#x3D; cache_next(i, m)) !&#x3D; begin);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hack</span><br><span class="line">    Class cls &#x3D; (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>cache_t</code> 如何查找 <code>sel</code>，本质上就是根据 <code>key</code> 如何查找 <code>index</code> 的过程；</strong><br>根据 <code>key</code> 计算出 <code>index</code> 值的这个算法称作哈希算法，尽可能减少不同的 <code>key</code> 得出相同 <code>index</code> 的情况出现，这种情况被称作哈希碰撞，同时还要保证得出的 <code>index</code> 值在合理的范围。<code>index</code> 越大，意味着对应的哈希表的长度越长，这是需要占用实际物理空间的，而内存是有限的。<br><strong>哈希表是一种通过牺牲一定空间，来换取时间效率的设计思想。</strong></p><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><strong>SEL</strong></h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在<code>Objc</code>中的表示类型（<code>Swift</code>中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的<code>id</code>，而这个<code>id</code>的数据结构是<code>SEL</code>，即表示一个方法的<code>selector</code>的指针。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-f1c54b79137a3a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><ul><li>方法的<code>selector</code>用于表示运行时方法的名字，<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>int</code>类型的地址)，这个标识就是<code>SEL</code>。</li><li>在<code>Objective-C</code>中，只要方法名相同，那么方法的<code>SEL</code>就是一样的，每一个方法都对应着一个<code>SEL</code>，所以在<code>Objective-C</code>中，同一个类中或者这个类的继承体系中，不能存在2个同名的方法，不同的类可以拥有相同的<code>selector</code>，不同的类的实例对象执行相同的<code>selector</code>，会在各自的方法列表中根据<code>selector</code>去寻找对应的<code>IMP</code>。</li><li>在本质上，<code>SEL</code>只是一个指向方法的指针（被<code>hash</code>化得<code>KEY</code>值），能提高方法的查询速度。</li></ul><h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><strong>IMP</strong></h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure><p>第一个参数是指向 <code>self</code> 的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器( <code>selector</code> )，接下来是方法的实际参数列表。</p><p><code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的，由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>。</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><strong>Method</strong></h4><p><code>Method</code>是一种代表类中的某个方法的类型。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-c75430d85b645678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-382fc04a120fc065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>注意：</p><ul><li>方法名类型为<code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li><li>方法类型<code>method_types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li><li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针。</li></ul><h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a><strong>Ivar</strong></h4><p><code>Ivar</code>是一种代表类中实例变量的类型。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-dcb54cf3c9cc43ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4f01a318d7041fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>参考资料<br><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/</a><br><a href="https://draveness.me/isa" target="_blank" rel="noopener">https://draveness.me/isa</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;94c23c27-7848-4abb-b0cd-e6c26f963e64.png&quot; alt=&quot;Paste_Image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;通过这张图描述了&lt;a href=&quot;https://github.com/iOS-Notes/iOS-Notes
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS superclass 和 isa 指针总结</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/iOS-superclass%E5%92%8Cisa-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/iOS-superclass%E5%92%8Cisa-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T11:25:09.000Z</published>
    <updated>2022-05-15T13:14:49.247Z</updated>
    
    <content type="html"><![CDATA[<p><img src="94c23c27-7848-4abb-b0cd-e6c26f963e64.png" alt="image.png"></p><ul><li><code>instance</code> 的 <code>isa</code> 指针指向 <code>class</code>；</li><li><code>class</code> 的 <code>isa</code> 指向 <code>meta-class</code>；</li><li><code>meta-class</code> 的 <code>isa</code> 指针指向基类的 <code>meta-class</code>；</li><li><code>class</code> 的 <code>superclass</code> 指针指向父类的 <code>class</code>；<br>如果没有父类，<code>superclass</code> 指针为 <code>nil</code></li><li><code>meta-class</code> 的 <code>superclass</code> 指针指向父类的 <code>meta-class</code>；</li><li>基类的 <code>meta-class</code> 的 <code>superclass</code> 指针指向基类的 <code>class</code>；</li></ul><p><code>instance</code> 调用对象方法的轨迹<br>通过 <code>isa</code> 指针找到 <code>class</code>，方法不存在，就通过 <code>superclass</code> 指针找父类，如果父类方法不存在，就通过 <code>superclass</code> 指针找根类(也就是 <code>NSObject</code>)，如果根类方法不存在，就会报 <code>unrecognized selector</code> 错误；</p><p><code>class</code> 调用类方法的轨迹<br>通过 <code>isa</code> 指针找 <code>meta-class</code>，方法不存在，就通过 <code>superclass</code> 找父类的 <code>meta-class</code>，如果父类的 <code>meta-class</code> 方法不存在，就通过 <code>superclass</code> 指针找根类(也就是 <code>NSObject</code>)的 <code>meta-class</code>，如果根类的 <code>meta-class</code> 方法不存在，就通过 <code>superclass</code> 找根类的 <code>class</code>，如果根类方法不存在，就会报 <code>unrecognized selector</code> 错误；</p><p><img src="36c7dac5-38e7-4086-989b-31d8ce4ba551.png" alt="image.png"><br><img src="5f0349f5-7cd6-4517-a405-7a8975e8b7cd.png" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p&#x2F;x (long)person-&gt;isa</span><br><span class="line">p&#x2F;x personClass</span><br></pre></td></tr></table></figure><p>从 <code>64bit</code> 开始，<code>isa</code> 需要进行一次位运算，才能计算出真实地址；说明，实例对象 <code>isa</code> 指针里面存放的地址值应该是这个类对象的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p&#x2F;x (long)person-&gt;isa</span><br><span class="line">p&#x2F;x studentClass-&gt;superclass</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;94c23c27-7848-4abb-b0cd-e6c26f963e64.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;instance&lt;/code&gt; 的 &lt;code&gt;isa&lt;/code&gt; 指针指向 &lt;code&gt;cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS superclass 指针</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/iOS-superclass-%E6%8C%87%E9%92%88/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/iOS-superclass-%E6%8C%87%E9%92%88/</id>
    <published>2022-05-15T08:25:09.000Z</published>
    <updated>2022-05-15T11:50:03.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2297f39e-58dd-4194-9aa7-b555bc9839e9.png" alt="image.png"></p><ul><li><code>class</code> 对象的 <code>superclass</code> 指针</li></ul><p>当 <code>Student</code> 的 <code>instance</code>对象要调用 <code>Person</code> 的对象方法时，会先通过 <code>isa</code> 指针找到 <code>Student</code> 的 <code>class</code>，然后通过 <code>superclass</code> 指针找到 <code>Person</code> 的 <code>class</code>，最后找到对象方法的实现进行调用；</p><p><img src="1652613038862.jpg" alt="image.png"></p><ul><li><code>meta-class</code> 对象的 <code>superclass</code> 指针</li></ul><p>当 <code>Student</code> 的 <code>class</code> 要调用 <code>Person</code> 的类方法时，会先通过 <code>isa</code> 指针找到 <code>Student</code> 的 <code>meta-class</code>，然后通过 <code>superclass</code> 指针找到 <code>Person</code> 的 <code>meta-class</code>，最后找到类方法的实现进行调用；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;2297f39e-58dd-4194-9aa7-b555bc9839e9.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; 对象的 &lt;code&gt;superclass&lt;/code&gt; 指针&lt;/li&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS isa 指针</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/iOS-isa-%E6%8C%87%E9%92%88/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/iOS-isa-%E6%8C%87%E9%92%88/</id>
    <published>2022-05-15T08:15:09.000Z</published>
    <updated>2022-05-15T11:50:07.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="6c03c3e0-e575-4136-bc80-f8593db0e0af.png" alt="image.png"></p><ul><li><p>实例对象的 <code>isa</code> 指针<br>实例对象的 <code>isa</code> 指向 <code>class</code>；<br>当调用实例对象方法时，通过实例对象的 <code>isa</code> 找到对应的实例对象 <code>class</code>，最后找到对象方法的实现进行调用；</p></li><li><p>类对象的 <code>isa</code> 指针<br>类对象的 <code>isa</code> 指向 <code>meta-class</code><br>当调用类方法时，通过 <code>class</code> 的 <code>isa</code> 找到 <code>meta-class</code>，最后找到类方法的实现进行调用；</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;6c03c3e0-e575-4136-bc80-f8593db0e0af.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实例对象的 &lt;code&gt;isa&lt;/code&gt; 指针&lt;br&gt;实例对象的 &lt;code&gt;isa&lt;/code&gt; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>objc_getClass、object_getClass 的区别</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/objc-getClass%E3%80%81object-getClass-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/objc-getClass%E3%80%81object-getClass-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-05-15T07:50:48.000Z</published>
    <updated>2022-05-15T07:58:37.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="objc-getClass、object-getClass-的区别"><a href="#objc-getClass、object-getClass-的区别" class="headerlink" title="objc_getClass、object_getClass 的区别"></a>objc_getClass、object_getClass 的区别</h3><ul><li><p>objc_getClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getClass(const char *aClassName)</span><br><span class="line">1&gt; 传入字符串类名</span><br><span class="line">2&gt; 返回对应的类对象</span><br></pre></td></tr></table></figure></li><li><p>object_getClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">1&gt; 传入的 obj 可能是实例对象、class 对象和 meta_class 对象</span><br><span class="line">2&gt; 返回指</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果传入的是实例对象，则返回类对象；</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果传入的是 class 对象，则返回 meta_class 对象；</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果传入的是 meta_class 对象，则返回 NSObject 对象的 meta_class 对象；</span><br></pre></td></tr></table></figure></li><li><ul><li>(Class)class、+ (Class)class<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回的就是对象</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;objc-getClass、object-getClass-的区别&quot;&gt;&lt;a href=&quot;#objc-getClass、object-getClass-的区别&quot; class=&quot;headerlink&quot; title=&quot;objc_getClass、object_getCl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一个NSObject对象占用多少个字节</title>
    <link href="https://sunjinshuai.github.io/2022/05/07/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
    <id>https://sunjinshuai.github.io/2022/05/07/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/</id>
    <published>2022-05-07T07:53:06.000Z</published>
    <updated>2022-05-07T08:04:54.152Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Objective-C</code> 中，我们可以通过一些方法来获取一个 <code>NSObject</code> 对象占用多少字节；<br>代码获取 <code>NSObject</code> 实例对象的成员变量字节大小</p><ul><li><p>获取一个 <code>NSObject</code> 实例对象的成员变量所占用的字节大小，可以用 <code>runtime</code> 的 <code>api</code>， <code>class_getInstanceSize</code> 来获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Returns the size of instances of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param cls A class object.</span><br><span class="line"> * </span><br><span class="line"> * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT size_t</span><br><span class="line">class_getInstanceSize(Class _Nullable cls) </span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8</span><br><span class="line">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));</span><br></pre></td></tr></table></figure></li><li><p>也可以通过 <code>malloc_size</code> 来获取</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern size_t malloc_size(const void *ptr);</span><br><span class="line">&#x2F;* Returns size of given ptr *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得obj指针所指向内存的大小 &gt;&gt; 16</span><br><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));</span><br></pre></td></tr></table></figure><ul><li>通过 lldb</li></ul><p><img src="4fe6154609b94d2e8dff2f95b173a0f6.png" alt="image.png"></p><p>总之，系统分配了 <code>16</code> 个字节给 <code>NSObject</code> 对象，但是 <code>NSObject</code> 对象只使用了 <code>8</code> 个字节的空间；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;Objective-C&lt;/code&gt; 中，我们可以通过一些方法来获取一个 &lt;code&gt;NSObject&lt;/code&gt; 对象占用多少字节；&lt;br&gt;代码获取 &lt;code&gt;NSObject&lt;/code&gt; 实例对象的成员变量字节大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RunLoop 的应用</title>
    <link href="https://sunjinshuai.github.io/2022/03/21/RunLoop-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2022/03/21/RunLoop-%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-03-21T00:18:04.000Z</published>
    <updated>2022-03-21T00:21:24.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ImageView-优化"><a href="#ImageView-优化" class="headerlink" title="ImageView 优化"></a>ImageView 优化</h3><p><code>UITableView</code> 在滚动的时候一个优化点之一就是 <code>UIImageView</code> 的显示，通常需要根据网络去下载图片。所以如果用户快速滚动列表的时候，如果立马下载并显示图片的话，势必会对 <code>UI</code> 的刷新产生影响，直观的表现就是会卡顿，<code>FPS</code> 达不到 <code>60</code>。</p><p>利用 <code>RunLoop</code> 可以实现这个效果，就是给下载并显示图片的方法指定 <code>NSRunLoopMode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickLoadIMage:(UIButton *)sender &#123;</span><br><span class="line">    &#x2F;&#x2F;[self.imageview performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;test&quot;] afterDelay:2];</span><br><span class="line">    [self performSelector:@selector(downloadAndShowImage) withObject:nil afterDelay:2 inModes:@[NSDefaultRunLoopMode, UITrackingRunLoopMode]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)downloadAndShowImage &#123;</span><br><span class="line">    self.imageview.image &#x3D; [UIImage imageNamed:@&quot;test&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ImageView-优化&quot;&gt;&lt;a href=&quot;#ImageView-优化&quot; class=&quot;headerlink&quot; title=&quot;ImageView 优化&quot;&gt;&lt;/a&gt;ImageView 优化&lt;/h3&gt;&lt;p&gt;&lt;code&gt;UITableView&lt;/code&gt; 在滚动的时
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>百度云盘破解</title>
    <link href="https://sunjinshuai.github.io/2022/03/20/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    <id>https://sunjinshuai.github.io/2022/03/20/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98%E7%A0%B4%E8%A7%A3/</id>
    <published>2022-03-20T11:18:37.000Z</published>
    <updated>2022-03-20T11:20:11.063Z</updated>
    
    <content type="html"><![CDATA[<p>会员体验一般为 <code>60</code> 秒，通过本代码可以一直以会员的速度下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CodeTips&#x2F;BaiduNetdiskPlugin-macOS.git &amp;&amp; .&#x2F;BaiduNetdiskPlugin-macOS&#x2F;Other&#x2F;Install.sh</span><br></pre></td></tr></table></figure><p>百度网盘全速下载</p><ul><li>先将你需要下载的地址复制进浏览器</li><li>然后在域名 <code>baidu</code> 后面拼接 <code>wp</code></li><li>回车。访问页面，选择下载地址 <code>1</code> 即可全速下载。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前</span><br><span class="line">https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1ubcQH34m69hIjYu3CD2S2g</span><br><span class="line">&#x2F;&#x2F; 之后</span><br><span class="line">https:&#x2F;&#x2F;pan.baiduwp.com&#x2F;s&#x2F;1ubcQH34m69hIjYu3CD2S2g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会员体验一般为 &lt;code&gt;60&lt;/code&gt; 秒，通过本代码可以一直以会员的速度下载。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS 渲染流程</title>
    <link href="https://sunjinshuai.github.io/2022/02/09/iOS-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>https://sunjinshuai.github.io/2022/02/09/iOS-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-02-09T10:33:05.000Z</published>
    <updated>2022-02-09T10:41:02.677Z</updated>
    
    <content type="html"><![CDATA[<p>原生界面更新渲染的流程，可以分为以下四步。</p><ul><li>第一步，更新视图树，同步更新图层树。</li><li>第二步，<code>CPU</code> 计算要显示的内容，包括视图创建（设置 <code>Layer</code> 的属性）、布局计算、视图绘制（创建 <code>Layer</code> 的 <code>Backing Image</code>）、图像解码转换。当 <code>runloop</code> 在 <code>BeforeWaiting</code> 和 <code>Exit</code> 时，会通知注册的监听，然后对图层打包，打完包后，将打包数据发送给一个独立负责渲染的进程 <code>Render Server</code>。</li><li>第三步，数据到达 <code>Render Server</code> 后会被反序列化，得到图层树，按照图层树中图层顺序、<code>RGBA</code> 值、图层 <code>frame</code> 过滤图层中被遮挡的部分，过滤后将图层树转成渲染树，渲染树的信息会转给 <code>OpenGL ES/Metal</code>。前面 <code>CPU</code> 所处理的这些事情统称为 <code>Commit Transaction</code>。</li><li>第四步，<code>Render Server</code> 会调用 <code>GPU</code>，<code>GPU</code> 开始进行前面提到的顶点着色器、形状装配、几何着色器、光栅化、片段着色器、测试与混合六个阶段。完成这六个阶段的工作后，再将 <code>CPU</code> 和 <code>GPU</code> 计算后的数据显示在屏幕的每个像素点上。</li></ul><p>整个渲染过程，如下图所示：<br><img src="d4ae58f7b0d09725757dca84ea7a318f.png" alt="image.png"></p><p>如上图所示，<code>CPU</code> 处理完渲染内容会输入到 <code>Render Server</code> 中，经图层树和渲染树的转换，通过 <code>OpenGL</code> 接口提供给 <code>GPU</code>，<code>GPU</code> 处理完后在屏幕上显示。渲染过程中 <code>Commit Trasaction</code> 的布局计算会重载视图 <code>LayoutSubviews</code> 方法，以及执行 <code>addSubview</code> 方法来添加视图。视图绘制会重载视图的 <code>drawRect</code> 方法。这几个方法都是 <code>iOS</code> 开发中常用的。</p><p>移动视图位置、删除视图、隐藏或显示视图、调用 <code>setNeedsDisplay</code> 或 <code>setNeedsDisplayInRect</code> 方法，都会触发界面更新，执行渲染流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原生界面更新渲染的流程，可以分为以下四步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，更新视图树，同步更新图层树。&lt;/li&gt;
&lt;li&gt;第二步，&lt;code&gt;CPU&lt;/code&gt; 计算要显示的内容，包括视图创建（设置 &lt;code&gt;Layer&lt;/code&gt; 的属性）、布局计算、视图绘制（
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈面向对象的六大设计原则</title>
    <link href="https://sunjinshuai.github.io/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://sunjinshuai.github.io/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2019-10-27T03:13:57.000Z</published>
    <updated>2022-02-10T07:12:05.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="588630-7d17a7d220c612f0.png" alt="image.png"></p><h3 id="原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="原则一、单一职责原则（Single Responsibility Principle，简称SRP ）"></a>原则一、单一职责原则（Single Responsibility Principle，简称SRP ）</h3><p>定义：应该有且仅有一个原因引起类的变更。</p><p>一个类只负责一项职责，如果发生变更时，可以考虑将一个类拆分成两个类，或者在一个类中添加新的方法。</p><p><strong>在真实的开发中，不仅仅是类、函数和接口也要遵循单一职责原则。即：一个函数负责一个功能。如果一个函数里面有不同的功能，则需要将不同的功能的函数分离出去。</strong></p><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li><li>类的可读性提高，复杂性减低。</li></ul><p>如果接口或者函数的单一职责做得好，一个接口或者函数的修改只对相应的类有影响，对其他接口或者函数无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><p>例如，需求上指出用一个类描述食肉和食草动物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 17:55:25.775317+0800 DesignPatterns[54087:24701786] 狼 吃肉</span><br><span class="line">2018-10-27 17:55:25.775689+0800 DesignPatterns[54087:24701786] 豹 吃肉</span><br><span class="line">2018-10-27 17:55:25.775721+0800 DesignPatterns[54087:24701786] 虎 吃肉</span><br></pre></td></tr></table></figure><p>上线后，发现问题了，并不是所有的动物都是吃肉的，比如羊就是吃草的。修改时如果遵循单一职责原则，需要将 <code>Animal</code> 类细分为食草动物类 <code>Herbivore</code>，食肉动物 <code>Carnivore</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Herbivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Herbivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Herbivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Carnivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Carnivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Carnivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Animal *carnivore &#x3D; [Carnivore new];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">NSLog(@&quot;\n&quot;);</span><br><span class="line">Animal *herbivore &#x3D; [Herbivore new];</span><br><span class="line">[herbivore eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>在子类里面重写父类的 <code>eatWithAnimalName</code> 函数，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:04:49.189722+0800 DesignPatterns[54422:24725132] 狼 吃肉</span><br><span class="line">2018-10-27 18:04:49.190450+0800 DesignPatterns[54422:24725132] 豹 吃肉</span><br><span class="line">2018-10-27 18:04:49.190482+0800 DesignPatterns[54422:24725132] 虎 吃肉</span><br><span class="line">2018-10-27 18:04:49.190498+0800 DesignPatterns[54422:24725132] </span><br><span class="line">2018-10-27 18:04:49.190530+0800 DesignPatterns[54422:24725132] 羊 吃草</span><br></pre></td></tr></table></figure><p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加食肉动物和食草动物的其他功能，就可以直接在这两个类里面添加即可。但是，有一点，修改花销是很大的，除了将原来的类分解之外，还需要修改 <code>main</code> 函数 。而直接修改类 <code>Animal</code> 来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    if ([@&quot;羊&quot; isEqualToString:animalName]) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:16:10.910397+0800 DesignPatterns[54677:24751636] 狼 吃肉</span><br><span class="line">2018-10-27 18:16:10.911105+0800 DesignPatterns[54677:24751636] 豹 吃肉</span><br><span class="line">2018-10-27 18:16:10.911138+0800 DesignPatterns[54677:24751636] 虎 吃肉</span><br><span class="line">2018-10-27 18:16:10.911160+0800 DesignPatterns[54677:24751636] 羊 吃草</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。<br>但是却存在着隐患：<strong>有一天需求上增加牛和马也需要吃草，则又需要修改 <code>Animal</code> 类的 <code>eatWithAnimalName</code> 函数，而对原有代码的修改会对调用狼、豹和虎吃肉等功能带来风险，也许某一天你会发现运行结果变为虎也吃草了。</strong>这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃草</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃肉</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatGrassWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:31:30.321473+0800 DesignPatterns[55048:24787008] 狼 吃肉</span><br><span class="line">2018-10-27 18:31:30.321884+0800 DesignPatterns[55048:24787008] 豹 吃肉</span><br><span class="line">2018-10-27 18:31:30.321922+0800 DesignPatterns[55048:24787008] 虎 吃肉</span><br><span class="line">2018-10-27 18:31:30.321939+0800 DesignPatterns[55048:24787008] 羊 吃草</span><br></pre></td></tr></table></figure><p>通过运行结果可以看到，这种修改方式没有改动原来的函数，而是在类中新加了一个函数，这样虽然也违背了<strong>类单一职责原则</strong>，但在函数级别上却是符合单一职责原则的，因为它并没有动原来函数的代码。</p><p>在实际的开发应用中，有很多复杂的场景，怎么设计一个类或者一个函数，让应用程序更加灵活，是更多程序员们值得思考的，需要结合特定的需求场景，有可能有些类里面有很多的功能，但是切记不要将不属于这个类本身的功能也强加进来，这样不仅带来不必要的维护成本，也违反了<strong>单一职责的设计原则</strong>。</p><h3 id="原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）"><a href="#原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）" class="headerlink" title="原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）"></a>原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）</h3><p>定义：如果对一个类型为 <code>T1</code> 的对象 <code>o1</code>，都有类型为 <code>T2</code> 的对象 <code>o2</code>，使得以 <code>T1</code> 定义的所有程序 <code>P</code> 在所有的对象 <code>o1</code> 都替换成 <code>o2</code> 时，程序 <code>P</code> 的行为没有发生变化，那么类型 <code>T2</code> 是类型 <code>T1</code> 的子类型。有点拗口，通俗点讲，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应</strong>。</p><p>面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。当使用继承时，遵循里氏替换原则。但是使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生影响。子类可以扩展父类的功能，但不能改变父类原有的功能。</p><p>注意：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>比如，需要完成一个两数相加的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; A.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface A : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"></span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">A *a &#x3D; [[A alloc] init];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, [a addition:100 b:50]);</span><br><span class="line">NSLog(@&quot;100+80&#x3D;%ld&quot;, [a addition:100 b:80]);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 22:53:23.549358+0800 DesignPatterns[18063:363232] 100+50&#x3D;150</span><br><span class="line">2018-11-01 22:53:23.549586+0800 DesignPatterns[18063:363232] 100+80&#x3D;180</span><br></pre></td></tr></table></figure><p>接着，需求上需要增加一个新的功能，完成两数相加，然后再与 <code>100</code> 求差，由类 <code>B</code> 来负责。即类 <code>B</code> 需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加 <code>100</code>。</li></ul><p>由于类 <code>A</code> 已经实现了加法功能，所以 <code>B</code> 继承 <code>A</code> 之后，只需要完成减法功能就可以了，但是在类 <code>B</code> 中不小心重写了父类 <code>A</code> 的减法功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface B : A</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 减法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)subtraction:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">B *b &#x3D; [[B alloc] init];</span><br><span class="line">NSInteger sub &#x3D; [b addition:100 b:50];</span><br><span class="line">NSInteger difference &#x3D; [b subtraction:sub b:100];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, sub);</span><br><span class="line">NSLog(@&quot;100+100+50&#x3D;%ld&quot;, difference);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 23:15:06.530080+0800 DesignPatterns[18363:375940] 100+50&#x3D;5000</span><br><span class="line">2018-11-01 23:15:06.530758+0800 DesignPatterns[18363:375940] 100+100+50&#x3D;4900</span><br></pre></td></tr></table></figure><p>发现原本运行正常的相减功能发生了错误，原因就是类 <code>B</code> 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 <code>B</code> 重写后的方法，造成原本运行正常的功能出现了错误。如果按照“里氏替换原则”，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类</strong>，是不成立的。</p><p>在平时的日常开发中，通常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。</p><h3 id="原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）"><a href="#原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）" class="headerlink" title="原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）"></a>原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）</h3><p><strong>依赖倒置原则的核心思想是面向接口编程。</strong></p><p>定义：模块间的依赖通过抽象发生，高层模块和低层模块之间不应该发生直接的依赖关系，二者都应该是通过接口或抽象类产生的；即依赖抽象，而不依赖具体的实现。</p><p>例如：类 <code>A</code> 直接依赖类 <code>B</code>，假如要将类 <code>A</code> 改为依赖类 <code>C</code>，则必须通过修改类 <code>A</code> 的代码来达成。比如在这种场景下，业务逻辑层类 <code>A</code> 相对于数据层类 <code>B</code> 是高层模块，因为业务逻辑层需要调用数据层去连接数据库，如果业务逻辑层类 <code>A</code> 依赖数据层类 <code>B</code> 的话，那么将来需求变更，需要把旧的数据层类 <code>B</code> 修改为新的数据层类 <code>C</code>，就必须通过修改类 <code>A</code>，这样就会给应用程序带来不必要的风险。</p><p>解决方案：将类 <code>A</code> 修改为依赖接口 <code>I</code>，类 <code>B</code> 和类 <code>C</code> 各自实现接口 <code>I</code>，类 <code>A</code> 通过接口 <code>I</code> 间接与类 <code>B</code> 或者类 <code>C</code> 发生联系，则会大大降低修改类 <code>A</code> 的几率。要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。</p><p>比如：母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@class Book;</span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(Book *)book;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">[mother tellStory:book];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 14:52:08.759154+0800 DesignPatterns[6135:458778] 妈妈开始讲故事</span><br><span class="line">2018-11-09 14:52:08.759365+0800 DesignPatterns[6135:458778] 很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure><p>将来有一天，需求变更成，增加让母亲讲一下报纸上的故事的功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 报纸内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如果将 <code>Newspaper</code> 类替换 <code>Book</code> 类，发现母亲看不懂报纸上的故事，必须要修改 <code>Mother</code> 类里面的 <code>tellStory</code> 方法才能看不懂报纸上的故事。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code> 类，这显然不是好的设计，高层模块都依赖了低层模块的改动，因此上述设计不符合依赖倒置原则。<code>Mother</code> 类与 <code>Book</code> 类之间的耦合性太高了，必须降低他们之间的耦合度才行。</p><p>解决方案，将母亲讲故事的方法抽象一个接口或者 <code>Protocol</code>，让<code>Mother</code> 类不再依赖 <code>Newspaper</code> 和 <code>Book</code> 类具体实现，而是依赖抽象出来的接口或者 <code>Protocol</code>。并且 <code>Newspaper</code> 和 <code>Book</code> 类也都依赖这个抽象出来的接口或者 <code>Protocol</code>，通过实现接口或者 <code>Protocol</code> 来做自己的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>Mother</code> 类与接口 <code>IReader</code> 发生依赖关系，而 <code>Book</code> 和 <code>Newspaper</code> 都属于读物的范畴，他们各自都去实现 <code>IReader</code> 接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Mother</span><br><span class="line"></span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading &#123;</span><br><span class="line">    NSLog(@&quot;妈妈开始讲故事&quot;);</span><br><span class="line">    if ([reading respondsToSelector:@selector(theStoryContent)]) &#123;</span><br><span class="line">        [reading theStoryContent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">Newspaper *newspaper &#x3D; [Newspaper new];</span><br><span class="line">[mother tellStory:book];</span><br><span class="line">[mother tellStory:newspaper];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 15:28:01.182603+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182879+0800 DesignPatterns[7055:532924] 很久很久以前有一个阿拉伯的故事……</span><br><span class="line">2018-11-09 15:28:01.182916+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182955+0800 DesignPatterns[7055:532924] 雄鹿终结勇士八连胜……</span><br></pre></td></tr></table></figure><p>这样修改后，无论以后怎样扩展 main 函数，都不需要再修改 <code>Mother</code> 类了。这里只是举了一个比较简单的例子，在实际的项目开发中，尽可能的采用“低耦合，高内聚”的原则，<strong>采用依赖倒置原则给多人并行开发带来了极大的便利</strong>，无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><h3 id="原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="原则四、接口隔离原则（Interface Segregation Principle,简称ISP）"></a>原则四、接口隔离原则（Interface Segregation Principle,简称ISP）</h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#39;ClassB&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br><span class="line">Class &#39;ClassD&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br></pre></td></tr></table></figure><p><strong>注意：在 <code>Objective-C</code> 中的协议可以通过 <code>@optional</code> 关键字声明不需要必须实现的方法，这个只是 <code>Objective-C</code> 的一个特性，可以消除在 <code>ClassB</code> 和 <code>ClassD</code> 中没有实现 <code>InterfaceH</code> 的 <code>protocol</code> 协议。</strong></p><p>比如，类 A 依赖接口 H 中的方法1、方法2、方法5，类 B 是对类 A 依赖的实现。类 C 依赖接口 H 中的方法3、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法，但由于实现了接口 H，因为接口 <code>H</code> 对于类 <code>A</code> 和类 <code>C</code> 来说不是最小接口，所以也必须要实现这些用不到的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。</p><p><strong>解决方法：将臃肿的接口 <code>H</code> 拆分为独立的几个接口，类 <code>A</code> 和类 <code>C</code> 分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH1 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH2 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH1&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH2&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。在实际项目开发中，只暴露给调用的类需要的方法，不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，不要试图去建立一个很庞大的接口供所有依赖它的类去调用。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><h3 id="原则五、迪米特法则（Law-of-Demeter，简称LOD）"><a href="#原则五、迪米特法则（Law-of-Demeter，简称LOD）" class="headerlink" title="原则五、迪米特法则（Law of Demeter，简称LOD）"></a>原则五、迪米特法则（Law of Demeter，简称LOD）</h3><p>定义：一个对象应该对其他对象保持最少的了解。</p><p>当类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外只暴露必要的接口。</p><p>解决方案：尽量降低类与类之间的耦合。</p><p>比如，有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工 <code>ID</code>：<br>Model 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; EmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface EmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 总公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *employee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubEmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubEmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 分公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *subemployee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Company 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; subCompany.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>从上面可以看出，打印 <code>Company</code> 所有员工的 <code>ID</code>，需要依赖分公司 <code>SubCompany</code>。但是在 <code>printAllEmployeeWithSubCompany:</code> 方法里面必须要初始化分公司员工 <code>SubEmployeeModel</code>。而<code>SubEmployeeModel</code> 和 <code>Company</code> 并不是直接联系，换句话说，总公司 <code>Company</code> 只需要依赖分公司 <code>SubCompany</code>，与分公司的员工 <code>SubEmployeeModel</code> 并没有任何联系，这样设计显然是增加了不必要的耦合。</p><p><strong>按照迪米特法则，类与类之间的应该减少不必要的关联程度。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    [subCompany printAllEmployee];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印分公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployee &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>修改后，为分公司增加了打印所有公钥 <code>ID</code> 的方法，总公司直接调分公司的打印方法，从而避免了与分公司的员工发生耦合。</p><p>耦合的方式很多，依赖、关联、组合、聚合等。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是过分的使用迪米特原则，会产生大量传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="原则六、开闭原则（Open-Close-Principle，简称OCP）"><a href="#原则六、开闭原则（Open-Close-Principle，简称OCP）" class="headerlink" title="原则六、开闭原则（Open Close Principle，简称OCP）"></a>原则六、开闭原则（Open Close Principle，简称OCP）</h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>核心思想：<strong>尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。</strong></p><p><strong>用抽象构建框架，用实现扩展细节</strong>，对扩展开放的关键是抽象，而对象的多态则保证了这种扩展的开放性。开放原则首先意味着我们可以自由地增加功能，而不会影响原有功能。这就要求我们能够通过继承完成功能的扩展。其次，开放原则还意味着实现是可替换的。只有利用抽象，才可以为定义提供不同的实现，然后根据不同的需求实例化不同的实现子类。</p><p>开放封闭原则的优点：</p><ul><li>代码可读性高，可维护性强。</li><li>帮助缩小逻辑粒度，以提高可复用性。</li><li>可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性。</li><li>在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求。</li></ul><p>比如，书店售书的经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IBookProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IBookProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍售价</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (CGFloat)bookPrice;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍作者</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookAuthor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; NovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface NovelBook : NSObject &lt;IBookProtocol&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟书店卖书</span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:11:32.642070+0800 DesignPatterns[1863:5763476] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：50.000000</span><br><span class="line">2018-11-12 15:11:32.642495+0800 DesignPatterns[1863:5763476] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:11:32.642530+0800 DesignPatterns[1863:5763476] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:11:32.642558+0800 DesignPatterns[1863:5763476] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br></pre></td></tr></table></figure><p>将来某一天需求变更为项目投产，书店盈利，书店决定，<code>40</code> 元以上打 <code>8</code> 折，<code>40</code> 元以下打 <code>9</code> 折。</p><p>在实际的项目开发中，如果不懂得开闭原则的话，很容易犯下面的错误：</p><ul><li>在 <code>IBookProtocol</code> 上新增加一个方法 <code>bookOffPrice()</code> 方法，专门进行打折，所有实现类实现这个方法，但是如果其他不想打折的书籍也会因为实现了书籍的接口必须打折。 </li><li>修改 <code>NovelBook</code> 实现类中的 <code>bookPrice()</code> 方中实现打折处理，由于该方法已经实现了打折处理价格，因此采购书籍人员看到的也是打折后的价格的情况。</li></ul><p>很显然按照上面两种方案的话，随着需求的增加，需要反复修改之前创建的类，给新增的类造成了不必要的冗余，业务逻辑的处理和需求不相符合等情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; OffNovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface OffNovelBook : NovelBook</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OffNovelBook</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author &#123;</span><br><span class="line">    return [super initWithBookName:name price:price author:author];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)bookPrice &#123;</span><br><span class="line">    CGFloat originalPrice &#x3D; [super bookPrice];</span><br><span class="line">    CGFloat offPrice      &#x3D; 0;</span><br><span class="line">    if (originalPrice &gt; 40) &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.8;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line">    return offPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BookStore</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book1 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book2 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book3 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book4 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book1 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book2 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book3 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book4 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的原价书籍记录如下：------------&quot;);</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的打折书籍记录如下：------------&quot;);</span><br><span class="line">for (OffNovelBook *novelBook in bookStore.offBookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:52:01.639550+0800 DesignPatterns[2962:6151804] ------------书店卖出去的原价书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.639895+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：30.000000</span><br><span class="line">2018-11-12 15:52:01.639927+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:52:01.639951+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:52:01.639971+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br><span class="line">2018-11-12 15:52:01.639988+0800 DesignPatterns[2962:6151804] ------------书店卖出去的打折书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.640029+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：27.000000</span><br><span class="line">2018-11-12 15:52:01.640145+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：56.000000</span><br><span class="line">2018-11-12 15:52:01.640194+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：64.000000</span><br><span class="line">2018-11-12 15:52:01.640217+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：36.000000</span><br></pre></td></tr></table></figure><p>在实际的项目开发中，</p><ul><li><p>对抽象定义的修改，要保证定义的接口或者 <code>Protocol</code> 的稳定，尤其要保证被其他对象调用的接口的稳定；否则，就会导致修改蔓延，牵一发而动全身。</p></li><li><p>对具体实现的修改，因为具体实现的修改，可能会给调用者带来意想不到的结果。如果确实需要修改具体的实现，就需要做好达到测试覆盖率要求的单元测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;588630-7d17a7d220c612f0.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）&quot;&gt;&lt;a href=&quot;#原则一、单一职
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 HTTPS 的原理详解</title>
    <link href="https://sunjinshuai.github.io/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sunjinshuai.github.io/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-09-13T15:23:54.000Z</published>
    <updated>2022-01-16T05:34:29.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><code>HTTP</code> 协议（<code>HyperText Transfer Protocol</code>，超文本传输协议）：是客户端浏览器或其他程序与 <code>Web</code> 服务器之间的应用层通信协议 。</p></li><li><p><code>HTTPS</code> 协议（<code>HyperText Transfer Protocol over Secure Socket Layer</code>）：可以理解为 <code>HTTP+SSL/TLS</code>， 即 <code>HTTP</code> 下加入 <code>SSL</code> 层，<code>HTTPS</code> 的安全基础是 <code>SSL</code>，因此加密的详细内容就需要 <code>SSL</code>，用于安全的 <code>HTTP</code> 数据传输。</p></li><li><p><code>SSL</code>（<code>Secure Socket Layer</code>，安全套接字层）：<code>1994</code> 年为 <code>Netscape</code> 所研发，<code>SSL</code> 协议位于 <code>TCP/IP</code> 协议与各种应用层协议之间，为数据通讯提供安全支持。</p></li><li><p><code>TLS</code>（<code>Transport Layer Security</code>，传输层安全）：其前身是 <code>SSL</code>，它最初的几个版本（<code>SSL 1.0</code>、<code>SSL 2.0</code>、<code>SSL 3.0</code>）由网景公司开发，<code>1999</code> 年从 <code>3.1</code> 开始被 <code>IETF</code> 标准化并改名，发展至今已经有 <code>TLS 1.0</code>、<code>TLS 1.1</code>、<code>TLS 1.2</code> 三个版本。<code>SSL3.0</code> 和 <code>TLS1.0</code> 由于存在安全漏洞，已经很少被使用到。<code>TLS 1.3</code> 改动会比较大，目前还在草案阶段，目前使用最广泛的是 <code>TLS 1.1</code>、<code>TLS 1.2</code>。</p></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>HTTP</code> 默认工作在 <code>TCP</code> 协议 <code>80</code> 端口，用户访问网站 <code>http://</code> 打头的都是标准 <code>HTTP</code> 服务。</li><li><code>HTTP</code> 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 <code>Web</code> 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</li><li><code>HTTPS</code> 默认工作在 <code>TCP</code> 协议 <code>443</code> 端口。</li><li><code>HTTPS</code>（<code>HTTP+SSL/TLS</code>）数据传输过程是加密的，安全性较好。</li></ul><p><code>HTTPS</code> 和 <code>HTTP</code> 协议相比提供了</p><ul><li>数据完整性：内容传输经过完整性校验</li><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h3 id="TLS-握手流程"><a href="#TLS-握手流程" class="headerlink" title="TLS 握手流程"></a>TLS 握手流程</h3><p><code>HTTPS</code> 在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。<code>TLS/SSL</code> 协议是一套加密传输的协议，使用了非对称加密，对称加密以及 <code>HASH</code> 算法。以 <code>RSA</code> 为例，<code>TLS</code> 握手流程如下：<br><img src="588630-0e87f4003f1e85ff.png" alt="image.png"></p><p><strong>上图中的 <code>CA</code> 证书验证，这一步是可选的，对于安全性要求高的场景会用到，比如，预防中间人攻击。</strong></p><h4 id="第一步-Client-Hello"><a href="#第一步-Client-Hello" class="headerlink" title="第一步 Client Hello"></a>第一步 <code>Client Hello</code></h4><p>客户端向服务端发送 <code>Client Hello</code> 消息，这个消息里包含了一个客户端生成的随机数 <code>Random1</code>、客户端支持的协议版本，会话 ID，密码套件，压缩算法等信息。</p><h4 id="第二步-Server-Hello"><a href="#第二步-Server-Hello" class="headerlink" title="第二步 Server Hello"></a>第二步 <code>Server Hello</code></h4><p>服务端向客户端发送 <code>Server Hello</code> 消息，这个消息会从 <code>Client Hello</code> 传过来的加密套件里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <code>Random2</code>。注意，至此客户端和服务端都拥有了两个随机数 <code>Random1+Random2</code> ，这两个随机数会在后续生成对称秘钥时用到。</p><p><strong>Client 发送一个 ClientHello 消息，Server 必须回应一个 ServerHello 消息或产生一个验证的错误并且使连接失败</strong></p><h5 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a><code>Certificate</code></h5><p>在 <code>Server Hello</code> 消息之后，服务端将自己的证书下发给客户端，<code>Server</code> 会在 <code>Certificate</code> 消息中发送它自己的证书，<strong>如果它即将被认证</strong>，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a><code>Server Key Exchange</code></h4><p>此外，如果需要的话，一个 <code>ServerKeyExchange</code> 消息会被发送，(例如, 如果 <code>Server</code> 没有证书, 或者它的证书只用于签名，<code>RSA</code> 密码套件就不会出现 <code>ServerKeyExchange</code> 消息，如果 <code>Server</code> 被认证过了，如果对于已选择的密码套件来说是合适的话，它可能会要求 <code>Client</code> 发送证书)。如果是 <code>DH</code> 算法，这里发送服务器使用的 <code>DH</code> 参数，<code>RSA</code> 算法不需要这一步；</p><h5 id="Certificate-Request"><a href="#Certificate-Request" class="headerlink" title="Certificate Request"></a><code>Certificate Request</code></h5><p>如果 Server 发送了一个 CertificateRequest 消息，Client 必须发送 Certificate 消息。</p><h5 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a><code>Server Hello Done</code></h5><p>Server Hello Done 通知客户端 Server Hello 过程结束。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>客户端收到了服务器发来的数据包后，会做这么几件事情：</p><h5 id="Client-Certificate"><a href="#Client-Certificate" class="headerlink" title="Client Certificate"></a><code>Client Certificate</code></h5><p>这是 <code>Client</code> 在收到一个 <code>ServerHelloDone</code> 消息后发送的第一个消息。这个消息只能在 <code>Server</code> 请求一个证书时发送。如果没有合适的证书，<code>Client</code> 必须发送一个不带证书的证书消息。如果 <code>Client</code> 不发送任何证书，<code>Server</code> 可以自行决定是否可以在不验证 <code>Client</code> 的情况下继续握手，<strong>或者回复一个致命 <code>handshake_failure</code> 警报 <code>alert</code> 信息。而且, 如果证书链某些方面不能接受(例如, 它没有被一个知名的可信 <code>CA</code> 签名)，<code>Server</code> 可以自行决定是否继续握手(考虑到 <code>Client</code> 无认证)或发送一个致命的警报 <code>alert</code> 信息。</strong></p><h5 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a><code>Client Key Exchange</code></h5><p>这个消息始终由 <code>Client</code> 发送。如果有 <code>Client Certificate</code> 消息的话，<code>Client Key Exchange</code> 紧跟在 <code>Client Certificate</code> 消息之后发送。如果不存在 <code>Client Certificate</code> 消息的话，它必须是在 <code>Client</code> 收到 <code>ServerHelloDone</code> 后发送的第一个消息。客户端根据服务器传来的公钥生成了 <code>PreMaster Key</code>，<code>Client Key Exchange</code> 就是将这个 <code>key</code> 传给服务端。</p><h5 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec Client"></a><code>Change Cipher Spec Client</code></h5><p>将刚才的消息使用刚才的 <code>PreMaster Key</code> 进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>服务器接受到客户端发来的消息后，会做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message Client"></a><code>Encrypted Handshake Message Client</code></h5><p>这一步对应的是 <code>Client Finish</code> 消息，使用私钥解密上面第2步中公钥加密的消息，得到客户端产生的随机序列号。使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。</p><h5 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec Server"></a><code>Change Cipher Spec Server</code></h5><p>使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。</p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>客户端收到服务器端的消息后，接着做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message Server"></a><code>Encrypted Handshake Message Server</code></h5><p>这一步对应的是 <code>Server Finish</code> 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><h4 id="第六步-Application-Data"><a href="#第六步-Application-Data" class="headerlink" title="第六步 Application Data"></a>第六步 <code>Application Data</code></h4><p>握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>采用 <code>HTTPS</code> 协议的服务器必须要有自己制作或者 <code>CA</code> 证书，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用 <code>CA</code> 证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><p>客户端收到服务器的回复后，首先客户端会从内置的证书列表中索引，查找服务器下发 <code>CA</code> 证书，如果没有找到，此时就会提示用户该证书是不可信任的。如果查到了对应 <code>CA</code> 证书，则取出 <code>public key</code> 公钥。然后，用 <code>public key</code> 公钥解密得到证书的内容和证书签名，内容包括证书的颁发机构，过期时间等。客户端会先验证证书签名的合法性，签名通过后，会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，客户端就可以安全使用 <code>public key</code> 公钥了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt; 协议（&lt;code&gt;HyperText Transfer Protocol&lt;/code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 iOS ARC 内存管理</title>
    <link href="https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-02-13T09:15:20.000Z</published>
    <updated>2022-01-16T11:28:16.661Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 采用的是引用计数式的内存管理方式：</p><ul><li><p>自己生成的对象自己持有。</p></li><li><p>非自己生成的对象自己也能持有。</p></li><li><p>自己持有的对象不再需要时释放。</p></li><li><p>非自己持有的对象自己无法释放。</p></li><li><p>使用以下名称开头的方法名意味着<strong>自己生成的对象只有自己持有</strong>：</p></li><li><p><code>alloc</code></p></li><li><p><code>new</code></p></li><li><p><code>copy</code></p></li><li><p><code>mutableCopy</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 自己生成并持有该对象</span><br><span class="line"> *&#x2F;</span><br><span class="line"> id obj0 &#x3D; [[NSObeject alloc] init];</span><br><span class="line"> id obj1 &#x3D; [NSObeject new];</span><br></pre></td></tr></table></figure><ul><li><p>非自己生成的对象，自己也能持有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 持有非自己生成的对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">[obj retain]; &#x2F;&#x2F; 自己持有对象</span><br></pre></td></tr></table></figure><p>备注：通过 <code>retain</code> 方法来让指针变量持有这个新生成的对象。</p></li><li><p>不再需要自己持有的对象时释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 不在需要自己持有的对象的时候，释放</span><br><span class="line"> *&#x2F;</span><br><span class="line">id obj &#x3D; [[NSObeject alloc] init]; &#x2F;&#x2F; 此时持有对象</span><br><span class="line">[obj release]; &#x2F;&#x2F; 释放对象</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 指向对象的指针仍就被保留在obj这个变量中</span><br><span class="line"> * 但对象已经释放，不可访问</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用 <code>release</code> 方法。<br>当调用对象的 <code>release</code> 方法只是将对象的引用计数器 <code>-1</code>，当对象的引用计数器为 <code>0</code> 的时候会调用了对象的 <code>dealloc</code> 方法才能进行释放对象的内存。</p></li><li><p>非自己生成的对象持有对象的释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;非自己生成的对象，暂时没有持有</span><br><span class="line">id obj &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过retain持有对象</span><br><span class="line">[obj retain];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放对象</span><br><span class="line">[obj release];</span><br></pre></td></tr></table></figure></li></ul><p>两种不允许的情况：</p><ul><li><p>释放自己不持有的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 非自己持有的对象无法释放</span><br><span class="line"> *&#x2F;</span><br><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">[obj release]; &#x2F;&#x2F; ~~~此时将运行时crash 或编译器报error~~~ 非 ARC 下，调用该方法会导致编译器报 issues。此操作的行为是未定义的，可能会导致运行时 crash 或者其它未知行为</span><br></pre></td></tr></table></figure></li><li><p>释放一个已经废弃了的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [[NSObject alloc] init];&#x2F;&#x2F;持有新生成的对象</span><br><span class="line">[obj doSomething];&#x2F;&#x2F;使用该对象</span><br><span class="line">[obj release];&#x2F;&#x2F;释放该对象，不再持有了</span><br><span class="line">[obj release];&#x2F;&#x2F;释放已经废弃了的对象，崩溃</span><br></pre></td></tr></table></figure></li></ul><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>当对象超出其作用域时，对象实例的 <code>release</code> 方法就会被调用，<code>autorelease</code> 的具体使用方法如下：</p><ul><li>生成并持有 <code>NSAutoreleasePool</code> 对象。</li><li>调用已分配对象的 <code>autorelease</code> 方法。</li><li>废弃 <code>NSAutoreleasePool</code> 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id) getAObjNotRetain &#123;</span><br><span class="line">    id obj &#x3D; [[NSObject alloc] init]; &#x2F;&#x2F; 自己持有对象</span><br><span class="line">    [obj autorelease]; &#x2F;&#x2F; 取得的对象存在，但自己不持有该对象</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特性是使用 <code>autorelease</code> 来实现的，<code>autorelease</code> 使得对象在超出生命周期后能正确的被释放(通过调用 <code>release</code> 方法)。在调用 <code>release</code> 后，对象会被立即释放，而调用 <code>autorelease</code> 后，对象不会被立即释放，而是注册到 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p><p>在 <code>ARC</code> 环境下，<code>id</code> 类型和对象类型和 <code>C</code> 语言其他类型不同，类型前必须加上所有权的修饰符。<br>所有权修饰符总共有4种：</p><ul><li>__strong</li><li>__weak</li><li>__autoreleasing</li><li>__unsafe_unretained</li></ul><h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h2><p><code>__strong</code> 表示强引用，对应定义 <code>property</code> 时用到的 <code>strong</code>。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 <code>nil</code>。<code>__strong</code> 修饰符是 <code>id</code> 类型和对象类型默认的所有权修饰符。</p><h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 <code>weak</code>。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 <code>nil</code>，这样可以防止野指针。<code>__weak</code> 最常见的一个作用就是用来避免强引用循环。</p><p><code>__weak</code> 的几个使用场景：</p><ul><li>在 <code>delegate</code> 关系中防止强引用循环。在 <code>ARC</code> 特性下，通常我们应该设置 <code>delegate</code> 属性为 <code>weak</code> 的。但是这里有一个疑问，我们常用到的 <code>UITableView</code> 的 <code>delegate</code> 属性是这样定义的：<code>@property (nonatomic, assign) id&lt;UITableViewDelegate&gt; delegate;</code>，为什么用的修饰符是<code>assign</code> 而不是 <code>weak</code>？其实这个 <code>assign</code> 在 <code>ARC</code> 中意义等同于 <code>__unsafe_unretained</code>（后面会讲到），它是为了在 <code>ARC</code> 特性下兼容 <code>iOS4</code> 及更低版本来实现弱引用机制。一般情况下，你应该尽量使用 <code>weak</code>。</li><li>在 <code>Block</code> 中防止强引用循环。</li><li>用来修饰指向由 <code>Interface Builder</code> 创建的控件。比如：<code>@property (nonatomic, weak) IBOutlet UIButton *testButton;</code>。</li></ul><p>另外，<code>__weak</code> 修饰符的变量，会被注册到 <code>autoreleasePool</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 &#x3D; obj;</span><br><span class="line">    NSLog(@&quot;obj2-%@&quot;,obj1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器转换上述代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initweak(&amp;obj1,obj);</span><br><span class="line">id tmp &#x3D; objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;,tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><p><code>objc_loadWeakRetained</code> 函数获取附有 <code>__weak</code> 修饰符变量所引用的对象并 <code>retain</code>, <code>objc_autorelease</code> 函数将对象放入 <code>autoreleasePool</code> 中，据此当我们访问 <code>weak</code> 修饰指针指向的对象时，实际上是访问注册到自动释放池的对象。因此，如果大量使用 <code>weak</code> 的话，在我们去访问 <code>weak</code> 修饰的对象时，会有大量对象注册到自动释放池,这会影响程序的性能。</p><p>解决方案：<br>要访问 <code>weak</code> 修饰的变量时，先将其赋给一个 <code>strong</code> 变量，然后进行访问。</p><p>为什么访问 <code>weak</code> 修饰的对象就会访问注册到自动释放池的对象呢?</p><p>因为 <code>weak</code> 不会引起对象的引用计数器变化，因此，该对象在运行过程中很有可能会被释放。所以，需要将对象注册到自动释放池中并在 <code>autoreleasePool</code> 销毁时释放对象占用的内存。</p><h2 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h2><p>在 <code>ARC</code> 模式下，我们不能显示的使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，通过将对象赋给 <code>__autoreleasing</code> 修饰的变量就能达到在 <code>MRC</code> 模式下调用对象的 <code>autorelease</code> 方法同样的效果。</p><p><code>__autoreleasing</code> 修饰的对象会被注册到 <code>Autorelease Pool</code> 中，并在 <code>Autorelease Pool</code> 销毁时被释放。</p><p><strong>注意：定义 <code>property</code> 时不能使用这个修饰符，因为任何一个对象的 <code>property</code> 都不应该是 <code>autorelease</code> 类型的。</strong></p><h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h2><p><code>ARC</code> 是在 <code>iOS5</code> 引入的，而 <code>__unsafe_unretained</code> 这个修饰符主要是为了在 <code>ARC</code> 刚发布时兼容 <code>iOS4</code> 以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义 <code>property</code> 时对应的是 <code>unsafe_unretained</code>。<code>__unsafe_unretained</code> 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 <code>retainCount +1</code>。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 <code>nil</code>，所以成为了野指针，非常不安全。</p><p><code>__unsafe_unretained</code> 的应用场景：</p><ul><li>在 ARC 环境下但是要兼容 iOS4.x 的版本，用 <code>__unsafe_unretained</code> 替代 <code>__weak</code> 解决强引用循环的问题。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结， <code>autorelease</code> 的机制却依然在很多地方默默起着作用，我们来看看这些场景：</p><ul><li>方法返回值。</li><li>访问 __weak 修饰的变量。</li><li>id 的指针或对象的指针(id *)。</li></ul><h3 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h3><p>首先，我们看这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  (NSMutableArray *)array  &#123;</span><br><span class="line">    NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(array);</span><br><span class="line">objc_release(array);</span><br></pre></td></tr></table></figure><p>这里 <code>array</code> 的所有权修饰符是默认的 <code>__strong</code>。由于 <code>return</code> 使得 <code>array</code> 超出其作用域，它强引用持有的对象本该被释放，但是由于该对象作为函数返回值，所以<strong>一般情况下编译器会自动将其注册到 <code>AutoreleasePool</code> 中（注意这里是一般情况下，在一些特定情况下，<code>ARC</code> 机制提出了巧妙的运行时优化方案来跳过 <code>autorelease</code> 机制。）</strong>。</p><h4 id="ARC-模式下方法返回值跳过-autorelease-机制的优化方案"><a href="#ARC-模式下方法返回值跳过-autorelease-机制的优化方案" class="headerlink" title="ARC 模式下方法返回值跳过 autorelease 机制的优化方案"></a>ARC 模式下方法返回值跳过 autorelease 机制的优化方案</h4><p>为什么方法返回值的时候需要用到 <code>autorelease</code>机制呢？</p><p>当对象被作为参数返回 <code>return</code> 之后，如果调用者需要使用就需要强引用它，那么它 <code>retainCount + 1</code>，用完之后再清理，使它 <code>retainCount - 1</code>。</p><p>如果在方法中创建了对象并作为返回值时，根据 <code>ARC</code> 内存管理的原则，谁创建谁释放。既然作为返回值，就必须保证返回时对象没被释放以便方法外的调用者能拿到有效的对象，否则你返回的是 nil，有何意义呢。所以就需要找一个合理的机制既能延长这个对象的生命周期，又能保证对其释放。这个机制就是 <code>autorelease 机制</code>。</p><p><code>ARC</code> 模式下在方法 <code>return</code> 的时候，会调用 <code>objc_autoreleaseReturnValue()</code><br>方法替代 <code>autorelease</code>。在调用者强引用方法返回对象的时候，会调用 <code>objc_retainAutoreleasedReturnValue()</code> 方法，该方法会去检查该方法或者调用方的执行命令列表，是否会被传给 <code>objc_retainAutoreleasedReturnValue()</code> 方法。如果里面有 <code>objc_retainAutoreleasedReturnValue()</code> 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 <code>autoreleasepool</code>中，也可以返回拿到相应的对象。如果没传，那么它就会走 <code>autorelease</code> 的过程注册到 <code>autoreleasepool</code> 中。</p><h3 id="访问-weak-修饰的变量"><a href="#访问-weak-修饰的变量" class="headerlink" title="访问 __weak 修饰的变量"></a>访问 __weak 修饰的变量</h3><p>在访问 <code>__weak</code> 修饰的变量时，实际上必定会访问注册到 <code>AutoreleasePool</code> 的对象。如下来年两段代码是相同的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [obj1 class]);</span><br><span class="line">&#x2F;&#x2F; 等同于：</span><br><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">id __autoreleasing tmp &#x3D; obj1;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [tmp class]);</span><br></pre></td></tr></table></figure><p>为什么会这样呢？因为 <code>__weak</code> 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 <code>AutoreleasePool</code> 中，就能保证 <code>AutoreleasePool</code> 被销毁前对象是存在的。</p><h3 id="id-的指针或对象的指针-id"><a href="#id-的指针或对象的指针-id" class="headerlink" title="id 的指针或对象的指针(id *)"></a>id 的指针或对象的指针(id *)</h3><p>另一个隐式地使用 <code>__autoreleasing</code> 的例子就是使用 id 的指针或对象的指针(id *) 的时候。</p><p>看一个最常见的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSError *__autoreleasing error;</span><br><span class="line">if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123;</span><br><span class="line">    NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 即使上面你没有写 __autoreleasing 来修饰 error，编译器也会帮你做下面的事情：</span><br><span class="line">NSError *error;</span><br><span class="line">NSError *__autoreleasing tempError &#x3D; error; &#x2F;&#x2F; 编译器添加</span><br><span class="line">if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) &#123;</span><br><span class="line">    error &#x3D; tempError; &#x2F;&#x2F; 编译器添加</span><br><span class="line">    NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error</code> 对象在你调用的方法中被创建，然后被放到 <code>AutoreleasePool</code> 中，等到使用结束后随着 <code>AutoreleasePool</code> 的销毁而释放，所以函数外 <code>error</code> 对象的使用者不需要关心它的释放。</p><p>在 <code>ARC</code> 中，所有这种指针的指针类型<code>（id *）</code>的函数参数如果不加修饰符，编译器会默认将他们认定为 <code>__autoreleasing</code> 类型。</p><p>有一点特别需要注意的是，某些类的方法会隐式地使用自己的 <code>AutoreleasePool</code>，在这种时候使用 <code>__autoreleasing</code> 类型要特别小心。比如 <code>NSDictionary</code> 的 <code>enumerateKeysAndObjectsUsingBlock</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; do stuff</span><br><span class="line">        if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">            *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; code:1 userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中其实会隐式地创建一个 <code>AutoreleasePool</code>，类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        @autoreleasepool &#123;  &#x2F;&#x2F; 被隐式创建。</span><br><span class="line">            if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">                *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; code:1 userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#x2F;&#x2F; *error 在这里已经被dict的做枚举遍历时创建的 Autorelease Pool释放掉了。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够正常的使用 <code>*error</code>，我们需要一个 <code>strong</code> 类型的临时引用，在 <code>dict</code> 的枚举 <code>Block</code> 中是用这个临时引用，保证引用指向的对象不会在出了 <code>dict</code> 的枚举 <code>Block</code> 后被释放，正确的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    NSError * __block tempError; &#x2F;&#x2F; 加 __block 保证可以在Block内被修改。</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        if (there is some error) &#123;</span><br><span class="line">            *tempError &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; code:1 userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    if (error !&#x3D; nil) &#123;</span><br><span class="line">        *error &#x3D; tempError;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C 采用的是引用计数式的内存管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自己生成的对象自己持有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非自己生成的对象自己也能持有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自己持有的对象不再需要时释放。&lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CocoaPods 使用总结</title>
    <link href="https://sunjinshuai.github.io/2018/05/09/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sunjinshuai.github.io/2018/05/09/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2018-05-09T10:31:52.000Z</published>
    <updated>2022-03-21T00:59:18.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocoaPods简介"><a href="#CocoaPods简介" class="headerlink" title="CocoaPods简介"></a>CocoaPods简介</h2><p><code>CocoaPods</code> 是专门为 <code>iOS</code> 工程提供第三方依赖库的管理工具，通过 <code>CocoaPods</code>，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置，就可以直观、集中和自动化地管理我们项目的第三方库。</p><p><code>CocoaPods</code> 将所有依赖的库都放在一个名为 <code>Pods</code> 的项目下，然后让主项目依赖 <code>Pods</code> 项目。然后，我们编码工作都从主项目转移到 <code>Pods</code> 项目。<code>Pods</code> 项目最终会编译为一个 <code>libPod-项目名.a</code> 静态库，主项目依赖于这个静态库。</p><p>对于资源文件，<code>CocoaPods</code> 提供了一个名为 <code>Pods-resources.sh</code> 的 <code>bash</code> 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。<code>CocoaPods</code> 通过一个名为 <code>Pods.xcconfig</code> 的文件来在编译时设置所有的依赖和参数。<code>CocoaPods</code> 是用 <code>Ruby</code> 写的，并由若干个 <code>Ruby</code> 包 (gems) 构成的。在解析整合过程中，最重要的几个 <code>gems</code> 分别是： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCocoaPods%2F" target="_blank" rel="noopener">CocoaPods/CocoaPods</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCore" target="_blank" rel="noopener">CocoaPods/Core</a> 和 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FXcodeproj" target="_blank" rel="noopener">CocoaPods/Xcodeproj</a>。</p><h2 id="CocoaPod的核心组件"><a href="#CocoaPod的核心组件" class="headerlink" title="CocoaPod的核心组件"></a>CocoaPod的核心组件</h2><ul><li>CocoaPods/CocoaPod<br>这是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 <code>CocoaPods</code> 涉及到的功能，并且还能通过调用所有其它的 <code>gems</code> 来执行任务。</li><li>CocoaPods/Core<br><code>Core</code> 组件提供支持与 <code>CocoaPods</code> 相关文件的处理，文件主要是 <code>Podfile</code> 和 <code>podspecs</code>。</li><li>Podfile<br><code>Podfile</code> 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <code>Podfile</code> 指南。</li><li>Podspec<br><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、<code>framework</code>、编译选项和某个库所需要的依赖等。</li><li>CocoaPods/Xcodeproj<br>这个 <code>gem</code> 组件负责所有工程文件的整合。它能够创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 <code>gem</code> 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 <code>gem</code>。</li></ul><h2 id="私有库开发流程"><a href="#私有库开发流程" class="headerlink" title="私有库开发流程"></a>私有库开发流程</h2><p>一般公司都会搭建自己的 <code>git</code> 服务器，在实战项目中，经常使用 <code>Cocoapods</code> 管理自己的私有库。</p><ul><li><code>git</code> 仓库至少需要两个，一个用于管理私有库对应版本的 <code>podspec</code> 文件，一个用于存放私有库的源文件。</li><li>查看现有的 <code>podspec</code> 源地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建一个私有的-podspec-主要包括如下几步："><a href="#创建一个私有的-podspec-主要包括如下几步：" class="headerlink" title="创建一个私有的 podspec 主要包括如下几步："></a>创建一个私有的 <code>podspec</code> 主要包括如下几步：</h3><ul><li>创建一个私有的 <code>Spec Repo</code>，用于管理私有库对应版本的 <code>podspec</code> 文件；</li><li>创建 <code>pod</code> 私有库所需要的项目工程文件，并上传到私有库；</li><li>创建 <code>pod</code> 所对应的 <code>podspec</code> 文件，并进行验证／测试；</li><li>向私有的 <code>Spec Repo</code> 中提交 <code>podspec</code>；</li><li>使用 <code>pod</code> 库；</li></ul><h3 id="创建一个私有的-Spec-Repo"><a href="#创建一个私有的-Spec-Repo" class="headerlink" title="创建一个私有的 Spec Repo"></a>创建一个私有的 <code>Spec Repo</code></h3><ul><li>在自己公司的 <code>git</code> 服务器上创建 <code>SpecsRepo</code> 仓库；</li><li>将私有 <code>SpecsRepo</code> 关联到本地；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add IMXSpecsRepo http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure></li></ul><p>查看 <code>SpecsRepo</code> 是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure><h3 id="创建-pod-私有库所需要的项目工程"><a href="#创建-pod-私有库所需要的项目工程" class="headerlink" title="创建 pod 私有库所需要的项目工程"></a>创建 pod 私有库所需要的项目工程</h3><h4 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create 仓库名字 --template-url&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXPodTemplte</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>手动创建</p><p>手动创建 <code>Xcode</code> 工程项目，创建 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create XXXX.podspec</span><br></pre></td></tr></table></figure><p>修改 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name             &#x3D; &#39;AKCBrowser&#39;</span><br><span class="line">  s.version          &#x3D; &#39;0.0.1&#39;</span><br><span class="line">  s.summary          &#x3D; &#39;A short description of AKCBrowser.&#39;</span><br><span class="line"></span><br><span class="line">  # This description is used to generate tags and improve search results.</span><br><span class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">  #   * Try to keep it short, snappy and to the point.</span><br><span class="line">  #   * Write the description between the DESC delimiters below.</span><br><span class="line">  #   * Finally, don&#39;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">  TODO: Add long description of the pod here.</span><br><span class="line">  DESC</span><br><span class="line"></span><br><span class="line">  s.homepage         &#x3D; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;</span><br><span class="line">  # s.screenshots     &#x3D; &#39;www.example.com&#x2F;screenshots_1&#39;, &#39;www.example.com&#x2F;screenshots_2&#39;</span><br><span class="line">  s.license          &#x3D; &#123; :type &#x3D;&gt; &#39;MIT&#39;, :file &#x3D;&gt; &#39;LICENSE&#39; &#125;</span><br><span class="line">  s.author           &#x3D; &#123; &#39;sunjinshuai&#39; &#x3D;&gt; &#39;s_mike@163.com&#39; &#125;</span><br><span class="line">  s.source           &#x3D; &#123; :git &#x3D;&gt; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line"></span><br><span class="line">  s.static_framework      &#x3D; true</span><br><span class="line">  s.requires_arc &#x3D; true</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;, &#39;Foundation&#39;</span><br><span class="line">  s.ios.deployment_target &#x3D; &#39;8.0&#39;</span><br><span class="line">  s.xcconfig &#x3D; &#123;</span><br><span class="line">    &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;MAS_SHORTHAND_GLOBALS&#x3D;1&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  s.resource_bundles &#x3D; &#123;</span><br><span class="line">    &#39;Browser&#39; &#x3D;&gt; [&#39;AKCBrowser&#x2F;Assets&#x2F;Browser&#x2F;*.*&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">  s.source_files &#x3D; &#39;AKCBrowser&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line"></span><br><span class="line">  s.dependency &#39;SDWebImage&#39;,&#39;4.2.3&#39;</span><br><span class="line">  s.dependency &#39;YYImage&#39;</span><br><span class="line">  s.dependency &#39;AKCFoundation&#39;</span><br><span class="line">  s.dependency &#39;AFNetworking&#x2F;Reachability&#39;</span><br><span class="line">  s.dependency &#39;SVProgressHUD&#39;</span><br><span class="line">  s.dependency &#39;AKCLog&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="podspec-语法简介"><a href="#podspec-语法简介" class="headerlink" title="podspec 语法简介"></a>podspec 语法简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure><p>更多语法查看(<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="noopener">http://guides.cocoapods.org/making/specs-and-specs-repo.html</a>)</p><h3 id="上传项目工程的源文件"><a href="#上传项目工程的源文件" class="headerlink" title="上传项目工程的源文件"></a>上传项目工程的源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><h3 id="验证-podspec-文件"><a href="#验证-podspec-文件" class="headerlink" title="验证 podspec 文件"></a>验证 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings --verbose</span><br><span class="line">pod lib lint --use-libraries --allow-warnings   &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line">pod lib lint --sources&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure><p>当看到 <code>AKCBrowser passed validation</code>。表示验证通过。</p><h3 id="向-Spec-Repo-中提交-podspec-文件"><a href="#向-Spec-Repo-中提交-podspec-文件" class="headerlink" title="向 Spec Repo 中提交 podspec 文件"></a>向 Spec Repo 中提交 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings</span><br><span class="line">pod repo push IMXSpecsRepo AKCProtobuf.podspec --allow-warnings --use-libraries  &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line"></span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings --sources&#x3D;&#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;ddcang&#x2F;iOSGiftBox&#x2F;SpecsRepo.git&#39;</span><br></pre></td></tr></table></figure><h2 id="多-target-时-Podfile-该如何写"><a href="#多-target-时-Podfile-该如何写" class="headerlink" title="多 target 时 Podfile 该如何写"></a>多 target 时 Podfile 该如何写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line"></span><br><span class="line">def commonPods #通用pods集</span><br><span class="line">    pod &#39;AFNetworking&#39;, &#39;~&gt; 2.0&#39;</span><br><span class="line">    pod &#39;Masonry&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def appOnlyPods #app专用pods集</span><br><span class="line">    pod &#39;MBProgressHUD&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def extensionPods #扩展专用pods集</span><br><span class="line">    pod &#39;GTSDKExtension&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :TestCocoaPods do</span><br><span class="line">    commonPods</span><br><span class="line">    appOnlyPods</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsTests do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsUITests do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # Pods for testing</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :SecondTarget do</span><br><span class="line">    commonPods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="如何忽略Pods警告"><a href="#如何忽略Pods警告" class="headerlink" title="如何忽略Pods警告"></a>如何忽略Pods警告</h2><p>在 <code>Podfile</code> 中对应的 <code>target</code> 或分组下加上关键字 <code>inhibit_all_warnings</code>即可。</p><h2 id="如何直接引用第三方库中的头文件"><a href="#如何直接引用第三方库中的头文件" class="headerlink" title="如何直接引用第三方库中的头文件"></a>如何直接引用第三方库中的头文件</h2><p>在用 <code>CocoaPods</code> 集成第三方库之后，默认情况下，我们需要使用类似 <code>#import &lt;XXX/YYY.h&gt;</code>的方式引入第三方库的头文件。</p><p>可以在 <code>Build Settings -&gt; User Header Search Paths</code> 中添加 <code>${SRCROOT}</code> 并设置成 <code>recursive</code>，这样我们就可以直接使用 <code>#impot &quot;YYY.h&quot;</code>这种方式了。</p><p>pod install 和 pod update 的选择</p><p>pod install：</p><p>按照官方文档所说，<code>pod install</code>在第一次检索集成第三方以及每一次在 <code>Podfile</code> 中新增、更改或删除 pod 的时候使用。每一次执行 <code>pod install</code>命令，它都会下载安装新的 <code>pod</code>，并且会把每一个安装的 <code>pod</code> 的版本信息写入 <code>Podfile.lock</code> 文件。<code>Podfile.lock</code> 文件跟踪每一个安装的 <code>pod</code> 的版本并且上锁。每一次执行 <code>pod install</code>命令，只解决还没有在 <code>Podfile.lock</code> 中列出的依赖：对于已在 Podfile.lock 中列出的 <code>pod</code>，会下载指定的版本，不会检查是否有新版本。对于没有在 <code>Podfile.lock</code> 中列出的 <code>pod</code>，它会搜索并安装 <code>Podfile</code> 中指定的版本。</p><p>pod update：</p><p>直接执行 <code>pod update</code>命令会检查安装 <code>Podfile</code> 中列出的所有 <code>pod</code> 的最新版本。只有当你想要更新 <code>pod</code> 库的版本时才使用 <code>pod update</code>；它不管 <code>Podfile.lock</code>是否存在，都会读取 <code>Podfile</code> 文件的最新版本，下载好之后，重新生成 <code>Podfile.lock</code>文件。</p><p>两者的区别：</p><ul><li><p>用 <code>pod install</code>命令来安装新的 <code>pod</code>，每次在 <code>Podfile</code> 中新增和删除 <code>pod</code> 都使用 <code>pod install</code>命令。</p></li><li><p>在 <code>Podfile</code> 中添加新的 <code>pod</code> 后应该用 <code>pod install</code>命令，而不是 <code>pod update</code>命令。通过 <code>pod install</code>命令安装新的 <code>pod</code> 而不用担心在同一进程中修改已有的 <code>pod</code>。</p></li><li><p><code>pod update</code>命令仅用在更新指定 <code>pod</code> 到指定版本或者更新所有 <code>pod</code>。</p></li></ul><p>如果想更新指定的 <code>pod</code> 仓库，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update XXX –no-repo-update</span><br></pre></td></tr></table></figure><p>如果想安装新添加的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install –no-repo-update</span><br></pre></td></tr></table></figure><p>当需要在 <code>CocoaPods</code> 中删除一个我们不要的库时 可以在 <code>Podfile</code> 中直接删除相关库；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod update --no-repo-update 会在删除相关库时 更新其他库版本</span><br><span class="line">pod update XXX --no-repo-update 只会删除相关库 和下方一致</span><br><span class="line">pod install --no-repo-update 只会删除相关库</span><br></pre></td></tr></table></figure><p>关于版本指定约束</p><p>一般我们在使用 <code>cocoapods</code> 导入第三方库前都会生成一个 <code>podfile</code> 文件，文件中记录着我们要导入的第三方库以及对应的版本信息，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39;, &#39;~&gt; 4.3.2&#39;</span><br></pre></td></tr></table></figure><p>让 <code>cocoapods</code> 导入 <code>SDWbImage</code>，版本号 <code>4.3.2</code> 和版本号处于 <code>4.3.2-4.4</code> 之间的，不包括 <code>4.4</code> 和更高版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39; --- 不指定版本，表示希望使用最新版本</span><br><span class="line">pod &#39;SDWebImage&#39;, &#39;4.3.2&#39; --- 指定明确版本，表示只想要这个版本</span><br><span class="line">逻辑关系</span><br><span class="line">&#39;&gt; 0.1&#39; --- 版本号大于0.1的</span><br><span class="line">&#39;&gt;&#x3D; 0.1&#39; --- 版本0.1和版本号大于0.1的</span><br><span class="line">&#39;&lt; 0.1&#39; --- 版本号小于0.1的</span><br><span class="line">&#39;&lt;&#x3D; 0.1&#39; --- 版本号0.1和版本号小于0.1的</span><br><span class="line">最优匹配</span><br><span class="line">&#39;~&gt; 0.1.2&#39; --- 版本0.1.2和版本号处于0.1.2-0.2之间的,不包括0.2和更高版本</span><br><span class="line">&#39;~&gt; 0.1&#39; --- 版本0.1和版本号处于0.1-1.0之间的,不包括1.0和更高版本</span><br><span class="line">&#39;~&gt; 0&#39; --- 版本0和更高，和没设没啥区</span><br></pre></td></tr></table></figure><p>tag 改动原则:  </p><ul><li>增加 api，修改第三位;   </li><li>修改 api，修改第二位；</li><li>大版本变更修改第一位;</li></ul><p>卸载旧版本 <code>cocoapods</code> 安装新的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sudo gem uninstall cocoapods-core cocoapods cocoapods-deintegrate cocoapods-downloader cocoapods-plugins cocoapods-search cocoapods-stats cocoapods-trunk cocoapods-try coderay colored2 concurrent-ruby cocoapods-clean</span><br><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p><code>pod</code> 库太多，每次构建编译都很耗费时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install! &#39;cocoapods&#39;, generate_multiple_pod_projects: true</span><br></pre></td></tr></table></figure><p><code>pod</code> 库每次修改代码，主工程必须 <code>clean</code> 再安装才可以看到新改动的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install! &#39;cocoapods&#39;, :disable_input_output_paths &#x3D;&gt; true</span><br></pre></td></tr></table></figure><p><code>pod lint</code> 产生的信息太多，一屏显示不全,但是出错之后我们可能需要去查看 <code>error</code> 信息，上下翻页不方便</p><p>利用脚本 <code>&gt;1.log 2&gt;&amp;1</code> 将当前的 <code>pod lint</code> 产生的信息写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --sources&#x3D;****,**** --allow-warnings --verbose --use-libraries &gt;1.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CocoaPods简介&quot;&gt;&lt;a href=&quot;#CocoaPods简介&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods简介&quot;&gt;&lt;/a&gt;CocoaPods简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CocoaPods&lt;/code&gt; 是专门为 &lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 AutoreleasePool 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2017-10-06T13:50:12.000Z</published>
    <updated>2022-01-09T11:51:07.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p><code>autorelease</code> 对象什么时候释放。</p><p><strong><code>autorelease</code> 的本质就是延迟调用 <code>release</code> 方法</strong></p><p>在 <code>MRC</code> 的环境下，可以通过调用 <code>[obj autorelease]</code> 将对象添加到当前的 <code>autoreleasepool</code> 中，来延迟释放内存； </p><p>在 <code>ARC</code>的环境下，当我们创建一个对象，可以通过 <code>__autoreleasing</code> 修饰符，会将对象添加到当前的 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p><p>注意：</p><ul><li><strong>编译器会检查方法名是否以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开始，如果不是则自动将返回值的对象注册到 <code>autoreleasepool</code> 中；</strong></li><li><strong>以 <code>__weak</code> 修饰的对象，会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong>调用 <code>Foundation</code> 对象的类方法(比如，<code>[NSMutableDictionary dictionary]</code>、<code>[NSArray array]</code> 等)会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong><code>id</code> 的指针或对象的指针在没有显式地指定修饰符时候，会被默认附加上 <code>__autoreleasing</code> 修饰符。</strong></li></ul><p>在没有手动加入 <code>autoreleasepool</code> 的情况下，<code>autorelease</code> 对象是在当前的 <code>runloop</code> 迭代结束时释放的，而它能够释放的原因是<strong>系统在每个 <code>runloop</code> 迭代中都加入了自动释放池 <code>push</code> 和 <code>pop</code></strong>。</p><p>当 <code>autoreleasepool</code> 销毁时，在调用堆栈中可以发现，系统调用了 <code>-[NSAutoreleasePool release]</code> 方法，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 <code>autoreleasepool</code> 中的 <code>autorelease</code> 对象执行 <code>release</code> 操作。</p><h1 id="AutoreleasePool-的实现原理"><a href="#AutoreleasePool-的实现原理" class="headerlink" title="AutoreleasePool 的实现原理"></a>AutoreleasePool 的实现原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>使用 <code>clang -rewrite-objc</code> 命令将下面的 <code>Objective-C</code> 代码重写成 <code>C++</code> 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br></pre></td></tr></table></figure><p>当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure><p>也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line">    void *atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#x2F;&#x2F; 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，单个 <code>autoreleasepool</code> 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code> 、<code>[obj release]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p><img src="588630-c77baf1ba3747632.png" alt="image.png"></p><p>从图中可以看出 </p><ul><li><code>AutoreleasePoolPage</code> 是由双向链表来实现的，<code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</li><li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整；</li><li><code>AutoreleasePool</code> 是按线程一一对应的，结构中的 <code>thread</code> 指针指向当前线程。</li><li><code>AutoreleasePoolPage</code> 会为每个对象会开辟 <code>4096</code> 字节内存。</li><li><code>id *next</code> 指向了下一个为空的内存地址(初始化为栈底)，如果有添加进来的 <code>autorelease</code> 对象，移动到下一个为空的内存地址中。</li></ul><p>如果 <code>AutoreleasePoolPage</code> 里面的 <code>autorelease</code> 对象满了，也就是 <code>id *next</code> 指针指向了栈顶，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来添加的 <code>autorelease</code> 对象在新的 <code>AutoreleasePoolPage</code> 加入，<code>id *next</code> 指针指向新的 <code>AutoreleasePoolPage</code> 为空的内存地址，即栈底。所以，向一个对象发送 <code>release</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的 <code>id *next</code> 指针指向的位置。</p><h3 id="POOL-SENTINEL-哨兵对象"><a href="#POOL-SENTINEL-哨兵对象" class="headerlink" title="POOL_SENTINEL(哨兵对象)"></a>POOL_SENTINEL(哨兵对象)</h3><p><img src="588630-8d76ce26495dfabd.png" alt="image.png"></p><p><strong><code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</strong></p><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>。</p><p>详细参考<a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">POOL_SENTINEL(哨兵对象)</a></p><h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h3><p><code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    if (UseGC) return nil;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码得出，每次执行 <code>objc_autoreleasePoolPush</code> 其实就是创建了一个新的 <code>autoreleasepool</code>，然后会把一个 <code>POOL_SENTINEL</code> <code>push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">    id *dest &#x3D; autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest &#x3D;&#x3D; POOL_SENTINEL);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数并传入哨兵对象  <code>POOL_SENTINEL</code> 来执行具体的插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full.</span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    assert(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    </span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; No pool in place.</span><br><span class="line">    assert(!hotPage());</span><br><span class="line">    </span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">                     (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push an autorelease pool boundary if it wasn&#39;t already requested.</span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p><ul><li>当前 <code>hotPage</code> 存在且没有满时，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 存在且已满时，调用 <code>autoreleaseFullPage</code> 初始化一个新的 <code>page</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 不存在时，调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul><h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><p>objc_autoreleasePoolPop(void *)函数本质上也是调用的AutoreleasePoolPage的pop函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    if (UseGC) return;</span><br><span class="line">    &#x2F;&#x2F; fixme rdar:&#x2F;&#x2F;9167170</span><br><span class="line">    if (!ctxt) return;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; pageForPointer(token);</span><br><span class="line">    id *stop &#x3D; (id *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    if (page-&gt;child) &#123;</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是<code>POOL_SENTINEL</code> 的内存地址。根据这个内存地址找到所在的 <code>AutoreleasePoolPage</code> 然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象。</p><p>总结：<br>每调用一次 <code>push</code> 操作就会创建一个新的 <code>autoreleasepool</code>，然后往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址.<br>在执行 <code>pop</code> 操作的时候传入 <code>POOL_SENTINEL</code>，根据传入的哨兵对象地址找到哨兵对象所处的 <code>page</code><br>在当前AutoreleasePoolPage中，然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象，并把 <code>id next</code> 指针到正确位置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试题：&quot;&gt;&lt;a href=&quot;#面试题：&quot; class=&quot;headerlink&quot; title=&quot;面试题：&quot;&gt;&lt;/a&gt;面试题：&lt;/h1&gt;&lt;p&gt;&lt;code&gt;autorelease&lt;/code&gt; 对象什么时候释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;autore
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
