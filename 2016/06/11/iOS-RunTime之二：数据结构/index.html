<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS RunTime之二：数据结构 · 孙金帅的技术博客</title><meta name="description" content="iOS RunTime之二：数据结构 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS RunTime之二：数据结构</h1><div class="post-info">2016年6月11日</div><div class="post-content"><p><img src="http://upload-images.jianshu.io/upload_images/588630-05d97aac774b34a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>通过这张图描述了<a href="https://github.com/iOS-Notes/iOS-Notes/tree/master/sourcecode/ObjectModel" target="_blank" rel="noopener">实例对象，类，元类之间的关系</a>；<br>图中实线是 <code>super_class</code> 指针，虚线是 <code>isa</code> 指针。<br>从图中看出：</p>
<ul>
<li>当发送一个实例方法的消息时，<code>isa</code> 指针会在这个类的实例方法列表中查找；</li>
<li>当发送一个类方法的消息时，<code>isa</code> 指针会在这个类的 <code>meta-class</code> 的方法列表中查找，<code>meta-class</code> 之所以重要，是因为它存储着一个类的所有类方法。</li>
<li>每个类都会有一个单独的 <code>meta-class</code>，因为每个类的类方法基本不可能完全相同。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-06943c1c4fb8ff3e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="super-class-与-self-class-的区别"><a href="#super-class-与-self-class-的区别" class="headerlink" title="[super class] 与 [self class] 的区别"></a>[super class] 与 [self class] 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>借助 <code>clang</code> 编译器，会被编译器转化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static instancetype _I_Student_init(Student * self, SEL _cmd) &#123;</span><br><span class="line"> self &#x3D; ((Student *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;init&quot;));</span><br><span class="line"> if (self) &#123;</span><br><span class="line">  id obj1 &#x3D; ((Class (*)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(&quot;class&quot;));</span><br><span class="line">  id obj2 &#x3D; ((Class (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(&quot;Student&quot;))&#125;, sel_registerName(&quot;class&quot;));</span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hj_pwgsq9614nb0vq4zd315tcx80000gn_T_Student_e7cbc1_mi_0,obj1);</span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hj_pwgsq9614nb0vq4zd315tcx80000gn_T_Student_e7cbc1_mi_1,obj2);</span><br><span class="line"> &#125;</span><br><span class="line"> return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见：<br> <code>[self class]</code> 编译器最终转成 <code>objc_msgSend(self,@selector(class))</code>，消息的接收者是当前所在类的实例对象，这个时候就会去 <code>self</code> 所在类 <code>Student</code> 去查找 <code>class</code> 方法，如果当前类 <code>Student</code> 没有 <code>class</code> 会向 <code>Student</code> 父类 <code>Person</code> 类找 <code>class</code> 方法，如果 <code>Person</code> 类也没有找到 <code>class</code> 方法，最终会找到最顶级父类 <code>NSObject</code> 的 <code>class</code> 方法，并调用了 <code>object_getClass(self)</code>，由于消息接收者是 <code>self</code> 当前类实例对象，所以最终 <code>[self class]</code> 输出 <code>Student</code>；</p>
<p><code>[super class]</code> 最终编译器转化成了 <code>objc_msgSendSuper(struct objc_super *,SEL)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_super</code> 是一个结构体，结构体里面有两个指针，一个是接收消息的 <code>receiver</code>，另一个是指向当前类的父类 <code>super_class</code>，通过 <code>super_class</code> 指针从父类的方法列表开始查找 <code>selector</code>，由于消息接收者还是当前类的实例对象 <code>self</code>，那么 <code>objc_msgSendSuper</code> 最后就转变成，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(objc_super-&gt;receiver, @selector(class))</span><br><span class="line">- (Class)class &#123;</span><br><span class="line">    return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于找到了父类 <code>NSObject</code> 里面的 <code>class</code> 方法的 <code>IMP</code>，又因为传入的入参 <code>objc_super-&gt;receiver = self</code>。<code>self</code> 就是 <code>Student</code>，调用 <code>class</code>，所以父类的方法 <code>class</code> 执行 <code>IMP</code> 之后，输出还是 <code>Student</code>，最后输出两个都一样，都是输出 <code>Student</code>。</p>
<h4 id="isMemberOfClass-和-isKindOfClass-的区别"><a href="#isMemberOfClass-和-isKindOfClass-的区别" class="headerlink" title="isMemberOfClass 和 isKindOfClass 的区别"></a>isMemberOfClass 和 isKindOfClass 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return object_getClass((id)self) &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    return [self class] &#x3D;&#x3D; cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; object_getClass((id)self); tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    for (Class tcls &#x3D; [self class]; tcls; tcls &#x3D; tcls-&gt;superclass) &#123;</span><br><span class="line">        if (tcls &#x3D;&#x3D; cls) return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isKindOfClass</code>：是判断方法调用者对象的类是否等于传入的这个类或者其子类；<br><code>isMemberOfClass</code>：<code>object_getClass()</code> 取得的是对象的 <code>isa</code> 指针指向的对象，也就是判断传入的类对象的元类对象是否与传入的这个对象相等，所以这个 <code>cls</code> 应该是元类对象才有可能相等，是检测方法调用者对象的类是否等于传入的这个类；</p>
<h4 id="objc-getClass-和-object-getClass-的区别"><a href="#objc-getClass-和-object-getClass-的区别" class="headerlink" title="objc_getClass 和 object_getClass 的区别"></a>objc_getClass 和 object_getClass 的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class _Nullable objc_getClass(const char * _Nonnull name)</span><br><span class="line">const char * _Nonnull object_getClassName(id _Nullable obj)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>objc_getClass</code><br><code>objc_getClass</code> 参数是类名的字符串，返回的就是这个类的类对象；</p>
</li>
<li><p><code>object_getClass</code><br><code>object_getClass</code> 参数是 <code>id</code> 类型，它返回的是这个 <code>id</code> 的 <code>isa</code> 指针所指向的 <code>Class</code>，如果是 <code>instance</code> 对象，返回 <code>class</code> 对象；如果是 <code>class</code> 对象，返回 <code>meta-class</code> 对象；如果是 <code>meta-class</code> 对象，返回 <code>NSObject</code> 的 <code>meta-class</code> 对象；</p>
</li>
</ul>
<h4 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>万物皆对象，通过源码分析，<code>NSObject</code> 里面包含一个 <code>objc_class</code> 结构体类型的 <code>isa</code> 指针；</p>
<h4 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Class、uintptr_t、结构体公用一块内存空间，isa_t 是一个 Class、同时是一个 64 位地址 bits、是一个 64 位结构体。</span><br><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">#if SUPPORT_PACKED_ISA</span><br><span class="line"></span><br><span class="line"># if __arm64__</span><br><span class="line">#   define ISA_MASK        0x0000000ffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x000003f000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x000001a000000001ULL</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33; &#x2F;&#x2F; MACH_VM_MAX_ADDRESS 0x1000000000</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;45)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;18)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"># elif __x86_64__</span><br><span class="line">#   define ISA_MASK        0x00007ffffffffff8ULL</span><br><span class="line">#   define ISA_MAGIC_MASK  0x001f800000000001ULL</span><br><span class="line">#   define ISA_MAGIC_VALUE 0x001d800000000001ULL</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1;</span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 44; &#x2F;&#x2F; MACH_VM_MAX_ADDRESS 0x7fffffe00000</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t deallocating      : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 8;</span><br><span class="line">#       define RC_ONE   (1ULL&lt;&lt;56)</span><br><span class="line">#       define RC_HALF  (1ULL&lt;&lt;7)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"># else</span><br><span class="line">#   error unknown architecture for packed isa</span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SUPPORT_PACKED_ISA</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-99d44cb6173267fe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p><code>isa_t</code> 是一个 <code>union</code> 类型的结构体，其中的 <code>isa_t</code>、<code>cls</code>、 <code>bits</code> 还有结构体共用同一块地址空间，而 <code>isa</code> 总共会占据 <code>64</code> 位的内存空间。<br>词语解析：<br><code>nonpointer</code>：代表是否开启 <code>isa</code> 指针优化。<code>nonpointer = 1</code>，代表开启 <code>isa</code> 指针优化<strong><code>Tagged Pointer</code></strong>。<br><code>has_assoc</code>：是否有设置过关联对象，如果没有，释放时会更快。<br><code>has_cxx_dtor</code>：是否有 <code>C++</code> 或者 <code>Objc</code> 的析构函数，如果没有，释放时会更快。<br><code>shiftcls</code>：类指针，存储着 <code>Class</code>、<code>Meta-Class</code> 对象的内存地址信息，<code>arm64</code> 架构中有 <code>33</code> 位可以存储类指针，在 <code>__x86_64__</code> 架构中有 <code>44</code> 位可以存储类指针。<br><code>magic</code>：判断对象是否初始化完成。<br><code>weakly_referenced</code>：是否有被弱引用指向过，如果没有，释放时会更快。<br><code>deallocating</code>：对象是否正在释放。<br><code>has_sidetable_rc</code>：判断该对象的引用计数是否过大，如果过大则需要其他哈希表来进行存储。<br><code>extra_rc</code>：存放该对象的引用计数值 <code>-1</code> 后的结果。对象的引用计数超过 <code>1</code>，会存在这个这个里面，如果引用计数为 <code>10</code>，<code>extra_rc</code> 的值就为 <code>9</code>。</p>
<p>注：本文提到的 <code>nonpointer</code> 等同于 <code>indexed</code>，在 <code>objc</code> 最新源码已改名为 <code>nonpointer</code>。</p>
<h4 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a>isa 的初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line">    assert(hasCxxDtor &#x3D;&#x3D; cls-&gt;hasCxxDtor());</span><br><span class="line"></span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    if (!nonpointer) &#123;</span><br><span class="line">        isa.cls &#x3D; cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        assert(!DisableNonpointerIsa);</span><br><span class="line">        assert(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        isa_t newisa(0);</span><br><span class="line"></span><br><span class="line">#if SUPPORT_INDEXED_ISA</span><br><span class="line">        assert(cls-&gt;classArrayIndex() &gt; 0);</span><br><span class="line">        newisa.bits &#x3D; ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.indexcls &#x3D; (uintptr_t)cls-&gt;classArrayIndex();</span><br><span class="line">#else</span><br><span class="line">        newisa.bits &#x3D; ISA_MAGIC_VALUE;</span><br><span class="line">        &#x2F;&#x2F; isa.magic is part of ISA_MAGIC_VALUE</span><br><span class="line">        &#x2F;&#x2F; isa.nonpointer is part of ISA_MAGIC_VALUE</span><br><span class="line">        newisa.has_cxx_dtor &#x3D; hasCxxDtor;</span><br><span class="line">        newisa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">#endif</span><br><span class="line">        isa &#x3D; newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>nonpointer</code> 是固定传 <code>true</code>，因为现在 <code>iOS</code> 已经迁移到 <code>64</code> 位系统了，也就是目前逻辑基本直走 <code>else</code> 分支，然后是 <code>SUPPORT_INDEXED_ISA</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __ARM_ARCH_7K__ &gt;&#x3D; 2</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 1</span><br><span class="line">#else</span><br><span class="line">#   define SUPPORT_INDEXED_ISA 0</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><code>SUPPORT_INDEXED_ISA = 1</code> 是另外一种优化，用 <code>isa</code> 内 <code>indexcls</code> 存储着类在类列表内的索引，用于 <code>apple watch</code> 设备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newisa.bits &#x3D; ISA_MAGIC_VALUE</span><br></pre></td></tr></table></figure>
<p>这里给 <code>bits</code> 赋初始，<code>ISA_MAGIC_VALUE = 0x001d800000000001ULL</code>，我们把它转化成二进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISA_MAGIC_VALUE &#x3D; 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-b57f63fdf0249507.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>也就是 <code>ISA_MAGIC_VALUE</code> 只设置 <code>nonpointer</code> 以及 <code>magic</code> 这两个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls &#x3D; (uintptr_t)cls &gt;&gt; 3</span><br></pre></td></tr></table></figure>
<p>将当前地址右移三位的主要原因是用于将 <code>Class</code> 指针中无用的后三位清楚减小内存的消耗，因为类的指针要按照字节（<code>8 bits</code>）对齐内存，其指针后三位都是没有意义的 <code>0</code>。</p>
<p><code>ISA_MASK</code> 分别是通过掩码的方式获取 <code>isa</code> 的类指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    return (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer</a></h4><p>在2013年9月苹果提出了 Tagged Pointer 的概念，对于64位程序，引入 Tagged Pointer 后，相关逻辑能减少一半的内存占用，以及 3 倍的访问速度提升，100 倍的创建、销毁速度提升。<br>例如，要存储一个 NSNumber 对象，其值是一个整数。正常情况下，如果这个整数只是一个 NSInteger 的普通变量，那么它所占用的内存是与 CPU 的位数有关，在 32 位 CPU 下占 4 个字节，在 64 位 CPU 下是占 8 个字节的。而指针类型的大小通常也是与 CPU 位数相关，一个指针所占用的内存在 32 位 CPU 下为 4 个字节，在 64 位 CPU 下也是 8 个字节。如果没有Tagged Pointer对象，从 32 位机器迁移到 64 位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-e79f562ed74e2fb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。由于 NSNumber、NSDate 一类的变量本身的值需要占用的内存大小常常不需要 8 个字节，拿整数来说，4 个字节所能表示的有符号整数就可以达到 20 多亿（注：2^31=2147483648，另外 1 位作为符号位)，对于绝大多数情况都是可以处理的。</p>
<p>所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了Tagged Pointer对象之后，64 位 CPU 下 NSNumber 的内存图变成了以下这样：<br><img src="https://upload-images.jianshu.io/upload_images/588630-577f7865fef3487a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>运行之后，我们得到的结果如下，可以看到，除去最后的数字最末尾的 2 以及最开头的 0xb，其它数字刚好表示了相应 NSNumber 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-08-26 19:58:08.232 TaggedPointer[87063:1919845] number1 Tagged Pointer is 0xb000000000000072</span><br><span class="line">2017-08-26 19:58:08.232 TaggedPointer[87063:1919845] number2 Tagged Pointer is 0xb0000000000006f2</span><br><span class="line">2017-08-26 19:58:08.232 TaggedPointer[87063:1919845] number3 Tagged Pointer is 0xb0000000000022b2</span><br></pre></td></tr></table></figure>

<p>尝试放一个 8 字节的长的整数到NSNumber实例中，对于这样的实例，由于Tagged Pointer无法将其按上面的压缩方式来保存，那么应该就会以普通对象的方式来保存，我们的实验代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-08-26 20:00:11.833 TaggedPointer[87122:1921799] number1 Tagged Pointer is 0xb000000000000072</span><br><span class="line">2017-08-26 20:00:11.833 TaggedPointer[87122:1921799] number2 Tagged Pointer is 0xb0000000000006f2</span><br><span class="line">2017-08-26 20:00:11.833 TaggedPointer[87122:1921799] number3 Tagged Pointer is 0xb0000000000022b2</span><br><span class="line">2017-08-26 20:00:11.833 TaggedPointer[87122:1921799] bigNumber Tagged Pointer is 0x6100000251a0</span><br></pre></td></tr></table></figure>
<p>运行之后，结果如下，验证了我们的猜测，bigNumber的地址更像是一个普通的指针地址，和它本身的值看不出任何关系。</p>
<p>可见，当 8 字节可以承载用于表示的数值时，系统就会以Tagged Pointer的方式生成指针，如果 8 字节承载不了时，则又用以前的方式来生成普通的指针。</p>
<p>苹果引入Tagged Pointer，不但减少了 64 位机器下程序的内存占用，还提高了运行效率。完美地解决了小内存对象在存储和访问效率上的问题。</p>
<h4 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    &#x2F;&#x2F; Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             &#x2F;&#x2F; formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    &#x2F;&#x2F; class_rw_t * plus custom rr&#x2F;alloc flags</span><br><span class="line"></span><br><span class="line">    class_rw_t *data() &#123; </span><br><span class="line">        return bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">    return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码分析：<br><code>objc_class</code> 里面包含一个 <code>objc_class</code> 结构体类型的 <code>superclass</code> 指针，可以通过 <code>superclass</code> 指针，查找到父类；<br><code>cache_t</code> 结构体的 <code>cache</code> 指针，<code>cache</code> 主要用于方法性能优化，对使用过的方法进行缓存，便于第二次查找；<br><code>class_data_bits_t</code> 结构体的 <code>bits</code> 指针，只含有一个 <code>64</code> 位的 <code>bits</code> 用于存储与类有关的信息；</p>
<p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 <code>rr/alloc</code> 的标志。</p>
<p>通过将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，返回 <code>class_rw_t *</code> 指针，其中 <code>Objc</code> 的类的属性、方法、以及遵循的协议都放在 <code>class_rw_t</code> 结构体中；</p>
<h4 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t occupied();</span><br><span class="line">    void incrementOccupied();</span><br><span class="line">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class="line">    void initializeToEmpty();</span><br><span class="line"></span><br><span class="line">    mask_t capacity();</span><br><span class="line">    bool isConstantEmptyCache();</span><br><span class="line">    bool canBeFreed();</span><br><span class="line"></span><br><span class="line">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class="line">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    void expand();</span><br><span class="line">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class="line">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key &#x3D; newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp &#x3D; newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>cache</code> 主要是为了优化方法调用的性能，一个接收者对象接收到一个消息时，它会根据 isa 指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是 <code>methodLists</code> 中遍历一遍，性能势必很差。这时，<code>cache</code> 就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到 <code>cache</code> 列表中，下次调用的时候就会优先去 <code>cache</code> 中查找，才去 <code>methodLists</code> 中查找方法。</p>
<p>从源码中可以看出，<br><code>_buckets</code> 指针是一个指向 <code>bucket_t</code> 结构体的哈希表，<code>_buckets</code> 哈希表里面包含多个 <code>bucket_t</code>，每个 <code>bucket_t</code> 里面存放着 <code>SEL</code> 和 <code>imp</code> 函数的内存地址的对应关系；<br><code>_mask</code> 是一个 <code>uint32_t</code> 的指针，表示整个 <code>_buckets</code> 哈希表的长度；<br><code>_occupied</code> 也是一个 <code>uint32_t</code> 的指针，在 <code>_buckets</code> 哈希表中已经缓存的方法数量；</p>
<p>在 <code>bucket_t</code> 结构体中，<code>_key</code> 是一个 <code>unsigned long</code> 的指针，其实是一个被 <code>hash</code> 化的一串数值，就是方法的 <code>sel</code>，也就是方法名；<code>_imp</code> 指针保持着对应的函数地址；</p>
<h6 id="cache-t-如何缓存-sel"><a href="#cache-t-如何缓存-sel" class="headerlink" title="cache_t 如何缓存 sel"></a>cache_t 如何缓存 sel</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">void cache_fill(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cache_fill_nolock(cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Never cache before +initialize is done</span><br><span class="line">    &#x2F;&#x2F; 系统要求在类初始化完成之前，不能进行方法返回，因此如果类没有完成初始化就 return</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span><br><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">    &#x2F;&#x2F; 因为有可能其他线程已经把该方法缓存起来，如果缓存中已经缓存过了，不用再缓存，直接 return</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache &#x3D; getCache(cls);</span><br><span class="line">    cache_key_t key &#x3D; getKey(sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span><br><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is too full. Expand it.</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span><br><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot because the </span><br><span class="line">    &#x2F;&#x2F; minimum size is 4 and we resized at 3&#x2F;4 full.</span><br><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity &#x3D; capacity();</span><br><span class="line">    uint32_t newCapacity &#x3D; oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    if ((uint32_t)(mask_t)newCapacity !&#x3D; newCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; mask overflow - can&#39;t grow further</span><br><span class="line">        &#x2F;&#x2F; fixme this wastes one bit of mask</span><br><span class="line">        newCapacity &#x3D; oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    bool freeOld &#x3D; canBeFreed();</span><br><span class="line"></span><br><span class="line">    bucket_t *oldBuckets &#x3D; buckets();</span><br><span class="line">    bucket_t *newBuckets &#x3D; allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache&#39;s old contents are not propagated. </span><br><span class="line">    &#x2F;&#x2F; This is thought to save cache memory at the cost of extra cache fills.</span><br><span class="line">    &#x2F;&#x2F; fixme re-measure this</span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; 0);</span><br><span class="line">    assert((uintptr_t)(mask_t)(newCapacity-1) &#x3D;&#x3D; newCapacity-1);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - 1);</span><br><span class="line">    </span><br><span class="line">    if (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先看缓存中是否已经存在了该方法，如果已经存在，直接return掉；</li>
<li>如果缓存是只读的，则需要重新申请缓存空间；</li>
<li>如果存入缓存后的大小小于当前大小的 <code>3/4</code>，则当前缓存大小还可以使用，无需扩容；</li>
<li>如果缓存太满，需要扩容，扩容为原来大小的 <code>2</code> 倍，重新申请缓存空间；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 &#x3D; 2,</span><br><span class="line">    INIT_CACHE_SIZE      &#x3D; (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果是首次调用这个函数，会使用一个初始容量值 <code>INIT_CACHE_SIZE</code> 来设定缓存容量；从 <code>INIT_CACHE_SIZE</code> 的定义显示它的值是 <code>4</code>，也就是说苹果给 <code>cache_t</code> 设定的初始容量是 <code>4</code>。</li>
<li>重新设置哈希表的长度 <code>_mask = newCapacity-1</code>，然后将旧内存释放掉，清空缓存；</li>
<li>当通过 <code>find()</code> 方法返回的 <code>bucket-&gt;key() == 0</code>，就说明该位置上是空的，没有缓存过方法，因此可以进行插入操作 <code>bucket-&gt;set(key, imp)</code>，也就是将方法缓存到这个位置上。</li>
</ul>
<p><strong>注意：传入 <code>cls</code> 得到缓存列表，如果是 <code>instance</code> 对象，返回 <code>class</code> 对象；如果是 <code>class</code> 对象，返回 <code>meta-class</code> 对象；如果是 <code>meta-class</code> 对象，返回 <code>NSObject</code> 的 <code>meta-class</code> 对象；</strong></p>
<h6 id="cache-t-如何查找-sel"><a href="#cache-t-如何查找-sel" class="headerlink" title="cache_t 如何查找 sel"></a>cache_t 如何查找 sel</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; mask();</span><br><span class="line">    &#x2F;&#x2F; 通过 cache_hash() 计算出 key 值 k 对应的 index 值 begin，用来记录查询起始索引；</span><br><span class="line">    mask_t begin &#x3D; cache_hash(k, m);</span><br><span class="line">    &#x2F;&#x2F; begin 赋值给 i，用于切换索引</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 用这个 i 从哈希表取值，如果取出来的 bucket_t 的 key &#x3D; k，则查询成功，返回该 bucket_t。</span><br><span class="line">        &#x2F;&#x2F; 如果 key &#x3D; 0，说明在索引 i 的位置上还没有缓存过方法，同样需要返回该 bucket_t，用于中止缓存查询。</span><br><span class="line">        if (b[i].key() &#x3D;&#x3D; 0  ||  b[i].key() &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i &#x3D; cache_next(i, m)) !&#x3D; begin);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hack</span><br><span class="line">    Class cls &#x3D; (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>cache_t</code> 如何查找 <code>sel</code>，本质上就是根据 <code>key</code> 如何查找 <code>index</code> 的过程；</strong><br>根据 <code>key</code> 计算出 <code>index</code> 值的这个算法称作哈希算法，尽可能减少不同的 <code>key</code> 得出相同 <code>index</code> 的情况出现，这种情况被称作哈希碰撞，同时还要保证得出的 <code>index</code> 值在合理的范围。<code>index</code> 越大，意味着对应的哈希表的长度越长，这是需要占用实际物理空间的，而内存是有限的。<br><strong>哈希表是一种通过牺牲一定空间，来换取时间效率的设计思想。</strong></p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><strong>SEL</strong></h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在<code>Objc</code>中的表示类型（<code>Swift</code>中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的<code>id</code>，而这个<code>id</code>的数据结构是<code>SEL</code>，即表示一个方法的<code>selector</code>的指针。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f1c54b79137a3a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>方法的<code>selector</code>用于表示运行时方法的名字，<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>int</code>类型的地址)，这个标识就是<code>SEL</code>。</li>
<li>在<code>Objective-C</code>中，只要方法名相同，那么方法的<code>SEL</code>就是一样的，每一个方法都对应着一个<code>SEL</code>，所以在<code>Objective-C</code>中，同一个类中或者这个类的继承体系中，不能存在2个同名的方法，不同的类可以拥有相同的<code>selector</code>，不同的类的实例对象执行相同的<code>selector</code>，会在各自的方法列表中根据<code>selector</code>去寻找对应的<code>IMP</code>。</li>
<li>在本质上，<code>SEL</code>只是一个指向方法的指针（被<code>hash</code>化得<code>KEY</code>值），能提高方法的查询速度。</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><strong>IMP</strong></h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>第一个参数是指向 <code>self</code> 的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器( <code>selector</code> )，接下来是方法的实际参数列表。</p>
<p><code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的，由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><strong>Method</strong></h4><p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c75430d85b645678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-382fc04a120fc065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意：</p>
<ul>
<li>方法名类型为<code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li>
<li>方法类型<code>method_types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>
<li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针。</li>
</ul>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a><strong>Ivar</strong></h4><p><code>Ivar</code>是一种代表类中实例变量的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-dcb54cf3c9cc43ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4f01a318d7041fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>参考资料<br><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/</a><br><a href="https://draveness.me/isa" target="_blank" rel="noopener">https://draveness.me/isa</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/06/12/iOS-RunTime%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/" class="prev">上一篇</a><a href="/2016/06/10/iOS-RunTime%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%AE%80%E4%BB%8B/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/06/11/iOS-RunTime之二：数据结构/';
var disqus_title = 'iOS RunTime之二：数据结构';
var disqus_url = 'https://sunjinshuai.github.io/2016/06/11/iOS-RunTime之二：数据结构/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>