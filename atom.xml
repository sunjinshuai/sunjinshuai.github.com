<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2020-01-10T03:31:14.000Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CocoaPods 使用总结</title>
    <link href="https://sunjinshuai.github.io/2019/12/10/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sunjinshuai.github.io/2019/12/10/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-12-10T01:39:14.000Z</published>
    <updated>2020-01-10T03:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocoaPods简介"><a href="#CocoaPods简介" class="headerlink" title="CocoaPods简介"></a>CocoaPods简介</h2><p><code>CocoaPods</code> 是专门为 <code>iOS</code> 工程提供第三方依赖库的管理工具，通过 <code>CocoaPods</code>，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置，就可以直观、集中和自动化地管理我们项目的第三方库。</p><p><code>CocoaPods</code> 将所有依赖的库都放在一个名为 <code>Pods</code> 的项目下，然后让主项目依赖 <code>Pods</code> 项目。然后，我们编码工作都从主项目转移到 <code>Pods</code> 项目。<code>Pods</code> 项目最终会编译为一个 <code>libPod-项目名.a</code> 静态库，主项目依赖于这个静态库。</p><p>对于资源文件，<code>CocoaPods</code> 提供了一个名为 <code>Pods-resources.sh</code> 的 <code>bash</code> 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。<code>CocoaPods</code> 通过一个名为 <code>Pods.xcconfig</code> 的文件来在编译时设置所有的依赖和参数。<code>CocoaPods</code> 是用 <code>Ruby</code> 写的，并由若干个 <code>Ruby</code> 包 (gems) 构成的。在解析整合过程中，最重要的几个 <code>gems</code> 分别是： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCocoaPods%2F" target="_blank" rel="noopener">CocoaPods/CocoaPods</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCore" target="_blank" rel="noopener">CocoaPods/Core</a> 和 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FXcodeproj" target="_blank" rel="noopener">CocoaPods/Xcodeproj</a>。</p><h2 id="CocoaPod的核心组件"><a href="#CocoaPod的核心组件" class="headerlink" title="CocoaPod的核心组件"></a>CocoaPod的核心组件</h2><ul><li>CocoaPods/CocoaPod<br>这是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 <code>CocoaPods</code> 涉及到的功能，并且还能通过调用所有其它的 <code>gems</code> 来执行任务。</li><li>CocoaPods/Core<br><code>Core</code> 组件提供支持与 <code>CocoaPods</code> 相关文件的处理，文件主要是 <code>Podfile</code> 和 <code>podspecs</code>。</li><li>Podfile<br><code>Podfile</code> 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <code>Podfile</code> 指南。</li><li>Podspec<br><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、<code>framework</code>、编译选项和某个库所需要的依赖等。</li><li>CocoaPods/Xcodeproj<br>这个 <code>gem</code> 组件负责所有工程文件的整合。它能够创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 <code>gem</code> 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 <code>gem</code>。</li></ul><h2 id="私有库开发流程"><a href="#私有库开发流程" class="headerlink" title="私有库开发流程"></a>私有库开发流程</h2><p>一般公司都会搭建自己的 <code>git</code> 服务器，在实战项目中，经常使用 <code>Cocoapods</code> 管理自己的私有库。</p><ul><li><code>git</code> 仓库至少需要两个，一个用于管理私有库对应版本的 <code>podspec</code> 文件，一个用于存放私有库的源文件。</li><li>查看现有的 <code>podspec</code> 源地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建一个私有的-podspec-主要包括如下几步："><a href="#创建一个私有的-podspec-主要包括如下几步：" class="headerlink" title="创建一个私有的 podspec 主要包括如下几步："></a>创建一个私有的 <code>podspec</code> 主要包括如下几步：</h3><ul><li>创建一个私有的 <code>Spec Repo</code>，用于管理私有库对应版本的 <code>podspec</code> 文件；</li><li>创建 <code>pod</code> 私有库所需要的项目工程文件，并上传到私有库；</li><li>创建 <code>pod</code> 所对应的 <code>podspec</code> 文件，并进行验证／测试；</li><li>向私有的 <code>Spec Repo</code> 中提交 <code>podspec</code>；</li><li>使用 <code>pod</code> 库；</li></ul><h3 id="创建一个私有的-Spec-Repo"><a href="#创建一个私有的-Spec-Repo" class="headerlink" title="创建一个私有的 Spec Repo"></a>创建一个私有的 <code>Spec Repo</code></h3><ul><li>在自己公司的 <code>git</code> 服务器上创建 <code>SpecsRepo</code> 仓库；</li><li>将私有 <code>SpecsRepo</code> 关联到本地；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add IMXSpecsRepo http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure></li></ul><p>查看 <code>SpecsRepo</code> 是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure><h3 id="创建-pod-私有库所需要的项目工程"><a href="#创建-pod-私有库所需要的项目工程" class="headerlink" title="创建 pod 私有库所需要的项目工程"></a>创建 pod 私有库所需要的项目工程</h3><h4 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create 仓库名字 --template-url&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXPodTemplte</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>手动创建</p><p>手动创建 <code>Xcode</code> 工程项目，创建 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create XXXX.podspec</span><br></pre></td></tr></table></figure><p>修改 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name             &#x3D; &#39;AKCBrowser&#39;</span><br><span class="line">  s.version          &#x3D; &#39;0.0.1&#39;</span><br><span class="line">  s.summary          &#x3D; &#39;A short description of AKCBrowser.&#39;</span><br><span class="line"></span><br><span class="line">  # This description is used to generate tags and improve search results.</span><br><span class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">  #   * Try to keep it short, snappy and to the point.</span><br><span class="line">  #   * Write the description between the DESC delimiters below.</span><br><span class="line">  #   * Finally, don&#39;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">  TODO: Add long description of the pod here.</span><br><span class="line">  DESC</span><br><span class="line"></span><br><span class="line">  s.homepage         &#x3D; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;</span><br><span class="line">  # s.screenshots     &#x3D; &#39;www.example.com&#x2F;screenshots_1&#39;, &#39;www.example.com&#x2F;screenshots_2&#39;</span><br><span class="line">  s.license          &#x3D; &#123; :type &#x3D;&gt; &#39;MIT&#39;, :file &#x3D;&gt; &#39;LICENSE&#39; &#125;</span><br><span class="line">  s.author           &#x3D; &#123; &#39;sunjinshuai&#39; &#x3D;&gt; &#39;s_mike@163.com&#39; &#125;</span><br><span class="line">  s.source           &#x3D; &#123; :git &#x3D;&gt; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line"></span><br><span class="line">  s.static_framework      &#x3D; true</span><br><span class="line">  s.requires_arc &#x3D; true</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;, &#39;Foundation&#39;</span><br><span class="line">  s.ios.deployment_target &#x3D; &#39;8.0&#39;</span><br><span class="line">  s.xcconfig &#x3D; &#123;</span><br><span class="line">    &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;MAS_SHORTHAND_GLOBALS&#x3D;1&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  s.resource_bundles &#x3D; &#123;</span><br><span class="line">    &#39;Browser&#39; &#x3D;&gt; [&#39;AKCBrowser&#x2F;Assets&#x2F;Browser&#x2F;*.*&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">  s.source_files &#x3D; &#39;AKCBrowser&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line"></span><br><span class="line">  s.dependency &#39;SDWebImage&#39;,&#39;4.2.3&#39;</span><br><span class="line">  s.dependency &#39;YYImage&#39;</span><br><span class="line">  s.dependency &#39;AKCFoundation&#39;</span><br><span class="line">  s.dependency &#39;AFNetworking&#x2F;Reachability&#39;</span><br><span class="line">  s.dependency &#39;SVProgressHUD&#39;</span><br><span class="line">  s.dependency &#39;AKCLog&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="podspec-语法简介"><a href="#podspec-语法简介" class="headerlink" title="podspec 语法简介"></a>podspec 语法简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure><p>更多语法查看(<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="noopener">http://guides.cocoapods.org/making/specs-and-specs-repo.html</a>)</p><h3 id="上传项目工程的源文件"><a href="#上传项目工程的源文件" class="headerlink" title="上传项目工程的源文件"></a>上传项目工程的源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><h3 id="验证-podspec-文件"><a href="#验证-podspec-文件" class="headerlink" title="验证 podspec 文件"></a>验证 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings --verbose</span><br><span class="line">pod lib lint --use-libraries --allow-warnings   &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line">pod lib lint --sources&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure><p>当看到 <code>AKCBrowser passed validation</code>。表示验证通过。</p><h3 id="向-Spec-Repo-中提交-podspec-文件"><a href="#向-Spec-Repo-中提交-podspec-文件" class="headerlink" title="向 Spec Repo 中提交 podspec 文件"></a>向 Spec Repo 中提交 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings</span><br><span class="line">pod repo push IMXSpecsRepo AKCProtobuf.podspec --allow-warnings --use-libraries  &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line"></span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings --sources&#x3D;&#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;ddcang&#x2F;iOSGiftBox&#x2F;SpecsRepo.git&#39;</span><br></pre></td></tr></table></figure><h2 id="多-target-时-Podfile-该如何写"><a href="#多-target-时-Podfile-该如何写" class="headerlink" title="多 target 时 Podfile 该如何写"></a>多 target 时 Podfile 该如何写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line"></span><br><span class="line">def commonPods #通用pods集</span><br><span class="line">    pod &#39;AFNetworking&#39;, &#39;~&gt; 2.0&#39;</span><br><span class="line">    pod &#39;Masonry&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def appOnlyPods #app专用pods集</span><br><span class="line">    pod &#39;MBProgressHUD&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def extensionPods #扩展专用pods集</span><br><span class="line">    pod &#39;GTSDKExtension&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :TestCocoaPods do</span><br><span class="line">    commonPods</span><br><span class="line">    appOnlyPods</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsTests do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsUITests do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # Pods for testing</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :SecondTarget do</span><br><span class="line">    commonPods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="如何忽略Pods警告"><a href="#如何忽略Pods警告" class="headerlink" title="如何忽略Pods警告"></a>如何忽略Pods警告</h2><p>在 <code>Podfile</code> 中对应的 <code>target</code> 或分组下加上关键字 <code>inhibit_all_warnings</code>即可。</p><h2 id="如何直接引用第三方库中的头文件"><a href="#如何直接引用第三方库中的头文件" class="headerlink" title="如何直接引用第三方库中的头文件"></a>如何直接引用第三方库中的头文件</h2><p>在用 <code>CocoaPods</code> 集成第三方库之后，默认情况下，我们需要使用类似 <code>#import &lt;XXX/YYY.h&gt;</code>的方式引入第三方库的头文件。</p><p>可以在 <code>Build Settings -&gt; User Header Search Paths</code> 中添加 <code>${SRCROOT}</code> 并设置成 <code>recursive</code>，这样我们就可以直接使用 <code>#impot &quot;YYY.h&quot;</code>这种方式了。</p><p>pod install 和 pod update 的选择</p><p>pod install：</p><p>按照官方文档所说，<code>pod install</code>在第一次检索集成第三方以及每一次在 <code>Podfile</code> 中新增、更改或删除 pod 的时候使用。每一次执行 <code>pod install</code>命令，它都会下载安装新的 <code>pod</code>，并且会把每一个安装的 <code>pod</code> 的版本信息写入 <code>Podfile.lock</code> 文件。<code>Podfile.lock</code> 文件跟踪每一个安装的 <code>pod</code> 的版本并且上锁。每一次执行 <code>pod install</code>命令，只解决还没有在 <code>Podfile.lock</code> 中列出的依赖：对于已在 Podfile.lock 中列出的 <code>pod</code>，会下载指定的版本，不会检查是否有新版本。对于没有在 <code>Podfile.lock</code> 中列出的 <code>pod</code>，它会搜索并安装 <code>Podfile</code> 中指定的版本。</p><p>pod update：</p><p>直接执行 <code>pod update</code>命令会检查安装 <code>Podfile</code> 中列出的所有 <code>pod</code> 的最新版本。只有当你想要更新 <code>pod</code> 库的版本时才使用 <code>pod update</code>；它不管 <code>Podfile.lock</code>是否存在，都会读取 <code>Podfile</code> 文件的最新版本，下载好之后，重新生成 <code>Podfile.lock</code>文件。</p><p>两者的区别：</p><ul><li><p>用 <code>pod install</code>命令来安装新的 <code>pod</code>，每次在 <code>Podfile</code> 中新增和删除 <code>pod</code> 都使用 <code>pod install</code>命令。</p></li><li><p>在 <code>Podfile</code> 中添加新的 <code>pod</code> 后应该用 <code>pod install</code>命令，而不是 <code>pod update</code>命令。通过 <code>pod install</code>命令安装新的 <code>pod</code> 而不用担心在同一进程中修改已有的 <code>pod</code>。</p></li><li><p><code>pod update</code>命令仅用在更新指定 <code>pod</code> 到指定版本或者更新所有 <code>pod</code>。</p></li></ul><p>如果想更新指定的 <code>pod</code> 仓库，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update XXX –no-repo-update</span><br></pre></td></tr></table></figure><p>如果想安装新添加的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install –no-repo-update</span><br></pre></td></tr></table></figure><p>当需要在 <code>CocoaPods</code> 中删除一个我们不要的库时 可以在 <code>Podfile</code> 中直接删除相关库；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod update --no-repo-update 会在删除相关库时 更新其他库版本</span><br><span class="line">pod update XXX --no-repo-update 只会删除相关库 和下方一致</span><br><span class="line">pod install --no-repo-update 只会删除相关库</span><br></pre></td></tr></table></figure><p>关于版本指定约束</p><p>一般我们在使用 <code>cocoapods</code> 导入第三方库前都会生成一个 <code>podfile</code> 文件，文件中记录着我们要导入的第三方库以及对应的版本信息，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39;, &#39;~&gt; 4.3.2&#39;</span><br></pre></td></tr></table></figure><p>让 <code>cocoapods</code> 导入 <code>SDWbImage</code>，版本号 <code>4.3.2</code> 和版本号处于 <code>4.3.2-4.4</code> 之间的，不包括 <code>4.4</code> 和更高版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39; --- 不指定版本，表示希望使用最新版本</span><br><span class="line">pod &#39;SDWebImage&#39;, &#39;4.3.2&#39; --- 指定明确版本，表示只想要这个版本</span><br><span class="line">逻辑关系</span><br><span class="line">&#39;&gt; 0.1&#39; --- 版本号大于0.1的</span><br><span class="line">&#39;&gt;&#x3D; 0.1&#39; --- 版本0.1和版本号大于0.1的</span><br><span class="line">&#39;&lt; 0.1&#39; --- 版本号小于0.1的</span><br><span class="line">&#39;&lt;&#x3D; 0.1&#39; --- 版本号0.1和版本号小于0.1的</span><br><span class="line">最优匹配</span><br><span class="line">&#39;~&gt; 0.1.2&#39; --- 版本0.1.2和版本号处于0.1.2-0.2之间的,不包括0.2和更高版本</span><br><span class="line">&#39;~&gt; 0.1&#39; --- 版本0.1和版本号处于0.1-1.0之间的,不包括1.0和更高版本</span><br><span class="line">&#39;~&gt; 0&#39; --- 版本0和更高，和没设没啥区</span><br></pre></td></tr></table></figure><p>tag 改动原则:  </p><ul><li>增加 api，修改第三位;   </li><li>修改 api，修改第二位；</li><li>大版本变更修改第一位;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CocoaPods简介&quot;&gt;&lt;a href=&quot;#CocoaPods简介&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods简介&quot;&gt;&lt;/a&gt;CocoaPods简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CocoaPods&lt;/code&gt; 是专门为 &lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈面向对象的六大设计原则</title>
    <link href="https://sunjinshuai.github.io/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://sunjinshuai.github.io/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2019-10-27T03:13:57.000Z</published>
    <updated>2020-01-10T03:31:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/588630-7d17a7d220c612f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="原则一、单一职责原则（Single Responsibility Principle，简称SRP ）"></a>原则一、单一职责原则（Single Responsibility Principle，简称SRP ）</h3><p>定义：应该有且仅有一个原因引起类的变更。</p><p>一个类只负责一项职责，如果发生变更时，可以考虑将一个类拆分成两个类，或者在一个类中添加新的方法。</p><p><strong>在真实的开发中，不仅仅是类、函数和接口也要遵循单一职责原则。即：一个函数负责一个功能。如果一个函数里面有不同的功能，则需要将不同的功能的函数分离出去。</strong></p><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li><li>类的可读性提高，复杂性减低。</li></ul><p>如果接口或者函数的单一职责做得好，一个接口或者函数的修改只对相应的类有影响，对其他接口或者函数无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><p>例如，需求上指出用一个类描述食肉和食草动物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 17:55:25.775317+0800 DesignPatterns[54087:24701786] 狼 吃肉</span><br><span class="line">2018-10-27 17:55:25.775689+0800 DesignPatterns[54087:24701786] 豹 吃肉</span><br><span class="line">2018-10-27 17:55:25.775721+0800 DesignPatterns[54087:24701786] 虎 吃肉</span><br></pre></td></tr></table></figure><p>上线后，发现问题了，并不是所有的动物都是吃肉的，比如羊就是吃草的。修改时如果遵循单一职责原则，需要将 <code>Animal</code> 类细分为食草动物类 <code>Herbivore</code>，食肉动物 <code>Carnivore</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Herbivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Herbivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Herbivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Carnivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Carnivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Carnivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Animal *carnivore &#x3D; [Carnivore new];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">NSLog(@&quot;\n&quot;);</span><br><span class="line">Animal *herbivore &#x3D; [Herbivore new];</span><br><span class="line">[herbivore eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>在子类里面重写父类的 <code>eatWithAnimalName</code> 函数，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:04:49.189722+0800 DesignPatterns[54422:24725132] 狼 吃肉</span><br><span class="line">2018-10-27 18:04:49.190450+0800 DesignPatterns[54422:24725132] 豹 吃肉</span><br><span class="line">2018-10-27 18:04:49.190482+0800 DesignPatterns[54422:24725132] 虎 吃肉</span><br><span class="line">2018-10-27 18:04:49.190498+0800 DesignPatterns[54422:24725132] </span><br><span class="line">2018-10-27 18:04:49.190530+0800 DesignPatterns[54422:24725132] 羊 吃草</span><br></pre></td></tr></table></figure><p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加食肉动物和食草动物的其他功能，就可以直接在这两个类里面添加即可。但是，有一点，修改花销是很大的，除了将原来的类分解之外，还需要修改 <code>main</code> 函数 。而直接修改类 <code>Animal</code> 来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    if ([@&quot;羊&quot; isEqualToString:animalName]) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:16:10.910397+0800 DesignPatterns[54677:24751636] 狼 吃肉</span><br><span class="line">2018-10-27 18:16:10.911105+0800 DesignPatterns[54677:24751636] 豹 吃肉</span><br><span class="line">2018-10-27 18:16:10.911138+0800 DesignPatterns[54677:24751636] 虎 吃肉</span><br><span class="line">2018-10-27 18:16:10.911160+0800 DesignPatterns[54677:24751636] 羊 吃草</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。<br>但是却存在着隐患：<strong>有一天需求上增加牛和马也需要吃草，则又需要修改 <code>Animal</code> 类的 <code>eatWithAnimalName</code> 函数，而对原有代码的修改会对调用狼、豹和虎吃肉等功能带来风险，也许某一天你会发现运行结果变为虎也吃草了。</strong>这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃草</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃肉</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatGrassWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:31:30.321473+0800 DesignPatterns[55048:24787008] 狼 吃肉</span><br><span class="line">2018-10-27 18:31:30.321884+0800 DesignPatterns[55048:24787008] 豹 吃肉</span><br><span class="line">2018-10-27 18:31:30.321922+0800 DesignPatterns[55048:24787008] 虎 吃肉</span><br><span class="line">2018-10-27 18:31:30.321939+0800 DesignPatterns[55048:24787008] 羊 吃草</span><br></pre></td></tr></table></figure><p>通过运行结果可以看到，这种修改方式没有改动原来的函数，而是在类中新加了一个函数，这样虽然也违背了<strong>类单一职责原则</strong>，但在函数级别上却是符合单一职责原则的，因为它并没有动原来函数的代码。</p><p>在实际的开发应用中，有很多复杂的场景，怎么设计一个类或者一个函数，让应用程序更加灵活，是更多程序员们值得思考的，需要结合特定的需求场景，有可能有些类里面有很多的功能，但是切记不要将不属于这个类本身的功能也强加进来，这样不仅带来不必要的维护成本，也违反了<strong>单一职责的设计原则</strong>。</p><h3 id="原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）"><a href="#原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）" class="headerlink" title="原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）"></a>原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）</h3><p>定义：如果对一个类型为 <code>T1</code> 的对象 <code>o1</code>，都有类型为 <code>T2</code> 的对象 <code>o2</code>，使得以 <code>T1</code> 定义的所有程序 <code>P</code> 在所有的对象 <code>o1</code> 都替换成 <code>o2</code> 时，程序 <code>P</code> 的行为没有发生变化，那么类型 <code>T2</code> 是类型 <code>T1</code> 的子类型。有点拗口，通俗点讲，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应</strong>。</p><p>面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。当使用继承时，遵循里氏替换原则。但是使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生影响。子类可以扩展父类的功能，但不能改变父类原有的功能。</p><p>注意：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>比如，需要完成一个两数相加的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; A.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface A : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"></span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">A *a &#x3D; [[A alloc] init];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, [a addition:100 b:50]);</span><br><span class="line">NSLog(@&quot;100+80&#x3D;%ld&quot;, [a addition:100 b:80]);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 22:53:23.549358+0800 DesignPatterns[18063:363232] 100+50&#x3D;150</span><br><span class="line">2018-11-01 22:53:23.549586+0800 DesignPatterns[18063:363232] 100+80&#x3D;180</span><br></pre></td></tr></table></figure><p>接着，需求上需要增加一个新的功能，完成两数相加，然后再与 <code>100</code> 求差，由类 <code>B</code> 来负责。即类 <code>B</code> 需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加 <code>100</code>。</li></ul><p>由于类 <code>A</code> 已经实现了加法功能，所以 <code>B</code> 继承 <code>A</code> 之后，只需要完成减法功能就可以了，但是在类 <code>B</code> 中不小心重写了父类 <code>A</code> 的减法功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface B : A</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 减法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)subtraction:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">B *b &#x3D; [[B alloc] init];</span><br><span class="line">NSInteger sub &#x3D; [b addition:100 b:50];</span><br><span class="line">NSInteger difference &#x3D; [b subtraction:sub b:100];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, sub);</span><br><span class="line">NSLog(@&quot;100+100+50&#x3D;%ld&quot;, difference);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 23:15:06.530080+0800 DesignPatterns[18363:375940] 100+50&#x3D;5000</span><br><span class="line">2018-11-01 23:15:06.530758+0800 DesignPatterns[18363:375940] 100+100+50&#x3D;4900</span><br></pre></td></tr></table></figure><p>发现原本运行正常的相减功能发生了错误，原因就是类 <code>B</code> 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 <code>B</code> 重写后的方法，造成原本运行正常的功能出现了错误。如果按照“里氏替换原则”，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类</strong>，是不成立的。</p><p>在平时的日常开发中，通常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。</p><h3 id="原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）"><a href="#原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）" class="headerlink" title="原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）"></a>原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）</h3><p><strong>依赖倒置原则的核心思想是面向接口编程。</strong></p><p>定义：模块间的依赖通过抽象发生，高层模块和低层模块之间不应该发生直接的依赖关系，二者都应该是通过接口或抽象类产生的；即依赖抽象，而不依赖具体的实现。</p><p>例如：类 <code>A</code> 直接依赖类 <code>B</code>，假如要将类 <code>A</code> 改为依赖类 <code>C</code>，则必须通过修改类 <code>A</code> 的代码来达成。比如在这种场景下，业务逻辑层类 <code>A</code> 相对于数据层类 <code>B</code> 是高层模块，因为业务逻辑层需要调用数据层去连接数据库，如果业务逻辑层类 <code>A</code> 依赖数据层类 <code>B</code> 的话，那么将来需求变更，需要把旧的数据层类 <code>B</code> 修改为新的数据层类 <code>C</code>，就必须通过修改类 <code>A</code>，这样就会给应用程序带来不必要的风险。</p><p>解决方案：将类 <code>A</code> 修改为依赖接口 <code>I</code>，类 <code>B</code> 和类 <code>C</code> 各自实现接口 <code>I</code>，类 <code>A</code> 通过接口 <code>I</code> 间接与类 <code>B</code> 或者类 <code>C</code> 发生联系，则会大大降低修改类 <code>A</code> 的几率。要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。</p><p>比如：母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@class Book;</span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(Book *)book;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">[mother tellStory:book];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 14:52:08.759154+0800 DesignPatterns[6135:458778] 妈妈开始讲故事</span><br><span class="line">2018-11-09 14:52:08.759365+0800 DesignPatterns[6135:458778] 很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure><p>将来有一天，需求变更成，增加让母亲讲一下报纸上的故事的功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 报纸内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如果将 <code>Newspaper</code> 类替换 <code>Book</code> 类，发现母亲看不懂报纸上的故事，必须要修改 <code>Mother</code> 类里面的 <code>tellStory</code> 方法才能看不懂报纸上的故事。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code> 类，这显然不是好的设计，高层模块都依赖了低层模块的改动，因此上述设计不符合依赖倒置原则。<code>Mother</code> 类与 <code>Book</code> 类之间的耦合性太高了，必须降低他们之间的耦合度才行。</p><p>解决方案，将母亲讲故事的方法抽象一个接口或者 <code>Protocol</code>，让<code>Mother</code> 类不再依赖 <code>Newspaper</code> 和 <code>Book</code> 类具体实现，而是依赖抽象出来的接口或者 <code>Protocol</code>。并且 <code>Newspaper</code> 和 <code>Book</code> 类也都依赖这个抽象出来的接口或者 <code>Protocol</code>，通过实现接口或者 <code>Protocol</code> 来做自己的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>Mother</code> 类与接口 <code>IReader</code> 发生依赖关系，而 <code>Book</code> 和 <code>Newspaper</code> 都属于读物的范畴，他们各自都去实现 <code>IReader</code> 接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Mother</span><br><span class="line"></span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading &#123;</span><br><span class="line">    NSLog(@&quot;妈妈开始讲故事&quot;);</span><br><span class="line">    if ([reading respondsToSelector:@selector(theStoryContent)]) &#123;</span><br><span class="line">        [reading theStoryContent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">Newspaper *newspaper &#x3D; [Newspaper new];</span><br><span class="line">[mother tellStory:book];</span><br><span class="line">[mother tellStory:newspaper];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 15:28:01.182603+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182879+0800 DesignPatterns[7055:532924] 很久很久以前有一个阿拉伯的故事……</span><br><span class="line">2018-11-09 15:28:01.182916+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182955+0800 DesignPatterns[7055:532924] 雄鹿终结勇士八连胜……</span><br></pre></td></tr></table></figure><p>这样修改后，无论以后怎样扩展 main 函数，都不需要再修改 <code>Mother</code> 类了。这里只是举了一个比较简单的例子，在实际的项目开发中，尽可能的采用“低耦合，高内聚”的原则，<strong>采用依赖倒置原则给多人并行开发带来了极大的便利</strong>，无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><h3 id="原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="原则四、接口隔离原则（Interface Segregation Principle,简称ISP）"></a>原则四、接口隔离原则（Interface Segregation Principle,简称ISP）</h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#39;ClassB&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br><span class="line">Class &#39;ClassD&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br></pre></td></tr></table></figure><p><strong>注意：在 <code>Objective-C</code> 中的协议可以通过 <code>@optional</code> 关键字声明不需要必须实现的方法，这个只是 <code>Objective-C</code> 的一个特性，可以消除在 <code>ClassB</code> 和 <code>ClassD</code> 中没有实现 <code>InterfaceH</code> 的 <code>protocol</code> 协议。</strong></p><p>比如，类 A 依赖接口 H 中的方法1、方法2、方法5，类 B 是对类 A 依赖的实现。类 C 依赖接口 H 中的方法3、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法，但由于实现了接口 H，因为接口 <code>H</code> 对于类 <code>A</code> 和类 <code>C</code> 来说不是最小接口，所以也必须要实现这些用不到的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。</p><p><strong>解决方法：将臃肿的接口 <code>H</code> 拆分为独立的几个接口，类 <code>A</code> 和类 <code>C</code> 分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH1 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH2 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH1&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH2&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。在实际项目开发中，只暴露给调用的类需要的方法，不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，不要试图去建立一个很庞大的接口供所有依赖它的类去调用。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><h3 id="原则五、迪米特法则（Law-of-Demeter，简称LOD）"><a href="#原则五、迪米特法则（Law-of-Demeter，简称LOD）" class="headerlink" title="原则五、迪米特法则（Law of Demeter，简称LOD）"></a>原则五、迪米特法则（Law of Demeter，简称LOD）</h3><p>定义：一个对象应该对其他对象保持最少的了解。</p><p>当类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外只暴露必要的接口。</p><p>解决方案：尽量降低类与类之间的耦合。</p><p>比如，有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工 <code>ID</code>：<br>Model 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; EmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface EmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 总公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *employee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubEmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubEmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 分公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *subemployee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Company 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; subCompany.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>从上面可以看出，打印 <code>Company</code> 所有员工的 <code>ID</code>，需要依赖分公司 <code>SubCompany</code>。但是在 <code>printAllEmployeeWithSubCompany:</code> 方法里面必须要初始化分公司员工 <code>SubEmployeeModel</code>。而<code>SubEmployeeModel</code> 和 <code>Company</code> 并不是直接联系，换句话说，总公司 <code>Company</code> 只需要依赖分公司 <code>SubCompany</code>，与分公司的员工 <code>SubEmployeeModel</code> 并没有任何联系，这样设计显然是增加了不必要的耦合。</p><p><strong>按照迪米特法则，类与类之间的应该减少不必要的关联程度。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    [subCompany printAllEmployee];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印分公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployee &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>修改后，为分公司增加了打印所有公钥 <code>ID</code> 的方法，总公司直接调分公司的打印方法，从而避免了与分公司的员工发生耦合。</p><p>耦合的方式很多，依赖、关联、组合、聚合等。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是过分的使用迪米特原则，会产生大量传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="原则六、开闭原则（Open-Close-Principle，简称OCP）"><a href="#原则六、开闭原则（Open-Close-Principle，简称OCP）" class="headerlink" title="原则六、开闭原则（Open Close Principle，简称OCP）"></a>原则六、开闭原则（Open Close Principle，简称OCP）</h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>核心思想：<strong>尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。</strong></p><p><strong>用抽象构建框架，用实现扩展细节</strong>，对扩展开放的关键是抽象，而对象的多态则保证了这种扩展的开放性。开放原则首先意味着我们可以自由地增加功能，而不会影响原有功能。这就要求我们能够通过继承完成功能的扩展。其次，开放原则还意味着实现是可替换的。只有利用抽象，才可以为定义提供不同的实现，然后根据不同的需求实例化不同的实现子类。</p><p>开放封闭原则的优点：</p><ul><li>代码可读性高，可维护性强。</li><li>帮助缩小逻辑粒度，以提高可复用性。</li><li>可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性。</li><li>在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求。</li></ul><p>比如，书店售书的经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IBookProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IBookProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍售价</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (CGFloat)bookPrice;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍作者</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookAuthor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; NovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface NovelBook : NSObject &lt;IBookProtocol&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟书店卖书</span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:11:32.642070+0800 DesignPatterns[1863:5763476] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：50.000000</span><br><span class="line">2018-11-12 15:11:32.642495+0800 DesignPatterns[1863:5763476] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:11:32.642530+0800 DesignPatterns[1863:5763476] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:11:32.642558+0800 DesignPatterns[1863:5763476] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br></pre></td></tr></table></figure><p>将来某一天需求变更为项目投产，书店盈利，书店决定，<code>40</code> 元以上打 <code>8</code> 折，<code>40</code> 元以下打 <code>9</code> 折。</p><p>在实际的项目开发中，如果不懂得开闭原则的话，很容易犯下面的错误：</p><ul><li>在 <code>IBookProtocol</code> 上新增加一个方法 <code>bookOffPrice()</code> 方法，专门进行打折，所有实现类实现这个方法，但是如果其他不想打折的书籍也会因为实现了书籍的接口必须打折。 </li><li>修改 <code>NovelBook</code> 实现类中的 <code>bookPrice()</code> 方中实现打折处理，由于该方法已经实现了打折处理价格，因此采购书籍人员看到的也是打折后的价格的情况。</li></ul><p>很显然按照上面两种方案的话，随着需求的增加，需要反复修改之前创建的类，给新增的类造成了不必要的冗余，业务逻辑的处理和需求不相符合等情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; OffNovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface OffNovelBook : NovelBook</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OffNovelBook</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author &#123;</span><br><span class="line">    return [super initWithBookName:name price:price author:author];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)bookPrice &#123;</span><br><span class="line">    CGFloat originalPrice &#x3D; [super bookPrice];</span><br><span class="line">    CGFloat offPrice      &#x3D; 0;</span><br><span class="line">    if (originalPrice &gt; 40) &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.8;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line">    return offPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BookStore</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book1 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book2 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book3 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book4 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book1 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book2 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book3 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book4 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的原价书籍记录如下：------------&quot;);</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的打折书籍记录如下：------------&quot;);</span><br><span class="line">for (OffNovelBook *novelBook in bookStore.offBookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:52:01.639550+0800 DesignPatterns[2962:6151804] ------------书店卖出去的原价书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.639895+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：30.000000</span><br><span class="line">2018-11-12 15:52:01.639927+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:52:01.639951+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:52:01.639971+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br><span class="line">2018-11-12 15:52:01.639988+0800 DesignPatterns[2962:6151804] ------------书店卖出去的打折书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.640029+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：27.000000</span><br><span class="line">2018-11-12 15:52:01.640145+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：56.000000</span><br><span class="line">2018-11-12 15:52:01.640194+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：64.000000</span><br><span class="line">2018-11-12 15:52:01.640217+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：36.000000</span><br></pre></td></tr></table></figure><p>在实际的项目开发中，</p><ul><li><p>对抽象定义的修改，要保证定义的接口或者 <code>Protocol</code> 的稳定，尤其要保证被其他对象调用的接口的稳定；否则，就会导致修改蔓延，牵一发而动全身。</p></li><li><p>对具体实现的修改，因为具体实现的修改，可能会给调用者带来意想不到的结果。如果确实需要修改具体的实现，就需要做好达到测试覆盖率要求的单元测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/588630-7d17a7d220c612f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTTPS的工作原理</title>
    <link href="https://sunjinshuai.github.io/2019/09/13/HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2019/09/13/HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2019-09-13T15:23:54.000Z</published>
    <updated>2020-05-20T03:37:56.118Z</updated>
    
    <content type="html"><![CDATA[<p><code>HTTPS</code> 和 <code>HTTP</code> 协议相比提供了</p><ul><li>数据完整性：内容传输经过完整性校验</li><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><code>HTTPS</code> 在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。<code>TLS/SSL</code> 协议是一套加密传输的协议，使用了非对称加密，对称加密以及 <code>HASH</code> 算法。以浏览器和服务器为例，<code>HTTPS</code> 通信过程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/588630-0e87f4003f1e85ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="握手.png"></p><p><strong>上图中的 <code>CA</code> 证书验证，这一步是可选的，对于安全性要求高的场景会用到，比如，预防中间人攻击。</strong></p><h4 id="第一步-Client-Hello"><a href="#第一步-Client-Hello" class="headerlink" title="第一步 Client Hello"></a>第一步 <code>Client Hello</code></h4><p>客户端向服务端发送 <code>Client Hello</code> 消息，这个消息里包含了一个客户端生成的随机数 <code>Random1</code>、客户端支持的加密套件和 <code>TLS/SSL Version</code> 等信息。</p><h4 id="第二步-Server-Hello"><a href="#第二步-Server-Hello" class="headerlink" title="第二步 Server Hello"></a>第二步 <code>Server Hello</code></h4><p>服务端向客户端发送 <code>Server Hello</code> 消息，这个消息会从 <code>Client Hello</code> 传过来的加密套件里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <code>Random2</code>。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><h5 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a><code>Certificate</code></h5><p>服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a><code>Server Key Exchange</code></h4><p>这个消息会紧随在 <code>Server</code> 证书消息之后发送，<code>ServerKeyExchange</code> 消息由 <code>Server</code> 发送，但仅在 <code>Server</code> 证书消息(如果发送了)没有包含足够的数据以允许 <code>Client</code> 交换一个预密钥时。如果是 <code>DH</code> 算法，这里发送服务器使用的 <code>DH</code> 参数，<code>RSA</code> 算法不需要这一步；</p><h5 id="Certificate-Request"><a href="#Certificate-Request" class="headerlink" title="Certificate Request"></a><code>Certificate Request</code></h5><p>Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</p><h5 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a><code>Server Hello Done</code></h5><p>Server Hello Done 通知客户端 Server Hello 过程结束。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>客户端收到了服务器发来的数据包后，会做这么几件事情：</p><h5 id="Certificate-Verify"><a href="#Certificate-Verify" class="headerlink" title="Certificate Verify"></a><code>Certificate Verify</code></h5><p>验证一下证书是否合法；如果证书合法，或者客户端接受和信任了不合法的证书，验证通过后取出证书中的服务端公钥，再生成一个随机数 <code>Random3</code>，再用服务端公钥非对称加密 <code>Random3</code> 生成 <code>PreMaster Key</code>。</p><h5 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a><code>Client Key Exchange</code></h5><p>客户端根据服务器传来的公钥生成了 <code>PreMaster Key</code>，<code>Client Key Exchange</code> 就是将这个 <code>key</code> 传给服务端。</p><h5 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec Client"></a><code>Change Cipher Spec Client</code></h5><p>将刚才的消息使用刚才的随机数进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>服务器接受到客户端发来的消息后，会做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message Client"></a><code>Encrypted Handshake Message Client</code></h5><p>这一步对应的是 <code>Client Finish</code> 消息，使用私钥解密上面第2步中公钥加密的消息，得到客户端产生的随机序列号。使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。</p><h5 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec Server"></a><code>Change Cipher Spec Server</code></h5><p>使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。</p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>客户端收到服务器端的消息后，接着做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message Server"></a><code>Encrypted Handshake Message Server</code></h5><p>这一步对应的是 <code>Server Finish</code> 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><h4 id="第六步-Application-Data"><a href="#第六步-Application-Data" class="headerlink" title="第六步 Application Data"></a>第六步 <code>Application Data</code></h4><p>握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>采用 <code>HTTPS</code> 协议的服务器必须要有自己制作或者 <code>CA</code> 证书，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用 <code>CA</code> 证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><p>客户端收到服务器的回复后，首先客户端会从内置的证书列表中索引，查找服务器下发 <code>CA</code> 证书，如果没有找到，此时就会提示用户该证书是不可信任的。如果查到了对应 <code>CA</code> 证书，则取出 <code>public key</code> 公钥。然后，用 <code>public key</code> 公钥解密得到证书的内容和证书签名，内容包括证书的颁发机构，过期时间等。客户端会先验证证书签名的合法性，签名通过后，会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，客户端就可以安全使用 <code>public key</code> 公钥了。 </p><h3 id="中间人攻击原理"><a href="#中间人攻击原理" class="headerlink" title="中间人攻击原理"></a>中间人攻击原理</h3><p><img src="https://upload-images.jianshu.io/upload_images/588630-4d9774eeb807e95d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中间人攻击原理"></p><p>针对 <code>SSL</code> 的中间人攻击方式主要有两类，分别是 <code>SSL</code> 劫持攻击和 <code>SSL</code> 剥离攻击，详细请看<a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/#mitm" target="_blank" rel="noopener">中间人攻击原理</a>。</p><h3 id="预防中间人攻击"><a href="#预防中间人攻击" class="headerlink" title="预防中间人攻击"></a>预防中间人攻击</h3><p>单向认证：<br>上图中的第二次握手，其实就是一次服务器-&gt;客户端的单向验证，服务器将自己的 <code>CA</code> 证书下发给客户端，让客户端验证自己的身份。</p><p>双向认证：<br>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务器 <code>CA</code> 证书以外，增加了服务器对客户端的 <code>CA</code> 证书认证。<br><a href="https://blog.csdn.net/duanbokan/article/details/50847612" target="_blank" rel="noopener">Https双向认证</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;HTTPS&lt;/code&gt; 和 &lt;code&gt;HTTP&lt;/code&gt; 协议相比提供了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据完整性：内容传输经过完整性校验&lt;/li&gt;
&lt;li&gt;数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥&lt;/li&gt;
&lt;li&gt;身份认证：第三方无法
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git中merge、rebase的区别</title>
    <link href="https://sunjinshuai.github.io/2019/08/06/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2019/08/06/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2019-08-06T06:15:32.000Z</published>
    <updated>2020-01-10T03:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般在公司git整合分支一般有两种方法——快速向前合并<code>git rebase</code>和三路合并<code>git merge</code>。其实在开发中，<code>git rebase</code>和<code>git merge</code>表达都是一个意思，即，将一个分支合并到另一个分支。</p><p>当开发一个新功能，一般我们会在<code>develop</code>分支上创建<code>featrue</code>分支：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-b6359864017521dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当我们这个新功能开发测试完毕之后，首先要把<code>featrue</code>分支合并到<code>develop</code>分支上，一般会根据实际情况选择是否使用<code>git merge</code>还是<code>git rebase</code>。</p><p><strong><code>git merge</code></strong><br>根据分支合并的原则，<code>git</code>会自动根据两个分支的共同祖和两个分支的最新提交<code>commit</code>记录进行一个三方合并，然后将合并中修改的内容生成一个新的<code>commit</code>记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-2fb4e523cea0a269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong><code>git merge</code>是一个安全的操作</strong></p><p><strong><code>git rebase</code></strong></p><p>它会把整个<code>feature</code>分支移动到<code>develop</code>分支的后面，有效地把所有<code>develop</code>分支上新的提交并入过来。但是，<code>git rebase</code>为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-93bdffa37317c083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong><code>git rebase</code>最大的特点就是让你的项目历史提交记录会非常整洁。</strong><br>首先，它不像<code>git merge</code>那样引入不必要的合并提交。其次，如上图所示，<code>git rebase</code>使项目历史提交记录呈现出一条直线。你可以从项目终点到起点浏览而不需要任何的分叉，可以让你更容易的使用<code>git log</code>查看项目的提交记录。</p><p><strong><code>git rebase</code>缺点就是安全性和可跟踪性。</strong></p><p><code>git rebase</code>的黄金法则：绝对不要在公共的分支上使用。如果你把<code>master</code>分支<code>rebase</code>到你的<code>feature</code>分支上：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-aa37afc6fe4ff411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这次<code>rebase</code>将<code>master</code>分支上的所有提交都移到了<code>feature</code>分支后面。<br>问题是它只发生在你的代码仓库中，而其他所有的开发者还在原来的<code>master</code>上工作。因为<code>rebase</code>引起了新的提交，所以<code>git</code>会认为你的<code>master</code>分支和其他人的<code>master</code>已经分叉了。</p><p>同步两个<code>master</code>分支的唯一办法是把它们<code>merge</code>到一起，导致一个额外的合并提交和两堆包含同样更改的提交。</p><p><strong><code>git rebase</code>不适用于公共的分支上。</strong></p><p>总结：选择<code>git merge</code>还是<code>git rebase</code>？</p><ul><li><p><code>git merge</code>是一个合并操作，会采用三路合并的方式将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容，生成一个新的<code>commit</code>记录。</p></li><li><p><code>git rebase</code>并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面，为原分支上每一个提交创建一个新的提交。</p></li><li><p><code>git merge</code>与<code>git rebase</code>都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般在公司git整合分支一般有两种方法——快速向前合并&lt;code&gt;git rebase&lt;/code&gt;和三路合并&lt;code&gt;git merge&lt;/code&gt;。其实在开发中，&lt;code&gt;git rebase&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;表达都是一个
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git的使用</title>
    <link href="https://sunjinshuai.github.io/2019/08/02/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2019/08/02/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-08-02T03:03:24.000Z</published>
    <updated>2020-01-10T03:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、git简介"><a href="#一、git简介" class="headerlink" title="一、git简介"></a>一、git简介</h4><p><code>git</code>是目前世界上被最广泛使用的现代软件版本管理系统。<code>git</code>本身亦是一个成熟并处于活跃开发状态的开源项目，它最初是由Linux操作系统内核的创造者Linus Torvalds在2005年创造。</p><h4 id="二、在Mac-OS-X上安装git"><a href="#二、在Mac-OS-X上安装git" class="headerlink" title="二、在Mac OS X上安装git"></a>二、在Mac OS X上安装git</h4><p>如果你正在使用Mac做开发，有两种安装<code>git</code>的方法。</p><ul><li>安装<code>homebrew</code>，然后通过<code>homebrew</code>安装<code>git</code>，具体方法请参考<code>homebrew</code>的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></li><li>直接从<code>AppStore</code>安装<code>Xcode</code>，<code>Xcode</code>集成了<code>git</code>。不过默认没有安装，你需要运行<code>Xcode</code>，选择菜单<code>“Xcode”-&gt;“Preferences”</code>，在弹出窗口中找到<code>“Downloads”</code>，选择<code>“Command Line Tools”</code>，点“Install”就可以完成安装了。</li></ul><h4 id="三、创建本地仓库"><a href="#三、创建本地仓库" class="headerlink" title="三、创建本地仓库"></a>三、创建本地仓库</h4><p>仓库：英文名<code>repository</code>，可以简单理解成一个目录，这个目录里面的所有文件都可以被<code>git</code>管理起来，每个文件的修改、删除，<code>git</code>都能记录，以便任何时刻都可以查找历史记录，或者在回滚到以前修改的状态。</p><p>1、首先，选择一个合适的地方，创建一个空目录，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>创建新的<code>git</code>仓库，会发下在当前的创建的目录下面多了一个<code>.git</code>的目录，这个目录是<code>git</code>来管理仓库的。<br>注意：<br><strong>没事千万不要手动修改这个目录里面的文件，不然就把会<code>git</code>仓库给破坏了。</strong></p><p>2、添加文件到git仓库</p><p>把文件添加到仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p>注意：<br><code>git add &lt;filename&gt;</code>是把某一个文件添加到<code>git</code>的缓存区里面。<br><code>git add .</code>是把所有的文件添加到<code>git</code>的缓存区里面。</p><p>3、把文件提交到本地仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>git commit</code>命令，一般会在后面加上<code>-m</code>表示本次提交到本地仓库的记录。</li><li><code>commit message</code>言简意赅，不要写无用信息，这样让别人不能看懂这次提交的意义。</li><li>在开发时，良好的习惯是根据工作进度及时<code>commit</code>，并务必注意附上有意义的<code>commit message</code>。创建完项目目录后，第一次提交的<code>commit message</code>一般为<code>Initial commit.</code>。</li><li>添加一个新的<code>Pod</code>库或<code>pod update</code>后，要单独提交一个<code>commit</code>，统一<code>commit message</code>为<code>pod add xxx</code>或<code>pod update xxx</code>。</li></ul><h4 id="四、远程仓库"><a href="#四、远程仓库" class="headerlink" title="四、远程仓库"></a>四、远程仓库</h4><p>一般使用<code>git</code>的公司都会有自己的<code>git</code>服务器或者使用第三方<code>git</code>服务器，比如<code>coding.net</code>、码云等。<br>由于你的本地<code>git</code>仓库和<code>git</code>服务器仓库之间的传输是通过<code>SSH</code>加密的，需要设置：</p><ul><li>创建<code>SSH Key</code>。在用户主目录下，看看有没有<code>.ssh</code>目录。如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有，可直接跳到下一步。如果没有，打开<code>Shell</code>，创建<code>SSH Key</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096</span><br></pre></td></tr></table></figure><ul><li>将公共SSH密钥复制到剪贴板：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><ul><li>登陆<code>git</code>服务器，打开<code>“Account settings”</code>，<code>“SSH Keys”</code>页面：</li><li>点<code>“Add SSH Key”</code>，填上任意Title，在<code>Key</code>文本框里粘贴<code>id_rsa.pub</code>文件的内容：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-93e16d0ca42e91bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：<br>为什么<code>git</code>服务器需要<code>SSH Key</code>呢？因为<code>git</code>服务器需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而<code>git</code>支持<code>SSH</code>协议，所以，<code>git</code>服务器只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，<code>git</code>服务器允许你添加多个<code>Key</code>。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的<code>Key</code>都添加到<code>git</code>服务器，就可以在每台电脑上往<code>git</code>服务器推送了。</p><h4 id="五、添加远程仓库"><a href="#五、添加远程仓库" class="headerlink" title="五、添加远程仓库"></a>五、添加远程仓库</h4><ul><li>登陆<code>git</code>服务器，然后，找到<code>“Create a new repo”</code>按钮，创建一个新的仓库：</li><li>在<code>Repository name</code>填入<code>learngit</code>，其他保持默认设置，点击<code>“Create repository”</code>按钮，就成功地创建了一个新的<code>git</code>仓库。<br>注意：<br>目前，在<code>git</code>服务器上的这个<code>learngit</code>仓库还是空的，<code>git</code>服务器告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到<code>git</code>服务器仓库。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-3270bd7b01a820cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过上图可以看出：<br>1、如果在本地没有创建仓库，可以通过下面命令从<code>git</code>服务器<code>clone</code>出一个新的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;learngit.git</span><br><span class="line">cd learngit</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;add README&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>2、如果本地已经创建了，可以通过下面命令把本地仓库与<code>git</code>服务器仓库进行关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd existing_folder</span><br><span class="line">git init</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;learngit.git</span><br><span class="line">git add .</span><br><span class="line">git commit</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>注意：<br>1、<code>git remote add origin</code>表示将本地服务器与<code>git</code>服务器进行关联。<br>2、<code>origin</code>是<code>git</code>服务器的别名，取什么名字都可以，你也可以在<code>push</code>时将<code>git</code>服务器替换为 origin。但为了以后<code>push</code>方便，我们第一次一般都会先<code>remote add</code>。<br>3、<code>git push -u origin master</code>将你修改或者添加的文件提交到<code>git</code>服务器。</p><p>3、git remote<br><code>git remote</code>命令允许你创建、查看和删除和其它仓库之间的远程连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p>列出和其他仓库之间的远程连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin  http:&#x2F;&#x2F;git.oschina.net&#x2F;sunjinshuai&#x2F;sample.git (fetch)</span><br><span class="line">origin  http:&#x2F;&#x2F;git.oschina.net&#x2F;sunjinshuai&#x2F;sample.git (push)</span><br></pre></td></tr></table></figure><p>列出和其他仓库之间的远程连接，但同时显示每个连接的<code>URL</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>创建一个新的远程仓库连接。在添加之后，可以将<code>&lt;name&gt;</code>作为<code>&lt;url&gt;</code>便捷的别名在其他<code>git</code>命令中使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm &lt;name&gt;</span><br></pre></td></tr></table></figure><p>移除名为的远程仓库的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</span><br></pre></td></tr></table></figure><p>将远程连接从<code>&lt;old-name&gt;</code>重命名为<code>&lt;new-name&gt;</code>。</p><h4 id="六、检查仓库状态"><a href="#六、检查仓库状态" class="headerlink" title="六、检查仓库状态"></a>六、检查仓库状态</h4><p>1、git status<br><code>git status</code>命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被<code>git</code>记录。</p><p>2、git log<br><code>git log</code>命令查看每次<code>commit</code>的历史记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><p>使用默认格式显示完整地<code>commit</code>记录，如果输出超过一屏，你可以用空格键来滚动，按q退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -n &lt;limit&gt;</span><br></pre></td></tr></table></figure><p>用<limit>限制提交的数量，比如<code>git log -n 3</code>只会显示3个提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p>将每个提交压缩到一行，当你需要查看项目历史的上层情况时这会很有用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure><p>除了<code>git log</code>信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure><p>显示代表每个提交的一堆信息，显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;&quot;&lt;pattern&gt;&quot;</span><br></pre></td></tr></table></figure><p>搜索特定作者的提交。<code>&lt;pattern&gt;</code>可以是字符串或正则表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --grep&#x3D;&quot;&lt;pattern&gt;&quot;</span><br></pre></td></tr></table></figure><p>搜索提交信息匹配特定<code>&lt;pattern&gt;</code>的提交。<code>&lt;pattern&gt;</code>可以是字符串或正则表达式。</p><h4 id="七、git-reset、git-checkout和git-revert"><a href="#七、git-reset、git-checkout和git-revert" class="headerlink" title="七、git reset、git checkout和git revert"></a>七、git reset、git checkout和git revert</h4><p><code>git</code>仓库有三个主要组成——工作目录，缓存区和提交历史。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-6a21a168d9789d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>git reset</code>、<code>git checkout</code>和<code>git revert</code>是你的<code>git</code>工具箱中最有用的一些命令。它们都用来撤销代码仓库中的某些更改，而前两个命令不仅可以作用于提交，还可以作用于特定文件。</p><p>因为它们非常相似，所以我们经常会搞混，不知道什么场景下该用哪个命令。</p><p>1、<code>git reset</code></p><p><code>git reset</code>操作会将当前分支的<code>HEAD</code>指向另外一个<code>commit</code>记录，这样可以在当前分支上移除部分<code>commit</code>记录。例如，在hotfix分支上回滚前两次的<code>commit</code>状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~2</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-b37c7f0e1cc74e53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-353241c3327b5ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>当执行<code>git reset</code>时，hotfix分支上最后两次提交的状态会变成空状态，等到<code>git</code>执行垃圾回收的时候，hotfix分支上最后两次提交的状态会被回收。</p><ul><li>–soft – 缓存区和工作目录都不会被改变</li><li>–mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</li><li>–hard – 缓存区和工作目录都同步到你指定的提交</li></ul><p><code>git reset</code>一般配合这些参数使用，<code>git reset --mixed HEAD</code>将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。如果你想完全舍弃你没有提交的改动，你可以使用<code>git reset --hard HEAD</code>，这是<code>git reset</code>最常用的两种用法。<br>注意：<br><strong><code>git reset</code>是不可逆的，因为<code>git reset</code>操作会重写当前分支的历史，用来撤销缓存区和工作目录的修改。<code>git reset</code>只适用于本地修改，不能重设服务器上的<code>commit</code>记录。</strong></p><p>2、<code>git checkout</code></p><ul><li>切换分支：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout hotfix</span><br></pre></td></tr></table></figure><p>注意：<br><strong>使用<code>git checkout</code>之前，要把工作区的内容提交到<code>git</code>服务器或者缓存区。<code>git checkout</code>是将<code>HEAD</code>指针从一个分支切换到另一个分支，然后更新工作目录。因为这可能会覆盖本地的修改，<code>git</code>会强制你提交或者缓存工作目录中的所有更改，不然在checkout的时候这些更改都会丢失。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-46593e029f800b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-0d591979a332a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>查看文件之前的版本</li></ul><p>除了切换分支之外，<code>git checkout</code>还可以将<code>HEAD</code>指针移动到当前分支其他的<code>commit</code>记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~2</span><br></pre></td></tr></table></figure><p><code>git checkout</code>更改的是工作目录而不是缓存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout HEAD~2 xxx</span><br></pre></td></tr></table></figure><p>如果你缓存并且提交了<code>checkout</code>的文件，它具备将某个文件回撤到之前版本的效果，注意它撤销了这个文件后面所有的更改。不影响你仓库的当前状态。你可以在新的快照中像其他文件一样重新提交旧版本。所以，在效果上，<code>git checkout</code>的这个用法可以用来将单个文件回滚到旧版本。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-1d467da0f8a6492e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e06dd9f6e82ec593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：<br><strong><code>git checkout</code>是可逆的。</strong></p><p>3、<code>git revert</code></p><p><code>git revert</code>撤销一个<code>commit</code>记录的同时会创建另一个新的<code>commit</code>记录，这是一个安全的方法，而不是从项目历史中移除这个提交。这避免了<code>git</code>丢失项目历史记录，这一点对于你的版本历史和协作的可靠性来说是很重要的。</p><p>比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD~2</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b3dfb6eb5f32e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-6fef5a231e49f9ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>git revert</code>应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用<code>git revert</code>，它帮你做了所有的事情。</p><p><code>git revert</code>回滚了单独一个提交，它没有移除后面的提交记录，同时会创建另一个新的<code>commit</code>记录。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-dcf4353870b8b2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>git reset</code>回滚了单独一个提交，并且移除后面的提交记录，是<strong>不可逆的</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/588630-bde0c98e8c62a2a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>git revert</code>可以针对历史记录中任何一个提交，而<code>git reset</code>只能从当前提交向前回滚。比如，你想用<code>git reset</code>重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。一般公司不提倡这么做。因此，<code>git revert</code>可以用在公共分支上，<code>git reset</code>应该用在私有分支上。</p><p>4、<strong><code>git reset</code>用慎用</strong><br>当有<code>commit</code>之后的提交被推送到公共分支上，你绝不应该使用<code>git reset</code>。使用<code>git reset</code>回滚了单独一个提交，并且移除后面的提交记录。当团队成员在上面继续开发的提交在协作时会引发严重的问题。当他们试着和你的仓库同步时，他们会发现项目历史的一部分突然消失了。<br>下面的序列展示了如果你尝试重设公共提交时会发生什么。<code>origin/master</code>是你本地<code>master</code>分支对应的中央仓库中的分支。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4ca6571366212ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-66c305ffcfbb405d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-f4eab69ac10165f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一旦你在重设之后又增加了新的提交，<code>git</code>会认为你的本地历史已经和 <code>origin/master</code>分叉了，同步你的仓库时的合并提交（merge commit）会使你的同事困惑。</p><p>5、<code>git clean</code></p><p><code>git clean</code>命令将未记录的文件从你的工作目录中移除。它只是提供了一条捷径，因为用<code>git status</code>查看未记录的文件，然后手动移除它们也很方便。和一般的<code>rm</code>命令一样，<code>git clean</code>是无法撤消的，所以在删除未记录的文件之前想清楚，你是否真的要这么做。</p><p><code>git clean</code>命令经常和<code>git reset --hard</code>一起使用。记住，<code>git reset</code>只影响被记录的文件，所以还需要一个单独的命令来清理未被记录的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。</p><p>注意：<br><strong><code>git clean</code>也是不可逆的。</strong></p><h4 id="八、分支"><a href="#八、分支" class="headerlink" title="八、分支"></a>八、分支</h4><p>1、git branch<br>分支代表了一条独立的开发流水线，<code>git branch</code>命令允许你创建、列出、重命名和删除分支。一般<code>git branch</code>和<code>git checkout</code>、<code>git merge</code>这两个命令通常紧密地结合在一起使用。一般使用过<code>git</code>的同学都知道：</p><ul><li><code>master</code>是长期分支，一般用于管理对外发布版本，每个<code>commit</code>对一个<code>tag</code>，也就是一个发布版本。</li><li><code>develop</code>是长期分支，一般用于作为日常开发汇总，即开发版的代码</li><li><code>feature</code>是短期分支，一般用于一个新功能的开发。</li><li><code>hotfix</code>是短期分支 ，一般用于正式发布以后，出现bug，需要创建一个分支，进行bug修补。</li><li><code>release</code>是短期分支，一般用于发布正式版本之前（即合并到<code>master</code>分支之前），需要有的预发布的版本进行测试。<code>release</code>分支在经历测试之后，测试确认验收，将会被合并的<code>develop</code>和<code>master</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>列出仓库中所有分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>创建一个名为 <branch> 的分支。不会自动切换到那个分支去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>删除指定分支。这是一个安全的操作，<code>git</code>会阻止你删除包含未合并更改的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>强制删除指定分支，即使包含未合并更改。如果你希望永远删除某条开发线的所有提交，你应该用这个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将当前分支命名为<branch>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>删除远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>查看本地和远程分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;branch1&gt; &lt;branch2&gt;</span><br></pre></td></tr></table></figure><p>修改分支的名字</p><p>2、git merge<br>用于合并指定分支到当前分支，<code>git merge</code>命令允许你将<code>git branch</code>创建的多条分支合并成一个。</p><p>注意：<br>合并指定分支到当前分支，当前分支会被更新，以响应合并操作，但目标分支完全不受影响。也就是说<code>git merge</code>经常和<code>git checkout</code>一起使用，选择当前分支，然后用<code>git branch -d</code>删除废弃的目标分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将指定分支并入当前分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将指定分支并入当前分支，但 总是 生成一个合并提交（即使是快速向前合并）。这可以用来记录仓库中发生的所有合并。</p><p>3、git merge几种方法</p><ul><li>快速向前合并<br>当当前分支顶端到目标分支路径是线性之时，我们可以采取快速向前合并。<code>git</code>只需要将当前分支顶端（快速向前地）移动到目标分支顶端，即可整合两个分支的历史，而不需要“真正”合并分支。它在效果上合并了历史，因为目标分支上的提交现在在当前分支可以访问到。比如，<code>some-feature</code>到<code>master</code>分支的快速向前合并会是这样的：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-944fb76a38db291d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-5ac694413e3967f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>三路合并<br>如果分支已经分叉了，那么就无法进行快速向前合并。当和目标分支之间的路径不是线性之时，<code>git</code>只能执行三路合并。三路合并使用一个专门的提交来合并两个分支的历史。这个术语取自这样一个事实，<code>git</code>使用三个提交来生成合并提交：两个分支顶端和它们共同的祖先。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-d78b8f3c40b6ef82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-90ea927631a7c49d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>很多开发者喜欢使用<code>git rebase</code>快速向前合并，来合并微小的功能或者修复bug，使用三路合并来整合长期运行的功能。后者导致的合并提交作为两个分支的连接标志。</p><p>4、解决冲突</p><p>如果你尝试合并的两个分支同一个文件的同一个部分，<code>git</code>将无法决定使用哪个版本。当这种情况发生时，它会停在合并提交，让你手动解决这些冲突。</p><p>当你遇到合并冲突时，运行<code>git status</code>命令来查看哪些文件存在需要解决的冲突。</p><p>当你手动修复完冲突之后，只需对冲突的文件运行<code>git add</code>告诉<code>git</code>冲突已解决。然后，运行<code>git commit</code>生成一个合并提交。</p><p>使用<code>git log --graph</code>命令可以看到分支合并图。</p><p>团队合作的分支看起来就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/588630-d2df21bfde4c29ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：<br><strong>提交冲突只会出现在三路合并中。在快速向前合并中，我们不可能出现冲突的更改。</strong></p><h4 id="九、创建标签"><a href="#九、创建标签" class="headerlink" title="九、创建标签"></a>九、创建标签</h4><p>一般在公司每一个上线版本都会打一个标签，为了记录和维护，当线上版本出现紧急bug，我们就可以通过<code>git checkout</code>检出项目，然后创建hotfix分支进行bug的修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>查看所有标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt;</span><br><span class="line">git tag &lt;name&gt; commit id</span><br></pre></td></tr></table></figure><p>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>查看标签信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>可以推送一个本地标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>可以推送全部未推送过的本地标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>可以删除一个本地标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;&lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>可以删除一个远程标签</p><h4 id="十、git-diff"><a href="#十、git-diff" class="headerlink" title="十、git diff"></a>十、<code>git diff</code></h4><p>用于显示提交和工作树等之间的更改，此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff</span><br><span class="line">git diff &lt;id1&gt;&lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异</span><br><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt; # 在两个分支之间比较</span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line">git diff --cached # 比较暂存区和版本库差异</span><br><span class="line">git diff --stat # 仅仅比较统计信息</span><br></pre></td></tr></table></figure><ul><li>检查工作树的几种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git diff            #(1)</span><br><span class="line">git diff --cached   #(2)</span><br><span class="line">git diff HEAD       #(3)</span><br></pre></td></tr></table></figure><ul><li>工作树中的更改尚未分段进行下一次提交。</li><li>索引和最后一次提交之间的变化; 查看已经<code>git add</code>，但没有<code>git commit</code>的改动。</li><li>自上次提交以来工作树中的更改; 如果运行<code>git commit -a</code>，查看将会提交什么。</li></ul><ul><li>显示工作版本(Working tree)和HEAD的差别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure><ul><li>直接将两个分支上最新的提交做diff</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt;</span><br></pre></td></tr></table></figure><ul><li>查看简单的diff结果，可以加上–stat参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --stat</span><br></pre></td></tr></table></figure><ul><li>查看当前目录和另外一个分支(develop)的差别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff tedevelopst</span><br></pre></td></tr></table></figure><ul><li>比较上次提交和上上次提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD^ HEAD</span><br></pre></td></tr></table></figure><h4 id="十一、git-rm"><a href="#十一、git-rm" class="headerlink" title="十一、git rm"></a>十一、<code>git rm</code></h4><p>用于从工作区和索引中删除文件</p><ul><li>删除text1.txt文件，并把它从git的仓库管理系统中移除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm text1.txt</span><br></pre></td></tr></table></figure><ul><li>删除文件夹：mydir，并把它从git的仓库管理系统中移除。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r mydir</span><br></pre></td></tr></table></figure><p>注意：<br>对于已经被<code>git rm</code>删除掉(还没被提交)的文件或目录，如果想取消其操作的话，可以首先通过<code>git add -i</code>的子命令<code>revert</code>从索引库中把它们剔除，然后用<code>git checkout &lt;文件&gt;</code>命令来达到取消的目。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">https://www.atlassian.com/git/tutorials/merging-vs-rebasing</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、git简介&quot;&gt;&lt;a href=&quot;#一、git简介&quot; class=&quot;headerlink&quot; title=&quot;一、git简介&quot;&gt;&lt;/a&gt;一、git简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git&lt;/code&gt;是目前世界上被最广泛使用的现代软件版本管理系统。&lt;code&gt;git&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flutter之环境搭建</title>
    <link href="https://sunjinshuai.github.io/2019/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://sunjinshuai.github.io/2019/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-07-25T03:11:45.000Z</published>
    <updated>2020-01-10T03:31:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>一、获取Flutter SDK</p><p>要获得 <code>Flutter</code>，请先使用 <code>git</code> 克隆 <code>Flutter</code>，然后将该 <code>flutter</code> 工具添加到您的用户路径。运行 <code>flutter doctor</code> 显示您可能需要安装的剩余依赖项。</p><p>由于国内被墙，需要设置下载镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn &#x2F;&#x2F;国内用户需要设置</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn &#x2F;&#x2F;国内用户需要设置</span><br></pre></td></tr></table></figure><p>Clone Flutter repo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b beta https:&#x2F;&#x2F;github.com&#x2F;flutter&#x2F;flutter.git</span><br></pre></td></tr></table></figure><p>二、配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">export PATH&#x3D;&#96;pwd&#96;&#x2F;flutter&#x2F;bin:$PATH</span><br><span class="line">(或者)</span><br><span class="line"># export FLUTTER_HOME&#x3D;&#x2F;Users&#x2F;sunjinshuai&#x2F;flutter</span><br><span class="line"># export PATH&#x3D;$PATH:$FLUTTER_HOME&#x2F;bin:</span><br><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>三、运行 flutter doctor</p><p>查看是否需要安装其它依赖项来完成安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>该命令检查您的环境并在终端窗口中显示报告，仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line">[✗] Android toolchain - develop for Android devices</span><br><span class="line">✗ Unable to locate Android SDK.</span><br><span class="line">Install Android Studio from: https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;index.html</span><br><span class="line">On first launch it will assist you in installing the Android SDK components.</span><br><span class="line">(or visit https:&#x2F;&#x2F;flutter.io&#x2F;setup&#x2F;#android-setup for detailed instructions).</span><br><span class="line">If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location.</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.25.1)</span><br><span class="line">[✓] Connected devices (2 available)</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>在 <a href="https://github.com/flutter/flutter/issues/13078" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/13078</a> 找到了解决方法，其实就是在 <code>bash_profile</code> 添加安卓SDK的环境变量即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br><span class="line"></span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</span><br><span class="line">[!] Android toolchain - develop for Android devices (Android SDK 28.0.1)</span><br><span class="line">✗ Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</span><br><span class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[!] VS Code (version 1.25.1)</span><br><span class="line">[✓] Connected devices (2 available)</span><br><span class="line"></span><br><span class="line">! Doctor found issues in 2 categories.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、获取Flutter SDK&lt;/p&gt;
&lt;p&gt;要获得 &lt;code&gt;Flutter&lt;/code&gt;，请先使用 &lt;code&gt;git&lt;/code&gt; 克隆 &lt;code&gt;Flutter&lt;/code&gt;，然后将该 &lt;code&gt;flutter&lt;/code&gt; 工具添加到您的用户路径。运行 &lt;c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git 奇技淫巧</title>
    <link href="https://sunjinshuai.github.io/2019/07/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>https://sunjinshuai.github.io/2019/07/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</id>
    <published>2019-07-12T13:45:47.000Z</published>
    <updated>2020-01-10T03:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><h2 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h2><p>例如：1.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 1.0.0 -m &quot;1.0.0 版本的备注信息.&quot;</span><br></pre></td></tr></table></figure><h2 id="推送所有-tag，同步到远程仓库："><a href="#推送所有-tag，同步到远程仓库：" class="headerlink" title="推送所有 tag，同步到远程仓库："></a>推送所有 tag，同步到远程仓库：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h2 id="删除本地-Tag"><a href="#删除本地-Tag" class="headerlink" title="删除本地 Tag"></a>删除本地 Tag</h2><p>例如：1.0.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 1.0.0</span><br></pre></td></tr></table></figure><p>删除远程标签需要先删除本地标签，再执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;1.0.0</span><br><span class="line">git push origin --delete tag 1.0.0</span><br></pre></td></tr></table></figure><h2 id="展示当前分支的最近的tag"><a href="#展示当前分支的最近的tag" class="headerlink" title="展示当前分支的最近的tag"></a>展示当前分支的最近的tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git describe --tags --abbrev&#x3D;0</span><br></pre></td></tr></table></figure><h2 id="默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag："><a href="#默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag：" class="headerlink" title="默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag："></a>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;version-number&gt; -m &quot;v1.0.0 发布(描述)&quot; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged master | grep -v &#39;^\*\|  master&#39; | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure><h2 id="列出远程服务器和本地的所有分支，以及分支上的最后提交"><a href="#列出远程服务器和本地的所有分支，以及分支上的最后提交" class="headerlink" title="列出远程服务器和本地的所有分支，以及分支上的最后提交"></a>列出远程服务器和本地的所有分支，以及分支上的最后提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="列出所有远程服务器上的分支"><a href="#列出所有远程服务器上的分支" class="headerlink" title="列出所有远程服务器上的分支"></a>列出所有远程服务器上的分支</h2><p>-r参数相当于：remote</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h2 id="同步本地与远程分支"><a href="#同步本地与远程分支" class="headerlink" title="同步本地与远程分支"></a>同步本地与远程分支</h2><p>删除远程不存在的本地分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --p</span><br></pre></td></tr></table></figure><h2 id="更新远程跟踪分支"><a href="#更新远程跟踪分支" class="headerlink" title="更新远程跟踪分支"></a>更新远程跟踪分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br></pre></td></tr></table></figure><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin&#x2F;&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure><h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1><h2 id="合并本地的最后两次-commit"><a href="#合并本地的最后两次-commit" class="headerlink" title="合并本地的最后两次 commit"></a>合并本地的最后两次 commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^git commit --amend</span><br></pre></td></tr></table></figure><h2 id="修改上一次的-commit-信息"><a href="#修改上一次的-commit-信息" class="headerlink" title="修改上一次的 commit 信息"></a>修改上一次的 commit 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty&#x3D;oneline --graph --decorate --all</span><br></pre></td></tr></table></figure><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  #默认就是-mixed参数。</span><br><span class="line">git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span><br><span class="line">git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   </span><br><span class="line">git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span><br></pre></td></tr></table></figure><h2 id="查看指定路径文件代码是谁写的"><a href="#查看指定路径文件代码是谁写的" class="headerlink" title="查看指定路径文件代码是谁写的"></a>查看指定路径文件代码是谁写的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="删除远程仓库地址"><a href="#删除远程仓库地址" class="headerlink" title="删除远程仓库地址"></a>删除远程仓库地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><p>暂存命令stash使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash #将本地修改暂时存储起来</span><br><span class="line">git stash list #查看暂存的信息</span><br><span class="line">git stash pop  #应用最近一次暂存的内容</span><br><span class="line">git stash apply stash@&#123;1&#125; #应用指定版本的暂存内容</span><br><span class="line">git stash clear  #清空暂存栈</span><br><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt; #从stash中拿出某个文件的修改</span><br></pre></td></tr></table></figure><h1 id="Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法"><a href="#Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法" class="headerlink" title="Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法"></a>Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法</h1><p>例如：取消某次合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge --abort #如果Git版本 &gt;&#x3D; 1.7.4</span><br><span class="line">git reset --merge #如果Git版本 &gt;&#x3D; 1.6.1</span><br></pre></td></tr></table></figure><p>注意：<br>在合并之前要保证没有未提交的文件，如果有未提交的文件但现在又不想提交，用stash命令暂存。</p><p>回退到某个版本并应用指定的几次提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 1d7444 #回退到某个版本</span><br><span class="line">git cherry-pick 626335 #将某次commit的更改应用到当前版本</span><br><span class="line">git cherry-pick …</span><br><span class="line">git push origin HEAD --force  #强制提交</span><br></pre></td></tr></table></figure><p>注意：<br>如果是撤销某次提交，可以用revert命令，git revert是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留; git reset是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区。</p><h1 id="git强制push"><a href="#git强制push" class="headerlink" title="git强制push"></a>git强制push</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure><h1 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h1><p>不添加参数，默认是-mixed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure><h1 id="撤销所有未提交的本地修改"><a href="#撤销所有未提交的本地修改" class="headerlink" title="撤销所有未提交的本地修改"></a>撤销所有未提交的本地修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><h1 id="Push-本地分支到指定远程分支"><a href="#Push-本地分支到指定远程分支" class="headerlink" title="Push 本地分支到指定远程分支"></a>Push 本地分支到指定远程分支</h1><p>例如：Push 本地当前分支到远程仓库 origin 的 master 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tag&quot;&gt;&lt;a href=&quot;#Tag&quot; class=&quot;headerlink&quot; title=&quot;Tag&quot;&gt;&lt;/a&gt;Tag&lt;/h1&gt;&lt;h2 id=&quot;添加-Tag&quot;&gt;&lt;a href=&quot;#添加-Tag&quot; class=&quot;headerlink&quot; title=&quot;添加 Tag&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 __attribute__</title>
    <link href="https://sunjinshuai.github.io/2019/02/25/%E6%B5%85%E8%B0%88-attribute/"/>
    <id>https://sunjinshuai.github.io/2019/02/25/%E6%B5%85%E8%B0%88-attribute/</id>
    <published>2019-02-25T03:16:35.000Z</published>
    <updated>2020-01-10T03:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>__attribute__</code> 是一个编译器指令，其实是 <code>GNU C</code> 的一种机制，本质是一个编译器的指令，在声明的时候可以提供一些属性，在编译阶段起作用，来做多样化的错误检查和高级优化。用于在 <code>C</code>、<code>C++</code>、<code>Objective-C</code> 中修饰变量、函数、参数、方法、类等。</p><p>合理使用 <code>__attribute__</code> 有什么好处？</p><ul><li>给编译器提供上下文，帮助编译器做优化，合理使用可以收到显著的优化效果。</li><li>编译器会根据 <code>__attribute__</code> 产生一些编译警告，使代码更规范。</li><li>给代码阅读者提供必要的注解，助其理解代码意图。</li></ul><p><strong>总之，<code>__attribute__</code> 起到了给编译器提供上下文的作用，如果错误的使用 <code>__attribute__</code> 指令，因为给编译器提供了错误的上下文，由此引起的错误通常很难被发现。</strong></p><h1 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h1><p>适用于方法、属性。告诉编译器已经过时，如果使用了，会报过时警告</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以自定义描述信息</span><br><span class="line">__attribute__((deprecated(&quot;已过期!&quot;)))</span><br><span class="line">&#x2F;&#x2F; 系统的宏定义</span><br><span class="line">DEPRECATED_ATTRIBUTE</span><br></pre></td></tr></table></figure><p>使用场景：</p><p>在组件化、<code>SDK</code> 的时候，因为某个需求，我们升级了 <code>API</code>，但是需要兼容老的版本，并且希望使用者调用最新的 <code>API</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 标记这个属性已过期</span><br><span class="line">@property (nonatomic, copy) NSString *name __attribute__((deprecated(&quot;属性已过期&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 标记方法已过期</span><br><span class="line">- (void)testOld __attribute__((deprecated(&quot;方法已过期, 请使用 test2&quot;))) &#123;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testNew &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译器警告，&#39;testOld&#39; is deprecated: 已过期, 请使用 testNew</span><br><span class="line">    [self testOld];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译器警告，提示 &quot;&#39;name&#39; 已过期...&quot;</span><br><span class="line">    NSLog(@&quot;%@&quot;, self.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unavailable"><a href="#unavailable" class="headerlink" title="unavailable"></a>unavailable</h1><p>适用于方法、属性。告诉编译器不可用。如果使用了，就会编译失败，提示错误信息</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以自定义描述信息</span><br><span class="line">__attribute__((unavailable(&quot;已经废弃,请使用 xxxx&quot;)))</span><br><span class="line">&#x2F;&#x2F; 系统宏定义</span><br><span class="line">NS_UNAVAILABLE;</span><br><span class="line">UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure><p>使用场景：</p><p>自定义了 <code>Class</code> 的初始化方法，不希望外界使用 <code>init</code> 初始化，并且给出正确的提示。<br>比希望继续使用某个属性，并且给出正确的提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name __attribute__((unavailable(&quot;这个属性已经废弃&quot;)));</span><br><span class="line"></span><br><span class="line">#pragma mark - 初始化</span><br><span class="line">- (instancetype)init __attribute__((unavailable(&quot;这个方法已经废弃,请使用 initWithName:&quot;)));</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(NSString *)Name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void) test &#123;</span><br><span class="line">    &#x2F;&#x2F; 编译不通过，提示 &quot;&#39;init&#39; 已经废弃了...&quot;</span><br><span class="line">    ViewController *vc &#x3D; [[ViewController alloc] init];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 编译不通过，提示 &quot;&#39;name&#39; 已经废弃了...&quot;</span><br><span class="line">    NSLog(@&quot;%@&quot;, vc.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="objc-subclassing-restricted"><a href="#objc-subclassing-restricted" class="headerlink" title="objc_subclassing_restricted"></a>objc_subclassing_restricted</h1><p>适用于 <code>Class</code>。告诉编译器我不能有子类，类似 <code>final</code> 关键字</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface ClangTest : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ClangTest.h&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这里编译出错，提示“Cannot subclass a class that was declared with the &#39;objc_subclassing_restricted&#39; attribute”</span><br><span class="line">@interface ClangSonTest : ClangTest</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h1 id="objc-requires-super"><a href="#objc-requires-super" class="headerlink" title="objc_requires_super"></a>objc_requires_super</h1><p>适用于方法。告诉编译器子类重写这个方法的时候，必须调用[Super xxx]</p><p>常用写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通用写法</span><br><span class="line">__attribute__((objc_requires_super))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统宏定义，其实和上面是一样的</span><br><span class="line">NS_REQUIRES_SUPER</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ClangTest : NSObject</span><br><span class="line"></span><br><span class="line">- (void)instanceMethod1 __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#import &quot;ClangTest.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ClangSonTest : KDClangTest</span><br><span class="line">@end</span><br><span class="line">@implementation KDClangSonTest</span><br><span class="line"></span><br><span class="line">- (void)instanceMethod1 &#123;</span><br><span class="line">    NSLog(@&quot;I am son&quot;);</span><br><span class="line">    &#x2F;&#x2F; 这里编译器会出现警告： Method possibly missing a [super instanceMethod1] call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="constructor-与-destructor"><a href="#constructor-与-destructor" class="headerlink" title="constructor 与 destructor"></a>constructor 与 destructor</h1><p>使用 <code>constructor</code> 属性修饰的函数能在 <code>main()</code> 函数之前执行，而使用 <code>destructor</code> 属性修饰的函数，在 <code>main()</code> 函数结束或 <code>exit()</code> 函数调用后执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main之前调用</span><br><span class="line">__attribute__((constructor))</span><br></pre></td></tr></table></figure><p>使用场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor)) void before_main() &#123;</span><br><span class="line">    printf(&quot;app before main\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) void after_main() &#123;</span><br><span class="line">    printf(&quot;app after main\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    printf(&quot;excute main\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<br>因为 <code>load</code> 是在 <code>class</code> 被加载的时候，就执行了，所以早于 <code>constructor</code>。<br>所以顺序应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load -&gt; attribute((constructor)) -&gt; main -&gt; attribute((destructor)) -&gt; initialize</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://nshipster.cn/__attribute__/" target="_blank" rel="noopener">https://nshipster.cn/__attribute__/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;__attribute__&lt;/code&gt; 是一个编译器指令，其实是 &lt;code&gt;GNU C&lt;/code&gt; 的一种机制，本质是一个编译器的指令，在声明的时候可以提供一些属性，在编译阶段起作用，来做多样化的错误检查和高级优化。用于在 &lt;code&gt;C&lt;/code&gt;、&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 iOS ARC 内存管理</title>
    <link href="https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-02-13T09:15:20.000Z</published>
    <updated>2020-01-10T03:16:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 采用的是引用计数式的内存管理方式：</p><ul><li>自己生成的对象自己持有。</li><li>非自己生成的对象自己也能持有。</li><li>自己持有的对象不再需要时释放。</li><li>非自己持有的对象自己无法释放。</li></ul><p>在 ARC 环境下，id 类型和对象类型和 C 语言其他类型不同，类型前必须加上所有权的修饰符。<br>所有权修饰符总共有4种：</p><ul><li>__strong</li><li>__weak</li><li>__autoreleasing</li><li>__unsafe_unretained</li></ul><h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h2><p><code>__strong</code> 表示强引用，对应定义 <code>property</code> 时用到的 <code>strong</code>。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 <code>nil</code>。<code>__strong</code> 修饰符是 <code>id</code> 类型和对象类型默认的所有权修饰符。</p><h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 <code>weak</code>。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 <code>nil</code>，这样可以防止野指针。<code>__weak</code> 最常见的一个作用就是用来避免强引用循环。</p><p><code>__weak</code> 的几个使用场景：</p><ul><li>在 <code>Delegate</code> 关系中防止强引用循环。在 ARC 特性下，通常我们应该设置 <code>Delegate</code> 属性为 <code>weak</code> 的。但是这里有一个疑问，我们常用到的 <code>UITableView</code> 的 <code>delegate</code> 属性是这样定义的： <code>@property (nonatomic, assign) id&lt;UITableViewDelegate&gt; delegate;</code>，为什么用的修饰符是 <code>assign</code> 而不是 <code>weak</code>？其实这个 <code>assign</code> 在 ARC 中意义等同于 <code>__unsafe_unretained</code>（后面会讲到），它是为了在 <code>ARC</code> 特性下兼容 <code>iOS4</code> 及更低版本来实现弱引用机制。一般情况下，你应该尽量使用 <code>weak</code>。</li><li>在 <code>Block</code> 中防止强引用循环。</li><li>用来修饰指向由 <code>Interface Builder</code> 创建的控件。比如：<code>@property (nonatomic, weak) IBOutlet UIButton *testButton;</code>。</li></ul><p>另外，<code>__weak</code> 修饰符的变量，会被注册到 <code>autoreleasePool</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 &#x3D; obj;</span><br><span class="line">    NSLog(@&quot;obj2-%@&quot;,obj1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器转换上述代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initweak(&amp;obj1,obj);</span><br><span class="line">id tmp &#x3D; objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;,tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><p><code>objc_loadWeakRetained</code> 函数获取附有 <code>__weak</code> 修饰符变量所引用的对象并 <code>retain</code>, <code>objc_autorelease</code> 函数将对象放入 <code>autoreleasePool</code> 中，据此当我们访问 <code>weak</code> 修饰指针指向的对象时，实际上是访问注册到自动释放池的对象。因此，如果大量使用 <code>weak</code> 的话，在我们去访问 <code>weak</code> 修饰的对象时，会有大量对象注册到自动释放池,这会影响程序的性能。</p><p>解决方案：<br>要访问 <code>weak</code> 修饰的变量时，先将其赋给一个 <code>strong</code> 变量，然后进行访问。</p><p>为什么访问 <code>weak</code> 修饰的对象就会访问注册到自动释放池的对象呢?</p><p>因为 <code>weak</code> 不会引起对象的引用计数器变化，因此，该对象在运行过程中很有可能会被释放。所以，需要将对象注册到自动释放池中并在 <code>autoreleasePool</code> 销毁时释放对象占用的内存。</p><h2 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h2><p>在 <code>ARC</code> 模式下，我们不能显示的使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，通过将对象赋给 <code>__autoreleasing</code> 修饰的变量就能达到在 <code>MRC</code> 模式下调用对象的 <code>autorelease</code> 方法同样的效果。</p><p><code>__autoreleasing</code> 修饰的对象会被注册到 <code>Autorelease Pool</code> 中，并在 <code>Autorelease Pool</code> 销毁时被释放。</p><p><strong>注意：定义 <code>property</code> 时不能使用这个修饰符，因为任何一个对象的 <code>property</code> 都不应该是 <code>autorelease</code> 类型的。</strong></p><h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h2><p><code>ARC</code> 是在 <code>iOS5</code> 引入的，而 <code>__unsafe_unretained</code> 这个修饰符主要是为了在 <code>ARC</code> 刚发布时兼容 <code>iOS4</code> 以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义 <code>property</code> 时对应的是 <code>unsafe_unretained</code>。<code>__unsafe_unretained</code> 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 <code>retainCount +1</code>。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 <code>nil</code>，所以成为了野指针，非常不安全。</p><p><code>__unsafe_unretained</code> 的应用场景：</p><ul><li>在 ARC 环境下但是要兼容 iOS4.x 的版本，用 <code>__unsafe_unretained</code> 替代 <code>__weak</code> 解决强引用循环的问题。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结， <code>autorelease</code> 的机制却依然在很多地方默默起着作用，我们来看看这些场景：</p><ul><li>方法返回值。</li><li>访问 __weak 修饰的变量。</li><li>id 的指针或对象的指针(id *)。</li></ul><h3 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h3><p>首先，我们看这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  (NSMutableArray *)array  &#123;</span><br><span class="line">    NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(array);</span><br><span class="line">objc_release(array);</span><br></pre></td></tr></table></figure><p>这里 <code>array</code> 的所有权修饰符是默认的 <code>__strong</code>。由于 <code>return</code> 使得 <code>array</code> 超出其作用域，它强引用持有的对象本该被释放，但是由于该对象作为函数返回值，所以<strong>一般情况下编译器会自动将其注册到 <code>AutoreleasePool</code> 中（注意这里是一般情况下，在一些特定情况下，<code>ARC</code> 机制提出了巧妙的运行时优化方案来跳过 <code>autorelease</code> 机制。）</strong>。</p><h4 id="ARC-模式下方法返回值跳过-autorelease-机制的优化方案"><a href="#ARC-模式下方法返回值跳过-autorelease-机制的优化方案" class="headerlink" title="ARC 模式下方法返回值跳过 autorelease 机制的优化方案"></a>ARC 模式下方法返回值跳过 autorelease 机制的优化方案</h4><p>为什么方法返回值的时候需要用到 <code>autorelease</code>机制呢？</p><p>当对象被作为参数返回 <code>return</code> 之后，如果调用者需要使用就需要强引用它，那么它 <code>retainCount + 1</code>，用完之后再清理，使它 <code>retainCount - 1</code>。</p><p>如果在方法中创建了对象并作为返回值时，根据 <code>ARC</code> 内存管理的原则，谁创建谁释放。既然作为返回值，就必须保证返回时对象没被释放以便方法外的调用者能拿到有效的对象，否则你返回的是 nil，有何意义呢。所以就需要找一个合理的机制既能延长这个对象的生命周期，又能保证对其释放。这个机制就是 <code>autorelease 机制</code>。</p><p><code>ARC</code> 模式下在方法 <code>return</code> 的时候，会调用 <code>objc_autoreleaseReturnValue()</code><br>方法替代 <code>autorelease</code>。在调用者强引用方法返回对象的时候，会调用 <code>objc_retainAutoreleasedReturnValue()</code> 方法，该方法会去检查该方法或者调用方的执行命令列表，是否会被传给 <code>objc_retainAutoreleasedReturnValue()</code> 方法。如果里面有 <code>objc_retainAutoreleasedReturnValue()</code> 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 <code>autoreleasepool</code>中，也可以返回拿到相应的对象。如果没传，那么它就会走 <code>autorelease</code> 的过程注册到 <code>autoreleasepool</code> 中。</p><h3 id="访问-weak-修饰的变量"><a href="#访问-weak-修饰的变量" class="headerlink" title="访问 __weak 修饰的变量"></a>访问 __weak 修饰的变量</h3><p>在访问 <code>__weak</code> 修饰的变量时，实际上必定会访问注册到 <code>AutoreleasePool</code> 的对象。如下来年两段代码是相同的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [obj1 class]);</span><br><span class="line">&#x2F;&#x2F; 等同于：</span><br><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">id __autoreleasing tmp &#x3D; obj1;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [tmp class]);</span><br></pre></td></tr></table></figure><p>为什么会这样呢？因为 <code>__weak</code> 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 <code>AutoreleasePool</code> 中，就能保证 <code>AutoreleasePool</code> 被销毁前对象是存在的。</p><h3 id="id-的指针或对象的指针-id"><a href="#id-的指针或对象的指针-id" class="headerlink" title="id 的指针或对象的指针(id *)"></a>id 的指针或对象的指针(id *)</h3><p>另一个隐式地使用 <code>__autoreleasing</code> 的例子就是使用 id 的指针或对象的指针(id *) 的时候。</p><p>看一个最常见的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSError *__autoreleasing error;</span><br><span class="line">￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123;</span><br><span class="line">    　　NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 即使上面你没有写 __autoreleasing 来修饰 error，编译器也会帮你做下面的事情：</span><br><span class="line">NSError *error;</span><br><span class="line">NSError *__autoreleasing tempError &#x3D; error; &#x2F;&#x2F; 编译器添加</span><br><span class="line">if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError])</span><br><span class="line">￼&#123;</span><br><span class="line">    　　error &#x3D; tempError; &#x2F;&#x2F; 编译器添加</span><br><span class="line">    　　NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error</code> 对象在你调用的方法中被创建，然后被放到 <code>AutoreleasePool</code> 中，等到使用结束后随着 <code>AutoreleasePool</code> 的销毁而释放，所以函数外 <code>error</code> 对象的使用者不需要关心它的释放。</p><p>在 <code>ARC</code> 中，所有这种指针的指针类型<code>（id *）</code>的函数参数如果不加修饰符，编译器会默认将他们认定为 <code>__autoreleasing</code> 类型。</p><p>有一点特别需要注意的是，某些类的方法会隐式地使用自己的 <code>AutoreleasePool</code>，在这种时候使用 <code>__autoreleasing</code> 类型要特别小心。比如 <code>NSDictionary</code> 的 <code>enumerateKeysAndObjectsUsingBlock</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; do stuff</span><br><span class="line">        if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">            *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; ￼code:1 userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        ￼</span><br><span class="line">    &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中其实会隐式地创建一个 <code>AutoreleasePool</code>，类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        @autoreleasepool &#123;  &#x2F;&#x2F; 被隐式创建。</span><br><span class="line">            if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">                *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; ￼code:1 userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            ￼          &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#x2F;&#x2F; *error 在这里已经被dict的做枚举遍历时创建的 Autorelease Pool释放掉了。</span><br><span class="line">    ￼&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够正常的使用 <code>*error</code>，我们需要一个 <code>strong</code> 类型的临时引用，在 <code>dict</code> 的枚举 <code>Block</code> 中是用这个临时引用，保证引用指向的对象不会在出了 <code>dict</code> 的枚举 <code>Block</code> 后被释放，正确的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    　　NSError * __block tempError; &#x2F;&#x2F; 加 __block 保证可以在Block内被修改。</span><br><span class="line">    　　[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        　　　　if (there is some error) &#123;</span><br><span class="line">            　　　　　　*tempError &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; ￼code:1 userInfo:nil];</span><br><span class="line">            　　　　&#125; ￼</span><br><span class="line">        　　&#125;]</span><br><span class="line">    　　if (error !&#x3D; nil) &#123;</span><br><span class="line">        　　　　*error &#x3D; tempError;</span><br><span class="line">        　　&#125; ￼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C 采用的是引用计数式的内存管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己生成的对象自己持有。&lt;/li&gt;
&lt;li&gt;非自己生成的对象自己也能持有。&lt;/li&gt;
&lt;li&gt;自己持有的对象不再需要时释放。&lt;/li&gt;
&lt;li&gt;非自己持有的对象自己无法释放。&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅析 NSTimer 和 CADisplayLink 内存泄漏</title>
    <link href="https://sunjinshuai.github.io/2018/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://sunjinshuai.github.io/2018/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2018-10-12T13:48:52.000Z</published>
    <updated>2020-01-10T03:23:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>谈论 <code>NSTimer &amp; CADisplayLink</code> 内存泄漏，要理解 <code>NSTimer &amp; CADisplayLink</code> 的基础概念，下面通过一个倒计时的实现的 <code>demo</code> 进入正题。</p><ul><li>第一种就是直接在 <code>TableView</code> 的 <code>Cell</code> 上使用 <code>NSTimer</code>，然后添加到当前线程所对应的 <code>RunLoop</code> 中的 <code>commonModes</code> 中。</li><li>第二种是通过 <code>Dispatch</code> 中的 <code>TimerSource</code> 来实现定时器。</li><li>第三种是使用 <code>CADisplayLink</code> 来实现。</li></ul><p>以 <code>UITableViewCell</code> 为例：</p><h3 id="一、在-Cell-中直接使用-NSTimer"><a href="#一、在-Cell-中直接使用-NSTimer" class="headerlink" title="一、在 Cell 中直接使用 NSTimer"></a>一、在 <code>Cell</code> 中直接使用 <code>NSTimer</code></h3><p>首先我们按照常规做法，直接在 <code>UITableView</code> 的 <code>Cell</code> 上添加相应的 <code>NSTimer</code>, 并使用 <code>scheduledTimer</code> 执行相应的代码块。<br>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        self.timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(countDown:) userInfo:nil repeats:YES];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown:(NSTimer *)timer &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.textLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时:%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:36:11.981473+0800 NSTimer&amp;CADisplayLink[24050:457782] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h3 id="二、DispatchTimerSource"><a href="#二、DispatchTimerSource" class="headerlink" title="二、DispatchTimerSource"></a>二、DispatchTimerSource</h3><p>接下来我们就在 <code>TableView</code> 的 <code>Cell</code> 上添加 <code>DispatchTimerSource</code>，然后看一下运行效果。当然下方代码片段我们是在全局队列中添加的 <code>DispatchTimerSource</code>，在主线程中进行更新。当然我们也可以在 <code>mainQueue</code> 中添加 <code>DispatchTimerSource</code>，这样也是可以正常工作的。当然我们不建议在 <code>MainQueue</code> 中做，因为在编程时尽量的把一些和主线程关联不太大的操作放到子线程中去做。<br>代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        [self countDown];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    &#x2F;&#x2F; 倒计时时间</span><br><span class="line">    __block NSInteger timeOut &#x3D; 60.0f;</span><br><span class="line">    dispatch_queue_t queue &#x3D; dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    dispatch_source_t _timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    &#x2F;&#x2F; 每秒执行一次</span><br><span class="line">    dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</span><br><span class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 倒计时结束，关闭</span><br><span class="line">        if (timeOut &lt;&#x3D; 0) &#123;</span><br><span class="line">            dispatch_source_cancel(_timer);</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                self.detailTextLabel.text &#x3D; @&quot;倒计时结束&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">                dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">                self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">            &#125;);</span><br><span class="line">            timeOut--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h3 id="三、CADisplayLink"><a href="#三、CADisplayLink" class="headerlink" title="三、CADisplayLink"></a>三、CADisplayLink</h3><p>接下来我们来使用 <code>CADisplayLink</code> 来实现定时器功能，<code>CADisplayLink</code> 可以添加到 <code>RunLoop</code> 中，每当屏幕需要刷新的时候，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，这时 <code>target</code> 可以读到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。</p><p>可以设想一下，我们在动画的过程中，<code>runloop</code> 被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行  <code>CADisplayLink</code> 的调用，从而造成动画过程的卡顿，使动画不流畅。</p><p>下方代码，为了不让屏幕的卡顿等引起的主线程所对应的 <code>RunLoop</code> 阻塞所造成的定时器不精确的问题。我们开启了一个新的线程，并且将 <code>CADisplayLink</code> 对象添加到这个子线程的 <code>RunLoop</code> 中，然后在主线程中更新UI即可。<br>具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</span><br><span class="line">    if (self &#x3D; [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</span><br><span class="line">        dispatch_queue_t disqueue &#x3D;  dispatch_queue_create(&quot;com.countdown&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        dispatch_group_t disgroup &#x3D; dispatch_group_create();</span><br><span class="line">        dispatch_group_async(disgroup, disqueue, ^&#123;</span><br><span class="line">            self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">            [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)countDown &#123;</span><br><span class="line">    NSDateFormatter *dateformatter &#x3D; [[NSDateFormatter alloc] init];</span><br><span class="line">    dateformatter.dateFormat &#x3D; @&quot;HH:mm:ss&quot;;</span><br><span class="line">    self.detailTextLabel.text &#x3D; [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.link invalidate];</span><br><span class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController-[MYNSTimerBlockViewController dealloc]</span><br></pre></td></tr></table></figure><h2 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h2><p>从上面的三种 <code>demo</code> 可以看出 <code>UITableViewCell</code> 没有被释放，由此得出结论，当 <code>UITableViewCell</code> 里面强引用了定时器，定时器又强引用了 <code>UITableViewCell</code>，这样两者的 <code>retainCount</code> 值一直都无法为0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>定时器的运行需要结合一个 <code>NSRunLoop</code>，同时 <code>NSRunLoop</code> 对该定时器会有一个强引用，这也是为什么我们不能对 <code>NSRunLoop</code> 中的定时器进行强引的原因。</p><p>由于 <code>NSRunLoop</code> 对定时器有引用，定时器怎样才能被释放掉。</p><blockquote><p>Removes the object from all runloop modes (releasing the receiver if it has been implicitly retained) and releases the target object.</p></blockquote><p>据官方介绍可知，<code>- invalidate</code> 做了两件事，首先是把本身（定时器）从 <code>NSRunLoop</code> 中移除，然后就是释放对 <code>target</code> 对象的强引用，从而解决定时器带来的内存泄漏问题。</p><p>从上面的 <code>demo</code> 中看出，在 <code>UITableViewCell</code> 的 <code>dealloc</code> 方法中调用 <code>invalidate</code> 方法，并没有解决问题。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里使用下 <code>Xcode8</code> 调试黑科技 <code>Memory Graph</code> 来检测下内存泄漏：</p><p><img src="https://upload-images.jianshu.io/upload_images/588630-f2c2468c9ecf756f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>从图中可以看出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop  ---&gt; 定时器 ---&gt; UITableViewCell</span><br></pre></td></tr></table></figure><p>导致 <code>UITableViewCell</code> 中没有释放掉定时器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.link &#x3D; [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</span><br><span class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>从代码中看出，<code>Target</code> 直接设置成 <code>self</code> 会造成内存泄， <code>CADisplayLink</code> 会强引用 <code>Target</code>。当 <code>CADisplayLink</code> 添加到 <code>NSRunLoop</code> 中，<code>NSRunLoop</code> 会强引用 <code>CADisplayLink</code>。如果仅仅在 <code>dealloc</code> 中调用 <code>CADisplayLink</code> 的 <code>invalidate</code> 方法是没用的，因为 <code>NSRunLoop</code> 的存在 <code>CADisplayLink</code> 不会被释放，<code>Target</code> 被强引用，<code>Target</code> 的 <code>dealloc</code> 方法不会被调用，<code>CADisplayLink</code> 的 <code>invalidate</code> 方法也不被调用，<code>CADisplayLink</code> 不会从 <code>NSRunLoop</code> 中移除，从而导致内存泄漏。</p><p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">NSRunLoop 的问题请查看这里</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、Target"><a href="#1、Target" class="headerlink" title="1、Target"></a>1、Target</h3><p>为了解决定时器与 <code>Target</code> 之间类似死锁的问题，我们会将定时器中的 <code>target</code> 对象替换成定时器自己，采用分类实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSTimer+TimerTarget.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSTimer (TimerTarget)</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</span><br><span class="line">repeat:(BOOL)yesOrNo </span><br><span class="line"> block:(void (^)(NSTimer *))block &#123;</span><br><span class="line">    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(startTimer:) userInfo:[block copy] repeats:yesOrNo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)startTimer:(NSTimer *)timer &#123;</span><br><span class="line">    void (^block)(NSTimer *timer) &#x3D; timer.userInfo;</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="2、Proxy"><a href="#2、Proxy" class="headerlink" title="2、Proxy"></a>2、Proxy</h3><p>这种方式就是创建一个 <code>NSProxy</code> 子类 <code>TimerProxy</code>，<code>TimerProxy</code> 的作用是什么呢？就是什么也不做，可以说只会重载消息转发机制，如果创建一个 <code>TimerProxy</code> 对象将其作为定时器的 <code>target</code>，专门用于转发定时器消息至 <code>Target</code> 对象，那么问题是不是就解决了呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 target:[TimerProxy timerProxyWithTarget:self] selector:@selector(startTimer) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line"></span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure><h3 id="3、NSTimer-Block"><a href="#3、NSTimer-Block" class="headerlink" title="3、NSTimer Block"></a>3、NSTimer Block</h3><p>还有一种方式就是采用Block，iOS 10增加的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ scheduledTimerWithTimeInterval:repeats:block:</span><br><span class="line"></span><br><span class="line">NSTimer *timer &#x3D; [NSTimer scheduledTimerWithTimeInterval:0.25 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;MYNSTimerTargetController timer start&quot;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">self.timer &#x3D; timer;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSTimer%26CADisplayLink" target="_blank" rel="noopener">浅析NSTimer &amp; CADisplayLink内存泄漏</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谈论 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 内存泄漏，要理解 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 的基础概念，下面通过一个倒计时的实现的 &lt;code&gt;demo&lt;/code&gt; 进入正题。
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVO 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2018-09-11T13:28:58.000Z</published>
    <updated>2020-01-10T03:23:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>KVO</code> 全称 <code>KeyValueObserving</code> 是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，当指定的对象的属性被修改后，则对象就会接受收到通知。简单的说就是每次指定的被观察的对象的属性被修改后，<code>KVO</code> 就会自动通知相应的观察者了。</p><h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul><li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li><li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li><li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li></ul><h1 id="KVO-实现原理："><a href="#KVO-实现原理：" class="headerlink" title="KVO 实现原理："></a>KVO 实现原理：</h1><p><code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p><blockquote><p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p></blockquote><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。重写的 <code>setter</code> 方法会在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针指向这个新创建的类，对象变成了新创建的类的实例，而不是原来真正的类。</p><h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a>KVO 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。<br>例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">@interface TestKVOViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Message *message;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestKVOViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    self.view.backgroundColor &#x3D; [UIColor whiteColor];</span><br><span class="line">    </span><br><span class="line">    Message *message &#x3D; [[Message alloc] init];</span><br><span class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    message.text &#x3D; @&quot;hello object-c&quot;;</span><br><span class="line">    self.message &#x3D; message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</span><br><span class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &#39;NSRangeException&#39;, reason: &#39;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&#39;</span><br><span class="line">*** First throw call stack:</span><br><span class="line">(</span><br><span class="line">0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</span><br><span class="line">1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</span><br><span class="line">2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</span><br><span class="line">3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</span><br><span class="line">4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</span><br><span class="line">5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</span><br><span class="line">6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</span><br><span class="line">7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</span><br><span class="line">8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</span><br><span class="line">9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</span><br><span class="line">10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</span><br><span class="line">11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</span><br><span class="line">12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</span><br><span class="line">14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</span><br><span class="line">15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</span><br><span class="line">16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</span><br><span class="line">17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</span><br><span class="line">18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</span><br><span class="line">19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</span><br><span class="line">20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</span><br><span class="line">21  ImplementKVO                        0x000000010dd2dfef main + 111</span><br><span class="line">22  libdyld.dylib                       0x00000001129fe955 start + 1</span><br><span class="line">23  ???                                 0x0000000000000001 0x0 + 1</span><br><span class="line">)</span><br><span class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</span><br></pre></td></tr></table></figure><h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</span><br><span class="line"></span><br><span class="line">@interface NSObject (KVO)</span><br><span class="line"></span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">forKey:(NSString *)key</span><br><span class="line">withBlock:(ObservingBlock)block;</span><br><span class="line"></span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p><ul><li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li><li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li><li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li><li>添加这个观察者；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</span><br><span class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</span><br><span class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</span><br><span class="line"> 4. 将调用对象添加到数组中。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)addObserver:(NSObject *)observer</span><br><span class="line">             forKey:(NSString *)key</span><br><span class="line">          withBlock:(ObservingBlock)block &#123;</span><br><span class="line">    </span><br><span class="line">    SEL setterSelector &#x3D; NSSelectorFromString(setterForGetter(key));</span><br><span class="line">    Method setterMethod &#x3D; class_getInstanceMethod([self class], setterSelector);</span><br><span class="line">    if (!setterMethod) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        </span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Class clazz &#x3D; object_getClass(self);</span><br><span class="line">    NSString *clazzName &#x3D; NSStringFromClass(clazz);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; if not an KVO class yet</span><br><span class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</span><br><span class="line">        clazz &#x3D; [self makeKvoClassWithOriginalClassName:clazzName];</span><br><span class="line">        object_setClass(self, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; add our kvo setter if this class (not superclasses) doesn&#39;t implement the setter?</span><br><span class="line">    if (![self hasSelector:setterSelector]) &#123;</span><br><span class="line">        const char *types &#x3D; method_getTypeEncoding(setterMethod);</span><br><span class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ObservationInfo *info &#x3D; [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    if (!observers) &#123;</span><br><span class="line">        observers &#x3D; [NSMutableArray array];</span><br><span class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">    [observers addObject:info];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p><p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 1. 判断是否存在KVO类，如果存在则返回。</span><br><span class="line"> 2. 如果不存在，则创建KVO类。</span><br><span class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</span><br><span class="line">    NSString *kvoClazzName &#x3D; [kKVOClassPrefix stringByAppendingString:originalClazzName];</span><br><span class="line">    Class clazz &#x3D; NSClassFromString(kvoClazzName);</span><br><span class="line">    </span><br><span class="line">    if (clazz) &#123;</span><br><span class="line">        return clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; class doesn&#39;t exist yet, make it</span><br><span class="line">    Class originalClazz &#x3D; object_getClass(self);</span><br><span class="line">    Class kvoClazz &#x3D; objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; grab class method&#39;s signature so we can borrow it</span><br><span class="line">    Method clazzMethod &#x3D; class_getInstanceMethod(originalClazz, @selector(class));</span><br><span class="line">    const char *types &#x3D; method_getTypeEncoding(clazzMethod);</span><br><span class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</span><br><span class="line">    </span><br><span class="line">    objc_registerClassPair(kvoClazz);</span><br><span class="line">    </span><br><span class="line">    return kvoClazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p><p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</span><br><span class="line">    NSString *setterName &#x3D; NSStringFromSelector(_cmd);</span><br><span class="line">    NSString *getterName &#x3D; getterForSetter(setterName);</span><br><span class="line">    </span><br><span class="line">    if (!getterName) &#123;</span><br><span class="line">        NSString *reason &#x3D; [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</span><br><span class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</span><br><span class="line">                                       reason:reason</span><br><span class="line">                                     userInfo:nil];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    id oldValue &#x3D; [self valueForKey:getterName];</span><br><span class="line">    </span><br><span class="line">    struct objc_super superclazz &#x3D; &#123;</span><br><span class="line">        .receiver &#x3D; self,</span><br><span class="line">        .super_class &#x3D; class_getSuperclass(object_getClass(self))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; cast our pointer so the compiler won&#39;t complain</span><br><span class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) &#x3D; (void *)objc_msgSendSuper;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; call super&#39;s setter, which is original class&#39;s setter method</span><br><span class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; look up observers and call the blocks</span><br><span class="line">    NSMutableArray *observers &#x3D; objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</span><br><span class="line">    for (ObservationInfo *each in observers) &#123;</span><br><span class="line">        if ([each.key isEqualToString:getterName]) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">                each.block(self, getterName, oldValue, newValue);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p><p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface ObservationInfo : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) NSObject *observer;</span><br><span class="line">@property (nonatomic, copy) NSString *key;</span><br><span class="line">@property (nonatomic, copy) ObservingBlock block;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ObservationInfo</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObserver:(NSObject *)observer</span><br><span class="line">                             Key:(NSString *)key</span><br><span class="line">                           block:(ObservingBlock)block &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _observer &#x3D; observer;</span><br><span class="line">        _key &#x3D; key;</span><br><span class="line">        _block &#x3D; block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Strikers/MYKit" target="_blank" rel="noopener">KVO crash 防护方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 全称 &lt;code&gt;KeyValueObserving&lt;/code&gt; 是 &lt;code&gt;Objective-C&lt;/code&gt; 对观察者模式&lt;code&gt;(Observer Pattern)&lt;/code&gt;的实现；&lt;code&gt;KVO&lt;/code&gt; 提
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 NSUserDefaults</title>
    <link href="https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/"/>
    <id>https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/</id>
    <published>2018-06-20T13:38:40.000Z</published>
    <updated>2018-09-12T13:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>NSUserDefaults</code> 适用于快速读取小规模的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br></pre></td></tr></table></figure><p>写入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *string &#x3D; @&quot;hahaha&quot;;</span><br><span class="line">[standardDefaults setObject:string forKey:@&quot;myKey&quot;];</span><br><span class="line">[standardDefaults synchronize];&#x2F;&#x2F; 写完别忘了同步</span><br></pre></td></tr></table></figure><p>读取数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *value &#x3D; [standardDefaults objectForKey:@&quot;myKey&quot;];</span><br></pre></td></tr></table></figure><p><code>NSUserDefaults</code> 可以理解成键值对</p><p>有时在写数据之前，想判断下这个健是否已经设置过默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">if ([standardDefaults stringForKey:@&quot;favoriteColor&quot;] &#x3D;&#x3D; nil) &#123;</span><br><span class="line">    [standardDefaults setObject:@&quot;Green&quot; forKey:@&quot;favoriteColor&quot;];</span><br><span class="line">    [standardDefaults synchronize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以使用 <code>registerDefaults:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">[standardDefaults registerDefaults:@&#123;@&quot;favoriteColor&quot;: @&quot;Green&quot;&#125;];</span><br><span class="line">[standardDefaults synchronize];</span><br></pre></td></tr></table></figure><p>每次程序启动的时候调用 <code>registerDefaults:</code> 方法都是安全的，完全可以将这个方法的调用放到 <code>applicationDidFinishLaunching:</code> 方法中，这个方法永远都不会覆盖用户设置的值。</p><p>但是并不是所有类型的对象都能够直接放入 <code>NSUserDefaults</code>，<code>NSUserDefaults</code> 只支持 <code>Foundation</code> 类型的对象，如果自定义 <code>NSObject</code> 对象存入 <code>NSUserDefaults</code> 就要实现 <code>NSCoding</code> 协议了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *age;</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (id)initWithCoder:(NSCoder *)coder;</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)coder;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (id)initWithCoder:(NSCoder *)coder &#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        self.age  &#x3D; [coder decodeObjectForKey:@&quot;age&quot;];</span><br><span class="line">        self.name &#x3D; [coder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCoder: (NSCoder *)coder &#123;</span><br><span class="line">    [coder encodeObject:self.age forKey:@&quot;age&quot;];</span><br><span class="line">    [coder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再存取时通过 <code>NSData</code> 做载体：</p><p>存入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *standardDefaults &#x3D; [NSUserDefaults standardUserDefaults];</span><br><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">NSData *personData &#x3D; [NSKeyedArchiver archivedDataWithRootObject:person];</span><br><span class="line">[standardDefaults setObject:personData forKey:@&quot;personKey&quot;];</span><br><span class="line">[standardDefaults synchronize];</span><br></pre></td></tr></table></figure><p>读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSData *newPersonData &#x3D; [standardDefaults objectForKey:&quot;personKey&quot;];</span><br><span class="line">Person *Person &#x3D; [NSKeyedUnarchiver unarchiveObjectWithData:newPersonData];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt; 适用于快速读取小规模的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2018/05/09/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2018/05/09/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2018-05-09T10:31:52.000Z</published>
    <updated>2020-01-10T03:33:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p><p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p><ul><li><p><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</p></li><li><p>查看现有的<code>podspec</code>源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul><li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li><li>创建pod私有库所需要的项目工程文件，并上传到私有库</li><li>创建pod所对应的podspec文件，并进行验证／测试</li><li>向私有的Spec Repo中提交podspec</li><li>使用pod库</li></ul><h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul><li><p>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</p></li><li><p>将私有Spec Repo关联到本地</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add FXSpesc http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git</span><br></pre></td></tr></table></figure><p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p></li><li><p>执行命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p><h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul><li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>手动创建Xcode工程(过于简单)</p></li></ul><h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul><li>如果用<code>pod</code>命令创建，</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 你项目工程文件</span><br><span class="line">pod spec create FXKit.podspec</span><br></pre></td></tr></table></figure></li><li><p>修改<code>podspec</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.name         &#x3D; &quot;FXKit&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.0.1&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;FXKit，繁星优选私有库&quot;</span><br><span class="line">  s.description  &#x3D; &lt;&lt;-DESC</span><br><span class="line">   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">  s.homepage     &#x3D; &quot;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git&quot;</span><br><span class="line"></span><br><span class="line">  # s.license    &#x3D; &quot;MIT (example)&quot;</span><br><span class="line">  s.license      &#x3D; &#123; :type &#x3D;&gt; &quot;MIT&quot;, :file &#x3D;&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line">  s.author       &#x3D; &#123; &quot;孙金帅&quot; &#x3D;&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</span><br><span class="line">  s.platform     &#x3D; :ios</span><br><span class="line">  s.source       &#x3D; &#123;</span><br><span class="line">:git &#x3D;&gt; &quot;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git&quot;,</span><br><span class="line">:tag &#x3D;&gt; &quot;#&#123;s.version&#125;&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s.source_files &#x3D; &#39;FXKit&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;</span><br><span class="line"></span><br><span class="line">  # s.resource_bundles &#x3D; &#123;</span><br><span class="line">  #   &#39;FXKit&#39; &#x3D;&gt; [&#39;FXKit&#x2F;Assets&#x2F;*.png&#39;]</span><br><span class="line">  # &#125;</span><br><span class="line"></span><br><span class="line">  s.public_header_files &#x3D; &#39;FXKit&#x2F;**&#x2F;*.h&#39;</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;</span><br><span class="line">  # s.dependency &#39;AFNetworking&#39;, &#39;~&gt; 2.3&#39;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure></li><li><p>commit项目工程的源文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXKitExampleDemo.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint FXKit.podspec --sources&#x3D;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p><h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</span><br><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push FXSpesc NAME.podspec --sources&#x3D;http:&#x2F;&#x2F;michael@git.51fanxing.com:88&#x2F;fxbest&#x2F;ios&#x2F;FXPodSpesc.git,https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git --allow-warnings --use-libraries</span><br></pre></td></tr></table></figure><h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库踩坑记</title>
    <link href="https://sunjinshuai.github.io/2018/05/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://sunjinshuai.github.io/2018/05/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E8%B8%A9%E5%9D%91%E8%AE%B0/</id>
    <published>2018-05-08T14:01:03.000Z</published>
    <updated>2020-01-10T03:33:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>即上一篇<a href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/">iOS之使用Cocoapods创建公有仓库</a>，本文就<code>CocoaPods</code>创建公有库踩到的坑做一下分享：</p><h4 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h4><ul><li>本地的公有仓库验证通过，但是远程仓库上的公有仓库验证不通过，路经不对。<br><img src="http://upload-images.jianshu.io/upload_images/588630-4a5138f97c4c6d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li></ul><p>解决办法：<br>重新打开<code>xxx.podspec</code>文件编辑一下，确定共享文件路径没有错误，然后再上传到<code>github</code>上验证。<br><code>source_files</code>文件格式有几种设置方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.source_files  &#x3D; &#39;Classes&#x2F;*.&#123;h,m&#125;&#39;</span><br><span class="line">s.source_files  &#x3D; &#39;Classes&#x2F;publicClass.&#123;h,m&#125;&#39;</span><br><span class="line">s.source_files  &#x3D; &#39;Classes&#39;</span><br><span class="line">s.source_files  &#x3D; &#39;Classes&#x2F;**&#x2F;*.&#123;h,m&#125;&#39;</span><br></pre></td></tr></table></figure><ul><li>执行<code>pod trunk push TestCocoaPods.podspec</code>时，报<code>[!] {&quot;name&quot;=&gt;[&quot;is already taken&quot;]}</code><br><img src="http://upload-images.jianshu.io/upload_images/588630-2a2f1d0e9d5c0864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li></ul><p>解决办法：<br>执行<code>pod search TestCocoaPods</code>，会发现有一个重名的公有库存在，重新创建一个公有库，<code>CocoaPods</code>不允许有重名的公有库存在。</p><ul><li>最后所有的验证都通过了也上传成功了，结果使用<code>pod search</code>仍然搜索不到。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-7076e838dbb41cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>解决办法：<br>1、执行<code>pod setup</code></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-fd244d2a25ef7af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>如果最底下会输出<code>setup completed</code>。说明执行<code>pod setup</code>成功。<br>2、如果<code>pod search</code>操作还是搜索失败，删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ~&#x2F;Library&#x2F;Caches&#x2F;CocoaPods&#x2F;search_index.json</span><br></pre></td></tr></table></figure><p>3、执行<code>pod search</code></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-be3fa814cb06d76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;即上一篇&lt;a href=&quot;https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%9
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库</title>
    <link href="https://sunjinshuai.github.io/2018/05/07/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2018/05/07/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2018-05-07T05:45:50.000Z</published>
    <updated>2020-01-10T03:33:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在开发过程中，经常会使用到第三框架，我们通过一个<code>pod install</code>命令，很方便的就将第三方框架加到我们自己的项目中。</p><p>如果我们也想将自己写的组件或库开源出去，让别人也可以通过<code>pod install</code>命令安装自己的框架该怎么做呢？下面，我就教大家一步一步的将自己的<code>pods</code>发布到<code>CocoaPods</code>中。如果你现在对<code>CocoaPods</code>还不太了解，推荐你看一看这篇文章：<a href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">CocoaPods的安装与使用</a></p><p>在 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 上创建一个开源项目，项目中必须包含这几个文件</p><ul><li><code>LICENSE</code>:开源许可证</li><li><code>README.md</code>:仓库说明</li><li>开源项目</li><li><code>cocoaPodsName.podspec</code>: <code>CocoaPods</code> 的描述文件，这个文件<strong>非常重要</strong></li></ul><p>下面就创建 <code>CocoaPods</code> 公有库做一下分享：</p><h4 id="在-github-上创建仓库。"><a href="#在-github-上创建仓库。" class="headerlink" title="在 github 上创建仓库。"></a>在 <code>github</code> 上创建仓库。</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-18287791668c31f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>备注：</p><ul><li><code>github</code> 仓库的名称，不允许重名。</li><li><code>LICENSE</code>：开源许可证，默认一般选择 <code>MIT</code>。</li></ul><h4 id="创建-podspec-文件"><a href="#创建-podspec-文件" class="headerlink" title="创建 *.podspec 文件"></a>创建 *.podspec 文件</h4><p>使用命令行、<code>sourceTree</code> 或者 <code>GitHub Mac</code> 将项目克隆到本地，然后 <code>cd</code> 进入本地项目工程中，然后创建 <code>*.podspec</code> 文件。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create cocoaPodsName;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-20364e263a61e972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>当 <code>Specification created at cocoaPodsName.podspec</code> 说明创建 <code>*.podspec</code> 文件成功，这时就会在你的本地项目工程中下生成 <code>cocoaPodsName.podspec</code> 文件。</p><h4 id="编辑-podspec-文件"><a href="#编辑-podspec-文件" class="headerlink" title="编辑 *.podspec 文件"></a>编辑 *.podspec 文件</h4><p>使用文本编辑器或者 <code>sublime</code> 等编辑 <code>*.podspec</code> 文件。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-ae92088a994e1ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>备注：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、s.name：公有库的名称。</span><br><span class="line">2、s.version：公有库的版本。</span><br><span class="line">3、s.summary：公有库简短介绍。</span><br><span class="line">4、s.description：公有库详细介绍。</span><br><span class="line">5、s.homepage：公有库在GitHub上的地址。</span><br><span class="line">6、s.license：开源协议。</span><br><span class="line">7、s.author：作者。</span><br><span class="line">8、s.source：公有库在GitHub上的地址和版本号。</span><br><span class="line">9、s.source_files：公有库对外共享的.h和.m文件。</span><br><span class="line">10、s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure><p>没有涉及到的字段可以去<a href="http://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="noopener">官方文档</a>查阅。</p><h4 id="验证-podspec-文件"><a href="#验证-podspec-文件" class="headerlink" title="验证 *.podspec 文件"></a>验证 *.podspec 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint cocoaPodsName.podspec --allow-warnings --verbose</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><code>--allow-warnings</code> 忽略开源项目工程里面的警告；</li><li><code>--verbose</code> 在控制台查看详细的信息。</li></ul><p>验证成功会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; cocoaPodsName (0.0.1)</span><br><span class="line"></span><br><span class="line">cocoaPodsName passed validation.</span><br></pre></td></tr></table></figure><h4 id="发布-podspec"><a href="#发布-podspec" class="headerlink" title="发布 *.podspec"></a>发布 *.podspec</h4><p>验证有效后，然后再将本地项目工程中得所有文件 <code>push</code> 到 <code>github</code> 上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;sunjinshuai&#x2F;test.git</span><br><span class="line">git push -u origin master</span><br><span class="line">$ git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">$ git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><p>向 <code>CocoaPods</code> 注册账户信息，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register 邮箱 ‘用户名’ --description&#x3D;‘描述’</span><br></pre></td></tr></table></figure><p>注意：<br>邮箱为<code>github</code>上的登录邮箱、用户名为<code>github</code>上的用户名。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e5852a3ef0d784db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>接收发送到邮箱的链接，点击进入后注册成功。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-31ebbd1972d0b840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>查看注册的个人信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-1c00ba7b4cc7dee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>验证发布到 <code>cocoapods</code>上的公有仓库是否有效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint cocoaPodsName.podspec --allow-warnings --verbose</span><br></pre></td></tr></table></figure><p>发布自己的库的 <code>podspec</code> 文件给 <code>cocoapods</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push cocoaPodsName.podspec --allow-warnings --verbose</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-3b58f26ecefe1456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>大功告成，使用<code>pod search cocoaPodsName</code>搜索即可。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-ebd6b6df003a75e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在开发过程中，经常会使用到第三框架，我们通过一个&lt;code&gt;pod install&lt;/code&gt;命令，很方便的就将第三方框架加到我们自己的项
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVC</title>
    <link href="https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/"/>
    <id>https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/</id>
    <published>2018-04-12T14:37:32.000Z</published>
    <updated>2018-09-12T13:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>KVC</code> 是 <code>KeyValue Coding</code> 的简称，遵循 <code>NSKeyValueCoding</code> 协议，它是一种可以直接通过字符串的名字 <code>key</code> 来访问类属性的机制，而不是通过调用 <code>setter</code>、<code>getter</code> 方法访问。</p><p>对于 <code>KVC</code>，<code>Cocoa</code> 自动放入和取出基本数据类型放入 <code>NSNumber</code> 或 <code>NSValue</code> 中，当使用 <code>setValue:ForKey:</code> 或者 <code>valueForKey:</code> 时，它自动将基本数据类型从这些对象中取出，仅 <code>KVC</code> 具有这种自动包装功能，常规方法调用和属性语法不具备该功能。</p><h1 id="setValue-forKey-的实现方式："><a href="#setValue-forKey-的实现方式：" class="headerlink" title="setValue:forKey 的实现方式："></a><code>setValue:forKey</code> 的实现方式：</h1><p>以字符串的形式向对象发送消息，首先查找以 <code>set&lt;Key&gt;</code> 命名的 <code>setter</code> 方法，如果成员用 <code>@property</code>，<code>@synthsize</code> 处理，因为 <code>@synthsize</code> 告诉编译器自动生成 <code>set&lt;Key&gt;:</code> 格式的 <code>setter</code> 方法，所以这种情况下会直接搜索到。如果上面的 <code>setter</code> 方法没有找到，如果类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。如果找到则设置成员的值，如果没有查找调用 <code>setValue:forUndefinedKey:</code>。</p><h1 id="valueForKey-的实现方式："><a href="#valueForKey-的实现方式：" class="headerlink" title="valueForKey: 的实现方式："></a><code>valueForKey:</code> 的实现方式：</h1><ul><li>首先查找以 <code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code> 命名的 <code>getter</code> 方法，找到直接调用。</li><li>如果上面的 <code>getter</code> 没有找到，则会查找 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 格式的方法，找到就会调用 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 方法，还有一个可选的 <code>get&lt;Key&gt;:range:</code> 方法。</li><li>若是还没查到，那么查找 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 格式的方法，如果找到就调用 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 方法。</li><li>若是还没查到，那么如果类方法 accessInstanceVariablesDirectly 返回 YES，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。</li><li>再没查到，调用 <code>valueForUndefinedKey:</code>。</li></ul><p>综上，<strong>使用 KVC 访问属性的代价比直接使用存取方法性能开销要大</strong>。</p><h1 id="值的正确性核查"><a href="#值的正确性核查" class="headerlink" title="值的正确性核查"></a>值的正确性核查</h1><p>KVC 提供属性值确认的 API，它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p><p>实现核查方法，为如下格式：<code>validate&lt;Key&gt;:error:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</span><br><span class="line">    &#x2F;&#x2F; The name must not be nil, and must be at least two characters long.</span><br><span class="line">    if ((*ioValue &#x3D;&#x3D; nil) || ([(NSString *)*ioValue length] &lt; 2]) &#123;</span><br><span class="line">        if (outError !&#x3D; NULL) &#123;</span><br><span class="line">            NSString *errorString &#x3D; NSLocalizedStringFromTable(</span><br><span class="line">                    @&quot;A Person&#39;s name must be at least two characters long&quot;, @&quot;Person&quot;,</span><br><span class="line">                    @&quot;validation: too short name error&quot;);</span><br><span class="line">            NSDictionary *userInfoDict &#x3D;</span><br><span class="line">                [NSDictionary dictionaryWithObject:errorString</span><br><span class="line">                                            forKey:NSLocalizedDescriptionKey];</span><br><span class="line">            *outError &#x3D; [[[NSError alloc] initWithDomain:PERSON_ERROR_DOMAIN</span><br><span class="line">                                                    code:PERSON_INVALID_NAME_CODE</span><br><span class="line">                                                userInfo:userInfoDict] autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用核查方法：<br><code>validateValue:forKey:error:</code>，默认实现会搜索 <code>validate&lt;Key&gt;:error:</code>格式的核查方法，找到则调用，未找到默认返回 <code>YES</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;KVC&lt;/code&gt; 是 &lt;code&gt;KeyValue Coding&lt;/code&gt; 的简称，遵循 &lt;code&gt;NSKeyValu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS之CocoaPods的安装与使用</title>
    <link href="https://sunjinshuai.github.io/2018/04/07/iOS%E4%B9%8BCocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2018/04/07/iOS%E4%B9%8BCocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2018-04-07T01:18:08.000Z</published>
    <updated>2020-01-10T03:33:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Cocoapods</code>是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。</p><p>当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当前的步伐，而应该不断进取，要做到能想<code>Cocoapods</code>提交项目，并且在自己项目中熟练应用该工具的程度。特别是如果一个大的公司来说的话,就有可能进行模块化开发了。对于国内很多公司还是在用OC来说的话，<code>Cocoapods</code>应该还是一个不错的模块管理的工具。</p><h4 id="升级ruby源"><a href="#升级ruby源" class="headerlink" title="升级ruby源"></a>升级ruby源</h4><p>安装<code>Cocoapods</code>需要用到<code>ruby</code>，Mac系统自带<code>ruby</code>，但如果不是最新的系统，最好更新一下。</p><p>注意：<br><code>ruby</code>的软件源<code>rubygems.org</code>被墙了，所以先换一下源。</p><ul><li>首先，执行以下命令删除原来的ruby源：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br></pre></td></tr></table></figure><p>注意：<br>执行命令后可在终端看见以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;rubygems.org&#x2F; removed from sources</span><br></pre></td></tr></table></figure><ul><li>然后下一步添加你找到的可用的镜像源(这里我没有用淘宝的源：<a href="https://ruby.taobao.org/" target="_blank" rel="noopener">https://ruby.taobao.org/</a>):</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources -a https:&#x2F;&#x2F;gems.ruby-china.org&#x2F;</span><br></pre></td></tr></table></figure><ul><li>验证新源是否替换成功</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem sources -l</span><br></pre></td></tr></table></figure><p>终端输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** CURRENT SOURCES ***</span><br><span class="line">https:&#x2F;&#x2F;gems.ruby-china.org&#x2F;</span><br></pre></td></tr></table></figure><p>到此<code>ruby</code>源替已经换成国内的源。</p><h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p>问题1、<code>While executing gem ... (Errno::EPERM)  Operation not permitted - /usr/bin/fuzzy_match</code>错误</p><p>解决方法:</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods</span><br></pre></td></tr></table></figure><p>然后提示<code>gems installed</code>即可。</p><p>问题2、<code>Error installing pods:active support requires Ruby version &gt;= 2.2.2</code><br>解决方案:</p><p>查看<code>ruby</code>版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure><p>终端会输出你的<code>ruby</code>版本信息</p><p>查看目前的所有<code>ruby</code>版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm list known</span><br></pre></td></tr></table></figure><p>如果提示<code>command not found</code>请先安装<code>rvm</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure><p>如果已安装会列出所有的<code>ruby</code>版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># MRI Rubies</span><br><span class="line">[ruby-]1.8.6[-p420]</span><br><span class="line">[ruby-]1.8.7[-head] # security released on head</span><br><span class="line">[ruby-]1.9.1[-p431]</span><br><span class="line">[ruby-]1.9.2[-p330]</span><br><span class="line">[ruby-]1.9.3[-p551]</span><br><span class="line">[ruby-]2.0.0[-p648]</span><br><span class="line">[ruby-]2.1[.10]</span><br><span class="line">[ruby-]2.2[.6]</span><br><span class="line">[ruby-]2.3[.3]</span><br><span class="line">[ruby-]2.4[.0]</span><br><span class="line">ruby-head</span><br><span class="line"></span><br><span class="line"># for forks use: rvm install ruby-head-&lt;name&gt; --url https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;ruby.git --branch 2.2</span><br><span class="line"></span><br><span class="line"># JRuby</span><br><span class="line">jruby-1.6[.8]</span><br><span class="line">jruby-1.7[.26]</span><br><span class="line">jruby[-9.1.7.0]</span><br><span class="line">jruby-head</span><br><span class="line"></span><br><span class="line"># Rubinius</span><br><span class="line">rbx-1[.4.3]</span><br></pre></td></tr></table></figure><p>然后安装最新的<code>ruby</code>版本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><h4 id="CocoaPods的使用"><a href="#CocoaPods的使用" class="headerlink" title="CocoaPods的使用"></a>CocoaPods的使用</h4><ul><li>查找第三方库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod search AFNetworking</span><br></pre></td></tr></table></figure><ul><li>创建Podfile文件</li></ul><p>在终端使用cd ＋路径切换到项目所在文件下，然后输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Podfile</span><br></pre></td></tr></table></figure><p>就可以在项目目录里看到<code>Podfile</code>文件。也可以使用<code>pod init</code>来创建，<code>Podfile</code>文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure><p>打开Podfile文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open Podfile</span><br></pre></td></tr></table></figure><p>然后<code>pod install</code>就可以了</p><h4 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h4><p>由于有<code>Podfile.lock</code>文件的保护下，在没有执行<code>pod update</code>命令的情况下，是不会将已有的第三方库进行升级的。所以运行<code>pod install</code>的情况下还是能编译通过的。</p><ul><li>pod</li></ul><p>一般在<code>Podfile</code>里面如果引入第三方库，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;AFNetworking&#39;, &#39;~&gt; 3.1.0&#39;</span><br></pre></td></tr></table></figure><p>可以看出<code>pod</code>关键字后面可以跟参数:</p><p>参数一： 版本号<br>从上面可以看得出<code>AFNetworking</code>后面跟了参数版本号。<br>不过版本号可以是大于、小于、等于等。当然具体的可以是’&gt; 3.1.0’, ‘&gt;= 3.1.0’, ‘&lt; 3.1.0’, ‘3.1.0’以及’<del>&gt; 3.1.0’。关于普通的就没什么好说了，最后一个</del>&gt;指的是正对最后一位来说。如使用’~&gt; 3.1.0’,意味着’&gt;= 3.1.0’并且’&lt; 3.2.0’的意思。</p><p>参数二：地址<br><code>Cocoapods</code>可以指定某一个<code>git</code>的目录或者是本地的目录。有的时候我们希望一直用某一个版本最新的版本，即使没有打版本的话，我们可以直接后面接上:<code>git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;</code>。<br>当然除了这种情况外，还有可能是如果是我们自己开发的私有库，并且在开发阶段的情况下，可能就希望开发模式进行引用，则可以使用path参数:<code>:path =&gt; &#39;~/Documents/AFNetworking</code>。</p><p>参数三：tag、branche、commit<br>有的时候我们希望引用有一个<code>tag</code>，<code>branch</code>或者是<code>comit</code>的内容的话可以使用这个参数，分别用<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</p><ul><li>platform</li></ul><p>这个参数是只依赖的库希望在哪个平台被编译，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;7.0&#39;</span><br></pre></td></tr></table></figure><ul><li>target</li></ul><p>这个是指定具体的配置是适配在哪个target，这里的target值得就是Xcode中的target。如果对于一些项目中你的不同target引用的框架不同的话，可以采用这个进行区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target &quot;ShowsApp&quot; do  </span><br><span class="line">  pod &#39;ShowsKit&#39;</span><br><span class="line">  target &quot;ShowsTV&quot; do</span><br><span class="line">    pod &quot;ShowTVAuth&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>use_frameworks!</li></ul><p>这个指明编译成动态库，而不是静态库，特别是在使用Swift库的过程中，特别需要使用这句。不过他会把所有项目的编译动态库，这一点有点不好。不过在使用Swift库的过程中就没办法了。</p><ul><li>source</li></ul><p>这个参数是指Cocoapods从哪些仓库(Spec)中获得框架的源代码，如果在结合使用开源库以及自己私有库的情况下，这个参数还是非常有意义的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;artsy&#x2F;Specs.git&#39;  </span><br><span class="line">source &#39;https:&#x2F;&#x2F;192.168.0.90:8888&#x2F;MySepcs&#x2F;Specs.git&#39;</span><br></pre></td></tr></table></figure><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod install --verbose --no-repo-update</span><br><span class="line">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure><p>pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是pod update会更新所有的类库，获取最新版本的类库。每次用pod update就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Cocoapods&lt;/code&gt;是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。&lt;/p&gt;
&lt;p&gt;当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>九宫格常用的宏</title>
    <link href="https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/"/>
    <id>https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/</id>
    <published>2018-01-16T13:47:19.000Z</published>
    <updated>2018-09-12T13:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>常用九宫格定义的宏如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**************************无间距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_SUPERVIEW_AND_WIDTH(SUPERVIEW,WIDTH,COLUMN) SUPERVIEW.subviews.count % COLUMN * WIDTH</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_SUPERVIEW_AND_HEIGHT(SUPERVIEW,HEIGHT,COLUMN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT</span><br><span class="line"></span><br><span class="line">&#x2F;**************************有间距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度  int width &#x3D; (SCREEN_WIDTH - (colunm - 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的横向间距</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + SUPERVIEW.subviews.count % COLUMN  * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * HEIGHT    指九宫格每个小格子的高度</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的纵向间距</span><br><span class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT + SUPERVIEW.subviews.count &#x2F; COLUMN * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;**************************有间距、有边距****************************&#x2F;</span><br><span class="line">&#x2F;** 设置格子的X坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * WIDTH     指九宫格每个小格子的宽度 int width &#x3D; (SCREEN_WIDTH - (colunm + 1) * margin) &#x2F; colunm;</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的横向间距 和 外边距</span><br><span class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_X_WITH_EDGE_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + (SUPERVIEW.subviews.count % COLUMN + 1) * MARGIN</span><br><span class="line"></span><br><span class="line">&#x2F;** 设置格子的Y坐标</span><br><span class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</span><br><span class="line"> * HEIGHT    指九宫格每个小格子的高度</span><br><span class="line"> * COLUMN    指九宫格的纵向列数</span><br><span class="line"> * MARGIN    指格子之间的纵向间距 和 外边距</span><br><span class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define CELL_Y_WITH_EDGE_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count &#x2F; COLUMN * HEIGHT + (SUPERVIEW.subviews.count &#x2F; COLUMN + 1) * MARGIN</span><br></pre></td></tr></table></figure><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/SudokuDemo" target="_blank" rel="noopener">九宫格demo地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;常用九宫格定义的宏如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>谈谈 Autolayout</title>
    <link href="https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/"/>
    <id>https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/</id>
    <published>2017-12-18T14:16:11.000Z</published>
    <updated>2018-08-25T02:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unable to simultaneously satisfy constraints.</span><br><span class="line">Probably at least one of the constraints in the following list is one you don&#39;t want.</span><br><span class="line">Try this:</span><br><span class="line"></span><br><span class="line">(1) look at each constraint and try to figure out which you don&#39;t expect;</span><br><span class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</span><br><span class="line">(Note: If you&#39;re seeing NSAutoresizingMaskLayoutConstraints that you don&#39;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</span><br><span class="line">(...........)</span><br><span class="line"></span><br><span class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</span><br><span class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit&#x2F;UIView.h&gt; may also be helpful.</span><br></pre></td></tr></table></figure><p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p><p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p><ul><li>打开断点导航（cmd+7）</li><li>点击左下角的+按钮</li><li>选择Add Symbolic Breakpoint</li><li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p><p>所以交给你一个小技巧，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">po [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; OC项目</span><br><span class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; Swift项目</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这样就可以直接看到输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</span><br><span class="line">UIWindow:0x7f9481c93360</span><br><span class="line">|   •UIView:0x7f9481c9d680</span><br><span class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</span><br></pre></td></tr></table></figure><p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p><p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x7f9481c9d990</span><br><span class="line">&lt;UIView: 0x7f9481c9d990; frame &#x3D; (0 0; 768 359); autoresize &#x3D; RM+BM; layer &#x3D; &lt;CALayer: 0x7fc82d338960&gt;&gt;</span><br></pre></td></tr></table></figure><p>改变颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor &#x3D; [UIColor redColor]</span><br><span class="line">(UICachedDeviceRGBColor *) $4 &#x3D; 0x0000000174469cc0</span><br></pre></td></tr></table></figure><p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p><h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p><ul><li>layoutSubViews：</li></ul><p>当 <code>View</code> 及其所有子视图的 <code>frame</code> 发生改变的时候，会调用 <code>layoutSubviews</code>，所以在需要更新 frame 来重新定位或更改大小时重载它。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。注意：<strong>最好不要在代码中手动调用 <code>layoutSubviews</code> 方法</strong>。当 <code>layoutSubviews</code> 完成后，在 <code>view</code> 的所有者 <code>view controller</code> 上，会触发  <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 <code>view</code> 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。</p><p>触发 <code>layoutSubviews</code> 的时机：</p><ul><li><p><code>addSubview</code> 方法会触发 <code>layoutSubviews</code>。</p></li><li><p>当 <code>view</code> 的 <code>Frame</code> 发生变化也会触发<code>layoutSubviews</code>。</p></li><li><p>滚动一个 <code>UIScrollView</code> 会触发 <code>layoutSubviews</code>。</p></li><li><p>旋转屏幕会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p></li><li><p>改变一个 <code>View</code> 大小的时候也会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p></li><li><p>setNeedsLayout<br>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法，表示视图的布局需要重新计算。告知页面需要更新，但是不会立刻开始更新视图，视图会在下一个 <code>runloop</code> 中更新，调用 <code>setNeedsLaylout</code> 方法视图被重新绘制并布局之间会有一段任意时间的间隔。</p></li><li><p>layoutIfNeeded<br>调用 <code>layoutIfNeeded</code> 会触发 <code>layoutSubviews</code>，告知页面布局立刻更新，所以一般都会和 <code>setNeedsLayout</code> 一起使用。如果希望立刻生成新的 <code>frame</code> 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p></li><li><p>setNeedsUpdateConstraints<br>告知需要更新约束，但是不会立刻开始，在下一次 <code>runloop</code> 中更新约束，通过标记 <code>update constraints</code> 来触发 <code>updateConstraints</code>。</p></li><li><p>updateConstraintsIfNeeded<br>告知立刻更新约束，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 <code>update constraints</code> 标记。如果认为这些约束需要被更新，它会立即触发 <code>updateConstraints</code>，而不会等到 <code>run loop</code> 的末尾。</p></li><li><p>updateConstraints<br>系统更新约束，注意：<strong>最好不要在代码中手动调用 <code>updateConstraints</code> 方法</strong>。通常在 <code>updateConstraints</code> 方法中实现必须要更新的约束，在设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 <code>update constarints</code>，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。</p></li></ul><p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p><h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.bounds &#x3D; CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</span><br></pre></td></tr></table></figure><p>那么很可能拿到 layer 的宽度是0。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">[self.view addSubview:redView];</span><br><span class="line">self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 设置约束</span><br><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">  make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame &#x3D; (0 0; 0 0); layer &#x3D; &lt;CALayer: 0x6040002274a0&gt;&gt;</span><br></pre></td></tr></table></figure><p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p><p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x60000003c460&gt;&gt;</span><br></pre></td></tr></table></figure><p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">    [redView setNeedsLayout];</span><br><span class="line">    [redView layoutIfNeeded];</span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame &#x3D; (-75 -40; 150 80); layer &#x3D; &lt;CALayer: 0x6040004207a0&gt;&gt;</span><br></pre></td></tr></table></figure><p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x600000233540&gt;&gt;</span><br></pre></td></tr></table></figure><p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;关于Autolayout的调试&quot;&gt;&lt;a href=&quot;#关于Autolayout的调试&quot; class=&quot;headerlink&quot; title=&quot;关于Autolayout的调试&quot;&gt;&lt;/a&gt;关于Autolayout的调试&lt;/h4&gt;&lt;p&gt;刚开始使用 Autolayout 遇
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="noopener">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>持续的软件版本发布/测试项目。</li><li>监控外部调用执行的工作。</li></ul><p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins官网</a>下载Jenkins；</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>点击Download：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p><p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a></p><ul><li>在Safari浏览器上，会出现Safari不能连接到服务器。</li><li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li></ul><p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="noopener">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>可以通过下面两种方式获取初始化密码：</p><ul><li>打开terminal，执行cat命令即可(需要管理员权限)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat &#x2F;Users&#x2F;Shared&#x2F;Jenkins&#x2F;Home&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>输入用户名和密码之后，Jenkins就彻底安装好了。</p><p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p><h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&#x2F;Uninstall.command</span><br></pre></td></tr></table></figure><h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo launchctl unload &#x2F;Library&#x2F;LaunchDaemons&#x2F;org.jenkins-ci.plist    </span><br><span class="line">sudo rm !$    </span><br><span class="line">sudo rm -rf &#x2F;Applications&#x2F;Jenkins &quot;&#x2F;Library&#x2F;Application Support&#x2F;Jenkins&quot; &#x2F;Library&#x2F;Documentation&#x2F;Jenkins    </span><br><span class="line">sudo rm -rf &#x2F;Users&#x2F;Shared&#x2F;Jenkins    </span><br><span class="line"># if you want to get rid of all the jobs and builds:    </span><br><span class="line">sudo dscl . -delete &#x2F;Users&#x2F;jenkins    </span><br><span class="line"># delete the jenkins user and group (if you chose to use them):    </span><br><span class="line">sudo dscl . -delete &#x2F;Groups&#x2F;jenkins</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
