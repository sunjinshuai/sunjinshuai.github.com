<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS RunTime之二：数据结构 · 孙金帅的技术博客</title><meta name="description" content="iOS RunTime之二：数据结构 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS RunTime之二：数据结构</h1><div class="post-info">2022年5月17日</div><div class="post-content"><p><img src="94c23c27-7848-4abb-b0cd-e6c26f963e64.png" alt="Paste_Image.png"></p>
<p>通过这张图描述了<a href="https://github.com/iOS-Notes/iOS-Notes/tree/master/sourcecode/ObjectModel" target="_blank" rel="noopener">实例对象，类，元类之间的关系</a>；<br>图中实线是 <code>super_class</code> 指针，虚线是 <code>isa</code> 指针。<br>从图中看出：</p>
<ul>
<li>当发送一个实例方法的消息时，<code>isa</code> 指针会在这个类的实例方法列表中查找；</li>
<li>当发送一个类方法的消息时，<code>isa</code> 指针会在这个类的 <code>meta-class</code> 的方法列表中查找，<code>meta-class</code> 之所以重要，是因为它存储着一个类的所有类方法。</li>
<li>每个类都会有一个单独的 <code>meta-class</code>，因为每个类的类方法基本不可能完全相同。</li>
</ul>
<h4 id="NSObject"><a href="#NSObject" class="headerlink" title="NSObject"></a>NSObject</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>万物皆对象，通过源码分析，<code>NSObject</code> 里面包含一个 <code>objc_class</code> 结构体类型的 <code>isa</code> 指针；</p>
<h4 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h4><p><img src="%E5%9B%BE%E7%89%873.png" alt="Paste_Image.png"></p>
<p>通过源码分析：<br><code>objc_class</code> 里面包含一个 <code>objc_class</code> 结构体类型的 <code>superclass</code> 指针，可以通过 <code>superclass</code> 指针，查找到父类；<br><code>cache_t</code> 结构体的 <code>cache</code> 指针，<code>cache</code> 主要用于方法性能优化，对使用过的方法进行缓存，便于第二次查找；<br><code>class_data_bits_t</code> 结构体的 <code>bits</code> 指针，只含有一个 <code>64</code> 位的 <code>bits</code> 用于存储与类有关的信息；</p>
<p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 <code>rr/alloc</code> 的标志。</p>
<p>通过将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，返回 <code>class_rw_t *</code> 指针，其中 <code>Objc</code> 的类的属性、方法、以及遵循的协议都放在 <code>class_rw_t</code> 结构体中；</p>
<h4 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    struct bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct bucket_t *buckets();</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t occupied();</span><br><span class="line">    void incrementOccupied();</span><br><span class="line">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class="line">    void initializeToEmpty();</span><br><span class="line"></span><br><span class="line">    mask_t capacity();</span><br><span class="line">    bool isConstantEmptyCache();</span><br><span class="line">    bool canBeFreed();</span><br><span class="line"></span><br><span class="line">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class="line">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class="line"></span><br><span class="line">    void expand();</span><br><span class="line">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class="line">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class="line"></span><br><span class="line">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    inline cache_key_t key() const &#123; return _key; &#125;</span><br><span class="line">    inline IMP imp() const &#123; return (IMP)_imp; &#125;</span><br><span class="line">    inline void setKey(cache_key_t newKey) &#123; _key &#x3D; newKey; &#125;</span><br><span class="line">    inline void setImp(IMP newImp) &#123; _imp &#x3D; newImp; &#125;</span><br><span class="line"></span><br><span class="line">    void set(cache_key_t newKey, IMP newImp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>cache</code> 主要是为了优化方法调用的性能，一个接收者对象接收到一个消息时，它会根据 isa 指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是 <code>methodLists</code> 中遍历一遍，性能势必很差。这时，<code>cache</code> 就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到 <code>cache</code> 列表中，下次调用的时候就会优先去 <code>cache</code> 中查找，才去 <code>methodLists</code> 中查找方法。</p>
<p>从源码中可以看出，<br><code>_buckets</code> 指针是一个指向 <code>bucket_t</code> 结构体的哈希表，<code>_buckets</code> 哈希表里面包含多个 <code>bucket_t</code>，每个 <code>bucket_t</code> 里面存放着 <code>SEL</code> 和 <code>imp</code> 函数的内存地址的对应关系；<br><code>_mask</code> 是一个 <code>uint32_t</code> 的指针，表示整个 <code>_buckets</code> 哈希表的长度；<br><code>_occupied</code> 也是一个 <code>uint32_t</code> 的指针，在 <code>_buckets</code> 哈希表中已经缓存的方法数量；</p>
<p>在 <code>bucket_t</code> 结构体中，<code>_key</code> 是一个 <code>unsigned long</code> 的指针，其实是一个被 <code>hash</code> 化的一串数值，就是方法的 <code>sel</code>，也就是方法名；<code>_imp</code> 指针保持着对应的函数地址；</p>
<h6 id="cache-t-如何缓存-sel"><a href="#cache-t-如何缓存-sel" class="headerlink" title="cache_t 如何缓存 sel"></a>cache_t 如何缓存 sel</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">void cache_fill(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cache_fill_nolock(cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Never cache before +initialize is done</span><br><span class="line">    &#x2F;&#x2F; 系统要求在类初始化完成之前，不能进行方法返回，因此如果类没有完成初始化就 return</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span><br><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">    &#x2F;&#x2F; 因为有可能其他线程已经把该方法缓存起来，如果缓存中已经缓存过了，不用再缓存，直接 return</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache &#x3D; getCache(cls);</span><br><span class="line">    cache_key_t key &#x3D; getKey(sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span><br><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is too full. Expand it.</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span><br><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot because the </span><br><span class="line">    &#x2F;&#x2F; minimum size is 4 and we resized at 3&#x2F;4 full.</span><br><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    uint32_t oldCapacity &#x3D; capacity();</span><br><span class="line">    uint32_t newCapacity &#x3D; oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    if ((uint32_t)(mask_t)newCapacity !&#x3D; newCapacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; mask overflow - can&#39;t grow further</span><br><span class="line">        &#x2F;&#x2F; fixme this wastes one bit of mask</span><br><span class="line">        newCapacity &#x3D; oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    bool freeOld &#x3D; canBeFreed();</span><br><span class="line"></span><br><span class="line">    bucket_t *oldBuckets &#x3D; buckets();</span><br><span class="line">    bucket_t *newBuckets &#x3D; allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache&#39;s old contents are not propagated. </span><br><span class="line">    &#x2F;&#x2F; This is thought to save cache memory at the cost of extra cache fills.</span><br><span class="line">    &#x2F;&#x2F; fixme re-measure this</span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; 0);</span><br><span class="line">    assert((uintptr_t)(mask_t)(newCapacity-1) &#x3D;&#x3D; newCapacity-1);</span><br><span class="line"></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - 1);</span><br><span class="line">    </span><br><span class="line">    if (freeOld) &#123;</span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先看缓存中是否已经存在了该方法，如果已经存在，直接return掉；</li>
<li>如果缓存是只读的，则需要重新申请缓存空间；</li>
<li>如果存入缓存后的大小小于当前大小的 <code>3/4</code>，则当前缓存大小还可以使用，无需扩容；</li>
<li>如果缓存太满，需要扩容，扩容为原来大小的 <code>2</code> 倍，重新申请缓存空间；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 &#x3D; 2,</span><br><span class="line">    INIT_CACHE_SIZE      &#x3D; (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果是首次调用这个函数，会使用一个初始容量值 <code>INIT_CACHE_SIZE</code> 来设定缓存容量；从 <code>INIT_CACHE_SIZE</code> 的定义显示它的值是 <code>4</code>，也就是说苹果给 <code>cache_t</code> 设定的初始容量是 <code>4</code>。</li>
<li>重新设置哈希表的长度 <code>_mask = newCapacity-1</code>，然后将旧内存释放掉，清空缓存；</li>
<li>当通过 <code>find()</code> 方法返回的 <code>bucket-&gt;key() == 0</code>，就说明该位置上是空的，没有缓存过方法，因此可以进行插入操作 <code>bucket-&gt;set(key, imp)</code>，也就是将方法缓存到这个位置上。</li>
</ul>
<p><strong>注意：传入 <code>cls</code> 得到缓存列表，如果是 <code>instance</code> 对象，返回 <code>class</code> 对象；如果是 <code>class</code> 对象，返回 <code>meta-class</code> 对象；如果是 <code>meta-class</code> 对象，返回 <code>NSObject</code> 的 <code>meta-class</code> 对象；</strong></p>
<h6 id="cache-t-如何查找-sel"><a href="#cache-t-如何查找-sel" class="headerlink" title="cache_t 如何查找 sel"></a>cache_t 如何查找 sel</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(cache_key_t k, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(k !&#x3D; 0);</span><br><span class="line"></span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; mask();</span><br><span class="line">    &#x2F;&#x2F; 通过 cache_hash() 计算出 key 值 k 对应的 index 值 begin，用来记录查询起始索引；</span><br><span class="line">    mask_t begin &#x3D; cache_hash(k, m);</span><br><span class="line">    &#x2F;&#x2F; begin 赋值给 i，用于切换索引</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 用这个 i 从哈希表取值，如果取出来的 bucket_t 的 key &#x3D; k，则查询成功，返回该 bucket_t。</span><br><span class="line">        &#x2F;&#x2F; 如果 key &#x3D; 0，说明在索引 i 的位置上还没有缓存过方法，同样需要返回该 bucket_t，用于中止缓存查询。</span><br><span class="line">        if (b[i].key() &#x3D;&#x3D; 0  ||  b[i].key() &#x3D;&#x3D; k) &#123;</span><br><span class="line">            return &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while ((i &#x3D; cache_next(i, m)) !&#x3D; begin);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; hack</span><br><span class="line">    Class cls &#x3D; (Class)((uintptr_t)this - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return (i+1) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>cache_t</code> 如何查找 <code>sel</code>，本质上就是根据 <code>key</code> 如何查找 <code>index</code> 的过程；</strong><br>根据 <code>key</code> 计算出 <code>index</code> 值的这个算法称作哈希算法，尽可能减少不同的 <code>key</code> 得出相同 <code>index</code> 的情况出现，这种情况被称作哈希碰撞，同时还要保证得出的 <code>index</code> 值在合理的范围。<code>index</code> 越大，意味着对应的哈希表的长度越长，这是需要占用实际物理空间的，而内存是有限的。<br><strong>哈希表是一种通过牺牲一定空间，来换取时间效率的设计思想。</strong></p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a><strong>SEL</strong></h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在<code>Objc</code>中的表示类型（<code>Swift</code>中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的<code>id</code>，而这个<code>id</code>的数据结构是<code>SEL</code>，即表示一个方法的<code>selector</code>的指针。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f1c54b79137a3a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>方法的<code>selector</code>用于表示运行时方法的名字，<code>Objective-C</code>在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(<code>int</code>类型的地址)，这个标识就是<code>SEL</code>。</li>
<li>在<code>Objective-C</code>中，只要方法名相同，那么方法的<code>SEL</code>就是一样的，每一个方法都对应着一个<code>SEL</code>，所以在<code>Objective-C</code>中，同一个类中或者这个类的继承体系中，不能存在2个同名的方法，不同的类可以拥有相同的<code>selector</code>，不同的类的实例对象执行相同的<code>selector</code>，会在各自的方法列表中根据<code>selector</code>去寻找对应的<code>IMP</code>。</li>
<li>在本质上，<code>SEL</code>只是一个指向方法的指针（被<code>hash</code>化得<code>KEY</code>值），能提高方法的查询速度。</li>
</ul>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a><strong>IMP</strong></h4><p>IMP实际上是一个函数指针，指向方法实现的首地址。其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id (*IMP)(id, SEL, ...)</span><br></pre></td></tr></table></figure>
<p>第一个参数是指向 <code>self</code> 的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器( <code>selector</code> )，接下来是方法的实际参数列表。</p>
<p><code>SEL</code>就是为了查找方法的最终实现<code>IMP</code>的，由于每个方法对应唯一的<code>SEL</code>，因此我们可以通过<code>SEL</code>方便快速准确地获得它所对应的<code>IMP</code>。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a><strong>Method</strong></h4><p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c75430d85b645678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-382fc04a120fc065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意：</p>
<ul>
<li>方法名类型为<code>SEL</code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li>
<li>方法类型<code>method_types</code>是个<code>char</code>指针，其实存储着方法的参数类型和返回值类型。</li>
<li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针。</li>
</ul>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a><strong>Ivar</strong></h4><p><code>Ivar</code>是一种代表类中实例变量的类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-dcb54cf3c9cc43ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4f01a318d7041fb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>参考资料<br><a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/" target="_blank" rel="noopener">https://www.infoq.cn/article/deep-understanding-of-tagged-pointer/</a><br><a href="https://draveness.me/isa" target="_blank" rel="noopener">https://draveness.me/isa</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2022/05/15/iOS-superclass%E5%92%8Cisa-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2022/05/17/iOS-RunTime之二：数据结构/';
var disqus_title = 'iOS RunTime之二：数据结构';
var disqus_url = 'https://sunjinshuai.github.io/2022/05/17/iOS-RunTime之二：数据结构/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>