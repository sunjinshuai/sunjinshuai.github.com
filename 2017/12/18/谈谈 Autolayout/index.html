<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 谈谈 Autolayout · 孙金帅的技术博客</title><meta name="description" content="谈谈 Autolayout - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">谈谈 Autolayout</h1><div class="post-info">2017年12月18日</div><div class="post-content"><h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unable to simultaneously satisfy constraints.</span><br><span class="line">Probably at least one of the constraints in the following list is one you don&#39;t want.</span><br><span class="line">Try this:</span><br><span class="line"></span><br><span class="line">(1) look at each constraint and try to figure out which you don&#39;t expect;</span><br><span class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</span><br><span class="line">(Note: If you&#39;re seeing NSAutoresizingMaskLayoutConstraints that you don&#39;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</span><br><span class="line">(...........)</span><br><span class="line"></span><br><span class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</span><br><span class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit&#x2F;UIView.h&gt; may also be helpful.</span><br></pre></td></tr></table></figure>

<p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p>
<p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p>
<ul>
<li>打开断点导航（cmd+7）</li>
<li>点击左下角的+按钮</li>
<li>选择Add Symbolic Breakpoint</li>
<li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p>
<p>所以交给你一个小技巧，添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">po [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; OC项目</span><br><span class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] &#x2F;&#x2F; Swift项目</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样就可以直接看到输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</span><br><span class="line">UIWindow:0x7f9481c93360</span><br><span class="line">|   •UIView:0x7f9481c9d680</span><br><span class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</span><br><span class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</span><br></pre></td></tr></table></figure>

<p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p>
<p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po 0x7f9481c9d990</span><br><span class="line">&lt;UIView: 0x7f9481c9d990; frame &#x3D; (0 0; 768 359); autoresize &#x3D; RM+BM; layer &#x3D; &lt;CALayer: 0x7fc82d338960&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>改变颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor &#x3D; [UIColor redColor]</span><br><span class="line">(UICachedDeviceRGBColor *) $4 &#x3D; 0x0000000174469cc0</span><br></pre></td></tr></table></figure>
<p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p>
<h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p>
<ul>
<li>layoutSubViews：</li>
</ul>
<p>当 <code>View</code> 及其所有子视图的 <code>frame</code> 发生改变的时候，会调用 <code>layoutSubviews</code>，所以在需要更新 frame 来重新定位或更改大小时重载它。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。注意：<strong>最好不要在代码中手动调用 <code>layoutSubviews</code> 方法</strong>。当 <code>layoutSubviews</code> 完成后，在 <code>view</code> 的所有者 <code>view controller</code> 上，会触发  <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 <code>view</code> 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。</p>
<p>触发 <code>layoutSubviews</code> 的时机：</p>
<ul>
<li><p><code>addSubview</code> 方法会触发 <code>layoutSubviews</code>。</p>
</li>
<li><p>当 <code>view</code> 的 <code>Frame</code> 发生变化也会触发<code>layoutSubviews</code>。</p>
</li>
<li><p>滚动一个 <code>UIScrollView</code> 会触发 <code>layoutSubviews</code>。</p>
</li>
<li><p>旋转屏幕会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p>
</li>
<li><p>改变一个 <code>View</code> 大小的时候也会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p>
</li>
<li><p>setNeedsLayout<br>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法，表示视图的布局需要重新计算。告知页面需要更新，但是不会立刻开始更新视图，视图会在下一个 <code>runloop</code> 中更新，调用 <code>setNeedsLaylout</code> 方法视图被重新绘制并布局之间会有一段任意时间的间隔。</p>
</li>
<li><p>layoutIfNeeded<br>调用 <code>layoutIfNeeded</code> 会触发 <code>layoutSubviews</code>，告知页面布局立刻更新，所以一般都会和 <code>setNeedsLayout</code> 一起使用。如果希望立刻生成新的 <code>frame</code> 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p>
</li>
<li><p>setNeedsUpdateConstraints<br>告知需要更新约束，但是不会立刻开始，在下一次 <code>runloop</code> 中更新约束，通过标记 <code>update constraints</code> 来触发 <code>updateConstraints</code>。</p>
</li>
<li><p>updateConstraintsIfNeeded<br>告知立刻更新约束，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 <code>update constraints</code> 标记。如果认为这些约束需要被更新，它会立即触发 <code>updateConstraints</code>，而不会等到 <code>run loop</code> 的末尾。</p>
</li>
<li><p>updateConstraints<br>系统更新约束，注意：<strong>最好不要在代码中手动调用 <code>updateConstraints</code> 方法</strong>。通常在 <code>updateConstraints</code> 方法中实现必须要更新的约束，在设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 <code>update constarints</code>，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。</p>
</li>
</ul>
<p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p>
<h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layer.bounds &#x3D; CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</span><br></pre></td></tr></table></figure>
<p>那么很可能拿到 layer 的宽度是0。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">[self.view addSubview:redView];</span><br><span class="line">self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 设置约束</span><br><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">  make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame &#x3D; (0 0; 0 0); layer &#x3D; &lt;CALayer: 0x6040002274a0&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p>
<p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">    [super viewDidLayoutSubviews];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x60000003c460&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">    [redView setNeedsLayout];</span><br><span class="line">    [redView layoutIfNeeded];</span><br><span class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame &#x3D; (-75 -40; 150 80); layer &#x3D; &lt;CALayer: 0x6040004207a0&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)testLayout &#123;</span><br><span class="line">    </span><br><span class="line">    UIView *redView &#x3D; [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor &#x3D; [UIColor redColor];</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    self.redView &#x3D; redView;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 设置约束</span><br><span class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.centerX.equalTo(self.view.mas_centerX);</span><br><span class="line">        make.centerY.equalTo(self.view.mas_centerY);</span><br><span class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame &#x3D; (0 0; 414 736); autoresize &#x3D; W+H; layer &#x3D; &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame &#x3D; (132 328; 150 80); layer &#x3D; &lt;CALayer: 0x600000233540&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/" class="prev">上一篇</a><a href="/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2017/12/18/谈谈 Autolayout/';
var disqus_title = '谈谈 Autolayout';
var disqus_url = 'https://sunjinshuai.github.io/2017/12/18/谈谈 Autolayout/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>