<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS之+load和+initialize的区别 · 孙金帅的技术博客</title><meta name="description" content="iOS之+load和+initialize的区别 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunjinshuai" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS之+load和+initialize的区别</h1><div class="post-info">2016年8月16日</div><div class="post-content"><p>在<code>NSObject</code>类中有两个非常特殊的类方法<code>+load</code>和<code>+initialize</code>，用于类的初始化:</p>
<h4 id="load方法调用顺序"><a href="#load方法调用顺序" class="headerlink" title="+load方法调用顺序"></a><code>+load</code>方法调用顺序</h4><p><code>+load</code>方法是当类或者分类被加载和初始化的时候时调用，下面通过一个demo验证一下<code>+load</code>方法的调用顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">@interface Parent : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Parent</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Child : Parent</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Child</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Other : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Other</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Parent (Load)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Parent (Load)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Child (Load)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Child (Load)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line"></div><div class="line">    Child *child = [[Child alloc] init];</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,child);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c5ee70ecd1f7a621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 运行结果：</div><div class="line">2016-08-16 17:52:53.336 MYUtils[2897:117680] Other , +[Other load]</div><div class="line">2016-08-16 17:52:53.339 MYUtils[2897:117680] Parent , +[Parent load]</div><div class="line">2016-08-16 17:52:53.340 MYUtils[2897:117680] Child , +[Child load]</div><div class="line">2016-08-16 17:52:53.351 MYUtils[2897:117680] Parent , +[Parent(Load) load]</div><div class="line">2016-08-16 17:52:53.352 MYUtils[2897:117680] Child , +[Child(Load) load]</div><div class="line">2016-08-16 17:52:53.357 MYUtils[2897:117680] &lt;Child: 0x600000019a40&gt;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-d319205f5dcb50dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 运行结果：</div><div class="line">2016-08-16 18:04:30.321 MYUtils[3186:131187] Parent , +[Parent load]</div><div class="line">2016-08-16 18:04:30.323 MYUtils[3186:131187] Other , +[Other load]</div><div class="line">2016-08-16 18:04:30.324 MYUtils[3186:131187] Child , +[Child load]</div><div class="line">2016-08-16 18:04:30.324 MYUtils[3186:131187] Parent , +[Parent(Load) load]</div><div class="line">2016-08-16 18:04:30.324 MYUtils[3186:131187] Child , +[Child(Load) load]</div><div class="line">2016-08-16 18:04:30.324 MYUtils[3186:131187] &lt;Child: 0x6080000106c0&gt;</div></pre></td></tr></table></figure>
<p>从上面的运行结果可以看出，子类的<code>+load</code>方法会在它的所有父类的<code>+load</code>方法之后执行，而分类的<code>+load</code>方法会在它的主类的<code>+load</code>方法之后执行，但是不同的类之间的<code>+load</code>方法的调用顺序是不确定的，在<code>Compile Sources</code>中，文件的引入的先后顺序决定不同的类之间的<code>+load</code>方法的调用顺序。</p>
<p>注意：<br><code>+load</code>方法调用时，如果调用别的类的方法，且该方法依赖于那个类的load方法进行初始化设置，那么必须确保那个类的<code>+load</code>方法已经调用了，比如在<code>Other</code>类中调用<code>Child</code>类里面的方法，则打印出的字符串就为null。</p>
<h4 id="load原理"><a href="#load原理" class="headerlink" title="+load原理"></a><code>+load</code>原理</h4><p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">+load加载原理</a></p>
<h4 id="load黑魔法"><a href="#load黑魔法" class="headerlink" title="+load黑魔法"></a><code>+load</code>黑魔法</h4><p>子类、父类和分类中的<code>+load</code>方法的实现是被区别对待的，也就是说如果子类没有实现<code>+load</code>方法，那么当它被加载和初始化的时候是不会去调用父类的<code>+load</code>方法的。同理，当一个类和它的分类都实现了<code>+load</code>方法时，两个方法都会被调用。</p>
<p>我们常常利用<code>+load</code>方法这一特性，做一些黑魔法，比如<code>Method Swizzle</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@interface Child (Load)</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Child (Load)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    Method originalFunc = class_getInstanceMethod([self class], @selector(originalFunc));</div><div class="line">    Method swizzledFunc = class_getInstanceMethod([self class], @selector(swizzledFunc));</div><div class="line"></div><div class="line">    method_exchangeImplementations(originalFunc, swizzledFunc);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="initialize方法调用顺序"><a href="#initialize方法调用顺序" class="headerlink" title="+initialize方法调用顺序"></a><code>+initialize</code>方法调用顺序</h4><p><code>+initialize</code>是在类或者其子类的第一个方法被调用前调用，这里第一个方法包括实例方法和类方法的调用。也就是说<code>+initialize</code>方法是以懒加载的方式被调用的。如果类文件被引用进来，但是没有使用，那么<code>+initialize</code>不会被调用，这一点有利于节约资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@interface Parent : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Parent</div><div class="line"></div><div class="line">+ (void)initialize &#123;</div><div class="line">    if (self == [Parent class]) &#123;</div><div class="line">        NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface Child : Parent</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Child</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line"></div><div class="line">    Child *child = [[Child alloc] init];</div><div class="line"></div><div class="line">    NSLog(@&quot;%@&quot;,child);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 运行结果：</div><div class="line">2016-08-16 18:43:13.567 MYUtils[3471:175092] Child , +[Parent initialize]</div><div class="line">2016-08-16 18:43:13.571 MYUtils[3471:175092] Child , +[Parent initialize]</div><div class="line">2016-08-16 18:43:13.574 MYUtils[3471:175092] &lt;Child: 0x60000001d170&gt;</div></pre></td></tr></table></figure>
<p>通过运行结果发现，父类的<code>+initialize</code>方法竟然调用了两次：<br>这是因为在创建子类对象时，首先要创建父类对象，所以会调用一次父类的<code>+initialize</code>方法，然后创建子类时，尽管自己没有实现<code>+initialize</code>方法，但还是会调用到父类的方法。</p>
<p>虽然<code>+initialize</code>方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求，所以在父类中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface Parent : NSObject</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Parent</div><div class="line"></div><div class="line">+ (void)initialize &#123;</div><div class="line">    if (self == [Parent class]) &#123;</div><div class="line">        NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>加上判断后，就不会因为子类而调用到自己的<code>+initialize</code>方法了。</p>
<h4 id="initialize原理"><a href="#initialize原理" class="headerlink" title="+initialize原理"></a><code>+initialize</code>原理</h4><p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">+initialize加载原理</a></p>
<h4 id="initialize黑魔法"><a href="#initialize黑魔法" class="headerlink" title="+initialize黑魔法"></a><code>+initialize</code>黑魔法</h4><p><code>+initialize</code>方法一般用于初始化全局变量或静态变量。</p>
<h4 id="initialize和-load区别"><a href="#initialize和-load区别" class="headerlink" title="+initialize和+load区别"></a><code>+initialize</code>和<code>+load</code>区别</h4><blockquote>
<p>+(void)initialize<br>The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.</p>
<p>+(void)load<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>The order of initialization is as follows:<br>  1、All initializers in any framework you link to.<br>  2、All +load methods in your image.<br>  3、All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.<br>  4、All initializers in frameworks that link to you.<br>In addition:<br>  1、A class’s +load method is called after all of its superclasses’ +load methods.<br>  2、A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>
</blockquote>
<p>苹果的官方文档很清楚地说明了<code>+initialize</code>和<code>+load</code>的区别在于：</p>
<p>不同点在于：</p>
<ul>
<li><code>+load</code>是只要类所在文件被引用就会被调用，而<code>+initialize</code>是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用到项目中，就不会有<code>+load</code>调用；但即使类文件被引用进来，但是没有使用，那么<code>+initialize</code>也不会被调用。</li>
<li><code>+load</code>方法通常用来进行<code>Method Swizzle</code>，<code>+initialize</code>方法一般用于初始化全局变量或静态变量。</li>
</ul>
<p>相同点在于：</p>
<ul>
<li>方法只会被调用一次。</li>
<li><code>+load</code>和<code>+initialize</code>方法内部使用了锁，因此它们是线程安全的。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/10/06/AutoreleasePool的实现原理/" class="prev">上一篇</a><a href="/2016/08/08/CocoaPods的安装与使用/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/08/16/iOS之-load和-initialize的区别/';
var disqus_title = 'iOS之+load和+initialize的区别';
var disqus_url = 'https://sunjinshuai.github.io/2016/08/16/iOS之-load和-initialize的区别/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>