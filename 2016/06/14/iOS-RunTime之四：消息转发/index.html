<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS RunTime之四：消息转发 · 孙金帅的技术博客</title><meta name="description" content="iOS RunTime之四：消息转发 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS RunTime之四：消息转发</h1><div class="post-info">2016年6月14日</div><div class="post-content"><h3 id="消息转发三部曲："><a href="#消息转发三部曲：" class="headerlink" title="消息转发三部曲："></a>消息转发三部曲：</h3><p>接上面<a href="https://www.jianshu.com/p/8cd06cd496d5" target="_blank" rel="noopener">消息发送</a>，如果当前类和父类中都没有找到实现，那么就会开始尝试动态方法解析。</p>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;6.IMP没有找到，尝试方法解析一次</span><br><span class="line">&#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    _class_resolveMethod(cls, sel, inst);</span><br><span class="line">    runtimeLock.read();</span><br><span class="line">    &#x2F;&#x2F; Don&#39;t cache the result; we don&#39;t hold the lock so it may have </span><br><span class="line">    &#x2F;&#x2F; changed already. Re-do the search from scratch instead.</span><br><span class="line">    triedResolver &#x3D; YES;</span><br><span class="line">    goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行了 <code>_class_resolveMethod:</code> 之后，会跳转到 <code>retry</code> 标签，重新执行查找方法实现的流程，只不过不会再调用 <code>_class_resolveMethod:</code> 方法了，因为通过 <code>triedResolver</code> 来判断是否进行该类是否进行过动态方法解析。如果首次走到这里，<code>triedResolver = NO</code>，当动态方法解析进行过一次之后，会设置 <code>triedResolver = YES</code>，这样下次走到这里的时候，就不会再次进行动态方法解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   void _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">   &#123;</span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; try [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]</span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        if (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_class_resolveMethod</code> 这个函数首先判断是否是 <code>meta-class</code> 类，如果不是元类，就执行 <code>_class_resolveInstanceMethod</code>，如果是元类，执行 <code>_class_resolveClassMethod</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">static void _class_resolveInstanceMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveInstanceMethod adds to self a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void _class_resolveClassMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;)) </span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(_class_getNonMetaClass(cls, inst), </span><br><span class="line">                        SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, NO&#x2F;*resolver*&#x2F;);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>_class_resolveInstanceMethod</code> 和 <code>_class_resolveClassMethod</code> 方法中，来查询是否已经在运行时将其动态插入类中的实现函数，如果没有重新调用 <code>lookUpImpOrNil</code> 并重新启动缓存，来判断是否已经添加上 <code>sel</code> 对应的 <code>IMP</code> 指针，并且重新触发 <code>objc_msgSend</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL _cmd, ...) &#123;</span><br><span class="line">  Class class &#x3D; object_getClass(self);</span><br><span class="line">  IMP imp &#x3D; class_getMethodImplementation(class, _cmd);</span><br><span class="line">  return imp ? imp(self, _cmd, ...) : 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要一提 <code>objc_msgSend</code>，都会说它的伪代码如下或类似的逻辑，反正就是获取 <code>IMP</code> 并调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMP class_getMethodImplementation(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line">    imp &#x3D; lookUpImpOrNil(cls, sel, nil, YES&#x2F;*initialize*&#x2F;, YES&#x2F;*cache*&#x2F;, YES&#x2F;*resolver*&#x2F;);</span><br><span class="line">    &#x2F;&#x2F; Translate forwarding function to C-callable external version</span><br><span class="line">    if (!imp) &#123;</span><br><span class="line">        return _objc_msgForward;</span><br><span class="line">    &#125;</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lookUpImpOrNil</code> 函数获取不到 <code>IMP</code> 时就返回 <code>_objc_msgForward</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, id inst, </span><br><span class="line">                   bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    if (imp &#x3D;&#x3D; _objc_msgForward_impcache) return nil;</span><br><span class="line">    else return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lookUpImpOrNil</code> 方法判断返回 <code>imp</code> 结果是否和 <code>_objc_msgForward_impcache</code> 相同，如果相同返回 <code>nil</code>，反之返回 <code>imp</code>。</p>
<p>回到 <code>lookUpImpOrForward</code> 方法中，如果也没有找到 <code>imp</code> 的实现，那么<code>method resolver</code> 也没用了，只能进入消息转发阶段。进入这个阶段之前，<code>imp</code>变成 <code>_objc_msgForward_impcache</code>，最后再加入缓存中。</p>
<p>当一个方法没有实现时，可以通过重写 <code>resolveInstanceMethod:</code> 和 <code>resolveClassMethod:</code> 方法，动态添加未实现的方法。其中第一个是添加实例方法，第二个是添加类方法。这两个方法都有一个 <code>BOOL</code> 返回值，返回 <code>NO</code> 则进入消息转发机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], sel, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="objc-msgForward"><a href="#objc-msgForward" class="headerlink" title="objc_msgForward"></a>objc_msgForward</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ENTRY __objc_msgForward_impcache</span><br><span class="line">&#x2F;&#x2F; Method cache version</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">&#x2F;&#x2F; Out-of-band condition register is NE for stret, EQ otherwise.</span><br><span class="line"></span><br><span class="line">MESSENGER_START</span><br><span class="line">nop</span><br><span class="line">MESSENGER_END_SLOW</span><br><span class="line"></span><br><span class="line">jne	__objc_msgForward_stret</span><br><span class="line">&#x2F;&#x2F;1.跳转到__objc_msgForward</span><br><span class="line">jmp	__objc_msgForward</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_impcache</span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward</span><br><span class="line">&#x2F;&#x2F; Non-stret version</span><br><span class="line">&#x2F;&#x2F;2.执行__objc_forward_handler</span><br><span class="line">movq	__objc_forward_handler(%rip), %r11</span><br><span class="line">jmp	*%r11</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ENTRY __objc_msgForward_stret</span><br><span class="line">&#x2F;&#x2F; Struct-return version</span><br><span class="line"></span><br><span class="line">movq	__objc_forward_stret_handler(%rip), %r11</span><br><span class="line">jmp	*%r11</span><br><span class="line"></span><br><span class="line">END_ENTRY __objc_msgForward_stret</span><br></pre></td></tr></table></figure>
<p>在执行 <code>_objc_msgForward</code> 之后会调用 <code>__objc_forward_handler</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noreturn)) void </span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span><br><span class="line">                &quot;(no message forward handler is installed)&quot;, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br><span class="line">void *_objc_forward_handler &#x3D; (void*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure>

<p>看源码实现当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：<code>unrecognized selector sent to instance</code>，然后接着会跳出一些堆栈信息，这些信息就是从这里而来。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>当动态方法解析不作处理返回 <code>NO</code> 时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行。<br>在消息转发机制执行前，<code>Runtime</code> 系统会再给我们一次偷梁换柱的机会，即通过重载 <code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法替换消息的接受者为其他对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if(aSelector &#x3D;&#x3D; @selector(mysteriousMethod:))&#123;</span><br><span class="line">        return alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>
<p>当 <code>forwardingTargetForSelector:</code> 方法未做出任何响应的话，会来到消息转发流程。消息转发时会首先调用 <code>methodSignatureForSelector:</code> 方法，在方法内部生成 <code>NSMethodSignature</code> 类型的方法签名对象。在生成签名对象时，可以指定 <code>target</code> 和 <code>SEL</code>，可以将这两个参数换成其他参数，将消息转发给其他对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[otherObject methodSignatureForSelector:otherSelector];</span><br></pre></td></tr></table></figure>
<p>生成 <code>NSMethodSignature</code> 签名对象后，就会调用 <code>forwardInvocation:</code> 方法，这是消息转发中最后一步了，如果在这步还没有对消息进行处理，则会导致崩溃。<br>该消息的唯一参数是个 <code>NSInvocation</code> 类型的对象，该对象封装了原始的消息和消息的参数。我们可以实现 <code>forwardInvocation:</code> 方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([object respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">        [anInvocation invokeWithTarget:object];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是参数 <code>anInvocation</code> 是从哪的来的呢？其实在 <code>forwardInvocation:</code> 消息发送前，<code>Runtime</code> 系统会向对象发送 <code>methodSignatureForSelector:</code> 消息，并取到返回的方法签名用于生成 <code>NSInvocation</code>对象。所以我们在重写 <code>forwardInvocation:</code> 的同时也要重写 <code>methodSignatureForSelector:</code> 方法，否则会抛异常。</p>
<p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 <code>forwardInvocation:</code> 消息通知该对象。每个对象都从 <code>NSObject</code> 类中继承了 <code>forwardInvocation:</code> 方法。然而，<code>NSObject</code> 中的方法实现只是简单地调用了 <code>doesNotRecognizeSelector:</code>。通过实现我们自己的 <code>forwardInvocation:</code> 方法，我们可以在该方法实现中将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code> 方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。</p>
<p><code>forwardInvocation:</code> 方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>注意：<br><code>forwardInvocation:</code> 方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将 <code>negotiate</code> 消息转发给其它对象，则这个对象不能有 <code>negotiate</code> 方法。否则，<code>forwardInvocation:</code> 将不可能会被调用。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9fb706d219d3b412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><img src="http://upload-images.jianshu.io/upload_images/588630-d0dcfa5deda2eb1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>1、动态解析<br>我们在<code>Car</code>类的<code>.m</code>文件里面，通过上面介绍<strong>动态解析</strong>可以知道，可以重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现。因为当<code>Runtime</code>系统在<code>Cache</code>和方法分发表中找不到要执行的方法时，<code>Runtime</code>会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-99c60c3aca2ed76e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>2、重定向<br>我们新建一个<code>Person</code>类，为了让运行时系统能够运行到<code>forwardingTargetForSelector:</code>方法，我们先在<code>resolveInstanceMethod:</code>中返回<code>NO</code>，代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8bd42146a3282f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4b2354c9f3aee51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从运行结果中看出，我们执行<code>[person fly]</code>方法，控制台中打出<code>Car</code>的<code>run</code>方法，最终也实现了消息的转发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">[person fly];</span><br></pre></td></tr></table></figure>

<p>3、转发<br>如果我们都不实现<code>forwardingTargetForSelector</code>，系统就会方法<code>methodSignatureForSelector</code>和<code>forwardInvocation</code>来实现转发，代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f758b33e20dff7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>从运行结果中看出，我们执行<code>[person fly]</code>方法，控制台中打出<code>Car</code>的<code>run</code>方法，最终也实现了消息的转发。</p>
<p>注意：</p>
<ul>
<li><code>methodSignatureForSelector</code>用来生成方法签名，这个签名就是给<code>forwardInvocation</code>中的参数<code>NSInvocation</code>调用的。</li>
<li><code>unrecognized selector sent to instance</code>，原来就是因为<code>methodSignatureForSelector</code>这个方法中，由于没有找到<code>fly</code>对应的实现方法，所以返回了一个空的方法签名，最终导致程序报错崩溃。</li>
</ul>
<p>以上就是消息的转发，如果有觉得上述我讲的不对的地方欢迎指出，大家多多交流沟通。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener" title="Objective-C 消息发送与转发机制原理">Objective-C 消息发送与转发机制原理</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/06/22/iOS-RunTime%E4%B9%8B%E5%85%AD%EF%BC%9ACategory/" class="prev">上一篇</a><a href="/2016/06/12/iOS-RunTime%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/06/14/iOS-RunTime之四：消息转发/';
var disqus_title = 'iOS RunTime之四：消息转发';
var disqus_url = 'https://sunjinshuai.github.io/2016/06/14/iOS-RunTime之四：消息转发/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>