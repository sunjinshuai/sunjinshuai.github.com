<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙金帅的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="测试">
<meta property="og:type" content="website">
<meta property="og:title" content="孙金帅的技术博客">
<meta property="og:url" content="https://sunjinshuai.github.io/index.html">
<meta property="og:site_name" content="孙金帅的技术博客">
<meta property="og:description" content="测试">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙金帅的技术博客">
<meta name="twitter:description" content="测试">
  
    <link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙金帅的技术博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://sunjinshuai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-AutoreleasePool的实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/06/AutoreleasePool的实现原理/" class="article-date">
  <time datetime="2016-10-06T06:32:16.000Z" itemprop="datePublished">2016-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/06/AutoreleasePool的实现原理/">AutoreleasePool的实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="面试题：autorelease对象什么时候释放。"><a href="#面试题：autorelease对象什么时候释放。" class="headerlink" title="面试题：autorelease对象什么时候释放。"></a>面试题：autorelease对象什么时候释放。</h4><p>autorelease的本质就是延迟调用<code>release</code>方法，在MRC的环境下，可以通过调用<code>[obj autorelease]</code>来延迟释放内存，在ARC的环境下，当我们创建一个对象，会将对象添加到当前的<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时，会对<code>autoreleasepool</code>里面的所有对象做一次<code>release</code>操作。在没有手动加入<code>autoreleasepool</code>的情况下，<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池<code>push</code>和<code>pop</code>。</p>
<p>当<code>autoreleasepool</code>销毁时，在调用堆栈中可以发现，系统调用了<code>-[NSAutoreleasePool release]</code>方法，这个方法最终通过调用<code>AutoreleasePoolPage::pop(void *)</code>函数来负责对<code>autoreleasepool</code>中的<code>autorelease</code>对象执行<code>release</code>操作。</p>
<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>我们打开<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a> 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到<code>autoreleasepool</code>的实现源码。其实，<code>autoreleasepool</code>是没有单独的内存结构的，它是通过以<code>AutoreleasePoolPage</code>为结点的双向链表来实现的。</p>
<ul>
<li>每一个线程的<code>autoreleasepool</code>其实就是一个指针的堆栈，结构中的thread指针指向当前线程；</li>
<li>每一个指针代表一个需要<code>release</code>的对象或者<code>POOL_SENTINEL</code>（哨兵对象，代表一个<code>autoreleasepool</code>的边界）；</li>
<li>一个<code>pool token</code>指向<code>autoreleasepool</code>所对应的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>；</li>
</ul>
<p>一个空的<code>AutoreleasePoolPage</code>的内存结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/588630-f64cda7c9112e5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><code>magic</code>用来校验<code>AutoreleasePoolPage</code>的结构是否完整；</li>
<li><code>next</code>指向最新添加的<code>autorelease</code>对象的下一个位置，初始化时指向 begin() ；</li>
<li><code>thread</code>指向当前线程；</li>
<li><code>parent</code>指向父结点，第一个结点的 parent 值为 nil ；</li>
<li><code>child</code>指向子结点，最后一个结点的 child 值为 nil ；</li>
<li><code>depth</code>代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code>代表 high water mark 。</li>
</ul>
<p>当<code>AutoreleasePoolPage</code>里面的<code>autorelease</code>对象满了，也就是next指针指向了栈顶，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>AutoreleasePoolPage</code>加入，新<code>AutoreleasePoolPage</code>的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。<br>另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。<br>所以，向一个对象发送<code>release</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶next指针指向的位置。</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a><code>autoreleasepool</code></h4><p>使用<code>clang -rewrite-objc</code>命令将下面的 Objective-C 代码重写成 C++ 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</div><div class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</div><div class="line"></div><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个<code>__AtAutoreleasePool</code>类型的局部变量<code>__autoreleasepool</code>来实现<code>@autoreleasepool {}</code>。当声明<code>__autoreleasepool</code>变量时，构造函数<code>__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p>当出了当前作用域时，析构函数<code>~__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure></p>
<p>也就是说<code>@autoreleasepool {}</code>的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line">    void *atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">    // 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</div><div class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code>、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a>objc_autoreleasePoolPush()</h4><p>上面提到的<code>objc_autoreleasePoolPush()</code>函数本质上就是调用的<code>AutoreleasePoolPage</code>的<code>push</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return nil;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据源码得出，每次执行<code>objc_autoreleasePoolPush</code>其实就是创建了一个新的<code>autoreleasepool</code>，对应<code>AutoreleasePoolPage</code>的具体实现就是往<code>AutoreleasePoolPage</code>中的<code>next</code>位置插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>的内存地址。并且把<code>pool token</code>指针指向这个地址，在执行<code>pop</code>操作的时候作为函数的入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline void *push()</div><div class="line">&#123;</div><div class="line">    id *dest = autoreleaseFast(POOL_SENTINEL);</div><div class="line">    assert(*dest == POOL_SENTINEL);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>push</code>函数通过调用<code>autoreleaseFast</code>函数来执行具体的插入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>autoreleaseFast</code>函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前<code>page</code>存在且没有满时，直接将对象添加到当前<code>page</code>中，即<code>next</code>指向的位置；</li>
<li>当前<code>page</code>存在且已满时，创建一个新的<code>page</code> ，并将对象添加到新创建的<code>page</code>中；</li>
<li>当前<code>page</code>不存在时，即还没有<code>page</code>时，创建第一个<code>page</code>，并将对象添加到新创建的<code>page</code>中。<br>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。</li>
</ul>
<h4 id="objc-autoreleasePoolPop-void"><a href="#objc-autoreleasePoolPop-void" class="headerlink" title="objc_autoreleasePoolPop(void *)"></a>objc_autoreleasePoolPop(void *)</h4><p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return;</div><div class="line"></div><div class="line">    // fixme rdar://9167170</div><div class="line">    if (!ctxt) return;</div><div class="line"></div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pop</code>函数的入参就是<code>push</code>函数的返回值，也就是<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>，直到<code>pool token</code>所在<code>page</code>的<code>next</code>指向<code>pool token</code>为止。</p>
<h4 id="autorelease对象释放原理"><a href="#autorelease对象释放原理" class="headerlink" title="autorelease对象释放原理"></a>autorelease对象释放原理</h4><p>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，在执行<code>objc_autoreleasePoolPop(void *)</code>操作的时候作为函数的入参。<br><img src="http://upload-images.jianshu.io/upload_images/588630-cf6a8a8bd44f721c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前<code>AutoreleasePoolPage</code>中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次<code>release</code>消息，并向回移动next指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个<code>AutoreleasePoolPage</code>，直到哨兵所在的<code>AutoreleasePoolPage</code>。</li>
</ul>
<p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数，当执行<code>pop</code>操作后，<br><img src="http://upload-images.jianshu.io/upload_images/588630-ee6388ccaec8b86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2016/10/06/AutoreleasePool的实现原理/" data-id="cj58z0pp00000jkfyaxaenm1g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Object-C编码规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/05/Object-C编码规范/" class="article-date">
  <time datetime="2015-05-05T09:24:55.000Z" itemprop="datePublished">2015-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/05/Object-C编码规范/">Object-C编码规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>1、任意函数长度不得超过50行。<br>2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。</p>
<p>3、在定义函数的行前留白一行。<br>4、功能相近的代码要放在一起。<br>5、使用#pragma来切分不同功能区域的代码。<br>6、二元运算符和参数之间需要放置一个空格，一元运算符、强制类型转换和参数之间不放置空格。关键字之后圆括号之前需要放置一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void *ptr = &amp;value + 10 * 3;</div><div class="line">NSString *str1 = (NSString *)str2;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">	[self doSomeThing];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7、长的字面值应被拆分为多行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSArray *theShit = @[</div><div class="line">    @&quot;Got some long string objects in here.&quot;,</div><div class="line">    [AndSomeModelObjects too],</div><div class="line">    @&quot;Moar strings.&quot;</div><div class="line">];</div><div class="line"></div><div class="line">NSDictionary *keyedShit = @&#123;</div><div class="line">    @&quot;this.key&quot;: @&quot;corresponds to this value&quot;,</div><div class="line">    @&quot;otherKey&quot;: @&quot;remoteData.payload&quot;,</div><div class="line">    @&quot;some&quot;: @&quot;more&quot;,</div><div class="line">    @&quot;JSON&quot;: @&quot;keys&quot;,</div><div class="line">    @&quot;and&quot;: @&quot;stuff&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名是编程中最基本的技能，我们给变量、函数、类、包等等命名。给他们以名字，让他们有意义，既能表示他们到底是做什么的，也能将其与其他变量区别开来。像人一样娶一个好名字至关重要，“丁当”总比“狗蛋”来的好听。 为什么要命名？ <strong>命名一定要“名副其实”，尽可能使用有意的名称，而且这个意义和指称的变量真实意义相关。</strong><br>1、基本原则<br>尽量不要出现没有任何意义的命名类似于下述形式的命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 1;</div><div class="line">int b = 3;</div><div class="line">CGPoint point = CGPointMake(a,b);</div></pre></td></tr></table></figure></p>
<p>如果换成下面的形式是不是可读性强了很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int startX = 1;</div><div class="line">int startY = 3;</div><div class="line">CGPoint startPoint = CGPointMake(startX,startY);</div></pre></td></tr></table></figure></p>
<p>命名首字母大写，其他命名首字母小写。并且采用驼峰格式分割单词。 例如：<code>FXTest</code><br>仿照 Cocoa 风格来，使用长命名风格。<br>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">extern ushort APIDefaultPageSize;        // 还行，能明白意思了</div><div class="line">extern ushort APIDefaultFetchPageSize;   // 加上些限定更好一些</div><div class="line">extern ushort APIFetchPageSizeDefault;   // 再好些，把重要的往前放</div><div class="line">FXToolbarComment    // 不推荐</div><div class="line">FXCommentToolbar    // OK，把类型（toolbar）置后</div></pre></td></tr></table></figure></p>
<p>2、类别的扩展名以“被扩展的类名+自定义命名部分组成” 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSSstring+Utils.h</div></pre></td></tr></table></figure></p>
<p>3、通知命名<br>基本命名格式是：<code>与通知相关的类名</code> + <code>Did | Will</code> + <code>UniquePartOfName</code> + <code>Notification</code>，例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSApplicationDidBecomeActiveNotification</div><div class="line">NSWindowDidMiniaturizeNotification</div><div class="line">NSTextViewDidChangeSelectionNotification</div><div class="line">NSColorPanelColorDidChangeNotification</div></pre></td></tr></table></figure></p>
<p>4、宏定义，全部字母大写，例如: <code>#define BW_DEBUG 1</code><br>5、常量定义，字符串定义以小写字母k开头，随后首字母大写，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static NSString* const kBWBarTitle = @&quot;动态&quot;;</div></pre></td></tr></table></figure></p>
<p>ps：如果要定义常量使用static const优于宏定义，前者会进行类型检查。<br>6、缩略词，以下是一些常用的首字母缩略词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ASCII,PDF,XML,HTML,URL,RTF,HTTP,TIFF,JPG,PNG,GIF,LZW,ROM,RGB,CMYK,MIDI,FTP</div></pre></td></tr></table></figure></p>
<p>7、命名空间，因为OC没有命名空间的概念，所以使用前两个或者多个字母来表示命名空间，例如<code>&quot;NSObject中的NS&quot;</code>，我们也使用自己的命名空间。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发现模块：DiscoverController，模块里面其他的控件或者model，DCModel，DCView</div><div class="line">个人中心模块：PersonalCenterViewController，模块里面其他的控件或者model，PCModel，PCView</div></pre></td></tr></table></figure></p>
<h4 id="点标记语法"><a href="#点标记语法" class="headerlink" title="点标记语法"></a>点标记语法</h4><p>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [UIColor orangeColor];</div><div class="line">[UIApplication sharedApplication].delegate;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[UIColor orangeColor]];</div><div class="line">UIApplication.sharedApplication.delegate;</div></pre></td></tr></table></figure></p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>1、方法命名尽可能清晰<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">insertObject:atIndex:</div><div class="line">removeObjectAtIndex:</div><div class="line">removeObject:</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insert:at:</div><div class="line">remove:</div></pre></td></tr></table></figure></p>
<p>2、类方法声明在方法类型与返回类型之间要有空格。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)methodName:(NSString *)string;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)methodName:(NSString *)string;</div></pre></td></tr></table></figure></p>
<p>3、函数<br>(1)、调用时所有参数应该在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</div></pre></td></tr></table></figure></p>
<p>(2)、或者每行一个参数，以冒号对齐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1</div><div class="line">                   name:arg2</div><div class="line">                   error:arg3];</div></pre></td></tr></table></figure></p>
<p>对于参数过多的函数，尽量使用后面一种对其方式。<br>(3)、不要使用下面的缩进风格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2  // some lines with &gt;1 arg</div><div class="line">              error:arg3];</div><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2 error:arg3];</div><div class="line">[myObject doFooWith:arg1</div><div class="line">          name:arg2  // aligning keywords instead of colons</div><div class="line">          error:arg3];</div></pre></td></tr></table></figure></p>
<p>(4)、如果对传入参数进行数据保护尽量不要用<code>if(!objc)</code>，使用断言来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)sendArgs:(NSDictionary*)args &#123;</div><div class="line">	NSAssert(args, @&quot;args is nil&quot;);</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(5)、方法参数名前一般使用的前缀包括“the”、“an”、“new”。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setTitle:(NSString *)aTitle;</div><div class="line">- (void)setName:(NSString *)newName;</div><div class="line">- (id)keyForOption:(CDCOption *)anOption</div><div class="line">- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;</div><div class="line">- (CDCEmail *)emailForRecipients: (NSArray *)theRecipients;</div></pre></td></tr></table></figure></p>
<p>4、方法名<br>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。<br>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。</p>
<ul>
<li><code>set</code> 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li>
<li><code>get</code> 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。<br>例：<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name;</div><div class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</div><div class="line">- (NSSize)cellSize;</div><div class="line">- (void)setupControllerObservers;</div><div class="line">- (void)setupController;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)getName;</div><div class="line">- (NSSize)calcCellSize;</div><div class="line">- (void)setController;</div></pre></td></tr></table></figure></p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>长的三元运算符应使用圆括号括起来。三元运算符仅用于赋值和做参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *gender = (stuff == thing ? @&quot;男&quot; : @&quot;女&quot;);</div></pre></td></tr></table></figure></p>
<p>当有nil时的三元运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *name = thingThatCouldBeNil ? defaultValue : @&quot;&quot;;</div></pre></td></tr></table></figure></p>
<p>不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *name = thingThatCouldBeNil ?: defaultValue;</div></pre></td></tr></table></figure></p>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>当使用<code>enum</code>关键字时，推荐使用苹果最新引入的固定基础类型语法，因为这将获得强类型检查与代码完成功能。SDK现在包含了一个固定基础类型的宏—<code>NS_ENUM()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, CertifiedModifyPassWordType)</div><div class="line">&#123;</div><div class="line">    CertifiedModifyPassWordTypeWithdrawals = 1,  // 提现</div><div class="line">    CertifiedModifyPassWordTypePaymentFail,  // 支付失败</div><div class="line">    CertifiedModifyPassWordTypePayment, // 支付</div><div class="line">    CertifiedModifyPassWordTypeOther</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>因为nil被解析为了NO，所以和nil作比较没有任何的必要。不要将变量和YES直接比较，因为YES被定义为1而BOOL类型是8位的unsigned int，即BOOL的值不仅仅是1或0。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (!someObject) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (someObject == nil) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (isAwesome)</div><div class="line">if (![someObject boolValue])</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if ([someObject boolValue] == NO)</div><div class="line">if (isAwesome == YES) // Never do this.</div></pre></td></tr></table></figure></p>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>应该使用线程安全的模式创建共享的单例实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">   static id sharedInstance = nil;</div><div class="line">   static dispatch_once_t onceToken;</div><div class="line">   dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      sharedInstance = [[self alloc] init];</div><div class="line">   &#125;);</div><div class="line">   return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单例的另一种做法，利用+ initialize方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static JSONAPI* sharedInstance = nil;</div><div class="line">+ (void)initialize &#123;</div><div class="line">    static dispatch_once_t once;</div><div class="line">    dispatch_once(&amp;once, ^&#123;</div><div class="line">        sharedInstance = [[JSONAPI alloc] init];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Block相关"><a href="#Block相关" class="headerlink" title="Block相关"></a>Block相关</h4><p>在block中使用到self变量的时候，一定要先weak再strong。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">[self doABlockOperation:^&#123;</div><div class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4><p>代理协议名，常用delegate、dateSource做结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</div><div class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</div></pre></td></tr></table></figure></p>
<p>以<code>did</code>、<code>will</code>、<code>should</code>等形容词，代表Event事件的Delegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)windowShouldClose:(id)sender;</div><div class="line">- (void)browserDidScroll:(NSBrowser *)sender;</div><div class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;</div></pre></td></tr></table></figure></p>
<h4 id="控制结构，if-else"><a href="#控制结构，if-else" class="headerlink" title="控制结构，if-else"></a>控制结构，if-else</h4><p>1、方法的花括号推荐另起一行。方法内部需要写在一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)methodName:(NSString *)string &#123;</div><div class="line">    if () &#123;</div><div class="line">    &#125; else &#123;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、条件判断的括号内侧不应有空格。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (a &lt; b) &#123;</div><div class="line">    // something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( a &lt; b ) &#123;</div><div class="line">    // something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、关系运算符（如<code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如<code>&amp;&amp;</code>、<code>||</code>）两边要有空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(someValue &gt; 100) ? YES : NO</div></pre></td></tr></table></figure></p>
<p>二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。<br>多个参数逗号后留一个空格（这也符合正常的西文语法）。<br>4、当需要满足一定条件时才执行某项操作时，使用return是正常合理的。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if (![someOther boolValue]) &#123;</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line">  //Do something important</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!error) &#123;</div><div class="line">    return success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if ([someOther boolValue]) &#123;</div><div class="line">      //Do something important</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!error)</div><div class="line">    return success;</div><div class="line">...</div><div class="line">if (!error) return success;</div></pre></td></tr></table></figure></p>
<h4 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h4><p>UIView的子类初始化的时候，不要进行任何布局操作。布局操作在LayoutSubViews里面做。<br>UIView的子类布局必须在layoutSubViews里面进行，需要布局的时候调用setNeedLayout来告诉系统，需要重新布局该View，不要直接调用layoutSubViews。</p>
<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4><p>在类定义中使用到自己定义的类的时候，尽量不要在头文件中引入自己定义的类的同文件，使用@class替换。在实现文件中引入相应头文件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// BWTest.h</div><div class="line">@class BWDataCenter;</div><div class="line">@interface BWTest : NSObject</div><div class="line">@property (nonatomic, strong) BWDataCenter* dataCenter;</div><div class="line">@end</div><div class="line"></div><div class="line">// BWTest.m</div><div class="line">#import &quot;BWDataCenter.h&quot;</div><div class="line">@implementation BWTest</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h4 id="项目工程文件"><a href="#项目工程文件" class="headerlink" title="项目工程文件"></a>项目工程文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#pragma mark - init Method</div><div class="line">填入init,initWithFrame等方法</div><div class="line">#pragma mark- View Life Cycle</div><div class="line">填入viewdidload,viewdidappear等方法</div><div class="line">#pragma mark- Delegate，DataSource, Callback Method</div><div class="line">填入tableview，scrollview等代理方法</div><div class="line">#pragma mark- Override Parent Methods</div><div class="line">填入updateViewConstraints,updateConstraint, prepareForSegue等方法</div><div class="line">#pragma mark- SubViews Configuration</div><div class="line">填入configureSubViews，configureTableView等方法，这里的方法在init方法或view life cycle被调用</div><div class="line">#pragma mark- Actions</div><div class="line">填入-(IBAction)action:(id)sender和[self addtarget:self action:@selector(action:)]动作指向的方法</div><div class="line">#pragma mark- Public Methods</div><div class="line">填入在.h外暴露的方法</div><div class="line">#pragma mark- Private Methods</div><div class="line">填入.m文件内部调用的方法</div><div class="line">#pragma mark- Getter Setter</div><div class="line">填入对@property初始化的方法</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2015/05/05/Object-C编码规范/" data-id="cj58z0pp60002jkfyomx8m04w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-block系列之block的实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/10/block系列之block的实现原理/" class="article-date">
  <time datetime="2014-07-10T15:07:10.000Z" itemprop="datePublished">2014-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/10/block系列之block的实现原理/">block系列之block的实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通过下面几个例子，探讨block是如何实现的：</p>
<h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  void (^blk)(void) = ^&#123;</div><div class="line">    printf(&quot;Hello, World!\n&quot;);</div><div class="line">  &#125;;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了研究编译器是如何实现 <code>block</code> 的，我们需要使用 <code>clang</code>。<code>clang</code> 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 <code>block</code> 具体的源码实现方式。该命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc block.c</div></pre></td></tr></table></figure>
<p>转化之后，生成block.app：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>block</code>在<code>clang</code>编译器编译之后，生成了一个<code>__block_impl</code>结构体，<code>isa</code>指针表明了<code>block</code>可以是一个对象，而<code>FuncPtr</code>指针显然是<code>block</code>对应的函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  printf(&quot;Hello, World!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们就具体看一下是如何实现的，<code>__main_block_impl_0</code> 就是该 <code>block</code> 的实现，从中我们可以看出：</p>
<ul>
<li><code>__main_block_impl_0</code>中包含了两个成员变量和一个构造函数，成员变量分别是<code>__block_impl</code>结构体和描述信息<code>__main_block_desc_0</code>，之后在构造函数中初始化<code>block</code>的类型信息和函数指针等信息。</li>
<li><code>__main_block_func_0</code>函数，即<code>block</code>对应的函数体。该函数接受一个<code>__cself</code>参数，即对应的<code>block</code>自身。</li>
<li><code>__main_block_desc_0</code>结构体，其中<code>Block_size</code>存储<code>block</code>大小。<br>从上面代码，可以看出执行block就是调用一个以block自身作为参数的函数，这个函数对应着block的执行体。</li>
</ul>
<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><p>block如何捕获变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  int i = 1024;</div><div class="line">  void (^blk)(void) = ^&#123;</div><div class="line">    printf(&quot;%d&quot;,i);</div><div class="line">  &#125;;</div><div class="line">  blk();</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int i;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int i = __cself-&gt;i; // bound by copy</div><div class="line">  printf(&quot;%d&quot;,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i = 1024;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出这次的<code>block</code>结构体<code>__main_block_impl_0</code>多了个成员变量<code>i</code>，用来存储使用到的局部变量<code>i</code>。当在 <code>block</code> 中引用的变量<code>i</code>的时候，实际是在声明 <code>block</code> 时，被<code>copy</code>到<code>__main_block_impl_0</code>结构体中的那个成员变量<code>i</code>，并且把<code>__cself</code>指针指向成员变量<code>i</code>。</p>
<p>如果尝试修改局部变量，编译会报错：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-121cf0b90c682d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p><strong>错误原因告诉我们变量不可赋值，也提醒我们要使用__block类型标识符。</strong><br>因为<code>main</code>函数中的局部变量<code>i</code>和函数<code>__main_block_func_0</code>不在同一个作用域中，调用过程中只是进行了值传递。当然，在上面代码中，我们可以通过指针来实现局部变量的修改。不过这是由于在调用<code>__main_block_func_0</code>时，<code>main</code>函数栈还没展开完成，变量<code>i</code>还在栈中。但是在很多情况下，<code>block</code>是作为参数传递以供后续回调执行的。通常在这些情况下，<code>block</code>被执行时，定义时所在的函数栈已经被展开，局部变量已经不在栈中了已经被销毁了，再用指针访问就会报常见的<strong>坏内存访问</strong>。</p>
<h4 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h4><p><code>__block</code>类型变量是如何支持修改。<br>int类型变量加上<code>__block</code>指示符，使得变量i可以在block函数体中被修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __block int i = 1024;</div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        i = 1023;</div><div class="line">        printf(&quot;%d&quot;,i);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line">  (i-&gt;__forwarding-&gt;i) = 1023;</div><div class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出，多出了一个<code>__Block_byref_i_0</code> 的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>__isa</code>指针也可以知道<code>__Block_byref_i_0</code>也可以是对象。</li>
<li><code>__forwarding</code>指针指向<code>__Block_byref_i_0</code></li>
<li>成员变量<code>i</code>，用来存储使用到的局部变量<code>i</code>。</li>
</ul>
<p><code>__main_block_impl_0</code>对应的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line">  (i-&gt;__forwarding-&gt;i) = 1023;</div><div class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>__main_block_impl_0</code>的成员变量<code>i</code>变成了<code>__Block_byref_i_0*</code>指针类型。</li>
<li><code>__Block_byref_i_0</code>指针类型变量<code>i</code>，通过其成员变量<code>__forwarding</code>指针来操作另一个成员变量。</li>
</ul>
<p>注意：<br><code>__Block_byref_i_0</code>类型变量i仍然处于栈上，当block被回调执行时，变量i所在的栈已经被展开。<br>查看<code>__main_block_desc_0</code>结构体，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div></pre></td></tr></table></figure>
<p>此时，<code>__main_block_desc_0</code>多了两个成员函数：<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p>
<p>当<code>block</code>从栈上被<code>copy</code>到堆上时，会调用<code>__main_block_copy_0</code>将<code>__block</code>类型的成员变量i从栈上复制到堆上；而当<code>block</code>被释放时，相应地会调用<code>__main_block_dispose_0</code>来释放<code>__block</code>类型的成员变量i。如果栈上和堆上同时对该变量进行操作，<code>__forwarding</code>的作用就体现出来了，当一个<code>__block</code>变量从栈上被复制到堆上时，栈上的那个<code>__Block_byref_i_0</code>结构体中的<code>__forwarding</code>指针也会指向堆上的结构。</p>
<p>References：<br><a href="http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="external">iOS中block实现的探究</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2014/07/10/block系列之block的实现原理/" data-id="cj58z0pp80004jkfy2kdcus12" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-block系列之block的存储域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/07/block系列之block的存储域/" class="article-date">
  <time datetime="2014-07-07T13:03:50.000Z" itemprop="datePublished">2014-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/07/block系列之block的存储域/">block系列之block的存储域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在 Objective-C 语言中，根据Block对象创建时所处数据区不同而进行区别，一共有 3 种类型的 block：</p>
<ul>
<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量，它是设置在程序的数据区域（.data区）中。</li>
<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁，超出变量作用域，栈上的Block以及  __block变量都被销毁。</li>
<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁，在变量作用域结束时不受影响。</li>
</ul>
<p>在ARC的环境下，block默认是从栈区copy到堆区。<br>栈上的block，如果其所属的变量作用域结束，该block就被废弃，如同一般的自动变量。当然，block中的__block变量也同时被废弃。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ef4fee05adf7961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p>在ARC的环境下，为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们需要把block复制到堆中，延长其生命周期。大多数情况下编译器会恰当地进行判断是否有需要将block从栈复制到堆，如果有，自动生成将block从栈上复制到堆上的代码。block的复制操作执行的是copy实例方法。Block只要调用了copy方法，栈块就会变成堆块。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f9ba1bdcc5db00f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2014/07/07/block系列之block的存储域/" data-id="cj58z0ppc0007jkfymjp6xrfs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-block系列之避免循环引用-weak与-strong的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/06/block系列之避免循环引用-weak与-strong的区别/" class="article-date">
  <time datetime="2014-07-06T08:04:47.000Z" itemprop="datePublished">2014-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/06/block系列之避免循环引用-weak与-strong的区别/">block系列之避免循环引用__weak与__strong的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>抛砖引玉：<br>我们一般都会遇到这样的问题，当A对象里面强引用了B对象，B对象又强引用了A对象，这样两者的retainCount值一直都无法为0。无论是A对象还是B对象销毁，A对象和B对象始终存在在内存无法中释放，从而导致内存泄露。</p>
<p>所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p>
<p>首先，先看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  [weakSelf doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在OC中，block是一个很实用的语法，特别是与GCD结合使用，可以很方便的实现多线程的并发。但是，如果使用不当，block也会引起一些循环引用的问题。</p>
<p><strong>__weak的出现就是为了解决在使用block时出现的循环引用问题。</strong>在使用block的时候，由于self是被强引用的，在ARC下，编译器自动将代码中的block从栈拷贝到堆时，block会强引用和持有self，而self恰好也强引用和持有了block，就造成了传说中的循环引用。在上面的代码中，在doSomething方法内，weakSelf不会被释放。<br>但是，像下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  [weakSelf doSomething];</div><div class="line">  [weakSelf doOtherThing];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在doSomething中，weakSelf不会变成nil，不过在doSomething执行完成，调用第二个方法doOtherThing的时候，weakSelf有可能被释放。</p>
<p><strong>__strong的出现为了保证在block内不会被释放。</strong>__strong表示强引用，当对象没有任何一个强引用指向它时，它才会被释放。weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  __strong __typeof(self) strongSelf = weakSelf;</div><div class="line">  [strongSelf doSomething];</div><div class="line">  [strongSelf doOtherThing];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 block 之前定义对 self 的一个弱引用 wself，因为是弱引用，所以当 self 被释放时 wself 会变为 nil；然后在 block 中引用该弱应用，<strong>考虑到多线程情况</strong>,通过使用强引用 self 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放；然后在之后的 block 块中使用该强引用 self，注意在使用前要对 self 进行了 nil 检测，因为多线程环境下在用弱引用 wself 对强引用 sself 赋值时，弱引用 wself 可能已经为 nil 了。<br>通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2014/07/06/block系列之避免循环引用-weak与-strong的区别/" data-id="cj58z0ppb0006jkfypxfb3p3k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-block系列之block基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/05/block系列之block基础/" class="article-date">
  <time datetime="2014-07-05T08:01:25.000Z" itemprop="datePublished">2014-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/05/block系列之block基础/">block系列之block基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>block是C语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。block在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它的由来和使用方法。</p>
<h4 id="block由来"><a href="#block由来" class="headerlink" title="block由来"></a>block由来</h4><p>先来看看C语言中标准的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int func(int count);</div></pre></td></tr></table></figure>
<p>它声明了名称为func的函数。下面看看怎么调用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int result = func(10);</div></pre></td></tr></table></figure>
<p>如果你知道函数指针，那么应该熟悉下面这个式子，它不用知道函数名也能够使用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int result = （*funcptr）(10);</div></pre></td></tr></table></figure>
<p>但是，实际上仍然需要知道函数的名称。在赋值函数指针时还是需要知道函数名称的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *funcptr (int)= &amp;func;</div></pre></td></tr></table></figure>
<p>为什么需要函数指针呢？<br>函数指针是为了获取函数的地址方便将函数作为参数时的调用.<br>为什么会出现匿名函数？<br>是为了代替函数指针，简化函数的书写。<br>block可以真正的实现不需要函数名称的函数，方便了函数的调用。通俗的讲block就是一段匿名代码块。</p>
<p>完整的block语法是如下形式：<br>block的声明格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">返回值类型 (^blockName)(参数列表);</div><div class="line">// block的声明</div><div class="line">int (^sumblock)(int arg1, int arg2);</div><div class="line">void (^blockName)(int arg1, int arg2)</div></pre></td></tr></table></figure>
<p>block的定义格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">返回值类型 (^block变量名)(形参列表) = ^(形参列表) &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>声明并使用block<br>开发者使用^操作符声明block变量，^表示是一个block的开始。block的body体在{ }之内。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myblock)(int) = ^(int num) &#123;</div><div class="line">  return num * multiplier;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-08c2619e323632fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>block可以使用“在其定义作用范围内的”变量；如果你声明了一个block变量，可以像函数一样使用它。</p>
<h4 id="block的用法"><a href="#block的用法" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void (^blockName)() = ^&#123;</div><div class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</div><div class="line">&#125;;</div><div class="line">blockName();</div></pre></td></tr></table></figure></p>
<p>有参数无返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void (^blockName)(int a, int b) = ^(int a, int b) &#123;</div><div class="line">  NSLog(@&quot;%d + %d = %d&quot;,a,b,a+b);</div><div class="line">&#125;;</div><div class="line">blockName(10,10);</div></pre></td></tr></table></figure></p>
<p>有参数有返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int (^sumblock)(int a, int b) = ^(int a, int b)&#123;</div><div class="line">  return a + b;</div><div class="line">&#125;;</div><div class="line">int sum = sumblock(10,10);</div><div class="line">NSLog(@&quot;sum = %d&quot;,sum);</div></pre></td></tr></table></figure></p>
<p>block结合typedef使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef int (^sumblock)(int, int);</div><div class="line"></div><div class="line">interface ViewController ()</div><div class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  self.sumblock = ^(int a, int b) &#123;</div><div class="line">    return a + b;</div><div class="line">  &#125;;</div><div class="line">  NSLog(@&quot;sum = %d&quot;,self.sumblock(10,10));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>block作为函数参数<br>block作为C函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1.定义一个形参为block的C函数</div><div class="line">void useblockForC(int(^ablock)(int, int))</div><div class="line">&#123;</div><div class="line">  NSLog(@&quot;result = %d&quot;, ablock(300,200));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.声明并赋值定义一个block变量</div><div class="line">int(^addblock)(int, int) = ^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 3.以block作为函数参数,把block像对象一样传递</div><div class="line">useblockForC(addblock);</div><div class="line"></div><div class="line">// 将第2点和第3点合并一起,以内联定义的block作为函数参数</div><div class="line">useblockForC(^(int x, int y) &#123;</div><div class="line">  return x+y;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>block作为OC函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1.定义一个形参为block的OC函数</div><div class="line">- (void)useblockForOC:(int(^)(int, int))ablock</div><div class="line">&#123;</div><div class="line">  NSLog(@&quot;result = %d&quot;, ablock(300,200));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.声明并赋值定义一个block变量</div><div class="line">int(^addblock)(int, int) = ^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 3.以block作为函数参数,把block像对象一样传递</div><div class="line">[self useblockForOC:addblock];</div><div class="line"></div><div class="line">// 将第2点和第3点合并一起,以内联定义的block作为函数参数</div><div class="line">[self useblockForOC:^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2014/07/05/block系列之block基础/" data-id="cj58z0pp70003jkfyed8ahgzr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HEXO搭建个人博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/04/HEXO搭建个人博客/" class="article-date">
  <time datetime="2014-07-04T13:41:47.000Z" itemprop="datePublished">2014-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/04/HEXO搭建个人博客/">HEXO搭建个人博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点会使用，并不难，但是要做到让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢。最近看到一些大神们的博客，貌似都是用hexo写得，本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装homebrew</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<p>安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install git</div></pre></td></tr></table></figure></p>
<p>安装node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure></p>
<p>安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p>
<h4 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h4><p>创建新建一个文件夹，用来存放本地博客。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>Hexo会在创建的文件夹创建本地博客所需的一切资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure></p>
<p>访问本地localhost:4000可以看到博客已经搭建成功。</p>
<h4 id="同步Hexo博客到Github"><a href="#同步Hexo博客到Github" class="headerlink" title="同步Hexo博客到Github"></a>同步Hexo博客到Github</h4><ul>
<li>在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。</li>
<li>开本地的创建的文件夹中的_config.yml配置文件，将其中的type设置为git。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">type: git</div><div class="line">repo: https://github.com/sunjinshuai/sunjinshuai.github.com</div><div class="line">branch: master</div></pre></td></tr></table></figure>
<p>在terminal终端，将当前目录切换到你的本地博客目录，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>在terminal终端，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate   // 可以简写成hexo g 根据markdown文件生成静态文件</div><div class="line">hexo deploy     // 或者简写成hexo d 将本地修改，部署到远端</div></pre></td></tr></table></figure></p>
<p>此时，打开浏览器，访问<a href="https://sunjinshuai.github.io">https://sunjinshuai.github.io</a> ，就可以看到你的博客。</p>
<h4 id="Hexo安装新主题apollo"><a href="#Hexo安装新主题apollo" class="headerlink" title="Hexo安装新主题apollo"></a>Hexo安装新主题apollo</h4><p>Hexo换皮肤还是比较简单的，既可以自己根据默认的主题来修改，也可以到<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a> 上去找主题。</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>github上的文档给出了详细的安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo init #blogname#</div><div class="line">cd #blogname# </div><div class="line">npm install</div><div class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</div><div class="line">git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo</div></pre></td></tr></table></figure></p>
<h5 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h5><p>安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: apollo</div><div class="line"></div><div class="line"># 在归档页面显示所有文章</div><div class="line"># 需要上面安装的 hexo-generator-archive 插件支持</div><div class="line">archive_generator:</div><div class="line">per_page: 0</div><div class="line">yearly: false</div><div class="line">monthly: false</div><div class="line">daily: false</div></pre></td></tr></table></figure></p>
<h4 id="hexo常用的命令"><a href="#hexo常用的命令" class="headerlink" title="hexo常用的命令"></a>hexo常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hexo init       //在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件</div><div class="line">hexo new “my new blog title”   //新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</div><div class="line">hexo clean      // 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存</div><div class="line">hexo generate   // 可以简写成hexo g 根据markdown文件生成静态文件</div><div class="line">hexo server     // 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问</div><div class="line">hexo deploy     // 或者简写成hexo d 将本地修改，部署到远端</div><div class="line">hexo version    // 显示hexo版本</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2014/07/04/HEXO搭建个人博客/" data-id="cj58z0pp30001jkfy7zxo3swp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/04/hello-world/" class="article-date">
  <time datetime="2014-07-04T13:40:47.000Z" itemprop="datePublished">2014-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://sunjinshuai.github.io/2014/07/04/hello-world/" data-id="cj58z0pp90005jkfy12d3cx9y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">七月 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/06/AutoreleasePool的实现原理/">AutoreleasePool的实现原理</a>
          </li>
        
          <li>
            <a href="/2015/05/05/Object-C编码规范/">Object-C编码规范</a>
          </li>
        
          <li>
            <a href="/2014/07/10/block系列之block的实现原理/">block系列之block的实现原理</a>
          </li>
        
          <li>
            <a href="/2014/07/07/block系列之block的存储域/">block系列之block的存储域</a>
          </li>
        
          <li>
            <a href="/2014/07/06/block系列之避免循环引用-weak与-strong的区别/">block系列之避免循环引用__weak与__strong的区别</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 sunjinshuai<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>