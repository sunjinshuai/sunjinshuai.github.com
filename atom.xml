<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2018-06-09T04:48:50.559Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈 Autolayout</title>
    <link href="https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/"/>
    <id>https://sunjinshuai.github.io/2017/12/18/谈谈 Autolayout/</id>
    <published>2017-12-18T14:16:11.000Z</published>
    <updated>2018-06-09T04:48:50.559Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Unable to simultaneously satisfy constraints.</div><div class="line">Probably at least one of the constraints in the following list is one you don&apos;t want.</div><div class="line">Try this:</div><div class="line"></div><div class="line">(1) look at each constraint and try to figure out which you don&apos;t expect;</div><div class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</div><div class="line">(Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(...........)</div><div class="line"></div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure></p>
<p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p>
<p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p>
<ul>
<li>打开断点导航（cmd+7）</li>
<li>点击左下角的+按钮</li>
<li>选择Add Symbolic Breakpoint</li>
<li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p>
<p>所以交给你一个小技巧，添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">po [[UIWindow keyWindow] _autolayoutTrace] // OC项目</div><div class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] // Swift项目</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样就可以直接看到输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</div><div class="line">UIWindow:0x7f9481c93360</div><div class="line">|   •UIView:0x7f9481c9d680</div><div class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</div><div class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</div><div class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</div></pre></td></tr></table></figure></p>
<p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p>
<p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) po 0x7f9481c9d990</div><div class="line">&lt;UIView: 0x7f9481c9d990; frame = (0 0; 768 359); autoresize = RM+BM; layer = &lt;CALayer: 0x7fc82d338960&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>改变颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor = [UIColor redColor]</div><div class="line">(UICachedDeviceRGBColor *) $4 = 0x0000000174469cc0</div></pre></td></tr></table></figure></p>
<p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p>
<h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p>
<ul>
<li><p><code>layoutSubViews：</code><br>添加子视图常重写这个方法，这个方法是用来重新布局子视图的，常用于对子视图布局，或者在其他方法中调用以达到重新布局的作用。</p>
</li>
<li><p><code>setNeedsLayout</code><br>告知页面需要更新，但是不会立刻开始更新，执行后会立刻调用<code>layoutSubviews</code>。</p>
</li>
<li><p><code>layoutIfNeeded</code><br>告知页面布局立刻更新，所以一般都会和<code>setNeedsLayout</code>一起使用。如果希望立刻生成新的<code>frame</code>需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p>
</li>
<li><p><code>setNeedsUpdateConstraints</code><br>告知需要更新约束，但是不会立刻开始</p>
</li>
<li><p><code>updateConstraintsIfNeeded</code><br>告知立刻更新约束</p>
</li>
<li><p><code>updateConstraints</code><br>系统更新约束</p>
</li>
</ul>
<h4 id="触发layoutSubviews的时机"><a href="#触发layoutSubviews的时机" class="headerlink" title="触发layoutSubviews的时机"></a>触发<code>layoutSubviews</code>的时机</h4><ul>
<li><code>init</code>方法初始化不会触发<code>layoutSubviews</code>，但是是用<code>initWithFrame</code> 进行初始化时，当<code>rect</code>的值不为<code>CGRectZero</code>时，会触发。</li>
<li><code>addSubview</code>方法会触发<code>layoutSubviews</code>。</li>
<li>设置<code>view</code>的<code>Frame</code>会触发<code>layoutSubviews</code>，前提是<code>frame</code>的值设置前后发生了变化。</li>
<li>滚动一个<code>UIScrollView</code>会触发<code>layoutSubviews</code>。</li>
<li>旋转<code>Screen</code>会触发父<code>UIView</code>上的<code>layoutSubviews</code>。</li>
<li>改变一个<code>UIView</code>大小的时候也会触发父<code>UIView</code>上的<code>layoutSubviews</code>。</li>
</ul>
<p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p>
<h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.bounds = CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</div></pre></td></tr></table></figure></p>
<p>那么很可能拿到 layer 的宽度是0。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">UIView *redView = [[UIView alloc] init];</div><div class="line">redView.backgroundColor = [UIColor redColor];</div><div class="line">[self.view addSubview:redView];</div><div class="line">self.redView = redView;</div><div class="line">    </div><div class="line">// 设置约束</div><div class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">  make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">  make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame = (0 0; 0 0); layer = &lt;CALayer: 0x6040002274a0&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p>
<p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p>
<p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLayoutSubviews &#123;</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">    </div><div class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame = (132 328; 150 80); layer = &lt;CALayer: 0x60000003c460&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">    [redView setNeedsLayout];</div><div class="line">    [redView layoutIfNeeded];</div><div class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">&#125;</div><div class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame = (-75 -40; 150 80); layer = &lt;CALayer: 0x6040004207a0&gt;&gt;</div></pre></td></tr></table></figure>
<p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">   </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame = (132 328; 150 80); layer = &lt;CALayer: 0x600000233540&gt;&gt;</div></pre></td></tr></table></figure>
<p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关于Autolayout的调试&quot;&gt;&lt;a href=&quot;#关于Autolayout的调试&quot; class=&quot;headerlink&quot; title=&quot;关于Autolayout的调试&quot;&gt;&lt;/a&gt;关于Autolayout的调试&lt;/h4&gt;&lt;p&gt;刚开始使用 Autolayout 遇
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac安装Jenkins系列/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:37:01.651Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="external">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>持续的软件版本发布/测试项目。</li>
<li>监控外部调用执行的工作。</li>
</ul>
<p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="external">Jenkins官网</a>下载Jenkins；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击Download：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p>
<p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a></p>
<ul>
<li>在Safari浏览器上，会出现Safari不能连接到服务器。</li>
<li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li>
</ul>
<p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="external">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以通过下面两种方式获取初始化密码：</p>
<ul>
<li>打开terminal，执行cat命令即可(需要管理员权限)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>输入用户名和密码之后，Jenkins就彻底安装好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p>
<h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Application Support/Jenkins/Uninstall.command</div></pre></td></tr></table></figure>
<h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist    </div><div class="line">sudo rm !$    </div><div class="line">sudo rm -rf /Applications/Jenkins &quot;/Library/Application Support/Jenkins&quot; /Library/Documentation/Jenkins    </div><div class="line">sudo rm -rf /Users/Shared/Jenkins    </div><div class="line"># if you want to get rid of all the jobs and builds:    </div><div class="line">sudo dscl . -delete /Users/jenkins    </div><div class="line"># delete the jenkins user and group (if you chose to use them):    </div><div class="line">sudo dscl . -delete /Groups/jenkins</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App的生命周期</title>
    <link href="https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://sunjinshuai.github.io/2017/11/18/App的生命周期/</id>
    <published>2017-11-17T16:02:28.000Z</published>
    <updated>2017-12-18T14:18:11.207Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS程序的启动执行顺序"><a href="#iOS程序的启动执行顺序" class="headerlink" title="iOS程序的启动执行顺序"></a>iOS程序的启动执行顺序</h4><p>程序启动顺序图<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062685cbe0f2c8?w=990&amp;h=717&amp;f=png&amp;s=115346" alt="iOS启动原理图"></p>
<p>具体执行流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);//__func__打印方法名</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:]</div><div class="line">-[AppDelegate applicationDidBecomeActive:]</div></pre></td></tr></table></figure>
<p>按下 <code>Command + H + SHIFT</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationWillResignActive:]</div><div class="line">-[AppDelegate applicationDidEnterBackground:]</div></pre></td></tr></table></figure></p>
<p>重新点击 进入程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationWillEnterForeground:]</div><div class="line">-[AppDelegate applicationDidBecomeActive:]</div></pre></td></tr></table></figure></p>
<p>内存警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationDidReceiveMemoryWarning:]</div></pre></td></tr></table></figure></p>
<h4 id="UIViewController-的生命周期"><a href="#UIViewController-的生命周期" class="headerlink" title="UIViewController 的生命周期"></a><code>UIViewController</code> 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">// 非storyBoard(xib或非xib)都走这个方法</div><div class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// storyBoard走这个方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// xib 加载 完成</div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 加载视图(默认从nib)</div><div class="line">- (void)loadView &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">    self.view.backgroundColor = [UIColor redColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图控制器中的视图加载完成，viewController自带的view加载完成</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidLoad];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 视图将要出现</div><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// view 即将布局其 Subviews</div><div class="line">- (void)viewWillLayoutSubviews &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillLayoutSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// view 已经布局其 Subviews</div><div class="line">- (void)viewDidLayoutSubviews &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图已经出现</div><div class="line">- (void)viewDidAppear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图将要消失</div><div class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图已经消失</div><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 出现内存警告</div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图被销毁</div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li><p><code>initWithNibName:bundle:</code><br>初始化<code>UIViewController</code>，执行关键数据初始化操作，非<code>StoryBoard</code>创建<code>UIViewController</code>都会调用这个方法。<br><strong>注意: 不要在这里做<code>View</code>相关操作，<code>View</code>在<code>loadView</code>方法中才初始化。</strong></p>
</li>
<li><p><code>initWithCoder:</code><br>如果使用<code>StoryBoard</code>进行视图管理，程序不会直接初始化一个<code>UIViewController</code>，<code>StoryBoard</code>会自动初始化或在<code>segue</code>被触发时自动初始化，因此方法<code>initWithNibName:bundle</code>不会被调用，但是<code>initWithCoder</code>会被调用。</p>
</li>
<li><p><code>awakeFromNib</code><br>当<code>awakeFromNib</code>方法被调用时，所有视图的<code>outlet</code>和<code>action</code>已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在<code>storyBoard</code>或<code>xib</code>中，所以可以在<code>awakeFromNib</code>方法中被加载进来。</p>
</li>
<li><p><code>loadView</code><br>当执行到<code>loadView</code>方法时，如果视图控制器是通过<code>nib</code>创建，那么视图控制器已经从<code>nib</code>文件中被解档并创建好了，接下来任务就是对<code>view</code>进行初始化。<br><code>loadView</code>方法在<code>UIViewController</code>对象的<code>view</code>被访问且为空的时候调用。这是它与<code>awakeFromNib</code>方法的一个区别。<br>假设我们在处理内存警告时释放<code>view</code>属性：<code>self.view = nil</code>。因此<code>loadView</code>方法在视图控制器的生命周期内可能被调用多次。<br><code>loadView</code>方法不应该直接被调用，而是由系统调用，它会加载或创建一个<code>view</code>并把它赋值给<code>UIViewController</code>的<code>view</code>属性。<br>在创建<code>view</code>的过程中，首先会根据<code>nibName</code>去找对应的<code>nib</code>文件然后加载。如果<code>nibName</code>为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码)<br><strong>注意:在重写loadView方法的时候，不要调用父类的方法。</strong></p>
</li>
<li><p><code>viewDidLoad</code><br>当<code>loadView</code>将<code>view</code>载入内存中，会进一步调用<code>viewDidLoad</code>方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。</p>
</li>
<li><p><code>viewWillAppear</code><br>系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。<br>另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。</p>
</li>
<li><p><code>viewWillLayoutSubviews</code><br><code>view</code>即将布局其<code>Subviews</code>。 比如<code>view</code>的<code>bounds</code>改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整<code>Subviews</code>的位置，在调整之前要做的工作可以放在该方法中实现</p>
</li>
<li><p><code>viewDidLayoutSubviews</code><br><code>view</code>已经布局其<code>Subviews</code>，这里可以放置调整完成之后需要做的工作。</p>
</li>
<li><p><code>viewDidAppear</code><br>在<code>view</code>被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。</p>
</li>
<li><p><code>viewWillDisappear</code><br>在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用<code>removeFromSuperview</code>。</p>
</li>
<li><p><code>viewDidDisappear</code><br><code>view</code>已经消失或被覆盖，此时已经调用<code>removeFromSuperView</code>;</p>
</li>
<li><p><code>dealloc</code><br>视图被销毁，此次需要对你在<code>init</code>和<code>viewDidLoad</code>中创建的对象进行释放。</p>
</li>
<li><p><code>didReceiveMemoryWarning</code><br>在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;a href=&quot;#iOS程序的启动执行顺序&quot; class=&quot;headerlink&quot; title=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;/a&gt;iOS程序的启动执行顺序&lt;/h4&gt;&lt;p&gt;程序启动顺序图&lt;br&gt;&lt;img src=&quot;https://u
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="https://sunjinshuai.github.io/2017/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://sunjinshuai.github.io/2017/09/23/对称加密与非对称加密/</id>
    <published>2017-09-23T14:21:21.000Z</published>
    <updated>2017-10-23T01:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>对称加密：<br>加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），对称加密是最快速、最简单的一种加密方式。<br>加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。</p>
<p>对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。</p>
<p>对称加密通常使用的是相对较小的密钥，一般小于256bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1bit来做这个密钥，那黑客们可以先试着用0来解密，不行的话就再用1解；但如果你的密钥有1MB大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。</p>
<p>比如常见的DES/AES都是属于对称加密算法。</p>
<p>优点：算法公开、计算量小、加密速度快、加密效率高。<br>缺点：秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。</p>
<p>另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p>非对称加密：<br>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。</p>
<p>私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。</p>
<p>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p>
<p>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。</p>
<p>与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。<br>比如RSA就是最常用的非对称加密算法。</p>
<p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<p>优点：安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。<br>缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p>
<p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p>
<p>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对称加密：&lt;br&gt;加密（encryption）与解密（decryption）使用的是同样的密钥（secret key），对称加密是最快速、最简单的一种加密方式。&lt;br&gt;加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之iconfont实战</title>
    <link href="https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2017/08/08/iOS之iconfont实战/</id>
    <published>2017-08-08T07:45:34.000Z</published>
    <updated>2017-08-08T08:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了<code>APP Slicing</code>功能，我司项目在itunes store下载的IPA体积大约在44M。</p>
<p>把我司iPA解压之后里面的<code>Assert.car</code>资源包的体积大约在22.1M，使用软件导出内部的资源文件发现3X系列的图片大小约为13.1M，2X系列的图片大小约为9.4M，两份加起来大于22.1M，所以可以看出我们的图片还是有很大的优化空间的。</p>
<p><a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>技术的主要目的是为减少应用体积而生。首先<code>icon</code>代表图标<code>font</code>代表字体。此技术便是将图标转化为字体，从而达到减小应用体积的目的(这样避免了@2X图和@3X图的使用，只需要一个字体图标就可搞定)。如需在项目中使用iconfont技术，图标矢量图一开始都应合并转化为字体库，只需要在项目中引入字体库就可以了。</p>
<p>优点:</p>
<ul>
<li>减小应用体积，字体文件比图片要小；</li>
<li>图标保真缩放，解决2x/3x乃至将来nx图问题；</li>
<li>方便更改图标颜色大小，图片复用；</li>
<li>一套图标资源可以在不用平台上使用(android、iOS、web)；</li>
</ul>
<p>缺点:</p>
<ul>
<li>只适用于纯色的icon；</li>
</ul>
<h4 id="iconfont实战"><a href="#iconfont实战" class="headerlink" title="iconfont实战"></a>iconfont实战</h4><ul>
<li><p>获取<code>.ttf</code>文件<br>登录<a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>，创建一个项目，设计师做好图标，把<code>.ttf</code>文件下载下来。<br>iconfont中的图标是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/588630-fff854d89142120b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>字体注册<br>iOS中使用自定义字体，将字体加入项目后，还需要注册字体。<br>注册的方式有两种：<br>－ 在Info.plist中声明”Fonts provided by application”</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b6a5790bed65a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>－ 调用API来注册。考虑到需要支持独立版和插件版，调用API注册更加方便。字体注册和获取的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)registerFontWithURL:(NSURL *)url &#123;</div><div class="line">    NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&apos;t exist&quot;);</div><div class="line">    CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)url);</div><div class="line">    CGFontRef newFont = CGFontCreateWithDataProvider(fontDataProvider);</div><div class="line">    CGDataProviderRelease(fontDataProvider);</div><div class="line">    CTFontManagerRegisterGraphicsFont(newFont, nil);</div><div class="line">    CGFontRelease(newFont);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIFont *)fontWithSize:(CGFloat)size &#123;</div><div class="line">    UIFont *font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">    if (font == nil) &#123;</div><div class="line">        [self registerFontWithURL: [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;]];</div><div class="line">        font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">        NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&apos;re using the correct font name.&quot;);</div><div class="line">    &#125;</div><div class="line">    return font;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>字体应用方式<br>可能的应用方式：<ul>
<li>UILabel作为Icon</li>
<li>UIButton的titleLabel作为Icon</li>
<li>根据字体生成UIImage</li>
</ul>
</li>
</ul>
<p>在实际项目中，鉴于将我们本来的icon当作字体使用，会让我们在项目中添加的控件方式有所变化，而且不容易控制颜色和图标大小，所以我这里推荐第三种方案，根据图片大小、颜色和Unicode码来生成并返回图片。</p>
<ul>
<li>应用到项目中<br>将<code>.ttf</code>文件引入到自己的工程中</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b463acca775cd8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>目前我司项目重构之后的图标为IconFont，新需求用到的图标也会优先采用IconFont。</p>
<p><a href="https://github.com/sunjinshuai/MYUtils" target="_blank" rel="external">demo地址</a></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="external">使用IconFont减小iOS应用体积</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了&lt;code&gt;APP Slicing&lt;/code&gt;功能，我司项目在i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 中 Label 的抗拉伸和抗压缩</title>
    <link href="https://sunjinshuai.github.io/2017/07/18/iOS-AutoLayout-%E4%B8%AD-Label-%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/"/>
    <id>https://sunjinshuai.github.io/2017/07/18/iOS-AutoLayout-中-Label-的抗拉伸和抗压缩/</id>
    <published>2017-07-17T16:42:23.000Z</published>
    <updated>2017-12-18T14:43:09.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-AutoLayout中Label的”抗拉伸”和”抗压缩”"><a href="#iOS-AutoLayout中Label的”抗拉伸”和”抗压缩”" class="headerlink" title="iOS AutoLayout中Label的”抗拉伸”和”抗压缩”"></a>iOS AutoLayout中Label的”抗拉伸”和”抗压缩”</h1><h4 id="关键词-intrinsic-content-size"><a href="#关键词-intrinsic-content-size" class="headerlink" title="关键词 intrinsic content size"></a>关键词 <code>intrinsic content size</code></h4><p>有些控件能通过自己显示的内容计算出需要的 <code>size</code>，这个自动计算出来 <code>size</code> 就是该控件的固有内容大小。这个大小是和需要显示的内容相关的。<code>UIButton</code>、<code>UILabel</code> 就是具有固有内容大小属性的控件。<code>UIButton</code> 可以根据它的 <code>title</code> 字符串长度和需要显示的 <code>image</code> 来计算需要的 <code>size</code>，<code>UILabel</code> 可以根据它的 <code>text</code> 来计算。</p>
<p>以 <code>UILable</code> 为例子：<br>在默认情况下，我们没有设置各个布局的优先级，那么他就会优先显示左边的 <code>label</code>，左边的完全显示后剩余的空间都是右边的 <code>label</code>，如果整个空间宽度都不够左边的 <code>label</code> 的话，那么右边的 <code>label</code> 没有显示的机会了。<br>如果我们现在的需求是优先显示右边的 <code>label</code>，左边的 <code>label</code> 内容超出的省略，这时就需要我们调整约束的优先级了。</p>
<p>原理：</p>
<ul>
<li>约束优先级： 在 <code>Autolayout</code>中每个约束都有一个优先级, 优先级的范围是 <code>1~1000</code>。创建一个约束，默认的优先级是最高的<code>1000</code></li>
<li><code>Content Hugging Priority</code> ：该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是 <code>250</code>。</li>
<li><code>Content Compression Resistance Priority</code> ：该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是 <code>750</code>。</li>
</ul>
<p>所以默认情况下两边的 <code>label</code> 的 <code>Content Hugging</code> 和 <code>Content Compression</code> 优先级都是一样的，为了让右边的 <code>label</code> 完全显示，那么我们需要增大右边 <code>label</code> 的抗压缩级，或者减小左边 <code>label</code> 的抗压缩级，总之是得让右边的抗压缩级大于左边的 <code>label</code>，这样才能让右边的label内容优先显示。</p>
<p><code>UIView</code> 中关于 <code>Content Hugging</code> 和 <code>Content Compression Resistance</code> 的方法有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line">- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line"></div><div class="line">- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line">- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS-AutoLayout中Label的”抗拉伸”和”抗压缩”&quot;&gt;&lt;a href=&quot;#iOS-AutoLayout中Label的”抗拉伸”和”抗压缩”&quot; class=&quot;headerlink&quot; title=&quot;iOS AutoLayout中Label的”抗拉伸”和”
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>探索 UIScrollView 的原理</title>
    <link href="https://sunjinshuai.github.io/2017/06/15/%E6%8E%A2%E7%B4%A2-UIScrollView-%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/06/15/探索-UIScrollView-的原理/</id>
    <published>2017-06-15T01:43:29.000Z</published>
    <updated>2017-12-18T14:44:11.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIScrollView的原理"><a href="#UIScrollView的原理" class="headerlink" title="UIScrollView的原理"></a>UIScrollView的原理</h1><p><code>UIKit</code> 坐标系每一个 <code>View</code> 都定义了他自己的坐标系，如下图所示，<code>x</code> 轴指向右方，<code>y</code> 轴指向下方：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b4be73e8ede40f16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>这个逻辑坐标系并不关注包含在其中 <code>View</code> 的宽度和高度，整个坐标系没有边界向四周无限延伸。<br>我们在坐标系中放置四个子 <code>View</code>，每一次色块代表一个 <code>View</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-173b57f84345e191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">UIView *redView = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 100, 100)];</div><div class="line">redView.backgroundColor = [UIColor colorWithRed:0.815 green:0.007</div><div class="line">blue:0.105 alpha:1];</div><div class="line"></div><div class="line">UIView *greenView = [[UIView alloc] initWithFrame:CGRectMake(150, 160, 150, 200)];</div><div class="line">greenView.backgroundColor = [UIColor colorWithRed:0.494 green:0.827</div><div class="line">blue:0.129 alpha:1];</div><div class="line"></div><div class="line">UIView *blueView = [[UIView alloc] initWithFrame:CGRectMake(40, 400, 200, 150)];</div><div class="line">blueView.backgroundColor = [UIColor colorWithRed:0.29 green:0.564</div><div class="line">blue:0.886 alpha:1];</div><div class="line"></div><div class="line">UIView *yellowView = [[UIView alloc] initWithFrame:CGRectMake(100, 600, 180, 150)];</div><div class="line">yellowView.backgroundColor = [UIColor colorWithRed:0.972 green:0.905</div><div class="line">blue:0.109 alpha:1];</div><div class="line"></div><div class="line">[mainView addSubview:redView];</div><div class="line">[mainView addSubview:greenView];</div><div class="line">[mainView addSubview:blueView];</div><div class="line">[mainView addSubview:yellowView];</div></pre></td></tr></table></figure>
<h4 id="bounds"><a href="#bounds" class="headerlink" title="bounds"></a>bounds</h4><p><code>Apple</code> 关于 <code>UIView</code> 的文档中是这样描述 <code>bounds</code> 属性的：</p>
<blockquote>
<p>bounds矩形…描述了该视图在其自身坐标系中的位置和大小。</p>
</blockquote>
<p>一个 <code>View</code> 可以被看作是定义在其所在坐标系平面上的一个矩形的可视区域，<code>View</code> 的边界表明了这个矩形可视区域的位置和大小。</p>
<p>假设我们的 <code>View</code> 宽320像素，高480像素，原点在（0，0）。那么这个 <code>View</code> 就变成了整个坐标系平面的观察口，它展示的只是整个平面的一小部分。位于该 <code>View</code> 边界外的区域依然存在，只是被隐藏起来了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ce142480ad4ae548.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一个 <code>View</code> 提供了其所在平面的一个观察口，<code>View</code> 的 <code>bounds</code> 矩形描述了这个可是区域的位置和大小。</p>
<p>接下来我们来试着修改 <code>bounds</code> 的原点坐标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGRect bounds = mainView.bounds;</div><div class="line">bounds.origin = CGPointMake(0, 100);</div><div class="line">mainView.bounds = bounds;</div></pre></td></tr></table></figure>
<p>当我们把 <code>bound</code> 原点设为（0，100）后，整个画面看起来就像这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-615c7c579a14e6f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>修改 <code>bounds</code> 的原点就相当与在平面上移动这个可视区域。</p>
<p>看起来好像是这个 <code>View</code> 向下移动了100像素，在这个 <code>View</code> 自己的坐标系中这确实没错。不过这个 <code>View</code> 真正位于屏幕上的位置（更准确的说在其父 <code>View</code> 上的位置）其实没有改变，因为这是由 <code>View</code> 的 <code>frame</code> 属性决定的，它并没有改变：</p>
<blockquote>
<p>frame矩形…定义了这个View在其父View坐标系中的位置和大小。</p>
</blockquote>
<p>由于 <code>View</code> 的位置是相对固定的，你可以把整个坐标平面想象成我们可以上下拖动的透明幕布，把这个 <code>View</code> 想象成我们观察坐标平面的窗口。调整 <code>View</code> 的 <code>Bounds</code> 属性就相当于拖动这个幕布，那么下方的内容就能在我们 <code>View</code> 中被观察到：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-660f880bec22bb97.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>修改 <code>bounds</code> 的原点坐标也相当于把整个坐标系向上拖动，因为 <code>View</code> 的 <code>frame</code> 没由变过，所以它相对于父 <code>View</code> 的位置没有变化过。</p>
<p>其实这就是 <code>UIScrollView</code> 滑动时所发生的事情。注意从一个用户的角度来看，他以为时这个 <code>View</code> 中的子 <code>View</code> 在移动，其实他们的在坐标系中位置（他们的 <code>frame</code> ）没有发生过变化。</p>
<p>一个 <code>scroll view</code> 并不需要其中子 <code>View</code> 的坐标来使他们滚动，唯一要做的就是改变他的 <code>bounds</code> 属性。知道了这一点，实现一个简单的 <code>scroll view</code> 就没什么困难了。我们用一个 <code>gesture recognizer</code> 来识别用户的拖动操作，根据用户拖动的偏移量来改变 <code>bounds</code> 的原点：</p>
<p>和真正的 <code>UIScrollView</code> 一样，我们的类也有一个 <code>contentSize</code> 属性，你必须从外部来设置这个值来指定可以滚动的区域，当我们改变 <code>bounds</code> 的大小时我们要确保设置的值是有效的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UIScrollView的原理&quot;&gt;&lt;a href=&quot;#UIScrollView的原理&quot; class=&quot;headerlink&quot; title=&quot;UIScrollView的原理&quot;&gt;&lt;/a&gt;UIScrollView的原理&lt;/h1&gt;&lt;p&gt;&lt;code&gt;UIKit&lt;/code&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第4期(2017.05.03)</title>
    <link href="https://sunjinshuai.github.io/2017/05/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E6%9C%9F-2017-05-03/"/>
    <id>https://sunjinshuai.github.io/2017/05/03/iOS学习笔记-第4期-2017-05-03/</id>
    <published>2017-05-03T03:20:08.000Z</published>
    <updated>2017-08-16T07:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>僵尸对象（Zombie Objects）</li>
<li>使用Instruments检测僵尸对象</li>
<li>iOS11适配之UITableview、UICollectionView下拉刷新错乱</li>
<li>@WeakObj和@StrongObj的宏定义</li>
</ul>
<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p>
<h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li>
</ul>
<p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p>
<h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p>
<p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    __unsafe_unretained NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">    [array addObject:@&quot;1&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：</p>
<ul>
<li>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针。<code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</li>
<li><code>assign</code>仅用于修饰<code>NSInteger</code>等OC基础类型，以及<code>short</code>、<code>int</code>、<code>double</code>、结构体等C数据类型，不修饰对象指针。</li>
<li>如果需要弱引用OC对象，建议使用<code>weak</code>关键字，因为被<code>weak</code>指针所引用的对象被回收后，<code>weak</code>指针会被赋为<code>nil</code>（空指针），给<code>nil</code>发任何消息都不会出问题。使用<code>weak</code>修饰代理对象属性就是很好的例子。</li>
</ul>
<h4 id="iOS11适配之UITableview、UICollectionView下拉刷新错乱"><a href="#iOS11适配之UITableview、UICollectionView下拉刷新错乱" class="headerlink" title="iOS11适配之UITableview、UICollectionView下拉刷新错乱"></a>iOS11适配之UITableview、UICollectionView下拉刷新错乱</h4><p>升级<code>Xcode 9</code>之后，在<code>iOS11</code>的环境下，发现原本没问题的<code>collectionView</code>和<code>tableView</code>像是中了风一样，头部刷新UI出现了错乱。</p>
<p>于是谷歌了一下发现<code>iOS11</code>弃用了<code>automaticallyAdjustsScrollViewInsets</code>属性，新增<code>contentInsetAdjustmentBehavior</code>来替代它。</p>
<p>关于<code>contentInsetAdjustmentBehavior</code>，<br>swift语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@available(iOS 11.0, *)</div><div class="line">public enum UIScrollViewContentInsetAdjustmentBehavior : Int &#123;</div><div class="line"></div><div class="line">    case automatic // Similar to .scrollableAxes, but will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewContentInset = YES inside a navigation controller, regardless of whether the scroll view is scrollable</div><div class="line"></div><div class="line">    case scrollableAxes // Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)</div><div class="line"></div><div class="line">    case never // contentInset is not adjusted</div><div class="line"></div><div class="line">    case always // contentInset is always adjusted by the scroll view&apos;s safeAreaInsets</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>UIScrollViewContentInsetAdjustmentBehavior 是一个枚举类型,值有以下几种:</p>
<ul>
<li><code>automatic</code>和<code>scrollableAxes</code>一样，<code>scrollView</code>会自动计算和适应顶部和底部的内边距并且在<code>scrollView</code>不可滚动时，也会设置内边距。</li>
<li><code>scrollableAxes</code>自动计算内边距。</li>
<li><code>never</code>不计算内边距。</li>
<li><code>always</code>根据<code>safeAreaInsets</code>计算内边距。<br>很显然，在适配<code>iOS11</code>的时候我们这里要设置为<code>never</code>。</li>
</ul>
<p>OC语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明tableView的位置 添加下面代码</div><div class="line">if (@available(iOS 11.0, *)) &#123;</div><div class="line">    _tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>swift语言:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明tableView的位置 添加下面代码</div><div class="line">if #available(iOS 11.0, *) &#123;</div><div class="line">    tableView.contentInsetAdjustmentBehavior = .never</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="WeakObj和-StrongObj的宏定义"><a href="#WeakObj和-StrongObj的宏定义" class="headerlink" title="@WeakObj和@StrongObj的宏定义"></a>@WeakObj和@StrongObj的宏定义</h4><p>我们都知道在防止如<code>block</code>的循环引用时，会使用<code>__weak</code>关键字做如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div></pre></td></tr></table></figure>
<p>后来，为了方便，不用每次都要写这样一句固定代码，我们定义了宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WeakSelf __weak typeof(self) weakSelf = self;</div></pre></td></tr></table></figure>
<p>之后，我们可以比较方便的在需要的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[weakSelf doSomething];</div></pre></td></tr></table></figure>
<p>再后来，我们发现不止<code>self</code>需要使用<code>weak</code>，可能有部分变量也需要<code>weak</code>，于是我们的宏继续进化，不仅仅只支持<code>self</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WeakObj(o) __weak typeof(o) o##Weak = o;</div></pre></td></tr></table></figure>
<p>这样，后续对需要使用<code>weak</code>的对象，只要写一句<code>WeakObj(obj)</code>即可使用<code>objWeak</code>变量。</p>
<p>再后来，我们发现了一些小技巧，可以让我们的这个宏看起来更原生一些，我们添加了@符号在前面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define WeakObj(o) autoreleasepool&#123;&#125; __weak typeof(o) o##Weak = o;</div><div class="line">#define StrongObj(o) autoreleasepool&#123;&#125; __strong typeof(o) o = o##Weak;</div></pre></td></tr></table></figure>
<p>使用上看起来是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@WeakObj(self);</div><div class="line">[var setBlock:^&#123;</div><div class="line">    @StrongObj(self);</div><div class="line">    [self doSomething];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;僵尸对象（Zombie Objects）&lt;/li&gt;
&lt;li&gt;使用Instruments检测僵尸对象&lt;/li&gt;
&lt;li&gt;iOS11适配之UITableview、UICollectionView下拉刷新错乱&lt;/li&gt;
&lt;l
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XXX软件已损坏，打不开，您应该将它移到废纸篓解决方案</title>
    <link href="https://sunjinshuai.github.io/2017/04/15/XXX%E8%BD%AF%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E6%89%93%E4%B8%8D%E5%BC%80%EF%BC%8C%E6%82%A8%E5%BA%94%E8%AF%A5%E5%B0%86%E5%AE%83%E7%A7%BB%E5%88%B0%E5%BA%9F%E7%BA%B8%E7%AF%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://sunjinshuai.github.io/2017/04/15/XXX软件已损坏，打不开，您应该将它移到废纸篓解决方案/</id>
    <published>2017-04-15T04:21:46.000Z</published>
    <updated>2017-12-18T14:22:43.819Z</updated>
    
    <content type="html"><![CDATA[<p>如果从第三方渠道下载的<code>Mac</code>软件，安装有时候会提示<strong>“XXX软件已损坏，打不开，您应该将它移到废纸篓”</strong>的提示，瞬间头大，仔细想肯定不会是<code>Mac</code>软件本身的问题，而是<code>Mac</code>系统的一个安全机制问题，按照如下方法操作，即打开安装使用<code>Mac</code>软件，再也不用头疼半天，一遍一遍的下载重试。</p>
<ul>
<li>首先需要打开系统偏好设置，选择安全与隐私；</li>
<li>然后点击左下角锁形按钮，这时会提示需要输入用户名和密码；</li>
<li>选择”任何来源”，然后点击允许来自任何来源，这样设置之后，再重新安装<code>Mac</code>软件，如果<code>Mac</code>软件本身没有问题，就不会出现”软件已损坏”的提示了。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062a8cc92ac349?w=1240&amp;h=1008&amp;f=png&amp;s=200300" alt="image.png"></p>
<p>针对，<code>macOS Sierra</code>系统的说明</p>
<p>若已安装了<code>macOS Sierra</code>则有可能会出现从第三方渠道下载安装的<code>Mac</code>软件<strong>“XXX软件已损坏，打不开，您应该将它移到废纸篓”</strong>的提示。原因是因为<code>macOS Sierra</code>系统屏蔽了任何来源的设置，需要打开”允许任何来源”才能安装。</p>
<ul>
<li>打开终端（按F4启动Launchpad，终端默认在“其他”中）</li>
<li>输入代码：<code>sudo spctl --master-disable</code></li>
<li>按回车输入自己电脑密码，再次回车。</li>
<li>打开系统偏好设置—&gt;安全性与隐私，若显示任何来源，大功告成；</li>
</ul>
<p>终于解决了这头疼的问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果从第三方渠道下载的&lt;code&gt;Mac&lt;/code&gt;软件，安装有时候会提示&lt;strong&gt;“XXX软件已损坏，打不开，您应该将它移到废纸篓”&lt;/strong&gt;的提示，瞬间头大，仔细想肯定不会是&lt;code&gt;Mac&lt;/code&gt;软件本身的问题，而是&lt;code&gt;Mac&lt;/cod
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/03/18/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/03/18/iOS之使用Cocoapods创建私有仓库/</id>
    <published>2017-03-18T10:31:52.000Z</published>
    <updated>2017-07-19T02:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
<p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p>
<ul>
<li><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</li>
<li><p>查看现有的<code>podspec</code>源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul>
<li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li>
<li>创建pod私有库所需要的项目工程文件，并上传到私有库</li>
<li>创建pod所对应的podspec文件，并进行验证／测试</li>
<li>向私有的Spec Repo中提交podspec</li>
<li>使用pod库</li>
</ul>
<h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul>
<li>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</li>
<li><p>将私有Spec Repo关联到本地</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add FXSpesc http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git</div></pre></td></tr></table></figure>
<p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p>
<h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul>
<li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>手动创建Xcode工程(过于简单)</p>
</li>
</ul>
<h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul>
<li>如果用<code>pod</code>命令创建，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你项目工程文件</div><div class="line">pod spec create FXKit.podspec</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  s.name         = &quot;FXKit&quot;</div><div class="line">  s.version      = &quot;0.0.1&quot;</div><div class="line">  s.summary      = &quot;FXKit，繁星优选私有库&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">		   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</div><div class="line">                   DESC</div><div class="line"></div><div class="line">  s.homepage     = &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;</div><div class="line"></div><div class="line">  # s.license    = &quot;MIT (example)&quot;</div><div class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line">  s.author       = &#123; &quot;孙金帅&quot; =&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</div><div class="line">  s.platform     = :ios</div><div class="line">  s.source       = &#123;</div><div class="line">	:git =&gt; &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;,</div><div class="line">	:tag =&gt; &quot;#&#123;s.version&#125;&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.source_files = &apos;FXKit/**/*.&#123;h,m&#125;&apos;</div><div class="line"></div><div class="line">  # s.resource_bundles = &#123;</div><div class="line">  #   &apos;FXKit&apos; =&gt; [&apos;FXKit/Assets/*.png&apos;]</div><div class="line">  # &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;FXKit/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;</div><div class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">s.name：私有库的名称，`pod search`搜索的关键词，注意这里一定要和`.podspec`的名称一样，否则报错。</div><div class="line">s.version：私有库的版本。</div><div class="line">s.ios.deployment_target：支持的pod最低版本。</div><div class="line">s.summary：私有库简介。</div><div class="line">s.description：私有库详细介绍。</div><div class="line">s.homepage：私有库在GitHub上的地址。</div><div class="line">s.license：开源协议。</div><div class="line">s.author：作者。</div><div class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</div><div class="line">s.source：私有库在GitHub上的地址和版本号。</div><div class="line">s.source_files：私有库对外共享的.h和.m文件。</div><div class="line">s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<ul>
<li>commit项目工程的源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git</div><div class="line">git push -u origin master</div><div class="line">git tag -m &quot;first release&quot; 0.0.1</div><div class="line">git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<ul>
<li>验证</li>
</ul>
<p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint FXKit.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p>
<h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</div><div class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</div><div class="line">pod repo push FXSpesc NAME.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings --use-libraries</div></pre></td></tr></table></figure>
<h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库踩坑记</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库踩坑记/</id>
    <published>2016-12-08T14:01:03.000Z</published>
    <updated>2017-08-08T07:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>即上一篇<a href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/">iOS之使用Cocoapods创建公有仓库</a>，本文就<code>CocoaPods</code>创建公有库踩到的坑做一下分享：</p>
<h4 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h4><ul>
<li>本地的公有仓库验证通过，但是远程仓库上的公有仓库验证不通过，路经不对。<br><img src="http://upload-images.jianshu.io/upload_images/588630-4a5138f97c4c6d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>重新打开<code>xxx.podspec</code>文件编辑一下，确定共享文件路径没有错误，然后再上传到<code>github</code>上验证。<br><code>source_files</code>文件格式有几种设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.source_files  = &apos;Classes/*.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes/publicClass.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes&apos;</div><div class="line">s.source_files  = &apos;Classes/**/*.&#123;h,m&#125;&apos;</div></pre></td></tr></table></figure>
<ul>
<li>执行<code>pod trunk push TestCocoaPods.podspec</code>时，报<code>[!] {&quot;name&quot;=&gt;[&quot;is already taken&quot;]}</code><br><img src="http://upload-images.jianshu.io/upload_images/588630-2a2f1d0e9d5c0864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>执行<code>pod search TestCocoaPods</code>，会发现有一个重名的公有库存在，重新创建一个公有库，<code>CocoaPods</code>不允许有重名的公有库存在。</p>
<ul>
<li>最后所有的验证都通过了也上传成功了，结果使用<code>pod search</code>仍然搜索不到。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7076e838dbb41cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>解决办法：<br>1、执行<code>pod setup</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fd244d2a25ef7af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果最底下会输出<code>setup completed</code>。说明执行<code>pod setup</code>成功。<br>2、如果<code>pod search</code>操作还是搜索失败，删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure></p>
<p>3、执行<code>pod search</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be3fa814cb06d76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即上一篇&lt;a href=&quot;https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%9
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库/</id>
    <published>2016-12-08T05:45:50.000Z</published>
    <updated>2017-08-08T06:00:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在开发过程中，经常会使用到第三框架，我们通过一个<code>pod install</code>命令，很方便的就将第三方框架加到我们自己的项目中。</p>
<p>如果我们也想将自己写的组件或库开源出去，让别人也可以通过<code>pod install</code>命令安装自己的框架该怎么做呢？下面，我就教大家一步一步的将自己的<code>pods</code>发布到<code>CocoaPods</code>中。如果你现在对<code>CocoaPods</code>还不太了解，推荐你看一看这篇文章：<a href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">CocoaPods的安装与使用</a></p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>1、注册<code>CocoaPods</code>账户信息<br>2、创建共享库文件并上传到公有仓库<br>3、编辑<code>.podspec</code>文件<br>4、打<code>tag</code>, 发布一个<code>release</code>版本<br>5、发布自己的库描述文件<code>podspec</code>给<code>cocoapods</code><br>6、关于查找和使用新创建的库<br>7、更新维护<code>podspec</code></p>
<p>下面就创建<code>CocoaPods</code>公有库做一下分享：</p>
<p>一、在github上创建项目，复制项目的链接路径，例如：<a href="https://github.com/sunjinshuai/MYSementManager" target="_blank" rel="external">https://github.com/sunjinshuai/MYSementManager</a>;</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-18287791668c31f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br>1、<code>GitHub</code>仓库的名称，不允许重名。<br>2、开源协议，一般都选择<code>MIT</code>。</p>
<p>二、使用命令行、<code>sourceTree</code>或者<code>GitHub Mac</code>版将项目克隆到本地新建的一个文件夹中;</p>
<p>三、cd进入本地该文件夹，将自己之前的工程文件(demo)以及共享文件(共享库Lib)拖入其中，并创建公有仓库，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create cocoaPodsName;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e67a3ac9fd6604f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br>1、自己的工程文件(demo)以及共享文件(共享库Lib)。<br>2、<code>MYSementManager.podspec</code>创建的公有库名称。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-20364e263a61e972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当<code>Specification created at MYSementManager.podspec</code>说明创建公有库成功。</p>
<p>四、使用文本编辑器或者<code>sublime</code>等编辑公有仓库信息(注意：引号不能搞错了，是英文格式的””,不是中文格式“”)，默认选择文本编辑器。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ae92088a994e1ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1、s.name：公有库的名称。</div><div class="line">2、s.version：公有库的版本。</div><div class="line">3、s.summary：公有库简短介绍。</div><div class="line">4、s.description：公有库详细介绍。</div><div class="line">5、s.homepage：公有库在GitHub上的地址。</div><div class="line">6、s.license：开源协议。</div><div class="line">7、s.author：作者。</div><div class="line">8、s.source：公有库在GitHub上的地址和版本号。</div><div class="line">9、s.source_files：公有库对外共享的.h和.m文件。</div><div class="line">10、s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<p>没有涉及到的字段可以去<a href="http://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="external">官方文档</a>查阅。</p>
<p>五、编辑结束保存，并验证本地的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint cocoaPodsName.podspec</div></pre></td></tr></table></figure>
<p>六、验证有效后，然后再将本地该文件夹中所有的文件<code>push</code>到<code>github</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin https://github.com/sunjinshuai/test.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>使用<code>git tag</code>(此方法操作后再<code>push</code>上传一次)或者直接在<code>github</code>上点击<code>release</code>进入后创建<code>release</code>并给公有仓库打上<code>tag</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -m &quot;first release&quot; 0.0.1</div><div class="line">$ git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<p>七、注册<code>trunk</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk register 邮箱 ‘用户名’ --description=‘描述’</div></pre></td></tr></table></figure>
<p>注意：<br>邮箱为<code>github</code>上的登录邮箱、用户名为<code>github</code>上的用户名。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e5852a3ef0d784db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>接收发送到邮箱的链接，点击进入后注册成功。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-31ebbd1972d0b840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>查看注册的个人信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk me</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1c00ba7b4cc7dee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>验证上传到<code>github</code>上的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec lint cocoaPodsName.podspec</div></pre></td></tr></table></figure>
<p>八、将公有仓库推送到<code>CocoaPods</code>上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk push cocoaPodsName.podspec</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3b58f26ecefe1456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>大功告成，使用<code>pod search cocoaPodsName</code>搜索即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ebd6b6df003a75e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在开发过程中，经常会使用到第三框架，我们通过一个&lt;code&gt;pod install&lt;/code&gt;命令，很方便的就将第三方框架加到我们自己的项
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程之二：NSThread的使用</title>
    <link href="https://sunjinshuai.github.io/2016/11/18/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BA%8C%EF%BC%9ANSThread%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/11/18/iOS多线程之二：NSThread的使用/</id>
    <published>2016-11-18T14:00:52.000Z</published>
    <updated>2017-12-18T14:19:04.298Z</updated>
    
    <content type="html"><![CDATA[<p>NSThread<br>NSThread封装性最差，最偏向于底层，主要基于thread使用，生命周期需要手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。</p>
<p>一、线程创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建并自动启动</div><div class="line">[NSThread detachNewThreadSelector:@selector(threadAlloc:) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">// 先创建线程，再启动</div><div class="line">NSThread *newThread = [[NSThread alloc] initWithTarget:self selector:@selector(run:) object:obj];</div><div class="line">[newThread run];</div><div class="line"></div><div class="line">// ios(10.0)，线程的创建，线程创建后直接运行</div><div class="line">[NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">[do something];</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:obj];</div></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2017/10/23/b99d29bda1bf4201f75954bb76d32fbc" alt="Paste_Image.png"></p>
<p>二、线程之间的通讯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 在主线程中运行方法，wait表示是否阻塞这个方法的调用，如果为YES则等待主线程中运行方法结束，一般可用于在子线程中调用UI方法。</div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div><div class="line"></div><div class="line">// 隐含产生新线程</div><div class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg;</div><div class="line"></div><div class="line">// 在指定线程中执行，但该线程必须具备run loop。</div><div class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</div></pre></td></tr></table></figure>
<p>三、NSThread的其它一些常用的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">+ (NSThread *)currentThread;                     // 获得当前线程</div><div class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti; // 线程休眠</div><div class="line">+ (NSThread *)mainThread;                        // 主线程，亦即UI线程了</div><div class="line">+ (BOOL)isMainThread;                            // 判断当前线程是否是主线程</div><div class="line">+ (BOOL)isMultiThreaded;                         // 判断当前线程是否是多线程</div><div class="line">+ (void)sleepUntilDate:(NSDate *)date;           // 当前线程休眠到指定日期</div><div class="line">+ (void)exit;                                    // 强行退出当前线程</div><div class="line">+ (double)threadPriority;                        // 获取当前线程线程优先级</div><div class="line">+ (BOOL)setThreadPriority:(double)p;             // 给当前线程设定优先级，调度优先级的取值范围是0.0 ~ 1.0，默认0.5，值越大，优先级越高。</div><div class="line">+ (NSArray *)callStackReturnAddresses            // 线程的调用都会有函数的调用函数的调用就会有栈返回地址的记录，在这里返回的是函 数调用返回的虚拟地址，说白了就是在该线程中函数调用的虚拟地址的数组</div><div class="line">+ (NSArray *)callStackSymbols                    // 同上面的方法一样，只不过返回的是该线程调用函数的名字数字</div><div class="line">+ (BOOL)isMainThread;                            // 当前线程是否主线程</div><div class="line">- (BOOL)isMainThread;</div><div class="line">- (BOOL)isExecuting;                             // 线程是否正在运行</div><div class="line">- (BOOL)isFinished;                              // 线程是否已结束</div><div class="line">- (void)cancel                                   // 终止线程循环</div><div class="line">- (void)start                                    // 开启线程循环</div><div class="line">- (void)isCancelled;                             // 判断线程是否撤销</div><div class="line">- (void)setName:(NSString *)n;                   // 设置线程名称</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSThread&lt;br&gt;NSThread封装性最差，最偏向于底层，主要基于thread使用，生命周期需要手动管理，所以这套方案也是偶尔用用，比如 [NSThread currentThread]，它可以获取当前线程类，你就可以知道当前线程的各种属性，用于调试十分方便。&lt;/p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程之一：基本概念</title>
    <link href="https://sunjinshuai.github.io/2016/11/17/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sunjinshuai.github.io/2016/11/17/iOS多线程之一：基本概念/</id>
    <published>2016-11-17T15:00:10.000Z</published>
    <updated>2017-12-18T14:19:19.346Z</updated>
    
    <content type="html"><![CDATA[<p>计算机操作系统都有的基本概念，以下概念简单方式来描述。</p>
<p><code>进程</code>：就是一个正在执行的程序。<br><code>线程</code>：是执行程序最基本的单元，它有自己栈和寄存器。</p>
<blockquote>
<p>进程和线程的区别<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
</blockquote>
<p><code>并发</code>：多个任务同时发生，需要被处理。比如，田径赛场上的起跑线上有多个运动员等待起跑。<br><code>并行</code>：在某一个时间能够同时处理多个任务。比如，火车站开放了多个检票口，同一时间能够服务多个旅客。<br><code>串行</code>：线程执行只能依次逐一先后有序的执行，串行中，一个任务的执行必须以上一个任务执行结束为前提。</p>
<blockquote>
<p>串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提，并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来，串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。</p>
</blockquote>
<p><code>同步</code>：就是顺序往下执行。举例：烧完水后泡茶<br><code>异步</code>：就是几件事情同时在执行。烧水的时候拿出茶具，洗茶具，然后泡茶。其中烧水和拿茶具，洗茶具是同时进行的。</p>
<p>二、iOS多线程方案</p>
<p>在<code>iOS</code>中其实目前有4套多线程方案，他们分别是：<br>1、pthreads<br>2、NSThread<br>3、GCD<br>4、NSOperation &amp; NSOperationQueue</p>
<p>参考：(<a href="http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html" target="_blank" rel="external">http://www.cnblogs.com/lmule/archive/2010/08/18/1802774.html</a>)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机操作系统都有的基本概念，以下概念简单方式来描述。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;进程&lt;/code&gt;：就是一个正在执行的程序。&lt;br&gt;&lt;code&gt;线程&lt;/code&gt;：是执行程序最基本的单元，它有自己栈和寄存器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程和线程的区别&lt;br
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AutoreleasePool的实现原理</title>
    <link href="https://sunjinshuai.github.io/2016/10/06/AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2016/10/06/AutoreleasePool的实现原理/</id>
    <published>2016-10-06T06:32:16.000Z</published>
    <updated>2017-07-06T08:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题：autorelease对象什么时候释放。"><a href="#面试题：autorelease对象什么时候释放。" class="headerlink" title="面试题：autorelease对象什么时候释放。"></a>面试题：autorelease对象什么时候释放。</h4><p>autorelease的本质就是延迟调用<code>release</code>方法，在MRC的环境下，可以通过调用<code>[obj autorelease]</code>来延迟释放内存，在ARC的环境下，当我们创建一个对象，会将对象添加到当前的<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时，会对<code>autoreleasepool</code>里面的所有对象做一次<code>release</code>操作。在没有手动加入<code>autoreleasepool</code>的情况下，<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池<code>push</code>和<code>pop</code>。</p>
<p>当<code>autoreleasepool</code>销毁时，在调用堆栈中可以发现，系统调用了<code>-[NSAutoreleasePool release]</code>方法，这个方法最终通过调用<code>AutoreleasePoolPage::pop(void *)</code>函数来负责对<code>autoreleasepool</code>中的<code>autorelease</code>对象执行<code>release</code>操作。</p>
<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>我们打开<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a> 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到<code>autoreleasepool</code>的实现源码。其实，<code>autoreleasepool</code>是没有单独的内存结构的，它是通过以<code>AutoreleasePoolPage</code>为结点的双向链表来实现的。</p>
<ul>
<li>每一个线程的<code>autoreleasepool</code>其实就是一个指针的堆栈，结构中的thread指针指向当前线程；</li>
<li>每一个指针代表一个需要<code>release</code>的对象或者<code>POOL_SENTINEL</code>（哨兵对象，代表一个<code>autoreleasepool</code>的边界）；</li>
<li>一个<code>pool token</code>指向<code>autoreleasepool</code>所对应的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>；</li>
</ul>
<p>一个空的<code>AutoreleasePoolPage</code>的内存结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/588630-f64cda7c9112e5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><code>magic</code>用来校验<code>AutoreleasePoolPage</code>的结构是否完整；</li>
<li><code>next</code>指向最新添加的<code>autorelease</code>对象的下一个位置，初始化时指向 begin() ；</li>
<li><code>thread</code>指向当前线程；</li>
<li><code>parent</code>指向父结点，第一个结点的 parent 值为 nil ；</li>
<li><code>child</code>指向子结点，最后一个结点的 child 值为 nil ；</li>
<li><code>depth</code>代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code>代表 high water mark 。</li>
</ul>
<p>当<code>AutoreleasePoolPage</code>里面的<code>autorelease</code>对象满了，也就是next指针指向了栈顶，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>AutoreleasePoolPage</code>加入，新<code>AutoreleasePoolPage</code>的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。<br>另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。<br>所以，向一个对象发送<code>release</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶next指针指向的位置。</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a><code>autoreleasepool</code></h4><p>使用<code>clang -rewrite-objc</code>命令将下面的 Objective-C 代码重写成 C++ 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</div><div class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</div><div class="line"></div><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个<code>__AtAutoreleasePool</code>类型的局部变量<code>__autoreleasepool</code>来实现<code>@autoreleasepool {}</code>。当声明<code>__autoreleasepool</code>变量时，构造函数<code>__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p>当出了当前作用域时，析构函数<code>~__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure></p>
<p>也就是说<code>@autoreleasepool {}</code>的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line">    void *atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">    // 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</div><div class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code>、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a>objc_autoreleasePoolPush()</h4><p>上面提到的<code>objc_autoreleasePoolPush()</code>函数本质上就是调用的<code>AutoreleasePoolPage</code>的<code>push</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return nil;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据源码得出，每次执行<code>objc_autoreleasePoolPush</code>其实就是创建了一个新的<code>autoreleasepool</code>，对应<code>AutoreleasePoolPage</code>的具体实现就是往<code>AutoreleasePoolPage</code>中的<code>next</code>位置插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>的内存地址。并且把<code>pool token</code>指针指向这个地址，在执行<code>pop</code>操作的时候作为函数的入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline void *push()</div><div class="line">&#123;</div><div class="line">    id *dest = autoreleaseFast(POOL_SENTINEL);</div><div class="line">    assert(*dest == POOL_SENTINEL);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>push</code>函数通过调用<code>autoreleaseFast</code>函数来执行具体的插入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>autoreleaseFast</code>函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前<code>page</code>存在且没有满时，直接将对象添加到当前<code>page</code>中，即<code>next</code>指向的位置；</li>
<li>当前<code>page</code>存在且已满时，创建一个新的<code>page</code> ，并将对象添加到新创建的<code>page</code>中；</li>
<li>当前<code>page</code>不存在时，即还没有<code>page</code>时，创建第一个<code>page</code>，并将对象添加到新创建的<code>page</code>中。<br>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。</li>
</ul>
<h4 id="objc-autoreleasePoolPop-void"><a href="#objc-autoreleasePoolPop-void" class="headerlink" title="objc_autoreleasePoolPop(void *)"></a>objc_autoreleasePoolPop(void *)</h4><p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return;</div><div class="line"></div><div class="line">    // fixme rdar://9167170</div><div class="line">    if (!ctxt) return;</div><div class="line"></div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pop</code>函数的入参就是<code>push</code>函数的返回值，也就是<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>，直到<code>pool token</code>所在<code>page</code>的<code>next</code>指向<code>pool token</code>为止。</p>
<h4 id="autorelease对象释放原理"><a href="#autorelease对象释放原理" class="headerlink" title="autorelease对象释放原理"></a>autorelease对象释放原理</h4><p>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，在执行<code>objc_autoreleasePoolPop(void *)</code>操作的时候作为函数的入参。<br><img src="http://upload-images.jianshu.io/upload_images/588630-cf6a8a8bd44f721c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前<code>AutoreleasePoolPage</code>中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次<code>release</code>消息，并向回移动next指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个<code>AutoreleasePoolPage</code>，直到哨兵所在的<code>AutoreleasePoolPage</code>。</li>
</ul>
<p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数，当执行<code>pop</code>操作后，<br><img src="http://upload-images.jianshu.io/upload_images/588630-ee6388ccaec8b86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;a href=&quot;#面试题：autorelease对象什么时候释放。&quot; class=&quot;headerlink&quot; title=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;/a&gt;面试题：autoreleas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Load&amp;Initialize</title>
    <link href="https://sunjinshuai.github.io/2016/09/19/Load-Initialize/"/>
    <id>https://sunjinshuai.github.io/2016/09/19/Load-Initialize/</id>
    <published>2016-09-19T15:20:55.000Z</published>
    <updated>2017-11-29T15:22:09.163Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (void)load;</div><div class="line">+ (void)initialize;</div></pre></td></tr></table></figure>
<h2 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h2><p>如果你实现了 <code>+ load</code> 方法，那么当类被加载到内存时，它会自动被调用，并且是在 <code>main</code> 函数调用之前被调用。</p>
<h4 id="load-方法的调用栈"><a href="#load-方法的调用栈" class="headerlink" title="load 方法的调用栈"></a>load 方法的调用栈</h4><p>首先分析一下 <code>load</code> 方法是如何被调用的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-79f9a27a6fad634c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从控制台的打印可以看出，运行之后，依然打印了 <code>XXXX load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p><code>load</code> 方法的调用顺序其实有迹可循，我们看到 <code>demo</code> 的项目设置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-578317d4cc2d9920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在 <code>TARGETS -&gt; Build Phases -&gt; Compile Sources</code>中调整一下文件的加载顺序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-0bdb3567814e7f69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果发现：</p>
<ul>
<li>在 <code>load</code> 方法的调用中会自动调用父类的方法，即<strong>父类先于子类调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>文件的加载顺序靠前的类优先调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>类先于分类调用</strong>。</li>
<li>在 <code>load</code> 方法的调用中，<strong>文件的加载顺序靠前的分类优先调用</strong>。</li>
</ul>
<h4 id="load方法如何加载到内存中"><a href="#load方法如何加载到内存中" class="headerlink" title="load方法如何加载到内存中"></a><code>load</code>方法如何加载到内存中</h4><p>使用 <code>Xcode</code> 添加一个符号断点 <code>+[Parent load]</code>：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fc3a92e363d99516.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p>
<p>重新运行程序。这时，代码会停在 <code>NSLog(@&quot;%@ , %s&quot;, [self class], __FUNCTION__);</code> 这一行的实现上：</p>
<p>左侧的调用栈很清楚的展示哪些方法被调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[Parent load]</div><div class="line">1  call_load_methods</div><div class="line">2  load_images</div><div class="line">3  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">...</div><div class="line">13 _dyld_start</div></pre></td></tr></table></figure>
<p>从runtime初始化开始</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9494f2a6913b9e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当 <code>Objective-C</code> 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入运行时的时候，进行回调。</p>
<ul>
<li><code>map_images</code> 主要是在 <code>image</code> 加载进内容后对其二进制内容进行解析，初始化里面的类的结构等。</li>
<li><code>load_images</code> 主要是调用 <code>call_load_methods</code>。按照继承层次依次调用 <code>Class</code> 的 <code>+load</code> 方法然后再是 <code>Category</code> 的 <code>+load</code> 方法。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ab9a17fe1c457f6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ec529c4bedd7e4ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从源码中可以看出，</p>
<ul>
<li>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> 递归把当前类和没有调用 <code>+ load</code> 方法的父类，通过 <code>add_class_to_loadable_list(cls)</code> 方法添加到 <code>loadable_classes</code> 列表中，<strong>保证父类在子类前调用 <code>+load</code> 方法</strong>。</li>
<li>通过 <code>_getObjc2NonlazyCategoryList</code> 获取所有的分类的列表之后，会通过 <code>remapClass</code> 获取分类对应的指针，然后调用<code>add_category_to_loadable_list</code> 把当前分类添加到 <code>loadable_categories</code> 列表中。</li>
</ul>
<p>在将镜像加载到运行时、对 <code>+load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>+load</code> 方法：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-908e53a2462438c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>不停调用类的 <code>+load</code> 方法，直到 <code>loadable_classes</code> 为空。</li>
<li>然后调用一次 <code>call_category_loads</code> 加载分类。</li>
<li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>+load</code> 方法。</li>
<li><strong>类先于分类调用</strong>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5c3408d006682624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后通过对应的 <code>SEL</code> ，找到 <code>IMP</code> 的实现并执行。</p>
<h4 id="load-方法的应用"><a href="#load-方法的应用" class="headerlink" title="load 方法的应用"></a>load 方法的应用</h4><p>由于调用 <code>+load</code> 方法运行时间过早，环境很不安全，我们应该尽量减少 <code>+load</code> 方法的逻辑。另一个原因是load方法是线程安全的，它内部使用了锁，所以我们应该避免线程阻塞在 <code>+load</code> 方法中。不过在这个时间点，所有的 <code>framework</code> 都已经加载到了运行时中，所以调用 <code>framework</code> 中的方法都是安全的。</p>
<h2 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h2><ul>
<li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用。</li>
<li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都已经加载到了内存中。</li>
<li><code>initialize</code> 的运行是线程安全的。</li>
<li>子类会继承父类的 <code>initialize</code> 方法。</li>
</ul>
<h4 id="执行顺序-1"><a href="#执行顺序-1" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>在项目中没有引用任何文件，当我们运行项目，会发现与 <code>load</code> 方法不同的是，虽然我们在 <code>initialize</code> 方法中调用了 <code>NSLog</code>。但是程序运行之后没有任何输出。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1ed8f3a5cc66ad20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>结果发现：<br>没有直接调用 <code>initialize</code> 方法。但是，这里也打印出了 <code>XXXX initialize</code> 字符串。</p>
<p><strong> <code>initialize</code> 只会在对应类的方法第一次被调用时，才会调用。</strong></p>
<p>由于子类会继承父类的 <code>initialize</code> 方法，即使子类没有实现 <code>initialize</code> 方法，也会调用父类的方法，这会导致一个很严重的问题：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e7b192de1527d86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>运行后发现父类的 <code>initialize</code> 方法竟然调用了两次：</p>
<p>虽然 <code>initialize</code> 方法对一个类而言只会调用一次，但这里由于出现了两个类，所以调用两次符合规则，但不符合我们的需求。正确使用initialize方法的姿势如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// In Parent.m</div><div class="line">+ (void)initialize &#123;</div><div class="line">if (self == [Parent class]) &#123;</div><div class="line">NSLog(@&quot;Initialize Parent, caller Class %@&quot;, [self class]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加上判断后，就不会因为子类而调用到自己的 <code>initialize</code> 方法了。</p>
<p><strong> 如果在分类中也实现了 <code>initialize</code>  方法，则会出现方法”覆盖”</strong>。</p>
<p>在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4b45dbbbeceffd7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从runtime初始化开始</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9eca14718fb589ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>lookUpImpOrForward</code> 方法只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时才会调用。</p>
<h4 id="Initialize-方法的应用"><a href="#Initialize-方法的应用" class="headerlink" title="Initialize 方法的应用"></a>Initialize 方法的应用</h4><p>由于 <code>initialize</code> 作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocoaPods的安装与使用</title>
    <link href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/08/08/CocoaPods的安装与使用/</id>
    <published>2016-08-08T03:16:06.000Z</published>
    <updated>2017-08-08T04:00:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Cocoapods</code>是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。</p>
<p>当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当前的步伐，而应该不断进取，要做到能想<code>Cocoapods</code>提交项目，并且在自己项目中熟练应用该工具的程度。特别是如果一个大的公司来说的话,就有可能进行模块化开发了。对于国内很多公司还是在用OC来说的话，<code>Cocoapods</code>应该还是一个不错的模块管理的工具。</p>
<h4 id="升级ruby源"><a href="#升级ruby源" class="headerlink" title="升级ruby源"></a>升级ruby源</h4><p>安装<code>Cocoapods</code>需要用到<code>ruby</code>，Mac系统自带<code>ruby</code>，但如果不是最新的系统，最好更新一下。</p>
<p>注意：<br><code>ruby</code>的软件源<code>rubygems.org</code>被墙了，所以先换一下源。</p>
<ul>
<li>首先，执行以下命令删除原来的ruby源：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources --remove https://rubygems.org/</div></pre></td></tr></table></figure>
<p>注意：<br>执行命令后可在终端看见以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://rubygems.org/ removed from sources</div></pre></td></tr></table></figure>
<ul>
<li>然后下一步添加你找到的可用的镜像源(这里我没有用淘宝的源：<a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a>):</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -a https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<ul>
<li>验证新源是否替换成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem sources -l</div></pre></td></tr></table></figure>
<p>终端输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*** CURRENT SOURCES ***</div><div class="line">https://gems.ruby-china.org/</div></pre></td></tr></table></figure>
<p>到此<code>ruby</code>源替已经换成国内的源。</p>
<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h5 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h5><p>问题1、<code>While executing gem ... (Errno::EPERM)  Operation not permitted - /usr/bin/fuzzy_match</code>错误</p>
<p>解决方法:</p>
<p>执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure></p>
<p>然后提示<code>gems installed</code>即可。</p>
<p>问题2、<code>Error installing pods:active support requires Ruby version &gt;= 2.2.2</code><br>解决方案:</p>
<p>查看<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -v</div></pre></td></tr></table></figure>
<p>终端会输出你的<code>ruby</code>版本信息</p>
<p>查看目前的所有<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm list known</div></pre></td></tr></table></figure>
<p>如果提示<code>command not found</code>请先安装<code>rvm</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -L get.rvm.io | bash -s stable</div></pre></td></tr></table></figure>
<p>如果已安装会列出所有的<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># MRI Rubies</div><div class="line">[ruby-]1.8.6[-p420]</div><div class="line">[ruby-]1.8.7[-head] # security released on head</div><div class="line">[ruby-]1.9.1[-p431]</div><div class="line">[ruby-]1.9.2[-p330]</div><div class="line">[ruby-]1.9.3[-p551]</div><div class="line">[ruby-]2.0.0[-p648]</div><div class="line">[ruby-]2.1[.10]</div><div class="line">[ruby-]2.2[.6]</div><div class="line">[ruby-]2.3[.3]</div><div class="line">[ruby-]2.4[.0]</div><div class="line">ruby-head</div><div class="line"></div><div class="line"># for forks use: rvm install ruby-head-&lt;name&gt; --url https://github.com/github/ruby.git --branch 2.2</div><div class="line"></div><div class="line"># JRuby</div><div class="line">jruby-1.6[.8]</div><div class="line">jruby-1.7[.26]</div><div class="line">jruby[-9.1.7.0]</div><div class="line">jruby-head</div><div class="line"></div><div class="line"># Rubinius</div><div class="line">rbx-1[.4.3]</div></pre></td></tr></table></figure>
<p>然后安装最新的<code>ruby</code>版本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install cocoapods</div></pre></td></tr></table></figure>
<h4 id="CocoaPods的使用"><a href="#CocoaPods的使用" class="headerlink" title="CocoaPods的使用"></a>CocoaPods的使用</h4><ul>
<li>查找第三方库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search AFNetworking</div></pre></td></tr></table></figure>
<ul>
<li>创建Podfile文件</li>
</ul>
<p>在终端使用cd ＋路径切换到项目所在文件下，然后输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch Podfile</div></pre></td></tr></table></figure>
<p>就可以在项目目录里看到<code>Podfile</code>文件。也可以使用<code>pod init</code>来创建，<code>Podfile</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod init</div></pre></td></tr></table></figure>
<p>打开Podfile文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open Podfile</div></pre></td></tr></table></figure>
<p>然后<code>pod install</code>就可以了</p>
<h4 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h4><p>由于有<code>Podfile.lock</code>文件的保护下，在没有执行<code>pod update</code>命令的情况下，是不会将已有的第三方库进行升级的。所以运行<code>pod install</code>的情况下还是能编译通过的。</p>
<ul>
<li>pod</li>
</ul>
<p>一般在<code>Podfile</code>里面如果引入第三方库，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div></pre></td></tr></table></figure>
<p>可以看出<code>pod</code>关键字后面可以跟参数:</p>
<p>参数一： 版本号<br>从上面可以看得出<code>AFNetworking</code>后面跟了参数版本号。<br>不过版本号可以是大于、小于、等于等。当然具体的可以是’&gt; 3.1.0’, ‘&gt;= 3.1.0’, ‘&lt; 3.1.0’, ‘3.1.0’以及’~&gt; 3.1.0’。关于普通的就没什么好说了，最后一个~&gt;指的是正对最后一位来说。如使用’~&gt; 3.1.0’,意味着’&gt;= 3.1.0’并且’&lt; 3.2.0’的意思。</p>
<p>参数二：地址<br><code>Cocoapods</code>可以指定某一个<code>git</code>的目录或者是本地的目录。有的时候我们希望一直用某一个版本最新的版本，即使没有打版本的话，我们可以直接后面接上:<code>git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;</code>。<br>当然除了这种情况外，还有可能是如果是我们自己开发的私有库，并且在开发阶段的情况下，可能就希望开发模式进行引用，则可以使用path参数:<code>:path =&gt; &#39;~/Documents/AFNetworking</code>。</p>
<p>参数三：tag、branche、commit<br>有的时候我们希望引用有一个<code>tag</code>，<code>branch</code>或者是<code>comit</code>的内容的话可以使用这个参数，分别用<code>:branch =&gt; &#39;branch名&#39;</code>、<code>:tag =&gt; &#39;tag名&#39;</code>、<code>:commit =&gt; &#39;提交号&#39;</code>。</p>
<ul>
<li>platform</li>
</ul>
<p>这个参数是只依赖的库希望在哪个平台被编译，比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">platform :ios, &apos;7.0&apos;</div></pre></td></tr></table></figure>
<ul>
<li>target</li>
</ul>
<p>这个是指定具体的配置是适配在哪个target，这里的target值得就是Xcode中的target。如果对于一些项目中你的不同target引用的框架不同的话，可以采用这个进行区分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">target &quot;ShowsApp&quot; do  </div><div class="line">  pod &apos;ShowsKit&apos;</div><div class="line">  target &quot;ShowsTV&quot; do</div><div class="line">    pod &quot;ShowTVAuth&quot;</div><div class="line">  end</div><div class="line">end</div></pre></td></tr></table></figure>
<ul>
<li>use_frameworks!</li>
</ul>
<p>这个指明编译成动态库，而不是静态库，特别是在使用Swift库的过程中，特别需要使用这句。不过他会把所有项目的编译动态库，这一点有点不好。不过在使用Swift库的过程中就没办法了。</p>
<ul>
<li>source</li>
</ul>
<p>这个参数是指Cocoapods从哪些仓库(Spec)中获得框架的源代码，如果在结合使用开源库以及自己私有库的情况下，这个参数还是非常有意义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source &apos;https://github.com/artsy/Specs.git&apos;  </div><div class="line">source &apos;https://192.168.0.90:8888/MySepcs/Specs.git&apos;</div></pre></td></tr></table></figure>
<h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>使用CocoaPods来添加第三方类库，无论是执行pod install还是pod update都卡在了Analyzing dependencies不动，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod install --verbose --no-repo-update</div><div class="line">pod update --verbose --no-repo-update</div></pre></td></tr></table></figure>
<p>pod install只会按照Podfile的要求来请求类库，如果类库版本号有变化，那么将获取失败。但是pod update会更新所有的类库，获取最新版本的类库。每次用pod update就行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Cocoapods&lt;/code&gt;是一个框架依赖管理的一个管理工具，主要是用来管理框架一些开源库在项目中的引用。简而言之就是用来管理你的项目中对开源框架或自己公司子模块的依赖。&lt;/p&gt;
&lt;p&gt;当然作为开发者来说，入门教程特别简单。但是作为一个开发人员不能只满足于当
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git中merge、rebase的区别</title>
    <link href="https://sunjinshuai.github.io/2016/08/04/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2016/08/04/源码管理工具之git中merge、rebase的区别/</id>
    <published>2016-08-04T06:15:32.000Z</published>
    <updated>2017-08-04T07:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般在公司git整合分支一般有两种方法——快速向前合并<code>git rebase</code>和三路合并<code>git merge</code>。其实在开发中，<code>git rebase</code>和<code>git merge</code>表达都是一个意思，即，将一个分支合并到另一个分支。</p>
<p>当开发一个新功能，一般我们会在<code>develop</code>分支上创建<code>featrue</code>分支：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b6359864017521dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当我们这个新功能开发测试完毕之后，首先要把<code>featrue</code>分支合并到<code>develop</code>分支上，一般会根据实际情况选择是否使用<code>git merge</code>还是<code>git rebase</code>。</p>
<p><strong><code>git merge</code></strong><br>根据分支合并的原则，<code>git</code>会自动根据两个分支的共同祖和两个分支的最新提交<code>commit</code>记录进行一个三方合并，然后将合并中修改的内容生成一个新的<code>commit</code>记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git merge master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2fb4e523cea0a269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git merge</code>是一个安全的操作</strong></p>
<p><strong><code>git rebase</code></strong></p>
<p>它会把整个<code>feature</code>分支移动到<code>develop</code>分支的后面，有效地把所有<code>develop</code>分支上新的提交并入过来。但是，<code>git rebase</code>为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git rebase master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93bdffa37317c083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git rebase</code>最大的特点就是让你的项目历史提交记录会非常整洁。</strong><br>首先，它不像<code>git merge</code>那样引入不必要的合并提交。其次，如上图所示，<code>git rebase</code>使项目历史提交记录呈现出一条直线。你可以从项目终点到起点浏览而不需要任何的分叉，可以让你更容易的使用<code>git log</code>查看项目的提交记录。</p>
<p><strong><code>git rebase</code>缺点就是安全性和可跟踪性。</strong></p>
<p><code>git rebase</code>的黄金法则：绝对不要在公共的分支上使用。如果你把<code>master</code>分支<code>rebase</code>到你的<code>feature</code>分支上：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aa37afc6fe4ff411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这次<code>rebase</code>将<code>master</code>分支上的所有提交都移到了<code>feature</code>分支后面。<br>问题是它只发生在你的代码仓库中，而其他所有的开发者还在原来的<code>master</code>上工作。因为<code>rebase</code>引起了新的提交，所以<code>git</code>会认为你的<code>master</code>分支和其他人的<code>master</code>已经分叉了。</p>
<p>同步两个<code>master</code>分支的唯一办法是把它们<code>merge</code>到一起，导致一个额外的合并提交和两堆包含同样更改的提交。</p>
<p><strong><code>git rebase</code>不适用于公共的分支上。</strong></p>
<p>总结：选择<code>git merge</code>还是<code>git rebase</code>？</p>
<ul>
<li><p><code>git merge</code>是一个合并操作，会采用三路合并的方式将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容，生成一个新的<code>commit</code>记录。</p>
</li>
<li><p><code>git rebase</code>并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面，为原分支上每一个提交创建一个新的提交。</p>
</li>
<li><p><code>git merge</code>与<code>git rebase</code>都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般在公司git整合分支一般有两种方法——快速向前合并&lt;code&gt;git rebase&lt;/code&gt;和三路合并&lt;code&gt;git merge&lt;/code&gt;。其实在开发中，&lt;code&gt;git rebase&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;表达都是一个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第3期(2016.08.03)</title>
    <link href="https://sunjinshuai.github.io/2016/08/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E6%9C%9F-2016-08-03/"/>
    <id>https://sunjinshuai.github.io/2016/08/03/iOS学习笔记-第3期-2016-08-03/</id>
    <published>2016-08-03T02:25:15.000Z</published>
    <updated>2017-08-19T05:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>数组容错处理</li>
<li>Foundation中的断言处理</li>
<li>文本计算的坑</li>
<li>UITableview的headerView和footerView高度的设置</li>
<li>UIWebView底部的黑条</li>
</ul>
<h4 id="数组容错处理"><a href="#数组容错处理" class="headerlink" title="数组容错处理"></a>数组容错处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> @method objectAtIndexCheck:</div><div class="line"> @abstract 检查是否越界和NSNull如果是返回nil</div><div class="line"> @result 返回对象</div><div class="line"> */</div><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &gt;= [self count]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id value = [self objectAtIndex:index];</div><div class="line">    if (value == [NSNull null]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h4><p><code>Foundation</code>中定义了两组断言相关的宏，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure></p>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ul>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ul>
<p>当断言失败时，通常是会抛出一个如下所示的异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure></p>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。每个线程都有自己的<code>NSAssertionHandler</code>对象。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure></p>
<p>另外，还定义了一个常量字符串，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure></p>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p><code>Xcode</code>已经默认将<code>release</code>环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. 所以不用担心在开发时候大胆使用。</p>
<p>自定义<code>NSAssertionHandler</code><br><code>NSAssertionHandler</code>实例是自动创建的，用于处理错误断言。如果<code>NSAssert</code>和<code>NSCAssert</code>条件评估为错误，会向<code>NSAssertionHandler</code>实例发送一个表示错误的字符串。每个线程都有它自己的<code>NSAssertionHandler</code>实例。<br>我们可以自定义处理方法，从而使用断言的时候，控制台输出错误，但是程序不会直接崩溃。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyAssertHandler.h&quot;</div><div class="line"></div><div class="line">@implementation MyAssertHandler</div><div class="line"></div><div class="line">//处理Objective-C的断言</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%li&quot;, NSStringFromSelector(selector), object, fileName, (long)line);</div><div class="line">&#125;</div><div class="line">//处理C的断言</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%li&quot;, functionName, fileName, (long)line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>给线程添加处理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义<code>NSAssertionHandler</code>后,程序能够获得断言失败后的信息,但是程序可以继续运行,不会强制退出程序。</p>
<h4 id="文本计算的坑"><a href="#文本计算的坑" class="headerlink" title="文本计算的坑"></a>文本计算的坑</h4><p>一般在开发的时候，很多时候需要先计算出文本在某字体下的宽高，再设置控件的frame。有时候文本计算得到的width和height是小数，有可能最后得到的结果不准确，那么控件的frame也不准确。所以我们经常做的一件事就是<code>Category</code>，即给<code>NSString</code>扩展方法，使用新增的方法统一计算文本的大小，在这些方法中使用ceil()将小数点后数据除去，使得计算的结果小数点后都是0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 单行的</div><div class="line">- (CGSize)textSizeWithFont:(UIFont *)font &#123;</div><div class="line">   CGSize textSize = [self sizeWithAttributes:@&#123;NSFontAttributeName:font&#125;];</div><div class="line">   textSize = CGSizeMake((int)ceil(textSize.width), (int)ceil(textSize.height));</div><div class="line">   return textSize;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根据字体、行数、行间距和constrainedWidth计算多行文本占据的size</div><div class="line">- (CGSize)textSizeWithFont:(UIFont*)font</div><div class="line">             numberOfLines:(NSInteger)numberOfLines</div><div class="line">               lineSpacing:(CGFloat)lineSpacing</div><div class="line">          constrainedWidth:(CGFloat)constrainedWidth</div><div class="line">          isLimitedToLines:(BOOL *)isLimitedToLines &#123;</div><div class="line"></div><div class="line">    if (self.length == 0) &#123;</div><div class="line">        return CGSizeZero;</div><div class="line">    &#125;</div><div class="line">    CGFloat oneLineHeight = font.lineHeight;</div><div class="line">    CGSize textSize = [self boundingRectWithSize:CGSizeMake(constrainedWidth, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size;</div><div class="line"></div><div class="line">    CGFloat rows = textSize.height / oneLineHeight;</div><div class="line">    CGFloat realHeight = oneLineHeight;</div><div class="line">    // 0 不限制行数</div><div class="line">    if (numberOfLines == 0) &#123;</div><div class="line">        if (rows &gt;= 1) &#123;</div><div class="line">            realHeight = (rows * oneLineHeight) + (rows - 1) * lineSpacing;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (rows &gt; numberOfLines) &#123;</div><div class="line">            rows = numberOfLines;</div><div class="line">            if (isLimitedToLines) &#123;</div><div class="line">                *isLimitedToLines = YES;  //被限制</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        realHeight = (rows * oneLineHeight) + (rows - 1) * lineSpacing;</div><div class="line">    &#125;</div><div class="line">    return CGSizeMake(ceil(constrainedWidth),ceil(realHeight));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UITableview的headerView和footerView高度的设置"><a href="#UITableview的headerView和footerView高度的设置" class="headerlink" title="UITableview的headerView和footerView高度的设置"></a>UITableview的headerView和footerView高度的设置</h4><p>一般在项目中使用<code>UITableview</code>的<code>headerView</code>和<code>footerView</code>的时候都会遇到一个问题，即给<code>headerView</code>和<code>footerView</code>高度设置0的时候，发现不好使。经过查阅资料得知如果给<code>headerView</code>和<code>footerView</code>高度设置0，则会被设置成为默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section &#123;</div><div class="line">    return CGFLOAT_MIN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section &#123;</div><div class="line">    return CGFLOAT_MIN;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UIWebView底部的黑条"><a href="#UIWebView底部的黑条" class="headerlink" title="UIWebView底部的黑条"></a>UIWebView底部的黑条</h4><p>一般我使用<code>UIWebView</code>的时候会发现，<code>UIWebView</code>底部的黑条很难看，特别是在底部还有透明控件的时候，隐藏的做法其实很简单，只需要将<code>opaque</code>设为NO，背景色设为<code>clearColor</code>即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组容错处理&lt;/li&gt;
&lt;li&gt;Foundation中的断言处理&lt;/li&gt;
&lt;li&gt;文本计算的坑&lt;/li&gt;
&lt;li&gt;UITableview的headerView和footerView高度的设置&lt;/li&gt;
&lt;li&gt;UIW
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS如何使用TestFlight进行App-Beta版测试</title>
    <link href="https://sunjinshuai.github.io/2016/07/25/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8TestFlight%E8%BF%9B%E8%A1%8CApp-Beta%E7%89%88%E6%B5%8B%E8%AF%95/"/>
    <id>https://sunjinshuai.github.io/2016/07/25/iOS如何使用TestFlight进行App-Beta版测试/</id>
    <published>2016-07-25T14:26:18.000Z</published>
    <updated>2018-06-09T07:10:23.913Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在2014WWDC中库克用了20秒的时间，简短的3句话，介绍了测试版本的TestFlight服务。TestFlight用于将Beta版测试，TestFlight已经被苹果收购，所以不要担心存在第三方测试造成数据泄露问题。TestFlight需要iOS8及以上版本的iOS设备才能运行，所以iOS7及之前的设备就不能安装了。TestFlight整合进了iTunes Connect，开发者可以通过电子邮件来邀请测试员来进行测试，这样开发者就可以更简单地让你的同行非同行、你的上级、你的客户、你所想要一起参与测试的人一起来测试应用。</p>
</blockquote>
<p>TestFlight的测试方式分为两种：</p>
<ul>
<li>一种是内部测试；</li>
<li>一种是外部测试。</li>
</ul>
<p>从功能上讲，这两种方式都可以为测试人员在测试阶段对你的App进行测试。但是既然分了内部测试和外部测试，他们肯定还是有区别的，所谓的内部主要是指iTunes Connect上在你的开发团队里参与技术开发或者管理的成员。最多可以邀请25个内部成员，而与之相对的外部测试，指的是那些不属于你的团队或者公司的测试者，外部测试人员的上限是2000人。这里有一点需要注意的是，在你邀请外部成员参与测试之前，需要先通过苹果的审核，一般审核会在一天左右。而这一限制在内部成员上就没有，也就是说只要你把你的App上传到iTunes Connect上之后内部成员就可以开始进行内部测试了，无需审核。在邀请发出后，有效测试时间为60天。</p>
<p>注意：</p>
<ul>
<li>现在公司也有使用比较老的测试方法，就是需要提供参与app测试人员的设备UDID，并且开发者需要将这些设备的UDID添加到开发者中心，每次有新的测试人员加入，需要重新生成profiles，重新打包，最可恶的是，只能添加100台设备的限制，总体来说，比较笨拙。</li>
<li>使用TestFlight测试的好处，只需要参与app测试人员提供一个邮箱，开发者登录iTunes Connect，给测试者发送邀请，测试者接受邀请，然后通过TestFlight，下载安装程序。不需要用户提供设备的UDID，最重要的一点是没有了100台设备的限制，一般内部测试人员最多25个人，外部测试人员最多2000个人，重点是<strong>不需要重新配置证书了，也不需要手动发送ipa包, 直接上传到iTunes即可。</strong></li>
<li>然而，也有其他公司在使用<strong>蒲公英</strong>等其他参与测试。</li>
</ul>
<p>接下来介绍一下TestFlight如何使用：</p>
<p>一、开发者需要做的事情</p>
<p>1、进入网址：<a href="https://itunesconnect.apple.com/" target="_blank" rel="external">https://itunesconnect.apple.com</a> 输入账号密码登录iTunes Connect。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c88eda738f1?w=1240&amp;h=757&amp;f=png&amp;s=264305" alt="Paste_Image.png"></p>
<p>2、成功登录iTunes Connect，点击我的App，进入App列表页</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c88f2b36fba?w=1240&amp;h=757&amp;f=png&amp;s=114351" alt="Paste_Image.png"></p>
<p>注意：</p>
<p>如果是初次创建的 App，需要创建一个 iTunes Connect Record。如果你的 App 已经创建好了，可以直接跳过这段，如果你要新建一个 App 的话，可以按照下面的步骤来做：</p>
<ul>
<li>登录 <a href="https://itunesconnect.apple.com/" target="_blank" rel="external">iTunes Connect</a> 。</li>
<li>在 iTunes Connect 的首页，点击‘My Apps’图标。</li>
<li>开发者第一次进到这里的时候，这里是个空白页。点击左上角的‘+’号按钮，创建一个新的 App 。在你创建了 App 之后，这里会显示你创建的 App 列表。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c88ed2f9690?w=1240&amp;h=407&amp;f=png&amp;s=25733" alt="Paste_Image.png"></p>
<ul>
<li><p>选择‘New App’。如果你只是 iOS 平台的开发者，这里不会出现其它的选项（如‘New Mac App’）。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c891c1662b4?w=574&amp;h=287&amp;f=png&amp;s=17998" alt="Paste_Image.png"></p>
</li>
<li><p>填写好如下弹窗内的信息，点击‘Create’按钮完成创建。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c891bd44df4?w=460&amp;h=525&amp;f=png&amp;s=25214" alt="Paste_Image.png"></p>
</li>
<li><p>对于一些必填信息，如果未填写的话，Apple 会在对话框内给出如下提示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89215e27c8?w=453&amp;h=525&amp;f=png&amp;s=24156" alt="Paste_Image.png"></p>
</li>
<li><p>提交App到iTunes connect。<br>在 Xcode 中配置好版本和证书信息。<br>选中菜单‘Product-&gt;Archive’将当前代码归档，归档完成后会弹出‘Organizer-Archives’对话框。<br>选择‘Validate’按钮来检测该归档文件是否符合要求。<br>验证通过之后，你可以选择‘Submit’来提交这个归档。</p>
</li>
</ul>
<p>3、每当你提交一个新的build之后，在 iTunes Connect的列表中都会对应的增加一个build。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c894b1da7a1?w=246&amp;h=273&amp;f=png&amp;s=15536" alt="Paste_Image.png"></p>
<p>选择TestFlight，在TestFlight中填写基本信息接收反馈的邮箱地址，隐私政策网址等。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c894b29a88b?w=1240&amp;h=671&amp;f=png&amp;s=87261" alt="Paste_Image.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c894c64b874?w=1240&amp;h=674&amp;f=png&amp;s=92273" alt="Paste_Image.png"></p>
<p>Internal Testing：内部测试<br>External Testing：外部测试</p>
<p>4、邀请测试人员</p>
<ul>
<li>内部测试：<br>点击Internal Testers，添加测试人员（一般内部测试人员最多25个人）<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8971b0d4c9?w=1240&amp;h=637&amp;f=png&amp;s=82502" alt="Paste_Image.png"></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8972dd4153?w=719&amp;h=678&amp;f=png&amp;s=33222" alt="Paste_Image.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8972e9478b?w=1240&amp;h=591&amp;f=png&amp;s=66166" alt="Paste_Image.png"></p>
<p>点击Select Version to Test，添加测试版本</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c898b870435?w=1240&amp;h=632&amp;f=png&amp;s=75184" alt="Paste_Image.png"></p>
<p>选中一个版本，点击OK<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c899566352a?w=646&amp;h=455&amp;f=png&amp;s=42621" alt="Paste_Image.png"></p>
<p>点击save<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c899748f843?w=1240&amp;h=633&amp;f=png&amp;s=93969" alt="Paste_Image.png"></p>
<p>点击Start Testing，之后会收到两封邮件，一封是邀请你加入测试组的邮件，点击同意即可，另一封是成功加入测试组的通知，点击start testing然后跳转到有加粗黑色字体的8个字母测试码的页面，下载TestFlight，然后点击Redeem，输入这8个字母即可下载测试app。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8995757da3?w=499&amp;h=173&amp;f=png&amp;s=17226" alt="Paste_Image.png"></p>
<p>点击Start Testing<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89b3ff16b3?w=888&amp;h=782&amp;f=png&amp;s=220304" alt="Paste_Image.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89c042e467?w=872&amp;h=568&amp;f=png&amp;s=85650" alt="Paste_Image.png"></p>
<ul>
<li>邀请外部测试人员</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89c2650bfd?w=1240&amp;h=466&amp;f=png&amp;s=64747" alt="Paste_Image.png"></p>
<p>点击External Testers，选择添加新测试员，或者使用CSV批量导入邀请外部测试人员。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89c1704a5b?w=1178&amp;h=379&amp;f=png&amp;s=27869" alt="Paste_Image.png"></p>
<p>输入电子邮件，名称和姓氏可不填，点击添加。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89e862f103?w=801&amp;h=677&amp;f=png&amp;s=35961" alt="Paste_Image.png"></p>
<p>点击Add Build to Test，添加测试版本<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89e871b440?w=1175&amp;h=318&amp;f=png&amp;s=19991" alt="Paste_Image.png"></p>
<p>点击Next，进入下一步</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89e92be8c6?w=644&amp;h=460&amp;f=png&amp;s=28775" alt="Paste_Image.png"></p>
<p>填写测试版本的一些信息，点击Next，进入下一步</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c89f54a138b?w=645&amp;h=458&amp;f=png&amp;s=24711" alt="Paste_Image.png"></p>
<p>填写联系人信息，和 Beta App Review审核的测试账号，点击Next，进入下一步</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a13a35fa6?w=646&amp;h=456&amp;f=png&amp;s=26579" alt="Paste_Image.png"></p>
<p>填写审核信息，然后点击submit，提交 Beta 审核，目前来看，Beta 审核还是比较快速的，有时候一个工作日就可以通过审核。可能是现在使用 TestFlight 功能的 App 还不太多吧；不知道等 TestFlight 普及之后，随着参与 Beta Review 的 App 越来越多，Beta 审核还能不能一直这么快。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a0e40939b?w=649&amp;h=453&amp;f=png&amp;s=12644" alt="Paste_Image.png"></p>
<p>注意：</p>
<p>还需要一提的是，外部测试人员想要参与测试的话，必须要 App 已经通过了 Beta App Review 才行。审核通过，点击Invite邀请按钮，测试者会收到来自TestFlight Beta Testing的邀请邮件。</p>
<p>二、开发者需要做的事情</p>
<p>1、在AppStore上面搜索“TestFlight”</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a1994efa3?w=750&amp;h=1334&amp;f=png&amp;s=347471" alt="41B2276FCDA83285299E76566F7CC7A7.png"></p>
<p>2、下载TestFlight</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a1c3739b7?w=750&amp;h=1334&amp;f=png&amp;s=345333" alt="F258A6014C8A0B15D16866DDF08EDE25.png"></p>
<p>3、打开TestFlight进行使用</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a3d2950db?w=640&amp;h=1136&amp;f=jpeg&amp;s=49391" alt="%PIDKXC5O`C%1857`2ZK6W2.jpg"></p>
<p>注意：</p>
<ul>
<li>应用提示是否允许“推送通知”，一般是允许的，提醒测试新版本；</li>
<li>这时候TestFlight内是没什么内容可看的；</li>
<li>等待开发者邀请测试。（注意查看关联Apple ID邮箱的邮件，2封邮件）</li>
</ul>
<p>4、接受邀请iTunes Connect</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a49954acc?w=893&amp;h=418&amp;f=png&amp;s=80338" alt="Paste_Image.png"></p>
<p>注意：</p>
<ul>
<li>打开邮箱邮件（电脑和手机操作都可以）；</li>
<li>点击邮件详情里面的“activate your access”，跳转到iTunes Connect登录页；</li>
<li>登录Apple ID账户，按提示勾选同意协议接受邀请。</li>
<li>这是第一封邮件，只有邀请加入开发者用户才会收到。只需要接受一次即可。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a45e28243?w=194&amp;h=344&amp;f=png&amp;s=26581" alt="Paste_Image.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a6ec014af?w=195&amp;h=343&amp;f=png&amp;s=31211" alt="Paste_Image.png"></p>
<p>5、接受TestFlight测试邀请</p>
<ul>
<li>打开邮箱邮件（电脑和手机操作都可以，推荐手机操作。）；</li>
<li>点击邮件详情里面的“Start Testing”；</li>
<li>打开“TestFlight”（手机操作第2步会自动打开TestFlight）；</li>
<li>在TestFlight显示App信息，可以接收测试邀请“Accept”。<br>ps：这是第二封邮件，只有邀请加入应用测试的才会收到。只需要接受一次即可。</li>
</ul>
<p>电脑操作要有这3步：</p>
<ul>
<li>Get TestFlight from the App Store<br>（翻译：到App Store下载TestFlight）</li>
<li>Open TestFlight and choose Redeem<br>（翻译：打开TestFlight选择Redeem）</li>
<li>Enter xxxxxx and start testing<br>（翻译：输入验证码，然后开始测试）<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a7694eaa0?w=750&amp;h=1334&amp;f=png&amp;s=192092" alt="7A7E0DE90230E930E93080D40EE3C3A3.png"></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a9263322e?w=750&amp;h=1334&amp;f=png&amp;s=126885" alt="56CDFF1CE801FA37ECF0948087D22CED.png"></p>
<p>6、打开TestFlight，输入验证码，Install应用。</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a949d7cf5?w=639&amp;h=1136&amp;f=png&amp;s=95657" alt="A278F5C094C8A1884412D4F2A6434144.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a9cf4f731?w=639&amp;h=1136&amp;f=png&amp;s=103183" alt="35585F326706916C0C05E3680BBEBCC6.png"></p>
<p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8a9bbd3a07?w=639&amp;h=1136&amp;f=png&amp;s=158838" alt="B512850F08A6D399EE6E3DE7F5CF0F8E.png"></p>
<p>注意：</p>
<p>安装完应用，会发现右侧有一个橘红色的点点。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062c8ab27e8045?w=192&amp;h=345&amp;f=png&amp;s=116152" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在2014WWDC中库克用了20秒的时间，简短的3句话，介绍了测试版本的TestFlight服务。TestFlight用于将Beta版测试，TestFlight已经被苹果收购，所以不要担心存在第三方测试造成数据泄露问题。TestFlight需要iO
    
    </summary>
    
    
  </entry>
  
</feed>
