<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2022-01-09T11:51:07.062Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 AutoreleasePool 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2017-10-06T13:50:12.000Z</published>
    <updated>2022-01-09T11:51:07.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p><code>autorelease</code> 对象什么时候释放。</p><p><strong><code>autorelease</code> 的本质就是延迟调用 <code>release</code> 方法</strong></p><p>在 <code>MRC</code> 的环境下，可以通过调用 <code>[obj autorelease]</code> 将对象添加到当前的 <code>autoreleasepool</code> 中，来延迟释放内存； </p><p>在 <code>ARC</code>的环境下，当我们创建一个对象，可以通过 <code>__autoreleasing</code> 修饰符，会将对象添加到当前的 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p><p>注意：</p><ul><li><strong>编译器会检查方法名是否以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开始，如果不是则自动将返回值的对象注册到 <code>autoreleasepool</code> 中；</strong></li><li><strong>以 <code>__weak</code> 修饰的对象，会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong>调用 <code>Foundation</code> 对象的类方法(比如，<code>[NSMutableDictionary dictionary]</code>、<code>[NSArray array]</code> 等)会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong><code>id</code> 的指针或对象的指针在没有显式地指定修饰符时候，会被默认附加上 <code>__autoreleasing</code> 修饰符。</strong></li></ul><p>在没有手动加入 <code>autoreleasepool</code> 的情况下，<code>autorelease</code> 对象是在当前的 <code>runloop</code> 迭代结束时释放的，而它能够释放的原因是<strong>系统在每个 <code>runloop</code> 迭代中都加入了自动释放池 <code>push</code> 和 <code>pop</code></strong>。</p><p>当 <code>autoreleasepool</code> 销毁时，在调用堆栈中可以发现，系统调用了 <code>-[NSAutoreleasePool release]</code> 方法，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 <code>autoreleasepool</code> 中的 <code>autorelease</code> 对象执行 <code>release</code> 操作。</p><h1 id="AutoreleasePool-的实现原理"><a href="#AutoreleasePool-的实现原理" class="headerlink" title="AutoreleasePool 的实现原理"></a>AutoreleasePool 的实现原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>使用 <code>clang -rewrite-objc</code> 命令将下面的 <code>Objective-C</code> 代码重写成 <code>C++</code> 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br></pre></td></tr></table></figure><p>当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure><p>也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line">    void *atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#x2F;&#x2F; 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，单个 <code>autoreleasepool</code> 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code> 、<code>[obj release]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p><img src="588630-c77baf1ba3747632.png" alt="image.png"></p><p>从图中可以看出 </p><ul><li><code>AutoreleasePoolPage</code> 是由双向链表来实现的，<code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</li><li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整；</li><li><code>AutoreleasePool</code> 是按线程一一对应的，结构中的 <code>thread</code> 指针指向当前线程。</li><li><code>AutoreleasePoolPage</code> 会为每个对象会开辟 <code>4096</code> 字节内存。</li><li><code>id *next</code> 指向了下一个为空的内存地址(初始化为栈底)，如果有添加进来的 <code>autorelease</code> 对象，移动到下一个为空的内存地址中。</li></ul><p>如果 <code>AutoreleasePoolPage</code> 里面的 <code>autorelease</code> 对象满了，也就是 <code>id *next</code> 指针指向了栈顶，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来添加的 <code>autorelease</code> 对象在新的 <code>AutoreleasePoolPage</code> 加入，<code>id *next</code> 指针指向新的 <code>AutoreleasePoolPage</code> 为空的内存地址，即栈底。所以，向一个对象发送 <code>release</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的 <code>id *next</code> 指针指向的位置。</p><h3 id="POOL-SENTINEL-哨兵对象"><a href="#POOL-SENTINEL-哨兵对象" class="headerlink" title="POOL_SENTINEL(哨兵对象)"></a>POOL_SENTINEL(哨兵对象)</h3><p><img src="588630-8d76ce26495dfabd.png" alt="image.png"></p><p><strong><code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</strong></p><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>。</p><p>详细参考<a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">POOL_SENTINEL(哨兵对象)</a></p><h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h3><p><code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    if (UseGC) return nil;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码得出，每次执行 <code>objc_autoreleasePoolPush</code> 其实就是创建了一个新的 <code>autoreleasepool</code>，然后会把一个 <code>POOL_SENTINEL</code> <code>push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">    id *dest &#x3D; autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest &#x3D;&#x3D; POOL_SENTINEL);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数并传入哨兵对象  <code>POOL_SENTINEL</code> 来执行具体的插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full.</span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    assert(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    </span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; No pool in place.</span><br><span class="line">    assert(!hotPage());</span><br><span class="line">    </span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">                     (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push an autorelease pool boundary if it wasn&#39;t already requested.</span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p><ul><li>当前 <code>hotPage</code> 存在且没有满时，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 存在且已满时，调用 <code>autoreleaseFullPage</code> 初始化一个新的 <code>page</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 不存在时，调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul><h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><p>objc_autoreleasePoolPop(void *)函数本质上也是调用的AutoreleasePoolPage的pop函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    if (UseGC) return;</span><br><span class="line">    &#x2F;&#x2F; fixme rdar:&#x2F;&#x2F;9167170</span><br><span class="line">    if (!ctxt) return;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; pageForPointer(token);</span><br><span class="line">    id *stop &#x3D; (id *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    if (page-&gt;child) &#123;</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是<code>POOL_SENTINEL</code> 的内存地址。根据这个内存地址找到所在的 <code>AutoreleasePoolPage</code> 然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象。</p><p>总结：<br>每调用一次 <code>push</code> 操作就会创建一个新的 <code>autoreleasepool</code>，然后往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址.<br>在执行 <code>pop</code> 操作的时候传入 <code>POOL_SENTINEL</code>，根据传入的哨兵对象地址找到哨兵对象所处的 <code>page</code><br>在当前AutoreleasePoolPage中，然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象，并把 <code>id next</code> 指针到正确位置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试题：&quot;&gt;&lt;a href=&quot;#面试题：&quot; class=&quot;headerlink&quot; title=&quot;面试题：&quot;&gt;&lt;/a&gt;面试题：&lt;/h1&gt;&lt;p&gt;&lt;code&gt;autorelease&lt;/code&gt; 对象什么时候释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;autore
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</id>
    <published>2016-09-23T14:21:21.000Z</published>
    <updated>2022-01-02T12:43:20.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>加密 <code>encryption</code> 与解密 <code>decryption</code> 使用的是同样的密钥 <code>secret key</code>，对称加密是最快速、最简单的一种加密方式。加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。<br>对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。<br>对称加密通常使用的是相对较小的密钥，一般小于 <code>256bit</code>。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用 <code>1bit</code> 来做这个密钥，那黑客们可以先试着用 <code>0</code> 来解密，不行的话就再用 <code>1</code> 解；但如果你的密钥有 <code>1MB</code> 大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。</p><h1 id="For-Example"><a href="#For-Example" class="headerlink" title="For Example"></a>For Example</h1><p>比如常见的 <code>DES/AES</code> 都是属于对称加密算法。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>算法公开、计算量小、加密速度快、加密效率高。</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。</p><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。<br>私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。<br>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p><h1 id="For-Example-1"><a href="#For-Example-1" class="headerlink" title="For Example"></a>For Example</h1><p><code>RSA</code> 就是最常用的非对称加密算法。<br>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。<br>与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p><p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><h1 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h1><p>安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。</p><h1 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h1><p>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。<br>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。<br>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h1&gt;&lt;p&gt;加密 &lt;code&gt;encryption&lt;/code&gt; 与解密 &lt;code&gt;decryption&lt;/code&gt; 使用的是同样的
      
    
    </summary>
    
    
    
      <category term="http" scheme="https://sunjinshuai.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>[self class] 与 [super class]</title>
    <link href="https://sunjinshuai.github.io/2016/04/17/self-class-%E4%B8%8E-super-class/"/>
    <id>https://sunjinshuai.github.io/2016/04/17/self-class-%E4%B8%8E-super-class/</id>
    <published>2016-04-17T06:31:36.000Z</published>
    <updated>2022-01-09T12:46:51.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果：</span><br><span class="line">2016-04-17 14:21:36.060 Test[8566:568584] NSStringFromClass([self class]) &#x3D; Son 2016-04-17 14:21:36.061 Test[8566:568584] NSStringFromClass([super class]) &#x3D; Son</span><br></pre></td></tr></table></figure><p><code>self</code> 是类的隐藏参数，指向当前调用方法的这个类的实例。<br><code>super</code> 是一个 <code>Magic Keyword</code>， 它本质是一个编译器标示符，和 <code>self</code> 是指向的同一个消息接受者。而不同的是，<code>super</code> 是告诉编译器，调用 <code>class</code> 这个方法时，要去父类的方法，而不是本类里的。</p><p>上面的demo中不管调用 <code>[self class]</code> 还是 <code>[super class]</code>，最终的接受消息的对象都是当前 <code>Son</code> 这个对象。</p><p>当使用 <code>self</code> 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；<br>当使用 <code>super</code> 时，则从父类的方法列表中开始找。</p><p>通过<code>clang</code>命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc test.m</span><br></pre></td></tr></table></figure><p><img src="588630-865511032a51310f.png" alt="image.png"></p><p>从上面的代码中，我们可以发现当在调用 <code>[self class]</code> 时，会转化成 <code>objc_msgSend</code> 方法。看下方法定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br></pre></td></tr></table></figure><p>而在调用 <code>[super class]</code> 时，会转化成 <code>objc_msgSendSuper</code> 方法。看下方法定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br></pre></td></tr></table></figure><p>查看 <code>objc_super</code> 结构体发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_super</code> 结构体有两个成员：</p><ul><li>第一个成员是接收消息的 <code>receiver</code>, 类似于上面的 <code>objc_msgSend</code> 方法第一个参数 <code>self</code>。</li><li>第二个成员是当前类的父类 <code>super_class</code> 。</li></ul><p>所以，当调用 <code>[self class]</code> 时，实际先调用的是 <code>objc_msgSend</code> 方法，第一个参数是接收消息的 <code>receiver</code> 也就是 <code>Son</code> 当前的这个实例，然后在 <code>Son</code> 类的方法列表开始查找 <code>selector</code>，如果没有，则去父类的方法列表开始查找 <code>selector</code>，如果父类里面也没有，则会在 <code>NSObject</code> 查找方法列表开始查找 <code>selector</code>，找到后以 <code>self</code> 去调用父类的这个 <code>selector</code>。</p><p><code>objc Runtime</code> 开源代码对 <code>- (Class)class</code> 方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">  return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>- (Class)class</code> 的实现就是返回 <code>self</code> 自己，故上述输出结果为 <code>Son</code>。</p><p>而当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 方法：</p><ul><li>从 <code>objc_super</code> 结构体指向的 <code>superClass</code> 父类的方法列表开始查找 <code>selector</code>，找到后以 <code>objc-&gt;receiver</code> 去调用父类的这个 <code>selector</code>。</li><li>由于找到了父类 <code>NSObject</code> 里面的 <code>class</code> 方法的 <code>IMP</code> ，又因为传入的入参 <code>objc_super-&gt;receiver</code> 指向 <code>self</code>。<code>self</code> 也就是 <code>Son</code> 当前的这个实例，所以父类的方法 <code>class</code> 执行 <code>IMP</code> 之后，输出还是 <code>Son</code>。<br>最后输出两个都一样，都是输出 <code>Son</code>。</li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/11/06/runtime-nuts/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何使用hexo搭建个人博客</title>
    <link href="https://sunjinshuai.github.io/2016/03/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunjinshuai.github.io/2016/03/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2016-03-05T13:41:47.000Z</published>
    <updated>2022-01-02T12:41:21.729Z</updated>
    
    <content type="html"><![CDATA[<p>经过各种找资料，踩过何种坑，终于搭建好了 <code>hexo</code>，域名目前用得时 <code>github</code> 的，我的 <code>hexo</code> 是 <code>3.2.2</code> 版本，<code>hexo</code> 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p><p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于 <code>CSDN</code>、博客园也都可以写文章，但是页面的样式我不是太喜欢，简书还算好点得。最近看到一些大神们的博客，貌似都是用 <code>hexo</code> 写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>hexo</code>是一个<code>npm</code>包，在<code>node</code>环境上运行，功能就是将你的文章（<code>.md</code>文件）生成为静态<code>html</code>文件。</p><h4 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h4><p>下面正式开始搭建博客！首先要想使用 <code>Hexo</code> 和 <code>github pages</code> 搭建博客，需要以下环境：</p><ul><li>在 <code>github</code> 上注册一个账号，并创建一个指定名字的 <code>reposity</code></li><li><code>homebrew</code> 套件管理器，主要用来安装 <code>git</code> 和 <code>node.js</code></li><li><code>git</code> 版本管理工具</li><li><code>node.js</code></li><li>配置 <code>SSH key</code></li><li>安装 <code>hexo</code></li><li>同步 <code>hexo</code> 博客到 <code>github</code></li></ul><h5 id="注册Github账号并创建reposity"><a href="#注册Github账号并创建reposity" class="headerlink" title="注册Github账号并创建reposity"></a>注册Github账号并创建reposity</h5><p>申请完账号，登陆之后，就可以创建 <code>reposity</code> 了，点击 <code>New repository</code><br>，会跳转到这个界面: </p><p><img src="588630-c658dc0c9c467b19.png" alt="Paste_Image.png"></p><h5 id="安装brewhome"><a href="#安装brewhome" class="headerlink" title="安装brewhome"></a>安装brewhome</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;Homebrew&#x2F;homebrew&#x2F;go&#x2F;install)”</span><br></pre></td></tr></table></figure><p>安装失败, 执行以下脚本卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot; </span><br><span class="line">报错：Failed to locate Homebrew!</span><br></pre></td></tr></table></figure><p>执行以下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;.git rm -rf Library .git .gitignore bin&#x2F;brew README.md share&#x2F;man&#x2F;man1&#x2F;brew rm -rf ~&#x2F;Library&#x2F;Caches&#x2F;Homebrew</span><br></pre></td></tr></table></figure><p>成功后，再次执行，下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><p>下载成功</p><h5 id="安装git版本管理工具"><a href="#安装git版本管理工具" class="headerlink" title="安装git版本管理工具"></a>安装git版本管理工具</h5><p><code>git</code> 是一个强大的版本管理工具，<code>github</code> 的版本管理就是基于 <code>git</code> 的，现在 <code>svn</code> 基本过时了，使用 <code>Git</code> 进行版本管理才是王道。安装完 <code>homebrew</code> 之后，安装 <code>Git</code> 几乎零成本，还是在 <code>terminal</code> 终端，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>然后等一段时间就 <code>ok</code> 了，<code>homebrew</code> 会自动去帮你完成下载安装。</p><h5 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h5><p><code>hexo</code> 是基于 <code>node.js</code> 的，所以要让 <code>hexo</code> 运行，<code>node.js</code> 环境是必不可少的。使用 <code>homebrew</code> 安装 <code>node.js</code> 也特别简单，在 <code>terminal</code> 终端输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>ps：安装最新版的 <code>Node.js</code> 之后，我们就可以使用 <code>npm</code> 命令，在 <code>mac</code> 下遇到 <code>npm</code> 命令找不到的问题，解决方案如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node &#x2F;usr&#x2F;lib&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node-waf &#x2F;usr&#x2F;bin&#x2F;node-waf</span><br></pre></td></tr></table></figure><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>前面我们安装了 <code>node.js</code>，装完 <code>node.js</code> 之后，我们就可以使用 <code>npm</code> 命令了，而 <code>hexo</code> 安装就是使用 <code>npm</code>，在终端输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>ps：等待一会儿，<code>hexo</code> 会自动完成下载安装。等 <code>hexo</code> 安装完成之后，在创建一个文件夹，这个文件夹以后就是你存放本地博客的地方了。</p><h4 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h4><p>创建新建一个文件夹，用来存放本地博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><code>hexo</code>会在创建的文件夹创建本地博客所需的一切资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>访问本地localhost:4000可以看到博客已经搭建成功。</p><h4 id="同步hexo博客到github"><a href="#同步hexo博客到github" class="headerlink" title="同步hexo博客到github"></a>同步hexo博客到github</h4><ul><li>配置本地和<code>github</code>的<code>ssh</code></li><li>在<code>github</code>上创建名字为<code>XXX.github.io</code>的项目，<code>XXX</code>为自己的<code>github</code>用户名。</li><li>开本地的创建的文件夹中的<code>_config.yml</code>配置文件，将其中的<code>type</code>设置为<code>git</code>。</li></ul><h6 id="检查你电脑上现有的ssh-key"><a href="#检查你电脑上现有的ssh-key" class="headerlink" title="检查你电脑上现有的ssh key"></a>检查你电脑上现有的ssh key</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh   # 切换到ssh目录</span><br><span class="line">ls -al ~&#x2F;.ssh # 查看</span><br></pre></td></tr></table></figure><p>注意：<br>如果你本地没有生成的话，终端上面会显示，<code>No such file or directory</code>。说明你是第一次使用git，如果已经存在的话，则会显示<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h6 id="获取ssh"><a href="#获取ssh" class="headerlink" title="获取ssh"></a>获取ssh</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096</span><br></pre></td></tr></table></figure><h6 id="配置github的ssh"><a href="#配置github的ssh" class="headerlink" title="配置github的ssh"></a>配置github的ssh</h6><p>登陆<code>github</code>后，点击右上角自己的头像–&gt;点击Your profile–&gt;点击你的博客远程仓库，页面中就能找到ssh。</p><p><img src="588630-6e5f1d0d3daf4880.png" alt="Paste_Image.png"></p><h4 id="安装自动部署发布工具"><a href="#安装自动部署发布工具" class="headerlink" title="安装自动部署发布工具"></a>安装自动部署发布工具</h4><p>这里用到了 hexo-deployer-git，使用如下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;sunjinshuai&#x2F;sunjinshuai.github.com</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>在terminal终端，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate   &#x2F;&#x2F; 可以简写成hexo g 根据markdown文件生成静态文件</span><br><span class="line">hexo deploy     &#x2F;&#x2F; 或者简写成hexo d 将本地修改，部署到远端</span><br></pre></td></tr></table></figure><p>此时，打开浏览器，访问<a href="https://sunjinshuai.github.io">https://sunjinshuai.github.io</a> ，就可以看到你的博客。</p><h4 id="Hexo安装新主题apollo"><a href="#Hexo安装新主题apollo" class="headerlink" title="Hexo安装新主题apollo"></a>Hexo安装新主题apollo</h4><p>Hexo换皮肤还是比较简单的，既可以自己根据默认的主题来修改，也可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 上去找主题。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>github上的文档给出了详细的安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init #blogname#</span><br><span class="line">cd #blogname#</span><br><span class="line">npm install</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pinggod&#x2F;hexo-theme-apollo.git themes&#x2F;apollo</span><br></pre></td></tr></table></figure><h5 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h5><p>安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: apollo</span><br><span class="line"></span><br><span class="line"># 在归档页面显示所有文章</span><br><span class="line"># 需要上面安装的 hexo-generator-archive 插件支持</span><br><span class="line">archive_generator:</span><br><span class="line">per_page: 0</span><br><span class="line">yearly: false</span><br><span class="line">monthly: false</span><br><span class="line">daily: false</span><br></pre></td></tr></table></figure><h4 id="hexo常用的命令"><a href="#hexo常用的命令" class="headerlink" title="hexo常用的命令"></a>hexo常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo init       &#x2F;&#x2F;在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件</span><br><span class="line">hexo new “my new blog title”   &#x2F;&#x2F;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</span><br><span class="line">hexo clean      &#x2F;&#x2F; 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存</span><br><span class="line">hexo generate   &#x2F;&#x2F; 可以简写成hexo g 根据markdown文件生成静态文件</span><br><span class="line">hexo server     &#x2F;&#x2F; 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问</span><br><span class="line">hexo deploy     &#x2F;&#x2F; 或者简写成hexo d 将本地修改，部署到远端</span><br><span class="line">hexo version    &#x2F;&#x2F; 显示hexo版本</span><br></pre></td></tr></table></figure><h4 id="关于HEXO安装失败的解决方法"><a href="#关于HEXO安装失败的解决方法" class="headerlink" title="关于HEXO安装失败的解决方法"></a>关于HEXO安装失败的解决方法</h4><p>目前国内npm源有问题；所以键入如下代码即可安装成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过各种找资料，踩过何种坑，终于搭建好了 &lt;code&gt;hexo&lt;/code&gt;，域名目前用得时 &lt;code&gt;github&lt;/code&gt; 的，我的 &lt;code&gt;hexo&lt;/code&gt; 是 &lt;code&gt;3.2.2&lt;/code&gt; 版本，&lt;code&gt;hexo&lt;/code&gt; 不同的版本
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://sunjinshuai.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
