<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈面向对象的六大设计原则 · 孙金帅的技术博客</title><meta name="description" content="浅谈面向对象的六大设计原则 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈面向对象的六大设计原则</h1><div class="post-info">2019年10月27日</div><div class="post-content"><p><img src="588630-7d17a7d220c612f0.png" alt="image.png"></p>
<h3 id="原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="原则一、单一职责原则（Single Responsibility Principle，简称SRP ）"></a>原则一、单一职责原则（Single Responsibility Principle，简称SRP ）</h3><p>定义：应该有且仅有一个原因引起类的变更。</p>
<p>一个类只负责一项职责，如果发生变更时，可以考虑将一个类拆分成两个类，或者在一个类中添加新的方法。</p>
<p><strong>在真实的开发中，不仅仅是类、函数和接口也要遵循单一职责原则。即：一个函数负责一个功能。如果一个函数里面有不同的功能，则需要将不同的功能的函数分离出去。</strong></p>
<p>优点：</p>
<ul>
<li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li>
<li>类的可读性提高，复杂性减低。</li>
</ul>
<p>如果接口或者函数的单一职责做得好，一个接口或者函数的修改只对相应的类有影响，对其他接口或者函数无影响，这对系统的扩展性、维护性都有非常大的帮助。</p>
<p>例如，需求上指出用一个类描述食肉和食草动物：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 17:55:25.775317+0800 DesignPatterns[54087:24701786] 狼 吃肉</span><br><span class="line">2018-10-27 17:55:25.775689+0800 DesignPatterns[54087:24701786] 豹 吃肉</span><br><span class="line">2018-10-27 17:55:25.775721+0800 DesignPatterns[54087:24701786] 虎 吃肉</span><br></pre></td></tr></table></figure>
<p>上线后，发现问题了，并不是所有的动物都是吃肉的，比如羊就是吃草的。修改时如果遵循单一职责原则，需要将 <code>Animal</code> 类细分为食草动物类 <code>Herbivore</code>，食肉动物 <code>Carnivore</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Herbivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Herbivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Herbivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Carnivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Carnivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Carnivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Animal *carnivore &#x3D; [Carnivore new];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">NSLog(@&quot;\n&quot;);</span><br><span class="line">Animal *herbivore &#x3D; [Herbivore new];</span><br><span class="line">[herbivore eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure>

<p>在子类里面重写父类的 <code>eatWithAnimalName</code> 函数，运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:04:49.189722+0800 DesignPatterns[54422:24725132] 狼 吃肉</span><br><span class="line">2018-10-27 18:04:49.190450+0800 DesignPatterns[54422:24725132] 豹 吃肉</span><br><span class="line">2018-10-27 18:04:49.190482+0800 DesignPatterns[54422:24725132] 虎 吃肉</span><br><span class="line">2018-10-27 18:04:49.190498+0800 DesignPatterns[54422:24725132] </span><br><span class="line">2018-10-27 18:04:49.190530+0800 DesignPatterns[54422:24725132] 羊 吃草</span><br></pre></td></tr></table></figure>
<p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加食肉动物和食草动物的其他功能，就可以直接在这两个类里面添加即可。但是，有一点，修改花销是很大的，除了将原来的类分解之外，还需要修改 <code>main</code> 函数 。而直接修改类 <code>Animal</code> 来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    if ([@&quot;羊&quot; isEqualToString:animalName]) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:16:10.910397+0800 DesignPatterns[54677:24751636] 狼 吃肉</span><br><span class="line">2018-10-27 18:16:10.911105+0800 DesignPatterns[54677:24751636] 豹 吃肉</span><br><span class="line">2018-10-27 18:16:10.911138+0800 DesignPatterns[54677:24751636] 虎 吃肉</span><br><span class="line">2018-10-27 18:16:10.911160+0800 DesignPatterns[54677:24751636] 羊 吃草</span><br></pre></td></tr></table></figure>
<p>可以看到，这种修改方式要简单的多。<br>但是却存在着隐患：<strong>有一天需求上增加牛和马也需要吃草，则又需要修改 <code>Animal</code> 类的 <code>eatWithAnimalName</code> 函数，而对原有代码的修改会对调用狼、豹和虎吃肉等功能带来风险，也许某一天你会发现运行结果变为虎也吃草了。</strong>这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃草</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃肉</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatGrassWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:31:30.321473+0800 DesignPatterns[55048:24787008] 狼 吃肉</span><br><span class="line">2018-10-27 18:31:30.321884+0800 DesignPatterns[55048:24787008] 豹 吃肉</span><br><span class="line">2018-10-27 18:31:30.321922+0800 DesignPatterns[55048:24787008] 虎 吃肉</span><br><span class="line">2018-10-27 18:31:30.321939+0800 DesignPatterns[55048:24787008] 羊 吃草</span><br></pre></td></tr></table></figure>
<p>通过运行结果可以看到，这种修改方式没有改动原来的函数，而是在类中新加了一个函数，这样虽然也违背了<strong>类单一职责原则</strong>，但在函数级别上却是符合单一职责原则的，因为它并没有动原来函数的代码。</p>
<p>在实际的开发应用中，有很多复杂的场景，怎么设计一个类或者一个函数，让应用程序更加灵活，是更多程序员们值得思考的，需要结合特定的需求场景，有可能有些类里面有很多的功能，但是切记不要将不属于这个类本身的功能也强加进来，这样不仅带来不必要的维护成本，也违反了<strong>单一职责的设计原则</strong>。</p>
<h3 id="原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）"><a href="#原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）" class="headerlink" title="原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）"></a>原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）</h3><p>定义：如果对一个类型为 <code>T1</code> 的对象 <code>o1</code>，都有类型为 <code>T2</code> 的对象 <code>o2</code>，使得以 <code>T1</code> 定义的所有程序 <code>P</code> 在所有的对象 <code>o1</code> 都替换成 <code>o2</code> 时，程序 <code>P</code> 的行为没有发生变化，那么类型 <code>T2</code> 是类型 <code>T1</code> 的子类型。有点拗口，通俗点讲，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应</strong>。</p>
<p>面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。当使用继承时，遵循里氏替换原则。但是使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生影响。子类可以扩展父类的功能，但不能改变父类原有的功能。</p>
<p>注意：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
</ul>
<p>比如，需要完成一个两数相加的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; A.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface A : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"></span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">A *a &#x3D; [[A alloc] init];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, [a addition:100 b:50]);</span><br><span class="line">NSLog(@&quot;100+80&#x3D;%ld&quot;, [a addition:100 b:80]);</span><br></pre></td></tr></table></figure>
<p>运行结果如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 22:53:23.549358+0800 DesignPatterns[18063:363232] 100+50&#x3D;150</span><br><span class="line">2018-11-01 22:53:23.549586+0800 DesignPatterns[18063:363232] 100+80&#x3D;180</span><br></pre></td></tr></table></figure>
<p>接着，需求上需要增加一个新的功能，完成两数相加，然后再与 <code>100</code> 求差，由类 <code>B</code> 来负责。即类 <code>B</code> 需要完成两个功能：</p>
<ul>
<li>两数相减。</li>
<li>两数相加，然后再加 <code>100</code>。</li>
</ul>
<p>由于类 <code>A</code> 已经实现了加法功能，所以 <code>B</code> 继承 <code>A</code> 之后，只需要完成减法功能就可以了，但是在类 <code>B</code> 中不小心重写了父类 <code>A</code> 的减法功能，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface B : A</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 减法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)subtraction:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">B *b &#x3D; [[B alloc] init];</span><br><span class="line">NSInteger sub &#x3D; [b addition:100 b:50];</span><br><span class="line">NSInteger difference &#x3D; [b subtraction:sub b:100];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, sub);</span><br><span class="line">NSLog(@&quot;100+100+50&#x3D;%ld&quot;, difference);</span><br></pre></td></tr></table></figure>
<p>运行结果如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 23:15:06.530080+0800 DesignPatterns[18363:375940] 100+50&#x3D;5000</span><br><span class="line">2018-11-01 23:15:06.530758+0800 DesignPatterns[18363:375940] 100+100+50&#x3D;4900</span><br></pre></td></tr></table></figure>
<p>发现原本运行正常的相减功能发生了错误，原因就是类 <code>B</code> 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 <code>B</code> 重写后的方法，造成原本运行正常的功能出现了错误。如果按照“里氏替换原则”，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类</strong>，是不成立的。</p>
<p>在平时的日常开发中，通常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。</p>
<h3 id="原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）"><a href="#原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）" class="headerlink" title="原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）"></a>原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）</h3><p><strong>依赖倒置原则的核心思想是面向接口编程。</strong></p>
<p>定义：模块间的依赖通过抽象发生，高层模块和低层模块之间不应该发生直接的依赖关系，二者都应该是通过接口或抽象类产生的；即依赖抽象，而不依赖具体的实现。</p>
<p>例如：类 <code>A</code> 直接依赖类 <code>B</code>，假如要将类 <code>A</code> 改为依赖类 <code>C</code>，则必须通过修改类 <code>A</code> 的代码来达成。比如在这种场景下，业务逻辑层类 <code>A</code> 相对于数据层类 <code>B</code> 是高层模块，因为业务逻辑层需要调用数据层去连接数据库，如果业务逻辑层类 <code>A</code> 依赖数据层类 <code>B</code> 的话，那么将来需求变更，需要把旧的数据层类 <code>B</code> 修改为新的数据层类 <code>C</code>，就必须通过修改类 <code>A</code>，这样就会给应用程序带来不必要的风险。</p>
<p>解决方案：将类 <code>A</code> 修改为依赖接口 <code>I</code>，类 <code>B</code> 和类 <code>C</code> 各自实现接口 <code>I</code>，类 <code>A</code> 通过接口 <code>I</code> 间接与类 <code>B</code> 或者类 <code>C</code> 发生联系，则会大大降低修改类 <code>A</code> 的几率。要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。</p>
<p>比如：母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@class Book;</span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(Book *)book;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">[mother tellStory:book];</span><br></pre></td></tr></table></figure>

<p>运行结果如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 14:52:08.759154+0800 DesignPatterns[6135:458778] 妈妈开始讲故事</span><br><span class="line">2018-11-09 14:52:08.759365+0800 DesignPatterns[6135:458778] 很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure>

<p>将来有一天，需求变更成，增加让母亲讲一下报纸上的故事的功能，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 报纸内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>如果将 <code>Newspaper</code> 类替换 <code>Book</code> 类，发现母亲看不懂报纸上的故事，必须要修改 <code>Mother</code> 类里面的 <code>tellStory</code> 方法才能看不懂报纸上的故事。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code> 类，这显然不是好的设计，高层模块都依赖了低层模块的改动，因此上述设计不符合依赖倒置原则。<code>Mother</code> 类与 <code>Book</code> 类之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>解决方案，将母亲讲故事的方法抽象一个接口或者 <code>Protocol</code>，让<code>Mother</code> 类不再依赖 <code>Newspaper</code> 和 <code>Book</code> 类具体实现，而是依赖抽象出来的接口或者 <code>Protocol</code>。并且 <code>Newspaper</code> 和 <code>Book</code> 类也都依赖这个抽象出来的接口或者 <code>Protocol</code>，通过实现接口或者 <code>Protocol</code> 来做自己的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>Mother</code> 类与接口 <code>IReader</code> 发生依赖关系，而 <code>Book</code> 和 <code>Newspaper</code> 都属于读物的范畴，他们各自都去实现 <code>IReader</code> 接口，这样就符合依赖倒置原则了，代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Mother</span><br><span class="line"></span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading &#123;</span><br><span class="line">    NSLog(@&quot;妈妈开始讲故事&quot;);</span><br><span class="line">    if ([reading respondsToSelector:@selector(theStoryContent)]) &#123;</span><br><span class="line">        [reading theStoryContent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">Newspaper *newspaper &#x3D; [Newspaper new];</span><br><span class="line">[mother tellStory:book];</span><br><span class="line">[mother tellStory:newspaper];</span><br></pre></td></tr></table></figure>

<p>运行结果如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 15:28:01.182603+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182879+0800 DesignPatterns[7055:532924] 很久很久以前有一个阿拉伯的故事……</span><br><span class="line">2018-11-09 15:28:01.182916+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182955+0800 DesignPatterns[7055:532924] 雄鹿终结勇士八连胜……</span><br></pre></td></tr></table></figure>

<p>这样修改后，无论以后怎样扩展 main 函数，都不需要再修改 <code>Mother</code> 类了。这里只是举了一个比较简单的例子，在实际的项目开发中，尽可能的采用“低耦合，高内聚”的原则，<strong>采用依赖倒置原则给多人并行开发带来了极大的便利</strong>，无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<h3 id="原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="原则四、接口隔离原则（Interface Segregation Principle,简称ISP）"></a>原则四、接口隔离原则（Interface Segregation Principle,简称ISP）</h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#39;ClassB&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br><span class="line">Class &#39;ClassD&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br></pre></td></tr></table></figure>

<p><strong>注意：在 <code>Objective-C</code> 中的协议可以通过 <code>@optional</code> 关键字声明不需要必须实现的方法，这个只是 <code>Objective-C</code> 的一个特性，可以消除在 <code>ClassB</code> 和 <code>ClassD</code> 中没有实现 <code>InterfaceH</code> 的 <code>protocol</code> 协议。</strong></p>
<p>比如，类 A 依赖接口 H 中的方法1、方法2、方法5，类 B 是对类 A 依赖的实现。类 C 依赖接口 H 中的方法3、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法，但由于实现了接口 H，因为接口 <code>H</code> 对于类 <code>A</code> 和类 <code>C</code> 来说不是最小接口，所以也必须要实现这些用不到的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。</p>
<p><strong>解决方法：将臃肿的接口 <code>H</code> 拆分为独立的几个接口，类 <code>A</code> 和类 <code>C</code> 分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH1 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH2 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH1&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH2&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。在实际项目开发中，只暴露给调用的类需要的方法，不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，不要试图去建立一个很庞大的接口供所有依赖它的类去调用。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<h3 id="原则五、迪米特法则（Law-of-Demeter，简称LOD）"><a href="#原则五、迪米特法则（Law-of-Demeter，简称LOD）" class="headerlink" title="原则五、迪米特法则（Law of Demeter，简称LOD）"></a>原则五、迪米特法则（Law of Demeter，简称LOD）</h3><p>定义：一个对象应该对其他对象保持最少的了解。</p>
<p>当类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外只暴露必要的接口。</p>
<p>解决方案：尽量降低类与类之间的耦合。</p>
<p>比如，有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工 <code>ID</code>：<br>Model 类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; EmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface EmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 总公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *employee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubEmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubEmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 分公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *subemployee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>Company 类，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; subCompany.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，打印 <code>Company</code> 所有员工的 <code>ID</code>，需要依赖分公司 <code>SubCompany</code>。但是在 <code>printAllEmployeeWithSubCompany:</code> 方法里面必须要初始化分公司员工 <code>SubEmployeeModel</code>。而<code>SubEmployeeModel</code> 和 <code>Company</code> 并不是直接联系，换句话说，总公司 <code>Company</code> 只需要依赖分公司 <code>SubCompany</code>，与分公司的员工 <code>SubEmployeeModel</code> 并没有任何联系，这样设计显然是增加了不必要的耦合。</p>
<p><strong>按照迪米特法则，类与类之间的应该减少不必要的关联程度。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    [subCompany printAllEmployee];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印分公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployee &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>修改后，为分公司增加了打印所有公钥 <code>ID</code> 的方法，总公司直接调分公司的打印方法，从而避免了与分公司的员工发生耦合。</p>
<p>耦合的方式很多，依赖、关联、组合、聚合等。</p>
<p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是过分的使用迪米特原则，会产生大量传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<h3 id="原则六、开闭原则（Open-Close-Principle，简称OCP）"><a href="#原则六、开闭原则（Open-Close-Principle，简称OCP）" class="headerlink" title="原则六、开闭原则（Open Close Principle，简称OCP）"></a>原则六、开闭原则（Open Close Principle，简称OCP）</h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p>核心思想：<strong>尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。</strong></p>
<p><strong>用抽象构建框架，用实现扩展细节</strong>，对扩展开放的关键是抽象，而对象的多态则保证了这种扩展的开放性。开放原则首先意味着我们可以自由地增加功能，而不会影响原有功能。这就要求我们能够通过继承完成功能的扩展。其次，开放原则还意味着实现是可替换的。只有利用抽象，才可以为定义提供不同的实现，然后根据不同的需求实例化不同的实现子类。</p>
<p>开放封闭原则的优点：</p>
<ul>
<li>代码可读性高，可维护性强。</li>
<li>帮助缩小逻辑粒度，以提高可复用性。</li>
<li>可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性。</li>
<li>在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求。</li>
</ul>
<p>比如，书店售书的经典例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IBookProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IBookProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍售价</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (CGFloat)bookPrice;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍作者</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookAuthor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; NovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface NovelBook : NSObject &lt;IBookProtocol&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟书店卖书</span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:11:32.642070+0800 DesignPatterns[1863:5763476] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：50.000000</span><br><span class="line">2018-11-12 15:11:32.642495+0800 DesignPatterns[1863:5763476] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:11:32.642530+0800 DesignPatterns[1863:5763476] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:11:32.642558+0800 DesignPatterns[1863:5763476] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br></pre></td></tr></table></figure>

<p>将来某一天需求变更为项目投产，书店盈利，书店决定，<code>40</code> 元以上打 <code>8</code> 折，<code>40</code> 元以下打 <code>9</code> 折。</p>
<p>在实际的项目开发中，如果不懂得开闭原则的话，很容易犯下面的错误：</p>
<ul>
<li>在 <code>IBookProtocol</code> 上新增加一个方法 <code>bookOffPrice()</code> 方法，专门进行打折，所有实现类实现这个方法，但是如果其他不想打折的书籍也会因为实现了书籍的接口必须打折。 </li>
<li>修改 <code>NovelBook</code> 实现类中的 <code>bookPrice()</code> 方中实现打折处理，由于该方法已经实现了打折处理价格，因此采购书籍人员看到的也是打折后的价格的情况。</li>
</ul>
<p>很显然按照上面两种方案的话，随着需求的增加，需要反复修改之前创建的类，给新增的类造成了不必要的冗余，业务逻辑的处理和需求不相符合等情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; OffNovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface OffNovelBook : NovelBook</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OffNovelBook</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author &#123;</span><br><span class="line">    return [super initWithBookName:name price:price author:author];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)bookPrice &#123;</span><br><span class="line">    CGFloat originalPrice &#x3D; [super bookPrice];</span><br><span class="line">    CGFloat offPrice      &#x3D; 0;</span><br><span class="line">    if (originalPrice &gt; 40) &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.8;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line">    return offPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BookStore</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book1 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book2 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book3 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book4 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book1 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book2 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book3 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book4 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的原价书籍记录如下：------------&quot;);</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的打折书籍记录如下：------------&quot;);</span><br><span class="line">for (OffNovelBook *novelBook in bookStore.offBookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:52:01.639550+0800 DesignPatterns[2962:6151804] ------------书店卖出去的原价书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.639895+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：30.000000</span><br><span class="line">2018-11-12 15:52:01.639927+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:52:01.639951+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:52:01.639971+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br><span class="line">2018-11-12 15:52:01.639988+0800 DesignPatterns[2962:6151804] ------------书店卖出去的打折书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.640029+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：27.000000</span><br><span class="line">2018-11-12 15:52:01.640145+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：56.000000</span><br><span class="line">2018-11-12 15:52:01.640194+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：64.000000</span><br><span class="line">2018-11-12 15:52:01.640217+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：36.000000</span><br></pre></td></tr></table></figure>

<p>在实际的项目开发中，</p>
<ul>
<li><p>对抽象定义的修改，要保证定义的接口或者 <code>Protocol</code> 的稳定，尤其要保证被其他对象调用的接口的稳定；否则，就会导致修改蔓延，牵一发而动全身。</p>
</li>
<li><p>对具体实现的修改，因为具体实现的修改，可能会给调用者带来意想不到的结果。如果确实需要修改具体的实现，就需要做好达到测试覆盖率要求的单元测试。</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2022/02/09/iOS-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/" class="prev">上一篇</a><a href="/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2019/10/27/浅谈面向对象的六大设计原则/';
var disqus_title = '浅谈面向对象的六大设计原则';
var disqus_url = 'https://sunjinshuai.github.io/2019/10/27/浅谈面向对象的六大设计原则/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>