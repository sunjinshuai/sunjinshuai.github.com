<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2022-01-16T05:34:29.036Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 HTTPS 的原理详解</title>
    <link href="https://sunjinshuai.github.io/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sunjinshuai.github.io/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-09-13T15:23:54.000Z</published>
    <updated>2022-01-16T05:34:29.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><code>HTTP</code> 协议（<code>HyperText Transfer Protocol</code>，超文本传输协议）：是客户端浏览器或其他程序与 <code>Web</code> 服务器之间的应用层通信协议 。</p></li><li><p><code>HTTPS</code> 协议（<code>HyperText Transfer Protocol over Secure Socket Layer</code>）：可以理解为 <code>HTTP+SSL/TLS</code>， 即 <code>HTTP</code> 下加入 <code>SSL</code> 层，<code>HTTPS</code> 的安全基础是 <code>SSL</code>，因此加密的详细内容就需要 <code>SSL</code>，用于安全的 <code>HTTP</code> 数据传输。</p></li><li><p><code>SSL</code>（<code>Secure Socket Layer</code>，安全套接字层）：<code>1994</code> 年为 <code>Netscape</code> 所研发，<code>SSL</code> 协议位于 <code>TCP/IP</code> 协议与各种应用层协议之间，为数据通讯提供安全支持。</p></li><li><p><code>TLS</code>（<code>Transport Layer Security</code>，传输层安全）：其前身是 <code>SSL</code>，它最初的几个版本（<code>SSL 1.0</code>、<code>SSL 2.0</code>、<code>SSL 3.0</code>）由网景公司开发，<code>1999</code> 年从 <code>3.1</code> 开始被 <code>IETF</code> 标准化并改名，发展至今已经有 <code>TLS 1.0</code>、<code>TLS 1.1</code>、<code>TLS 1.2</code> 三个版本。<code>SSL3.0</code> 和 <code>TLS1.0</code> 由于存在安全漏洞，已经很少被使用到。<code>TLS 1.3</code> 改动会比较大，目前还在草案阶段，目前使用最广泛的是 <code>TLS 1.1</code>、<code>TLS 1.2</code>。</p></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>HTTP</code> 默认工作在 <code>TCP</code> 协议 <code>80</code> 端口，用户访问网站 <code>http://</code> 打头的都是标准 <code>HTTP</code> 服务。</li><li><code>HTTP</code> 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 <code>Web</code> 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</li><li><code>HTTPS</code> 默认工作在 <code>TCP</code> 协议 <code>443</code> 端口。</li><li><code>HTTPS</code>（<code>HTTP+SSL/TLS</code>）数据传输过程是加密的，安全性较好。</li></ul><p><code>HTTPS</code> 和 <code>HTTP</code> 协议相比提供了</p><ul><li>数据完整性：内容传输经过完整性校验</li><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h3 id="TLS-握手流程"><a href="#TLS-握手流程" class="headerlink" title="TLS 握手流程"></a>TLS 握手流程</h3><p><code>HTTPS</code> 在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。<code>TLS/SSL</code> 协议是一套加密传输的协议，使用了非对称加密，对称加密以及 <code>HASH</code> 算法。以 <code>RSA</code> 为例，<code>TLS</code> 握手流程如下：<br><img src="588630-0e87f4003f1e85ff.png" alt="image.png"></p><p><strong>上图中的 <code>CA</code> 证书验证，这一步是可选的，对于安全性要求高的场景会用到，比如，预防中间人攻击。</strong></p><h4 id="第一步-Client-Hello"><a href="#第一步-Client-Hello" class="headerlink" title="第一步 Client Hello"></a>第一步 <code>Client Hello</code></h4><p>客户端向服务端发送 <code>Client Hello</code> 消息，这个消息里包含了一个客户端生成的随机数 <code>Random1</code>、客户端支持的协议版本，会话 ID，密码套件，压缩算法等信息。</p><h4 id="第二步-Server-Hello"><a href="#第二步-Server-Hello" class="headerlink" title="第二步 Server Hello"></a>第二步 <code>Server Hello</code></h4><p>服务端向客户端发送 <code>Server Hello</code> 消息，这个消息会从 <code>Client Hello</code> 传过来的加密套件里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <code>Random2</code>。注意，至此客户端和服务端都拥有了两个随机数 <code>Random1+Random2</code> ，这两个随机数会在后续生成对称秘钥时用到。</p><p><strong>Client 发送一个 ClientHello 消息，Server 必须回应一个 ServerHello 消息或产生一个验证的错误并且使连接失败</strong></p><h5 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a><code>Certificate</code></h5><p>在 <code>Server Hello</code> 消息之后，服务端将自己的证书下发给客户端，<code>Server</code> 会在 <code>Certificate</code> 消息中发送它自己的证书，<strong>如果它即将被认证</strong>，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a><code>Server Key Exchange</code></h4><p>此外，如果需要的话，一个 <code>ServerKeyExchange</code> 消息会被发送，(例如, 如果 <code>Server</code> 没有证书, 或者它的证书只用于签名，<code>RSA</code> 密码套件就不会出现 <code>ServerKeyExchange</code> 消息，如果 <code>Server</code> 被认证过了，如果对于已选择的密码套件来说是合适的话，它可能会要求 <code>Client</code> 发送证书)。如果是 <code>DH</code> 算法，这里发送服务器使用的 <code>DH</code> 参数，<code>RSA</code> 算法不需要这一步；</p><h5 id="Certificate-Request"><a href="#Certificate-Request" class="headerlink" title="Certificate Request"></a><code>Certificate Request</code></h5><p>如果 Server 发送了一个 CertificateRequest 消息，Client 必须发送 Certificate 消息。</p><h5 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a><code>Server Hello Done</code></h5><p>Server Hello Done 通知客户端 Server Hello 过程结束。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>客户端收到了服务器发来的数据包后，会做这么几件事情：</p><h5 id="Client-Certificate"><a href="#Client-Certificate" class="headerlink" title="Client Certificate"></a><code>Client Certificate</code></h5><p>这是 <code>Client</code> 在收到一个 <code>ServerHelloDone</code> 消息后发送的第一个消息。这个消息只能在 <code>Server</code> 请求一个证书时发送。如果没有合适的证书，<code>Client</code> 必须发送一个不带证书的证书消息。如果 <code>Client</code> 不发送任何证书，<code>Server</code> 可以自行决定是否可以在不验证 <code>Client</code> 的情况下继续握手，<strong>或者回复一个致命 <code>handshake_failure</code> 警报 <code>alert</code> 信息。而且, 如果证书链某些方面不能接受(例如, 它没有被一个知名的可信 <code>CA</code> 签名)，<code>Server</code> 可以自行决定是否继续握手(考虑到 <code>Client</code> 无认证)或发送一个致命的警报 <code>alert</code> 信息。</strong></p><h5 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a><code>Client Key Exchange</code></h5><p>这个消息始终由 <code>Client</code> 发送。如果有 <code>Client Certificate</code> 消息的话，<code>Client Key Exchange</code> 紧跟在 <code>Client Certificate</code> 消息之后发送。如果不存在 <code>Client Certificate</code> 消息的话，它必须是在 <code>Client</code> 收到 <code>ServerHelloDone</code> 后发送的第一个消息。客户端根据服务器传来的公钥生成了 <code>PreMaster Key</code>，<code>Client Key Exchange</code> 就是将这个 <code>key</code> 传给服务端。</p><h5 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec Client"></a><code>Change Cipher Spec Client</code></h5><p>将刚才的消息使用刚才的 <code>PreMaster Key</code> 进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>服务器接受到客户端发来的消息后，会做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message Client"></a><code>Encrypted Handshake Message Client</code></h5><p>这一步对应的是 <code>Client Finish</code> 消息，使用私钥解密上面第2步中公钥加密的消息，得到客户端产生的随机序列号。使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。</p><h5 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec Server"></a><code>Change Cipher Spec Server</code></h5><p>使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。</p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>客户端收到服务器端的消息后，接着做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message Server"></a><code>Encrypted Handshake Message Server</code></h5><p>这一步对应的是 <code>Server Finish</code> 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><h4 id="第六步-Application-Data"><a href="#第六步-Application-Data" class="headerlink" title="第六步 Application Data"></a>第六步 <code>Application Data</code></h4><p>握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>采用 <code>HTTPS</code> 协议的服务器必须要有自己制作或者 <code>CA</code> 证书，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用 <code>CA</code> 证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><p>客户端收到服务器的回复后，首先客户端会从内置的证书列表中索引，查找服务器下发 <code>CA</code> 证书，如果没有找到，此时就会提示用户该证书是不可信任的。如果查到了对应 <code>CA</code> 证书，则取出 <code>public key</code> 公钥。然后，用 <code>public key</code> 公钥解密得到证书的内容和证书签名，内容包括证书的颁发机构，过期时间等。客户端会先验证证书签名的合法性，签名通过后，会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，客户端就可以安全使用 <code>public key</code> 公钥了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt; 协议（&lt;code&gt;HyperText Transfer Protocol&lt;/code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 AutoreleasePool 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2017-10-06T13:50:12.000Z</published>
    <updated>2022-01-09T11:51:07.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p><code>autorelease</code> 对象什么时候释放。</p><p><strong><code>autorelease</code> 的本质就是延迟调用 <code>release</code> 方法</strong></p><p>在 <code>MRC</code> 的环境下，可以通过调用 <code>[obj autorelease]</code> 将对象添加到当前的 <code>autoreleasepool</code> 中，来延迟释放内存； </p><p>在 <code>ARC</code>的环境下，当我们创建一个对象，可以通过 <code>__autoreleasing</code> 修饰符，会将对象添加到当前的 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p><p>注意：</p><ul><li><strong>编译器会检查方法名是否以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开始，如果不是则自动将返回值的对象注册到 <code>autoreleasepool</code> 中；</strong></li><li><strong>以 <code>__weak</code> 修饰的对象，会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong>调用 <code>Foundation</code> 对象的类方法(比如，<code>[NSMutableDictionary dictionary]</code>、<code>[NSArray array]</code> 等)会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong><code>id</code> 的指针或对象的指针在没有显式地指定修饰符时候，会被默认附加上 <code>__autoreleasing</code> 修饰符。</strong></li></ul><p>在没有手动加入 <code>autoreleasepool</code> 的情况下，<code>autorelease</code> 对象是在当前的 <code>runloop</code> 迭代结束时释放的，而它能够释放的原因是<strong>系统在每个 <code>runloop</code> 迭代中都加入了自动释放池 <code>push</code> 和 <code>pop</code></strong>。</p><p>当 <code>autoreleasepool</code> 销毁时，在调用堆栈中可以发现，系统调用了 <code>-[NSAutoreleasePool release]</code> 方法，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 <code>autoreleasepool</code> 中的 <code>autorelease</code> 对象执行 <code>release</code> 操作。</p><h1 id="AutoreleasePool-的实现原理"><a href="#AutoreleasePool-的实现原理" class="headerlink" title="AutoreleasePool 的实现原理"></a>AutoreleasePool 的实现原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>使用 <code>clang -rewrite-objc</code> 命令将下面的 <code>Objective-C</code> 代码重写成 <code>C++</code> 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br></pre></td></tr></table></figure><p>当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure><p>也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line">    void *atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#x2F;&#x2F; 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，单个 <code>autoreleasepool</code> 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code> 、<code>[obj release]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p><img src="588630-c77baf1ba3747632.png" alt="image.png"></p><p>从图中可以看出 </p><ul><li><code>AutoreleasePoolPage</code> 是由双向链表来实现的，<code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</li><li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整；</li><li><code>AutoreleasePool</code> 是按线程一一对应的，结构中的 <code>thread</code> 指针指向当前线程。</li><li><code>AutoreleasePoolPage</code> 会为每个对象会开辟 <code>4096</code> 字节内存。</li><li><code>id *next</code> 指向了下一个为空的内存地址(初始化为栈底)，如果有添加进来的 <code>autorelease</code> 对象，移动到下一个为空的内存地址中。</li></ul><p>如果 <code>AutoreleasePoolPage</code> 里面的 <code>autorelease</code> 对象满了，也就是 <code>id *next</code> 指针指向了栈顶，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来添加的 <code>autorelease</code> 对象在新的 <code>AutoreleasePoolPage</code> 加入，<code>id *next</code> 指针指向新的 <code>AutoreleasePoolPage</code> 为空的内存地址，即栈底。所以，向一个对象发送 <code>release</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的 <code>id *next</code> 指针指向的位置。</p><h3 id="POOL-SENTINEL-哨兵对象"><a href="#POOL-SENTINEL-哨兵对象" class="headerlink" title="POOL_SENTINEL(哨兵对象)"></a>POOL_SENTINEL(哨兵对象)</h3><p><img src="588630-8d76ce26495dfabd.png" alt="image.png"></p><p><strong><code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</strong></p><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>。</p><p>详细参考<a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">POOL_SENTINEL(哨兵对象)</a></p><h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h3><p><code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    if (UseGC) return nil;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码得出，每次执行 <code>objc_autoreleasePoolPush</code> 其实就是创建了一个新的 <code>autoreleasepool</code>，然后会把一个 <code>POOL_SENTINEL</code> <code>push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">    id *dest &#x3D; autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest &#x3D;&#x3D; POOL_SENTINEL);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数并传入哨兵对象  <code>POOL_SENTINEL</code> 来执行具体的插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full.</span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    assert(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    </span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; No pool in place.</span><br><span class="line">    assert(!hotPage());</span><br><span class="line">    </span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">                     (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push an autorelease pool boundary if it wasn&#39;t already requested.</span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p><ul><li>当前 <code>hotPage</code> 存在且没有满时，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 存在且已满时，调用 <code>autoreleaseFullPage</code> 初始化一个新的 <code>page</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 不存在时，调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul><h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><p>objc_autoreleasePoolPop(void *)函数本质上也是调用的AutoreleasePoolPage的pop函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    if (UseGC) return;</span><br><span class="line">    &#x2F;&#x2F; fixme rdar:&#x2F;&#x2F;9167170</span><br><span class="line">    if (!ctxt) return;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; pageForPointer(token);</span><br><span class="line">    id *stop &#x3D; (id *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    if (page-&gt;child) &#123;</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是<code>POOL_SENTINEL</code> 的内存地址。根据这个内存地址找到所在的 <code>AutoreleasePoolPage</code> 然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象。</p><p>总结：<br>每调用一次 <code>push</code> 操作就会创建一个新的 <code>autoreleasepool</code>，然后往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址.<br>在执行 <code>pop</code> 操作的时候传入 <code>POOL_SENTINEL</code>，根据传入的哨兵对象地址找到哨兵对象所处的 <code>page</code><br>在当前AutoreleasePoolPage中，然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象，并把 <code>id next</code> 指针到正确位置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试题：&quot;&gt;&lt;a href=&quot;#面试题：&quot; class=&quot;headerlink&quot; title=&quot;面试题：&quot;&gt;&lt;/a&gt;面试题：&lt;/h1&gt;&lt;p&gt;&lt;code&gt;autorelease&lt;/code&gt; 对象什么时候释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;autore
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</id>
    <published>2016-09-23T14:21:21.000Z</published>
    <updated>2022-01-02T12:43:20.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>加密 <code>encryption</code> 与解密 <code>decryption</code> 使用的是同样的密钥 <code>secret key</code>，对称加密是最快速、最简单的一种加密方式。加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。<br>对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。<br>对称加密通常使用的是相对较小的密钥，一般小于 <code>256bit</code>。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用 <code>1bit</code> 来做这个密钥，那黑客们可以先试着用 <code>0</code> 来解密，不行的话就再用 <code>1</code> 解；但如果你的密钥有 <code>1MB</code> 大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。</p><h1 id="For-Example"><a href="#For-Example" class="headerlink" title="For Example"></a>For Example</h1><p>比如常见的 <code>DES/AES</code> 都是属于对称加密算法。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>算法公开、计算量小、加密速度快、加密效率高。</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。</p><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。<br>私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。<br>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p><h1 id="For-Example-1"><a href="#For-Example-1" class="headerlink" title="For Example"></a>For Example</h1><p><code>RSA</code> 就是最常用的非对称加密算法。<br>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。<br>与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p><p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><h1 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h1><p>安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。</p><h1 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h1><p>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。<br>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。<br>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h1&gt;&lt;p&gt;加密 &lt;code&gt;encryption&lt;/code&gt; 与解密 &lt;code&gt;decryption&lt;/code&gt; 使用的是同样的
      
    
    </summary>
    
    
    
      <category term="http" scheme="https://sunjinshuai.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>[self class] 与 [super class]</title>
    <link href="https://sunjinshuai.github.io/2016/04/17/self-class-%E4%B8%8E-super-class/"/>
    <id>https://sunjinshuai.github.io/2016/04/17/self-class-%E4%B8%8E-super-class/</id>
    <published>2016-04-17T06:31:36.000Z</published>
    <updated>2022-01-09T12:46:51.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果：</span><br><span class="line">2016-04-17 14:21:36.060 Test[8566:568584] NSStringFromClass([self class]) &#x3D; Son 2016-04-17 14:21:36.061 Test[8566:568584] NSStringFromClass([super class]) &#x3D; Son</span><br></pre></td></tr></table></figure><p><code>self</code> 是类的隐藏参数，指向当前调用方法的这个类的实例。<br><code>super</code> 是一个 <code>Magic Keyword</code>， 它本质是一个编译器标示符，和 <code>self</code> 是指向的同一个消息接受者。而不同的是，<code>super</code> 是告诉编译器，调用 <code>class</code> 这个方法时，要去父类的方法，而不是本类里的。</p><p>上面的demo中不管调用 <code>[self class]</code> 还是 <code>[super class]</code>，最终的接受消息的对象都是当前 <code>Son</code> 这个对象。</p><p>当使用 <code>self</code> 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；<br>当使用 <code>super</code> 时，则从父类的方法列表中开始找。</p><p>通过<code>clang</code>命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc test.m</span><br></pre></td></tr></table></figure><p><img src="588630-865511032a51310f.png" alt="image.png"></p><p>从上面的代码中，我们可以发现当在调用 <code>[self class]</code> 时，会转化成 <code>objc_msgSend</code> 方法。看下方法定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br></pre></td></tr></table></figure><p>而在调用 <code>[super class]</code> 时，会转化成 <code>objc_msgSendSuper</code> 方法。看下方法定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br></pre></td></tr></table></figure><p>查看 <code>objc_super</code> 结构体发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_super</code> 结构体有两个成员：</p><ul><li>第一个成员是接收消息的 <code>receiver</code>, 类似于上面的 <code>objc_msgSend</code> 方法第一个参数 <code>self</code>。</li><li>第二个成员是当前类的父类 <code>super_class</code> 。</li></ul><p>所以，当调用 <code>[self class]</code> 时，实际先调用的是 <code>objc_msgSend</code> 方法，第一个参数是接收消息的 <code>receiver</code> 也就是 <code>Son</code> 当前的这个实例，然后在 <code>Son</code> 类的方法列表开始查找 <code>selector</code>，如果没有，则去父类的方法列表开始查找 <code>selector</code>，如果父类里面也没有，则会在 <code>NSObject</code> 查找方法列表开始查找 <code>selector</code>，找到后以 <code>self</code> 去调用父类的这个 <code>selector</code>。</p><p><code>objc Runtime</code> 开源代码对 <code>- (Class)class</code> 方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">  return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>- (Class)class</code> 的实现就是返回 <code>self</code> 自己，故上述输出结果为 <code>Son</code>。</p><p>而当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 方法：</p><ul><li>从 <code>objc_super</code> 结构体指向的 <code>superClass</code> 父类的方法列表开始查找 <code>selector</code>，找到后以 <code>objc-&gt;receiver</code> 去调用父类的这个 <code>selector</code>。</li><li>由于找到了父类 <code>NSObject</code> 里面的 <code>class</code> 方法的 <code>IMP</code> ，又因为传入的入参 <code>objc_super-&gt;receiver</code> 指向 <code>self</code>。<code>self</code> 也就是 <code>Son</code> 当前的这个实例，所以父类的方法 <code>class</code> 执行 <code>IMP</code> 之后，输出还是 <code>Son</code>。<br>最后输出两个都一样，都是输出 <code>Son</code>。</li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/11/06/runtime-nuts/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何使用hexo搭建个人博客</title>
    <link href="https://sunjinshuai.github.io/2016/03/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunjinshuai.github.io/2016/03/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2016-03-05T13:41:47.000Z</published>
    <updated>2022-01-02T12:41:21.729Z</updated>
    
    <content type="html"><![CDATA[<p>经过各种找资料，踩过何种坑，终于搭建好了 <code>hexo</code>，域名目前用得时 <code>github</code> 的，我的 <code>hexo</code> 是 <code>3.2.2</code> 版本，<code>hexo</code> 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p><p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于 <code>CSDN</code>、博客园也都可以写文章，但是页面的样式我不是太喜欢，简书还算好点得。最近看到一些大神们的博客，貌似都是用 <code>hexo</code> 写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>hexo</code>是一个<code>npm</code>包，在<code>node</code>环境上运行，功能就是将你的文章（<code>.md</code>文件）生成为静态<code>html</code>文件。</p><h4 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h4><p>下面正式开始搭建博客！首先要想使用 <code>Hexo</code> 和 <code>github pages</code> 搭建博客，需要以下环境：</p><ul><li>在 <code>github</code> 上注册一个账号，并创建一个指定名字的 <code>reposity</code></li><li><code>homebrew</code> 套件管理器，主要用来安装 <code>git</code> 和 <code>node.js</code></li><li><code>git</code> 版本管理工具</li><li><code>node.js</code></li><li>配置 <code>SSH key</code></li><li>安装 <code>hexo</code></li><li>同步 <code>hexo</code> 博客到 <code>github</code></li></ul><h5 id="注册Github账号并创建reposity"><a href="#注册Github账号并创建reposity" class="headerlink" title="注册Github账号并创建reposity"></a>注册Github账号并创建reposity</h5><p>申请完账号，登陆之后，就可以创建 <code>reposity</code> 了，点击 <code>New repository</code><br>，会跳转到这个界面: </p><p><img src="588630-c658dc0c9c467b19.png" alt="Paste_Image.png"></p><h5 id="安装brewhome"><a href="#安装brewhome" class="headerlink" title="安装brewhome"></a>安装brewhome</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;Homebrew&#x2F;homebrew&#x2F;go&#x2F;install)”</span><br></pre></td></tr></table></figure><p>安装失败, 执行以下脚本卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot; </span><br><span class="line">报错：Failed to locate Homebrew!</span><br></pre></td></tr></table></figure><p>执行以下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;.git rm -rf Library .git .gitignore bin&#x2F;brew README.md share&#x2F;man&#x2F;man1&#x2F;brew rm -rf ~&#x2F;Library&#x2F;Caches&#x2F;Homebrew</span><br></pre></td></tr></table></figure><p>成功后，再次执行，下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><p>下载成功</p><h5 id="安装git版本管理工具"><a href="#安装git版本管理工具" class="headerlink" title="安装git版本管理工具"></a>安装git版本管理工具</h5><p><code>git</code> 是一个强大的版本管理工具，<code>github</code> 的版本管理就是基于 <code>git</code> 的，现在 <code>svn</code> 基本过时了，使用 <code>Git</code> 进行版本管理才是王道。安装完 <code>homebrew</code> 之后，安装 <code>Git</code> 几乎零成本，还是在 <code>terminal</code> 终端，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>然后等一段时间就 <code>ok</code> 了，<code>homebrew</code> 会自动去帮你完成下载安装。</p><h5 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h5><p><code>hexo</code> 是基于 <code>node.js</code> 的，所以要让 <code>hexo</code> 运行，<code>node.js</code> 环境是必不可少的。使用 <code>homebrew</code> 安装 <code>node.js</code> 也特别简单，在 <code>terminal</code> 终端输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>ps：安装最新版的 <code>Node.js</code> 之后，我们就可以使用 <code>npm</code> 命令，在 <code>mac</code> 下遇到 <code>npm</code> 命令找不到的问题，解决方案如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node &#x2F;usr&#x2F;lib&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node-waf &#x2F;usr&#x2F;bin&#x2F;node-waf</span><br></pre></td></tr></table></figure><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>前面我们安装了 <code>node.js</code>，装完 <code>node.js</code> 之后，我们就可以使用 <code>npm</code> 命令了，而 <code>hexo</code> 安装就是使用 <code>npm</code>，在终端输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>ps：等待一会儿，<code>hexo</code> 会自动完成下载安装。等 <code>hexo</code> 安装完成之后，在创建一个文件夹，这个文件夹以后就是你存放本地博客的地方了。</p><h4 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h4><p>创建新建一个文件夹，用来存放本地博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><code>hexo</code>会在创建的文件夹创建本地博客所需的一切资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>访问本地localhost:4000可以看到博客已经搭建成功。</p><h4 id="同步hexo博客到github"><a href="#同步hexo博客到github" class="headerlink" title="同步hexo博客到github"></a>同步hexo博客到github</h4><ul><li>配置本地和<code>github</code>的<code>ssh</code></li><li>在<code>github</code>上创建名字为<code>XXX.github.io</code>的项目，<code>XXX</code>为自己的<code>github</code>用户名。</li><li>开本地的创建的文件夹中的<code>_config.yml</code>配置文件，将其中的<code>type</code>设置为<code>git</code>。</li></ul><h6 id="检查你电脑上现有的ssh-key"><a href="#检查你电脑上现有的ssh-key" class="headerlink" title="检查你电脑上现有的ssh key"></a>检查你电脑上现有的ssh key</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh   # 切换到ssh目录</span><br><span class="line">ls -al ~&#x2F;.ssh # 查看</span><br></pre></td></tr></table></figure><p>注意：<br>如果你本地没有生成的话，终端上面会显示，<code>No such file or directory</code>。说明你是第一次使用git，如果已经存在的话，则会显示<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h6 id="获取ssh"><a href="#获取ssh" class="headerlink" title="获取ssh"></a>获取ssh</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096</span><br></pre></td></tr></table></figure><h6 id="配置github的ssh"><a href="#配置github的ssh" class="headerlink" title="配置github的ssh"></a>配置github的ssh</h6><p>登陆<code>github</code>后，点击右上角自己的头像–&gt;点击Your profile–&gt;点击你的博客远程仓库，页面中就能找到ssh。</p><p><img src="588630-6e5f1d0d3daf4880.png" alt="Paste_Image.png"></p><h4 id="安装自动部署发布工具"><a href="#安装自动部署发布工具" class="headerlink" title="安装自动部署发布工具"></a>安装自动部署发布工具</h4><p>这里用到了 hexo-deployer-git，使用如下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;sunjinshuai&#x2F;sunjinshuai.github.com</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>在terminal终端，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate   &#x2F;&#x2F; 可以简写成hexo g 根据markdown文件生成静态文件</span><br><span class="line">hexo deploy     &#x2F;&#x2F; 或者简写成hexo d 将本地修改，部署到远端</span><br></pre></td></tr></table></figure><p>此时，打开浏览器，访问<a href="https://sunjinshuai.github.io">https://sunjinshuai.github.io</a> ，就可以看到你的博客。</p><h4 id="Hexo安装新主题apollo"><a href="#Hexo安装新主题apollo" class="headerlink" title="Hexo安装新主题apollo"></a>Hexo安装新主题apollo</h4><p>Hexo换皮肤还是比较简单的，既可以自己根据默认的主题来修改，也可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 上去找主题。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>github上的文档给出了详细的安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init #blogname#</span><br><span class="line">cd #blogname#</span><br><span class="line">npm install</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pinggod&#x2F;hexo-theme-apollo.git themes&#x2F;apollo</span><br></pre></td></tr></table></figure><h5 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h5><p>安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: apollo</span><br><span class="line"></span><br><span class="line"># 在归档页面显示所有文章</span><br><span class="line"># 需要上面安装的 hexo-generator-archive 插件支持</span><br><span class="line">archive_generator:</span><br><span class="line">per_page: 0</span><br><span class="line">yearly: false</span><br><span class="line">monthly: false</span><br><span class="line">daily: false</span><br></pre></td></tr></table></figure><h4 id="hexo常用的命令"><a href="#hexo常用的命令" class="headerlink" title="hexo常用的命令"></a>hexo常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo init       &#x2F;&#x2F;在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件</span><br><span class="line">hexo new “my new blog title”   &#x2F;&#x2F;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</span><br><span class="line">hexo clean      &#x2F;&#x2F; 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存</span><br><span class="line">hexo generate   &#x2F;&#x2F; 可以简写成hexo g 根据markdown文件生成静态文件</span><br><span class="line">hexo server     &#x2F;&#x2F; 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问</span><br><span class="line">hexo deploy     &#x2F;&#x2F; 或者简写成hexo d 将本地修改，部署到远端</span><br><span class="line">hexo version    &#x2F;&#x2F; 显示hexo版本</span><br></pre></td></tr></table></figure><h4 id="关于HEXO安装失败的解决方法"><a href="#关于HEXO安装失败的解决方法" class="headerlink" title="关于HEXO安装失败的解决方法"></a>关于HEXO安装失败的解决方法</h4><p>目前国内npm源有问题；所以键入如下代码即可安装成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过各种找资料，踩过何种坑，终于搭建好了 &lt;code&gt;hexo&lt;/code&gt;，域名目前用得时 &lt;code&gt;github&lt;/code&gt; 的，我的 &lt;code&gt;hexo&lt;/code&gt; 是 &lt;code&gt;3.2.2&lt;/code&gt; 版本，&lt;code&gt;hexo&lt;/code&gt; 不同的版本
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://sunjinshuai.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
