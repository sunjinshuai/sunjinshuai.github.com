<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2018-09-12T13:35:30.040Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 KVO 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2018/09/11/%E6%B5%85%E8%B0%88-KVO-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2018/09/11/浅谈-KVO-的实现原理/</id>
    <published>2018-09-11T13:28:58.000Z</published>
    <updated>2018-09-12T13:35:30.040Z</updated>
    
    <content type="html"><![CDATA[<p><code>KVO</code> 全称 <code>KeyValueObserving</code> 是 <code>Objective-C</code> 对观察者模式<code>(Observer Pattern)</code>的实现；<code>KVO</code> 提供一种机制，当指定的对象的属性被修改后，则对象就会接受收到通知。简单的说就是每次指定的被观察的对象的属性被修改后，<code>KVO</code> 就会自动通知相应的观察者了。</p>
<h1 id="KVO-实现机制"><a href="#KVO-实现机制" class="headerlink" title="KVO 实现机制"></a>KVO 实现机制</h1><h4 id="使用KVO分为三个步骤："><a href="#使用KVO分为三个步骤：" class="headerlink" title="使用KVO分为三个步骤："></a>使用KVO分为三个步骤：</h4><ul>
<li>通过 <code>addObserver:forKeyPath:options:context:</code> 方法注册观察者，观察者可以接收 <code>keyPath</code> 属性的变化事件。</li>
<li>在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，当 <code>keyPath</code> 属性发生改变后，<code>KVO</code> 会回调这个方法来通知观察者。</li>
<li>当观察者不需要监听时，可以调用 <code>removeObserver:forKeyPath:</code> 方法将 <code>KVO</code> 移除。需要注意的是，调用 <code>removeObserver</code> 需要在观察者消失之前，否则会导致 <code>Crash</code>。</li>
</ul>
<p><code>Apple</code> 的文档有简单提到过 <code>KVO</code> 的实现：</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling… When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class …</p>
</blockquote>
<h4 id="简单概述下-KVO-的实现："><a href="#简单概述下-KVO-的实现：" class="headerlink" title="简单概述下 KVO 的实现："></a>简单概述下 <code>KVO</code> 的实现：</h4><p><strong><code>KVO</code> 是通过 <code>isa-swizzling</code> 技术实现的</strong>，当你观察一个对象时，一个新的类会动态被创建。这个类继承自该对象的原本的类，并重写了被观察属性的 <code>setter</code> 方法。重写的 <code>setter</code> 方法会在调用原 <code>setter</code> 方法之前和之后，通知所有观察对象值的更改。最后把这个对象的 <code>isa</code> 指针指向这个新创建的类，对象变成了新创建的类的实例，而不是原来真正的类。</p>
<h1 id="KVO-缺陷"><a href="#KVO-缺陷" class="headerlink" title="KVO 缺陷"></a><code>KVO</code> 缺陷</h1><p>使用 <code>KVO</code> 时，既需要进行注册成为某个对象属性的观察者，还要在合适的时间点将自己移除，在观察者中实现 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，并在方法里判断这次是不是自己要观测的属性发生了变化，并且很重要的一点就是 <code>KVO</code> 如果使用不当很容易导致 <code>Crash</code>。<br>例如，重复 <code>addObserver</code> 和 <code>removeObserver</code> 导致的 <code>Crash</code>，<code>Observer</code> 被释放导致的崩溃，<code>keyPath</code> 传错导致的崩溃等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface TestKVOViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) Message *message;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TestKVOViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    self.view.backgroundColor = [UIColor whiteColor];</div><div class="line">    </div><div class="line">    Message *message = [[Message alloc] init];</div><div class="line">    [message addObserver:self forKeyPath:@&quot;text&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil];</div><div class="line">    </div><div class="line">    message.text = @&quot;hello object-c&quot;;</div><div class="line">    self.message = message;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([keyPath isEqualToString:@&quot;text&quot;]) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, change);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</div><div class="line">    [self.message removeObserver:self forKeyPath:@&quot;text&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-21 12:29:03.397434+0800 ImplementKVO[18119:266230] [general] Caught exception during autorelease pool drain NSRangeException: Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer. userInfo: (null)</div><div class="line">2017-06-21 12:29:03.402598+0800 ImplementKVO[18119:266230] *** Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;Cannot remove an observer &lt;TestKVOViewController 0x7faf7b502610&gt; for the key path &quot;text&quot; from &lt;Message 0x60400001eef0&gt; because it is not registered as an observer.&apos;</div><div class="line">*** First throw call stack:</div><div class="line">(</div><div class="line">	0   CoreFoundation                      0x000000010efa11e6 __exceptionPreprocess + 294</div><div class="line">	1   libobjc.A.dylib                     0x000000010e636031 objc_exception_throw + 48</div><div class="line">	2   CoreFoundation                      0x000000010f016975 +[NSException raise:format:] + 197</div><div class="line">	3   Foundation                          0x000000010e061e43 -[NSObject(NSKeyValueObserverRegistration) _removeObserver:forProperty:] + 488</div><div class="line">	4   Foundation                          0x000000010e061c03 -[NSObject(NSKeyValueObserverRegistration) removeObserver:forKeyPath:] + 84</div><div class="line">	5   ImplementKVO                        0x000000010dd2de9c -[TestKVOViewController dealloc] + 172</div><div class="line">	6   UIKit                               0x000000010f406f74 __destroy_helper_block_.150 + 80</div><div class="line">	7   libsystem_blocks.dylib              0x0000000112a7098a _Block_release + 111</div><div class="line">	8   UIKit                               0x000000010f4e01e5 -[UIViewAnimationBlockDelegate .cxx_destruct] + 58</div><div class="line">	9   libobjc.A.dylib                     0x000000010e634920 _ZL27object_cxxDestructFromClassP11objc_objectP10objc_class + 127</div><div class="line">	10  libobjc.A.dylib                     0x000000010e640502 objc_destructInstance + 124</div><div class="line">	11  libobjc.A.dylib                     0x000000010e640539 object_dispose + 22</div><div class="line">	12  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</div><div class="line">	13  CoreFoundation                      0x000000010ef0464d -[__NSDictionaryI dealloc] + 125</div><div class="line">	14  libobjc.A.dylib                     0x000000010e64aa6e _ZN11objc_object17sidetable_releaseEb + 202</div><div class="line">	15  libobjc.A.dylib                     0x000000010e64b1b2 _ZN12_GLOBAL__N_119AutoreleasePoolPage3popEPv + 860</div><div class="line">	16  CoreFoundation                      0x000000010eeeb136 _CFAutoreleasePoolPop + 22</div><div class="line">	17  CoreFoundation                      0x000000010ef27eae __CFRunLoopRun + 2350</div><div class="line">	18  CoreFoundation                      0x000000010ef2730b CFRunLoopRunSpecific + 635</div><div class="line">	19  GraphicsServices                    0x0000000114119a73 GSEventRunModal + 62</div><div class="line">	20  UIKit                               0x000000010f41e057 UIApplicationMain + 159</div><div class="line">	21  ImplementKVO                        0x000000010dd2dfef main + 111</div><div class="line">	22  libdyld.dylib                       0x00000001129fe955 start + 1</div><div class="line">	23  ???                                 0x0000000000000001 0x0 + 1</div><div class="line">)</div><div class="line">libc++abi.dylib: terminating with uncaught exception of type NSException</div></pre></td></tr></table></figure>
<h1 id="手动实现-KVO"><a href="#手动实现-KVO" class="headerlink" title="手动实现 KVO"></a>手动实现 KVO</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef void(^ObservingBlock)(id observedObject, NSString *observedKey, id oldValue, id newValue);</div><div class="line"></div><div class="line">@interface NSObject (KVO)</div><div class="line"></div><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">forKey:(NSString *)key</div><div class="line">withBlock:(ObservingBlock)block;</div><div class="line"></div><div class="line">- (void)removeObserver:(NSObject *)observer forKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>接下来，实现 <code>addObserver:forKey:withBlock:</code> 方法：</p>
<ul>
<li>检查对象的类有没有相应的 <code>setter</code> 方法。如果没有抛出异常；</li>
<li>检查对象 <code>isa</code> 指向的类是不是一个 <code>KVO</code> 类。如果不是，新建一个继承原来类的子类，并把 <code>isa</code> 指向这个新建的子类；</li>
<li>检查对象的 <code>KVO</code> 类重写过没有这个 <code>setter</code> 方法。如果没有，添加重写的 <code>setter</code> 方法；</li>
<li>添加这个观察者；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 1. 通过Method判断是否有这个key对应的selector，如果没有则Crash。</div><div class="line"> 2. 判断当前类是否是KVO子类，如果不是则创建，并设置其isa指针。</div><div class="line"> 3. 如果没有实现，则添加Key对应的setter方法。</div><div class="line"> 4. 将调用对象添加到数组中。</div><div class="line"> */</div><div class="line">- (void)addObserver:(NSObject *)observer</div><div class="line">             forKey:(NSString *)key</div><div class="line">          withBlock:(ObservingBlock)block &#123;</div><div class="line">    </div><div class="line">    SEL setterSelector = NSSelectorFromString(setterForGetter(key));</div><div class="line">    Method setterMethod = class_getInstanceMethod([self class], setterSelector);</div><div class="line">    if (!setterMethod) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have a setter for key %@&quot;, self, key];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Class clazz = object_getClass(self);</div><div class="line">    NSString *clazzName = NSStringFromClass(clazz);</div><div class="line">    </div><div class="line">    // if not an KVO class yet</div><div class="line">    if (![clazzName hasPrefix:kKVOClassPrefix]) &#123;</div><div class="line">        clazz = [self makeKvoClassWithOriginalClassName:clazzName];</div><div class="line">        object_setClass(self, clazz);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // add our kvo setter if this class (not superclasses) doesn&apos;t implement the setter?</div><div class="line">    if (![self hasSelector:setterSelector]) &#123;</div><div class="line">        const char *types = method_getTypeEncoding(setterMethod);</div><div class="line">        class_addMethod(clazz, setterSelector, (IMP)kvo_setter, types);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ObservationInfo *info = [[ObservationInfo alloc] initWithObserver:observer Key:key block:block];</div><div class="line">    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</div><div class="line">    if (!observers) &#123;</div><div class="line">        observers = [NSMutableArray array];</div><div class="line">        objc_setAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers), observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    [observers addObject:info];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步，先通过 <code>setterForGetter()</code> 方法获得相应的 <code>setter</code> 的名字 <code>(SEL)</code> 。也就是把 <code>key</code> 的首字母大写，然后前面加上 <code>set</code> 后面加上 <code>:</code> ，这样 <code>key</code> 就变成了 <code>setKey:</code> 。然后再用 <code>class_getInstanceMethod</code> 去获得 <code>setKey:</code> 的实现 <code>(Method)</code> 。如果没有，自然要抛出异常。</p>
<p>第二步，我们先看类名有没有我们定义的前缀。如果没有，我们就去创建新的子类，并通过 <code>object_setClass()</code> 修改 <code>isa</code> 指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 1. 判断是否存在KVO类，如果存在则返回。</div><div class="line"> 2. 如果不存在，则创建KVO类。</div><div class="line"> 3. 重写KVO类的class方法，指向自定义的IMP。</div><div class="line"> */</div><div class="line">- (Class)makeKvoClassWithOriginalClassName:(NSString *)originalClazzName &#123;</div><div class="line">    NSString *kvoClazzName = [kKVOClassPrefix stringByAppendingString:originalClazzName];</div><div class="line">    Class clazz = NSClassFromString(kvoClazzName);</div><div class="line">    </div><div class="line">    if (clazz) &#123;</div><div class="line">        return clazz;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // class doesn&apos;t exist yet, make it</div><div class="line">    Class originalClazz = object_getClass(self);</div><div class="line">    Class kvoClazz = objc_allocateClassPair(originalClazz, kvoClazzName.UTF8String, 0);</div><div class="line">    </div><div class="line">    // grab class method&apos;s signature so we can borrow it</div><div class="line">    Method clazzMethod = class_getInstanceMethod(originalClazz, @selector(class));</div><div class="line">    const char *types = method_getTypeEncoding(clazzMethod);</div><div class="line">    class_addMethod(kvoClazz, @selector(class), (IMP)kvo_class, types);</div><div class="line">    </div><div class="line">    objc_registerClassPair(kvoClazz);</div><div class="line">    </div><div class="line">    return kvoClazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当动态创建新的类需要调用 <code>objc/runtime.h</code> 中定义的 <code>objc_allocateClassPair()</code> 函数。传一个父类，类名，然后额外的空间（通常为 0），它返回给你一个类。然后就给这个类添加方法，也可以添加变量。这里，我们只重写了 <code>class</code> 方法。跟 <code>Apple</code> 一样，这时候我们也企图隐藏这个子类的存在。最后 <code>objc_registerClassPair()</code> 告诉 <code>Runtime</code> 这个类的存在。</p>
<p>第三步，重写 <code>setter</code> 方法。新的 <code>setter</code> 在调用原 <code>setter</code> 方法后，通知每个观察者（调用之前传入的 block ）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">static void kvo_setter(id self, SEL _cmd, id newValue) &#123;</div><div class="line">    NSString *setterName = NSStringFromSelector(_cmd);</div><div class="line">    NSString *getterName = getterForSetter(setterName);</div><div class="line">    </div><div class="line">    if (!getterName) &#123;</div><div class="line">        NSString *reason = [NSString stringWithFormat:@&quot;Object %@ does not have setter %@&quot;, self, setterName];</div><div class="line">        @throw [NSException exceptionWithName:NSInvalidArgumentException</div><div class="line">                                       reason:reason</div><div class="line">                                     userInfo:nil];</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    id oldValue = [self valueForKey:getterName];</div><div class="line">    </div><div class="line">    struct objc_super superclazz = &#123;</div><div class="line">        .receiver = self,</div><div class="line">        .super_class = class_getSuperclass(object_getClass(self))</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    // cast our pointer so the compiler won&apos;t complain</div><div class="line">    void (*objc_msgSendSuperCasted)(void *, SEL, id) = (void *)objc_msgSendSuper;</div><div class="line">    </div><div class="line">    // call super&apos;s setter, which is original class&apos;s setter method</div><div class="line">    objc_msgSendSuperCasted(&amp;superclazz, _cmd, newValue);</div><div class="line">    </div><div class="line">    // look up observers and call the blocks</div><div class="line">    NSMutableArray *observers = objc_getAssociatedObject(self, (__bridge const void *)(kKVOAssociatedObservers));</div><div class="line">    for (ObservationInfo *each in observers) &#123;</div><div class="line">        if ([each.key isEqualToString:getterName]) &#123;</div><div class="line">            dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">                each.block(self, getterName, oldValue, newValue);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里会对 <code>objc_msgSendSuper</code> 进行类型转换。因为在 <code>Xcode 6</code> 之后， <code>LLVM</code> 会对 <code>objc_msgSendSuper</code> 以及 <code>objc_msgSend</code> 做严格的类型检查，如果不做类型转换。<code>Xcode</code> 会提示有 <code>too many arguments</code> 的错误。（在 WWDC 2014 的视频 What new in LLVM 中有提到过这个问题。）</p>
<p>最后一步，把这个观察的相关信息存在 <code>associatedObject</code> 里。观察的相关信息(观察者，被观察的 <code>key</code> , 和传入的 <code>block</code> )封装在 <code>ObservationInfo</code> 类里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface ObservationInfo : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, weak) NSObject *observer;</div><div class="line">@property (nonatomic, copy) NSString *key;</div><div class="line">@property (nonatomic, copy) ObservingBlock block;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ObservationInfo</div><div class="line"></div><div class="line">- (instancetype)initWithObserver:(NSObject *)observer</div><div class="line">                             Key:(NSString *)key</div><div class="line">                           block:(ObservingBlock)block &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _observer = observer;</div><div class="line">        _key = key;</div><div class="line">        _block = block;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p><a href="https://github.com/iOS-Strikers/MYKit" target="_blank" rel="external">KVO crash 防护方案</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;KVO&lt;/code&gt; 全称 &lt;code&gt;KeyValueObserving&lt;/code&gt; 是 &lt;code&gt;Objective-C&lt;/code&gt; 对观察者模式&lt;code&gt;(Observer Pattern)&lt;/code&gt;的实现；&lt;code&gt;KVO&lt;/code&gt; 提
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flutter之环境搭建</title>
    <link href="https://sunjinshuai.github.io/2018/07/25/Flutter%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://sunjinshuai.github.io/2018/07/25/Flutter之环境搭建/</id>
    <published>2018-07-25T03:11:45.000Z</published>
    <updated>2018-08-25T03:12:34.163Z</updated>
    
    <content type="html"><![CDATA[<p>一、获取Flutter SDK</p>
<p>要获得 <code>Flutter</code>，请先使用 <code>git</code> 克隆 <code>Flutter</code>，然后将该 <code>flutter</code> 工具添加到您的用户路径。运行 <code>flutter doctor</code> 显示您可能需要安装的剩余依赖项。</p>
<p>由于国内被墙，需要设置下载镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置</div><div class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置</div></pre></td></tr></table></figure></p>
<p>Clone Flutter repo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone -b beta https://github.com/flutter/flutter.git</div></pre></td></tr></table></figure>
<p>二、配置环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim ~/.bash_profile</div><div class="line">export PATH=`pwd`/flutter/bin:$PATH</div><div class="line">(或者)</div><div class="line"># export FLUTTER_HOME=/Users/sunjinshuai/flutter</div><div class="line"># export PATH=$PATH:$FLUTTER_HOME/bin:</div><div class="line">source ~/.bash_profile</div></pre></td></tr></table></figure>
<p>三、运行 flutter doctor</p>
<p>查看是否需要安装其它依赖项来完成安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div></pre></td></tr></table></figure>
<p>该命令检查您的环境并在终端窗口中显示报告，仔细检查命令行输出以获取可能需要安装的其他软件或进一步需要执行的任务，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</div><div class="line">[✗] Android toolchain - develop for Android devices</div><div class="line">✗ Unable to locate Android SDK.</div><div class="line">Install Android Studio from: https://developer.android.com/studio/index.html</div><div class="line">On first launch it will assist you in installing the Android SDK components.</div><div class="line">(or visit https://flutter.io/setup/#android-setup for detailed instructions).</div><div class="line">If Android SDK has been installed to a custom location, set $ANDROID_HOME to that location.</div><div class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</div><div class="line">[✓] Android Studio (version 3.1)</div><div class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</div><div class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</div><div class="line">[!] VS Code (version 1.25.1)</div><div class="line">[✓] Connected devices (2 available)</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>在 <a href="https://github.com/flutter/flutter/issues/13078" target="_blank" rel="external">https://github.com/flutter/flutter/issues/13078</a> 找到了解决方法，其实就是在 <code>bash_profile</code> 添加安卓SDK的环境变量即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">flutter doctor</div><div class="line"></div><div class="line">Doctor summary (to see all details, run flutter doctor -v):</div><div class="line">[✓] Flutter (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale zh-Hans-CN)</div><div class="line">[!] Android toolchain - develop for Android devices (Android SDK 28.0.1)</div><div class="line">✗ Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses</div><div class="line">[✓] iOS toolchain - develop for iOS devices (Xcode 9.2)</div><div class="line">[✓] Android Studio (version 3.1)</div><div class="line">✗ Flutter plugin not installed; this adds Flutter specific functionality.</div><div class="line">✗ Dart plugin not installed; this adds Dart specific functionality.</div><div class="line">[!] VS Code (version 1.25.1)</div><div class="line">[✓] Connected devices (2 available)</div><div class="line"></div><div class="line">! Doctor found issues in 2 categories.</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一、获取Flutter SDK&lt;/p&gt;
&lt;p&gt;要获得 &lt;code&gt;Flutter&lt;/code&gt;，请先使用 &lt;code&gt;git&lt;/code&gt; 克隆 &lt;code&gt;Flutter&lt;/code&gt;，然后将该 &lt;code&gt;flutter&lt;/code&gt; 工具添加到您的用户路径。运行 &lt;c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈 NSUserDefaults</title>
    <link href="https://sunjinshuai.github.io/2018/06/20/%E6%B5%85%E8%B0%88-NSUserDefaults/"/>
    <id>https://sunjinshuai.github.io/2018/06/20/浅谈-NSUserDefaults/</id>
    <published>2018-06-20T13:38:40.000Z</published>
    <updated>2018-09-12T13:40:27.315Z</updated>
    
    <content type="html"><![CDATA[<p><code>NSUserDefaults</code> 适用于快速读取小规模的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div></pre></td></tr></table></figure>
<p>写入数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;hahaha&quot;;</div><div class="line">[standardDefaults setObject:string forKey:@&quot;myKey&quot;];</div><div class="line">[standardDefaults synchronize];// 写完别忘了同步</div></pre></td></tr></table></figure></p>
<p>读取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *value = [standardDefaults objectForKey:@&quot;myKey&quot;];</div></pre></td></tr></table></figure></p>
<p><code>NSUserDefaults</code> 可以理解成键值对</p>
<p>有时在写数据之前，想判断下这个健是否已经设置过默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div><div class="line">if ([standardDefaults stringForKey:@&quot;favoriteColor&quot;] == nil) &#123;</div><div class="line">    [standardDefaults setObject:@&quot;Green&quot; forKey:@&quot;favoriteColor&quot;];</div><div class="line">    [standardDefaults synchronize];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实可以使用 <code>registerDefaults:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div><div class="line">[standardDefaults registerDefaults:@&#123;@&quot;favoriteColor&quot;: @&quot;Green&quot;&#125;];</div><div class="line">[standardDefaults synchronize];</div></pre></td></tr></table></figure>
<p>每次程序启动的时候调用 <code>registerDefaults:</code> 方法都是安全的，完全可以将这个方法的调用放到 <code>applicationDidFinishLaunching:</code> 方法中，这个方法永远都不会覆盖用户设置的值。</p>
<p>但是并不是所有类型的对象都能够直接放入 <code>NSUserDefaults</code>，<code>NSUserDefaults</code> 只支持 <code>Foundation</code> 类型的对象，如果自定义 <code>NSObject</code> 对象存入 <code>NSUserDefaults</code> 就要实现 <code>NSCoding</code> 协议了，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface Person : NSObject&lt;NSCoding&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *age;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">- (id)initWithCoder:(NSCoder *)coder;</div><div class="line">- (void)encodeWithCoder:(NSCoder *)coder;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">- (id)initWithCoder:(NSCoder *)coder &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        self.age  = [coder decodeObjectForKey:@&quot;age&quot;];</div><div class="line">        self.name = [coder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)encodeWithCoder: (NSCoder *)coder &#123;</div><div class="line">    [coder encodeObject:self.age forKey:@&quot;age&quot;];</div><div class="line">    [coder encodeObject:self.name forKey:@&quot;name&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再存取时通过 <code>NSData</code> 做载体：</p>
<p>存入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];</div><div class="line">Person *person = [[Person alloc] init];</div><div class="line">NSData *personData = [NSKeyedArchiver archivedDataWithRootObject:person];</div><div class="line">[standardDefaults setObject:personData forKey:@&quot;personKey&quot;];</div><div class="line">[standardDefaults synchronize];</div></pre></td></tr></table></figure>
<p>读取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSData *newPersonData = [standardDefaults objectForKey:&quot;personKey&quot;];</div><div class="line">Person *Person = [NSKeyedUnarchiver unarchiveObjectWithData:newPersonData];</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt; 适用于快速读取小规模的数据&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈 KVC</title>
    <link href="https://sunjinshuai.github.io/2018/04/12/%E6%B5%85%E8%B0%88-KVC/"/>
    <id>https://sunjinshuai.github.io/2018/04/12/浅谈-KVC/</id>
    <published>2018-04-12T14:37:32.000Z</published>
    <updated>2018-09-12T13:38:20.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>KVC</code> 是 <code>KeyValue Coding</code> 的简称，遵循 <code>NSKeyValueCoding</code> 协议，它是一种可以直接通过字符串的名字 <code>key</code> 来访问类属性的机制，而不是通过调用 <code>setter</code>、<code>getter</code> 方法访问。</p>
<p>对于 <code>KVC</code>，<code>Cocoa</code> 自动放入和取出基本数据类型放入 <code>NSNumber</code> 或 <code>NSValue</code> 中，当使用 <code>setValue:ForKey:</code> 或者 <code>valueForKey:</code> 时，它自动将基本数据类型从这些对象中取出，仅 <code>KVC</code> 具有这种自动包装功能，常规方法调用和属性语法不具备该功能。</p>
<h1 id="setValue-forKey-的实现方式："><a href="#setValue-forKey-的实现方式：" class="headerlink" title="setValue:forKey 的实现方式："></a><code>setValue:forKey</code> 的实现方式：</h1><p>以字符串的形式向对象发送消息，首先查找以 <code>set&lt;Key&gt;</code> 命名的 <code>setter</code> 方法，如果成员用 <code>@property</code>，<code>@synthsize</code> 处理，因为 <code>@synthsize</code> 告诉编译器自动生成 <code>set&lt;Key&gt;:</code> 格式的 <code>setter</code> 方法，所以这种情况下会直接搜索到。如果上面的 <code>setter</code> 方法没有找到，如果类方法 <code>accessInstanceVariablesDirectly</code> 返回 <code>YES</code>，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。如果找到则设置成员的值，如果没有查找调用 <code>setValue:forUndefinedKey:</code>。</p>
<h1 id="valueForKey-的实现方式："><a href="#valueForKey-的实现方式：" class="headerlink" title="valueForKey: 的实现方式："></a><code>valueForKey:</code> 的实现方式：</h1><ul>
<li>首先查找以 <code>get&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;Key&gt;</code> 命名的 <code>getter</code> 方法，找到直接调用。</li>
<li>如果上面的 <code>getter</code> 没有找到，则会查找 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 格式的方法，找到就会调用 <code>countOf&lt;Key&gt;</code>、<code>objectIn&lt;Key&gt;AtIndex:</code>、<code>&lt;Key&gt;AtIndexes</code> 方法，还有一个可选的 <code>get&lt;Key&gt;:range:</code> 方法。</li>
<li>若是还没查到，那么查找 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 格式的方法，如果找到就调用 <code>countOf&lt;Key&gt;</code>、<code>enumeratorOf&lt;Key&gt;</code>、<code>memberOf&lt;Key&gt;:</code> 方法。</li>
<li>若是还没查到，那么如果类方法 accessInstanceVariablesDirectly 返回 YES，那么将在对象内部查找名为 <code>_&lt;key&gt;</code>、<code>_is&lt;Key&gt;</code>、<code>&lt;key&gt;</code>、<code>is&lt;key&gt;</code> 的实例变量。</li>
<li>再没查到，调用 <code>valueForUndefinedKey:</code>。</li>
</ul>
<p>综上，<strong>使用 KVC 访问属性的代价比直接使用存取方法性能开销要大</strong>。</p>
<h1 id="值的正确性核查"><a href="#值的正确性核查" class="headerlink" title="值的正确性核查"></a>值的正确性核查</h1><p>KVC 提供属性值确认的 API，它可以用来检查 set 的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</p>
<p>实现核查方法，为如下格式：<code>validate&lt;Key&gt;:error:</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateName:(id *)ioValue error:(NSError **)outError &#123;</div><div class="line">    // The name must not be nil, and must be at least two characters long.</div><div class="line">    if ((*ioValue == nil) || ([(NSString *)*ioValue length] &lt; 2]) &#123;</div><div class="line">        if (outError != NULL) &#123;</div><div class="line">            NSString *errorString = NSLocalizedStringFromTable(</div><div class="line">                    @&quot;A Person&apos;s name must be at least two characters long&quot;, @&quot;Person&quot;,</div><div class="line">                    @&quot;validation: too short name error&quot;);</div><div class="line">            NSDictionary *userInfoDict =</div><div class="line">                [NSDictionary dictionaryWithObject:errorString</div><div class="line">                                            forKey:NSLocalizedDescriptionKey];</div><div class="line">            *outError = [[[NSError alloc] initWithDomain:PERSON_ERROR_DOMAIN</div><div class="line">                                                    code:PERSON_INVALID_NAME_CODE</div><div class="line">                                                userInfo:userInfoDict] autorelease];</div><div class="line">        &#125;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用核查方法：<br><code>validateValue:forKey:error:</code>，默认实现会搜索 <code>validate&lt;Key&gt;:error:</code>格式的核查方法，找到则调用，未找到默认返回 <code>YES</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;KVC&lt;/code&gt; 是 &lt;code&gt;KeyValue Coding&lt;/code&gt; 的简称，遵循 &lt;code&gt;NSKeyValu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>九宫格常用的宏</title>
    <link href="https://sunjinshuai.github.io/2018/01/16/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AE%8F/"/>
    <id>https://sunjinshuai.github.io/2018/01/16/九宫格常用的宏/</id>
    <published>2018-01-16T13:47:19.000Z</published>
    <updated>2018-09-12T13:47:58.245Z</updated>
    
    <content type="html"><![CDATA[<p>常用九宫格定义的宏如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">/**************************无间距****************************/</div><div class="line">/** 设置格子的X坐标</div><div class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</div><div class="line"> * WIDTH     指九宫格每个小格子的宽度  int width = (SCREEN_WIDTH - (colunm - 1) * margin) / colunm;</div><div class="line"> * COLUMN    指九宫格的纵向列数</div><div class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</div><div class="line"> */</div><div class="line">#define CELL_X_WITH_SUPERVIEW_AND_WIDTH(SUPERVIEW,WIDTH,COLUMN) SUPERVIEW.subviews.count % COLUMN * WIDTH</div><div class="line"></div><div class="line">/** 设置格子的Y坐标</div><div class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</div><div class="line"> * WIDTH     指九宫格每个小格子的宽度  int width = (SCREEN_WIDTH - (colunm - 1) * margin) / colunm;</div><div class="line"> * COLUMN    指九宫格的纵向列数</div><div class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</div><div class="line"> */</div><div class="line">#define CELL_Y_WITH_SUPERVIEW_AND_HEIGHT(SUPERVIEW,HEIGHT,COLUMN) SUPERVIEW.subviews.count / COLUMN * HEIGHT</div><div class="line"></div><div class="line">/**************************有间距****************************/</div><div class="line">/** 设置格子的X坐标</div><div class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</div><div class="line"> * WIDTH     指九宫格每个小格子的宽度  int width = (SCREEN_WIDTH - (colunm - 1) * margin) / colunm;</div><div class="line"> * COLUMN    指九宫格的纵向列数</div><div class="line"> * MARGIN    指格子之间的横向间距</div><div class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</div><div class="line"> */</div><div class="line">#define CELL_X_WITH_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + SUPERVIEW.subviews.count % COLUMN  * MARGIN</div><div class="line"></div><div class="line">/** 设置格子的Y坐标</div><div class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</div><div class="line"> * HEIGHT    指九宫格每个小格子的高度</div><div class="line"> * COLUMN    指九宫格的纵向列数</div><div class="line"> * MARGIN    指格子之间的纵向间距</div><div class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</div><div class="line"> */</div><div class="line">#define CELL_Y_WITH_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count / COLUMN * HEIGHT + SUPERVIEW.subviews.count / COLUMN * MARGIN</div><div class="line"></div><div class="line">/**************************有间距、有边距****************************/</div><div class="line">/** 设置格子的X坐标</div><div class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</div><div class="line"> * WIDTH     指九宫格每个小格子的宽度 int width = (SCREEN_WIDTH - (colunm + 1) * margin) / colunm;</div><div class="line"> * COLUMN    指九宫格的纵向列数</div><div class="line"> * MARGIN    指格子之间的横向间距 和 外边距</div><div class="line"> * 注意： MARGIN 和 WIDTH 不能都是 CGFloat</div><div class="line"> */</div><div class="line">#define CELL_X_WITH_EDGE_PARAMETERS(SUPERVIEW,WIDTH,COLUMN,MARGIN) SUPERVIEW.subviews.count % COLUMN * WIDTH + (SUPERVIEW.subviews.count % COLUMN + 1) * MARGIN</div><div class="line"></div><div class="line">/** 设置格子的Y坐标</div><div class="line"> * SUPERVIEW 指九宫格每个小格子的父视图</div><div class="line"> * HEIGHT    指九宫格每个小格子的高度</div><div class="line"> * COLUMN    指九宫格的纵向列数</div><div class="line"> * MARGIN    指格子之间的纵向间距 和 外边距</div><div class="line"> * 注意： MARGIN 和 HEIGHT 不能都是 CGFloat</div><div class="line"> */</div><div class="line">#define CELL_Y_WITH_EDGE_PARAMETERS(SUPERVIEW,HEIGHT,COLUMN,MARGIN) SUPERVIEW.subviews.count / COLUMN * HEIGHT + (SUPERVIEW.subviews.count / COLUMN + 1) * MARGIN</div></pre></td></tr></table></figure>
<p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/SudokuDemo" target="_blank" rel="external">九宫格demo地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用九宫格定义的宏如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谈谈 Autolayout</title>
    <link href="https://sunjinshuai.github.io/2017/12/18/%E8%B0%88%E8%B0%88%20Autolayout/"/>
    <id>https://sunjinshuai.github.io/2017/12/18/谈谈 Autolayout/</id>
    <published>2017-12-18T14:16:11.000Z</published>
    <updated>2018-08-25T02:51:53.750Z</updated>
    
    <content type="html"><![CDATA[<h4 id="关于Autolayout的调试"><a href="#关于Autolayout的调试" class="headerlink" title="关于Autolayout的调试"></a>关于Autolayout的调试</h4><p>刚开始使用 Autolayout 遇到下面的警告人容易让人气馁，经常不知所措而放弃了使用 Autolayout。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Unable to simultaneously satisfy constraints.</div><div class="line">Probably at least one of the constraints in the following list is one you don&apos;t want.</div><div class="line">Try this:</div><div class="line"></div><div class="line">(1) look at each constraint and try to figure out which you don&apos;t expect;</div><div class="line">(2) find the code that added the unwanted constraint or constraints and fix it.</div><div class="line">(Note: If you&apos;re seeing NSAutoresizingMaskLayoutConstraints that you don&apos;t understand, refer to the documentation for the UIView property translatesAutoresizingMaskIntoConstraints)</div><div class="line">(...........)</div><div class="line"></div><div class="line">Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger.</div><div class="line">The methods in the UIConstraintBasedLayoutDebugging category on UIView listed in &lt;UIKit/UIView.h&gt; may also be helpful.</div></pre></td></tr></table></figure></p>
<p>正如输出中所述，<code>Make a symbolic breakpoint at UIViewAlertForUnsatisfiableConstraints to catch this in the debugger</code>，现在介绍下使用 <code>UIViewAlertForUnsatisfiableConstraints</code> 的调试方法。</p>
<p>在 <code>UIViewAlertForUnsatisfiableConstraints</code> 添加 <code>symbolic breakpoint</code>：</p>
<ul>
<li>打开断点导航（cmd+7）</li>
<li>点击左下角的+按钮</li>
<li>选择Add Symbolic Breakpoint</li>
<li>在Symbol添加UIViewAlertForUnsatisfiableConstraints</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-352497a3fe02d591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>再次调试的时候就可以通过 lldb 来调试了，然并卵，如果你不知道 lldb 的话。</p>
<p>所以交给你一个小技巧，添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">po [[UIWindow keyWindow] _autolayoutTrace] // OC项目</div><div class="line">expr -l objc++ -O -- [[UIWindow keyWindow] _autolayoutTrace] // Swift项目</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-14bda92176ecfd3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这样就可以直接看到输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(lldb) po [[UIWindow keyWindow] _autolayoutTrace]</div><div class="line">UIWindow:0x7f9481c93360</div><div class="line">|   •UIView:0x7f9481c9d680</div><div class="line">|   |   *UIView:0x7f9481c9d990- AMBIGUOUS LAYOUT for UIView:0x7f9481c9d990.minX&#123;id: 13&#125;, UIView:0x7f9481c9d990.minY&#123;id: 16&#125;</div><div class="line">|   |   *_UILayoutGuide:0x7f9481c9e160- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9e160.minY&#123;id: 17&#125;</div><div class="line">|   |   *_UILayoutGuide:0x7f9481c9ebb0- AMBIGUOUS LAYOUT for _UILayoutGuide:0x7f9481c9ebb0.minY&#123;id: 27&#125;</div></pre></td></tr></table></figure></p>
<p>其中 AMBIGUOUS 相关的视图就是约束有问题的。0x7f9481c9d990就是有问题视图的首地址。</p>
<p>当然进一步的调试需要 lldb 的命令。比如，打印视图对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) po 0x7f9481c9d990</div><div class="line">&lt;UIView: 0x7f9481c9d990; frame = (0 0; 768 359); autoresize = RM+BM; layer = &lt;CALayer: 0x7fc82d338960&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>改变颜色：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(lldb) expr ((UIView *)0x174197010).backgroundColor = [UIColor redColor]</div><div class="line">(UICachedDeviceRGBColor *) $4 = 0x0000000174469cc0</div></pre></td></tr></table></figure></p>
<p>剩下的就是去代码中找到这个视图，然后修改其约束了。</p>
<h4 id="AutoLayout-关于-update-的几个方法"><a href="#AutoLayout-关于-update-的几个方法" class="headerlink" title="AutoLayout 关于 update 的几个方法"></a>AutoLayout 关于 update 的几个方法</h4><p>UIView 是我们经常使用的一个基本控件，其中有几个基本的布局方法需要清楚。</p>
<ul>
<li>layoutSubViews：</li>
</ul>
<p>当 <code>View</code> 及其所有子视图的 <code>frame</code> 发生改变的时候，会调用 <code>layoutSubviews</code>，所以在需要更新 frame 来重新定位或更改大小时重载它。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。注意：<strong>最好不要在代码中手动调用 <code>layoutSubviews</code> 方法</strong>。当 <code>layoutSubviews</code> 完成后，在 <code>view</code> 的所有者 <code>view controller</code> 上，会触发  <code>viewDidLayoutSubviews</code> 调用。因为 <code>viewDidLayoutSubviews</code> 是 <code>view</code> 布局更新后会被唯一可靠调用的方法，所以你应该把所有依赖于布局或者大小的代码放在 <code>viewDidLayoutSubviews</code> 中，而不是放在 <code>viewDidLoad</code> 或者 <code>viewDidAppear</code> 中。</p>
<p>触发 <code>layoutSubviews</code> 的时机：</p>
<ul>
<li><code>addSubview</code> 方法会触发 <code>layoutSubviews</code>。</li>
<li>当 <code>view</code> 的 <code>Frame</code> 发生变化也会触发<code>layoutSubviews</code>。</li>
<li>滚动一个 <code>UIScrollView</code> 会触发 <code>layoutSubviews</code>。</li>
<li>旋转屏幕会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</li>
<li><p>改变一个 <code>View</code> 大小的时候也会触发父 <code>View</code> 上的 <code>layoutSubviews</code>。</p>
</li>
<li><p>setNeedsLayout<br>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法，表示视图的布局需要重新计算。告知页面需要更新，但是不会立刻开始更新视图，视图会在下一个 <code>runloop</code> 中更新，调用 <code>setNeedsLaylout</code> 方法视图被重新绘制并布局之间会有一段任意时间的间隔。</p>
</li>
<li><p>layoutIfNeeded<br>调用 <code>layoutIfNeeded</code> 会触发 <code>layoutSubviews</code>，告知页面布局立刻更新，所以一般都会和 <code>setNeedsLayout</code> 一起使用。如果希望立刻生成新的 <code>frame</code> 需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</p>
</li>
<li><p>setNeedsUpdateConstraints<br>告知需要更新约束，但是不会立刻开始，在下一次 <code>runloop</code> 中更新约束，通过标记 <code>update constraints</code> 来触发 <code>updateConstraints</code>。</p>
</li>
<li><p>updateConstraintsIfNeeded<br>告知立刻更新约束，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 <code>update constraints</code> 标记。如果认为这些约束需要被更新，它会立即触发 <code>updateConstraints</code>，而不会等到 <code>run loop</code> 的末尾。</p>
</li>
<li><p>updateConstraints<br>系统更新约束，注意：<strong>最好不要在代码中手动调用 <code>updateConstraints</code> 方法</strong>。通常在 <code>updateConstraints</code> 方法中实现必须要更新的约束，在设置或者解除约束、更改约束的优先级或者常量值，或者从视图层级中移除一个视图时都会设置一个内部的标记 <code>update constarints</code>，这个标记会在下一个更新周期中触发调用 <code>updateConstrains</code>。</p>
</li>
</ul>
<p><strong>注意：layoutSubViews 在 drawRect 之前调用。</strong></p>
<h4 id="AutoLayout-与-Frame"><a href="#AutoLayout-与-Frame" class="headerlink" title="AutoLayout 与 Frame"></a>AutoLayout 与 Frame</h4><p>在使用 AutoLayout 的时候可能也会同时也会用到 frame，比如需要用到 layer 的时候，想让 layer 的尺寸是由其它视图尺寸设定的，而这个视图又是由约束控制布局的，如果将 layer 的初始化与 view 的初始化放在一个方法中；<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">layer.bounds = CGRectMake(0,0,view.bounds.size.widith * 0.5,50)</div></pre></td></tr></table></figure></p>
<p>那么很可能拿到 layer 的宽度是0。</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">UIView *redView = [[UIView alloc] init];</div><div class="line">redView.backgroundColor = [UIColor redColor];</div><div class="line">[self.view addSubview:redView];</div><div class="line">self.redView = redView;</div><div class="line">    </div><div class="line">// 设置约束</div><div class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">  make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">  make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">  make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">&#125;];</div><div class="line">    </div><div class="line">NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">2017-06-08 15:32:51.815107+0800 MasonryDemo[42940:1076244] self.view 的尺寸&lt;UIView: 0x7fd8cd408960; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000227200&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fd8cd407650; frame = (0 0; 0 0); layer = &lt;CALayer: 0x6040002274a0&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>这个时候，看到为什么设置了约束，而打印出来的 frame 是 (0 0; 0 0)，是因为约束被设置之后它并不会立即对 view 作出改变，而是要等到 layout 时，才会对视图的尺寸进行修改，而 layout 通常是在视图已经加载到父视图上面时做出响应。</p>
<p>所以如果在 viewDidLoad 中设置了约束，那么要等到 viewDidAppear 时 view 的尺寸才会真正改变。</p>
<p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLayoutSubviews &#123;</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">    </div><div class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,self.redView);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-08 15:50:41.621147+0800 MasonryDemo[43363:1089098] self.view 的尺寸&lt;UIView: 0x7fe412f0f780; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000238b00&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe412e045b0; frame = (132 328; 150 80); layer = &lt;CALayer: 0x60000003c460&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>1、把获取 frame 的设置写到 layoutSubviews 中或者写到 viewDidLayoutSubviews 中即可。因为 layout 约束生效时 view 的 center 或者 bounds 就会被修改，当 center 或者 bounds 被修改时layoutSubview 就会被调用，随后 viewDidLayoutSubviews 就回被调用。这个时候，设置约束的视图 frame 就不再是 (0,0,0,0) 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">    [redView setNeedsLayout];</div><div class="line">    [redView layoutIfNeeded];</div><div class="line">    NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">&#125;</div><div class="line">2017-06-08 15:52:32.749105+0800 MasonryDemo[43419:1090641] self.view 的尺寸&lt;UIView: 0x7fe36440b5f0; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x604000422100&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fe364405040; frame = (-75 -40; 150 80); layer = &lt;CALayer: 0x6040004207a0&gt;&gt;</div></pre></td></tr></table></figure>
<p>2、如果将约束和 frame 写在同一方法中，写完约束就设置 frame，而不是想把 frame 的设置放到 layoutSubview 中，比如设置好约束后马上就想根据约束的结果计算高度，那么必须在设置完约束之后手动调用<br>setNeedsLayout 和 layoutIfNeeded 方法，让视图立即 layout，更新 frame，<strong>但是这个时候就可以拿到真实的 size 并不能拿到真实的 center ，不建议这么使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)testLayout &#123;</div><div class="line">    </div><div class="line">    UIView *redView = [[UIView alloc] init];</div><div class="line">    redView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:redView];</div><div class="line">    self.redView = redView;</div><div class="line">    </div><div class="line">    // 设置约束</div><div class="line">    [redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">        make.centerX.equalTo(self.view.mas_centerX);</div><div class="line">        make.centerY.equalTo(self.view.mas_centerY);</div><div class="line">        make.size.mas_equalTo(CGSizeMake(150, 80));</div><div class="line">    &#125;];</div><div class="line">   </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;self.view 的尺寸%@，redView 的尺寸%@&quot;,self.view,redView);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">2017-06-08 15:55:56.282546+0800 MasonryDemo[43500:1092911] self.view 的尺寸&lt;UIView: 0x7fda85e0d540; frame = (0 0; 414 736); autoresize = W+H; layer = &lt;CALayer: 0x600000233620&gt;&gt;，redView 的尺寸&lt;UIView: 0x7fda85e0c770; frame = (132 328; 150 80); layer = &lt;CALayer: 0x600000233540&gt;&gt;</div></pre></td></tr></table></figure>
<p>3、在 dispatch_after 里面可以拿到真实的 frame ，或许是因为设置约束和获取 frame 不在同一个 runloop 的原因吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;关于Autolayout的调试&quot;&gt;&lt;a href=&quot;#关于Autolayout的调试&quot; class=&quot;headerlink&quot; title=&quot;关于Autolayout的调试&quot;&gt;&lt;/a&gt;关于Autolayout的调试&lt;/h4&gt;&lt;p&gt;刚开始使用 Autolayout 遇
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git 奇技淫巧</title>
    <link href="https://sunjinshuai.github.io/2017/12/12/git-%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    <id>https://sunjinshuai.github.io/2017/12/12/git-奇技淫巧/</id>
    <published>2017-12-12T13:45:47.000Z</published>
    <updated>2018-09-12T13:46:14.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h1><h2 id="添加-Tag"><a href="#添加-Tag" class="headerlink" title="添加 Tag"></a>添加 Tag</h2><p>例如：1.0.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a 1.0.0 -m &quot;1.0.0 版本的备注信息.&quot;</div></pre></td></tr></table></figure>
<h2 id="推送所有-tag，同步到远程仓库："><a href="#推送所有-tag，同步到远程仓库：" class="headerlink" title="推送所有 tag，同步到远程仓库："></a>推送所有 tag，同步到远程仓库：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin --tags</div></pre></td></tr></table></figure>
<h2 id="删除本地-Tag"><a href="#删除本地-Tag" class="headerlink" title="删除本地 Tag"></a>删除本地 Tag</h2><p>例如：1.0.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -d 1.0.0</div></pre></td></tr></table></figure>
<p>删除远程标签需要先删除本地标签，再执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git push origin :refs/tags/1.0.0</div><div class="line">git push origin --delete tag 1.0.0</div></pre></td></tr></table></figure>
<h2 id="展示当前分支的最近的tag"><a href="#展示当前分支的最近的tag" class="headerlink" title="展示当前分支的最近的tag"></a>展示当前分支的最近的tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git describe --tags --abbrev=0</div></pre></td></tr></table></figure>
<h2 id="默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag："><a href="#默认-tag-是打在最近的一次-commit-上，如果需要指定-commit-打-tag：" class="headerlink" title="默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag："></a>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a &lt;version-number&gt; -m &quot;v1.0.0 发布(描述)&quot; &lt;commit-id&gt;</div></pre></td></tr></table></figure>
<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -</div></pre></td></tr></table></figure>
<h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch --merged master | grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d</div></pre></td></tr></table></figure>
<h2 id="列出远程服务器和本地的所有分支，以及分支上的最后提交"><a href="#列出远程服务器和本地的所有分支，以及分支上的最后提交" class="headerlink" title="列出远程服务器和本地的所有分支，以及分支上的最后提交"></a>列出远程服务器和本地的所有分支，以及分支上的最后提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -vv</div></pre></td></tr></table></figure>
<h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -a</div></pre></td></tr></table></figure></p>
<h2 id="列出所有远程服务器上的分支"><a href="#列出所有远程服务器上的分支" class="headerlink" title="列出所有远程服务器上的分支"></a>列出所有远程服务器上的分支</h2><p>-r参数相当于：remote<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -r</div></pre></td></tr></table></figure></p>
<h2 id="同步本地与远程分支"><a href="#同步本地与远程分支" class="headerlink" title="同步本地与远程分支"></a>同步本地与远程分支</h2><p>删除远程不存在的本地分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch --p</div></pre></td></tr></table></figure>
<h2 id="更新远程跟踪分支"><a href="#更新远程跟踪分支" class="headerlink" title="更新远程跟踪分支"></a>更新远程跟踪分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div></pre></td></tr></table></figure>
<h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b &lt;branch-name&gt;</div></pre></td></tr></table></figure>
<h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</div></pre></td></tr></table></figure>
<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git push origin --delete &lt;remote-branchname&gt;</div><div class="line">git push origin :&lt;remote-branchname&gt;</div></pre></td></tr></table></figure>
<h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -m &lt;new-branch-name&gt;</div></pre></td></tr></table></figure>
<h1 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h1><h2 id="合并本地的最后两次-commit"><a href="#合并本地的最后两次-commit" class="headerlink" title="合并本地的最后两次 commit"></a>合并本地的最后两次 commit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD^git commit --amend</div></pre></td></tr></table></figure>
<h2 id="修改上一次的-commit-信息"><a href="#修改上一次的-commit-信息" class="headerlink" title="修改上一次的 commit 信息"></a>修改上一次的 commit 信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit --amend</div></pre></td></tr></table></figure>
<h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --pretty=oneline --graph --decorate --all</div></pre></td></tr></table></figure>
<h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git revert &lt;commit-id&gt;</div></pre></td></tr></table></figure>
<h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git reset &lt;commit-id&gt;  #默认就是-mixed参数。</div><div class="line">git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</div><div class="line">git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   </div><div class="line">git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</div></pre></td></tr></table></figure>
<h2 id="查看指定路径文件代码是谁写的"><a href="#查看指定路径文件代码是谁写的" class="headerlink" title="查看指定路径文件代码是谁写的"></a>查看指定路径文件代码是谁写的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git blame &lt;file-name&gt;</div></pre></td></tr></table></figure>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="删除远程仓库地址"><a href="#删除远程仓库地址" class="headerlink" title="删除远程仓库地址"></a>删除远程仓库地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote remove origin &lt;remote-url&gt;</div></pre></td></tr></table></figure>
<h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin &lt;URL&gt;</div></pre></td></tr></table></figure>
<h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin &lt;remote-url&gt;</div></pre></td></tr></table></figure>
<h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote</div></pre></td></tr></table></figure>
<h1 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h1><p>暂存命令stash使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git stash #将本地修改暂时存储起来</div><div class="line">git stash list #查看暂存的信息</div><div class="line">git stash pop  #应用最近一次暂存的内容</div><div class="line">git stash apply stash@&#123;1&#125; #应用指定版本的暂存内容</div><div class="line">git stash clear  #清空暂存栈</div><div class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt; #从stash中拿出某个文件的修改</div></pre></td></tr></table></figure></p>
<h1 id="Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法"><a href="#Git取消合并-merge-、暂存修改-stash-、回退到某个版本-reset-的使用方法" class="headerlink" title="Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法"></a>Git取消合并(merge)、暂存修改(stash)、回退到某个版本(reset)的使用方法</h1><p>例如：取消某次合并<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git merge --abort #如果Git版本 &gt;= 1.7.4</div><div class="line">git reset --merge #如果Git版本 &gt;= 1.6.1</div></pre></td></tr></table></figure></p>
<p>注意：<br>在合并之前要保证没有未提交的文件，如果有未提交的文件但现在又不想提交，用stash命令暂存。</p>
<p>回退到某个版本并应用指定的几次提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git reset --hard 1d7444 #回退到某个版本</div><div class="line">git cherry-pick 626335 #将某次commit的更改应用到当前版本</div><div class="line">git cherry-pick …</div><div class="line">git push origin HEAD --force  #强制提交</div></pre></td></tr></table></figure></p>
<p>注意：<br>如果是撤销某次提交，可以用revert命令，git revert是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留; git reset是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区。</p>
<h1 id="git强制push"><a href="#git强制push" class="headerlink" title="git强制push"></a>git强制push</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master -f</div></pre></td></tr></table></figure>
<h1 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h1><p>不添加参数，默认是-mixed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset &lt;file-name&gt;</div></pre></td></tr></table></figure></p>
<h1 id="撤销所有未提交的本地修改"><a href="#撤销所有未提交的本地修改" class="headerlink" title="撤销所有未提交的本地修改"></a>撤销所有未提交的本地修改</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout .</div></pre></td></tr></table></figure>
<h1 id="Push-本地分支到指定远程分支"><a href="#Push-本地分支到指定远程分支" class="headerlink" title="Push 本地分支到指定远程分支"></a>Push 本地分支到指定远程分支</h1><p>例如：Push 本地当前分支到远程仓库 origin 的 master 分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tag&quot;&gt;&lt;a href=&quot;#Tag&quot; class=&quot;headerlink&quot; title=&quot;Tag&quot;&gt;&lt;/a&gt;Tag&lt;/h1&gt;&lt;h2 id=&quot;添加-Tag&quot;&gt;&lt;a href=&quot;#添加-Tag&quot; class=&quot;headerlink&quot; title=&quot;添加 Tag&quot;&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac安装Jenkins系列</title>
    <link href="https://sunjinshuai.github.io/2017/11/29/Mac%E5%AE%89%E8%A3%85Jenkins%E7%B3%BB%E5%88%97/"/>
    <id>https://sunjinshuai.github.io/2017/11/29/Mac安装Jenkins系列/</id>
    <published>2017-11-29T15:29:13.000Z</published>
    <updated>2017-11-29T15:37:01.651Z</updated>
    
    <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种<a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90" target="_blank" rel="external">持续集成</a>工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>持续的软件版本发布/测试项目。</li>
<li>监控外部调用执行的工作。</li>
</ul>
<p>使用Jenkins持续化集成，可以帮助开发人员，缩减开发周期，快速迭代版本，开发人员只关注开发任务，像给测试、产品、市场人员打包等等，这些任务就可以交给其他人员来完成，利用Jenkins的优点，只需要点击构建项目，就能完成自动打包，测试人员也只需要扫一下二维码即可安装，很方便，这也算是给测试带来的便利。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>登录<a href="https://jenkins.io/" target="_blank" rel="external">Jenkins官网</a>下载Jenkins；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-67232327f1f66e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击Download：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-a17520b0ba049c02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-920782eda654745c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>备注：需要注意的是在下载的时候勾选Mac平台下的pkg包。</p>
<p>下载下来以后，双击即可安装，安装时第一步是输入密码：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-75923641c13ee123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e372d2df9e67fcfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-389a2ae653be2a0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93ccab9f5d1487d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ab7a00ae5191423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-faeb4b1fca308f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e61a43c8638c2816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装完成之后，Safari可能会自动打开，如果没有自动打开，打开浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a></p>
<ul>
<li>在Safari浏览器上，会出现Safari不能连接到服务器。</li>
<li>在谷歌浏览器上，会报<strong>“dial tcp [::1]:8080: getsockopt: connection refused”</strong>。</li>
</ul>
<p>解决方案：<br>猜想可能是Mac电脑上没有安装Java环境，安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank" rel="external">jre</a>、安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">jdk</a>之后，从新刷新浏览器，友好的界面出现了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-df2b3456b8b381ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果Mac电脑上面安装了Java环境，重启浏览器，输入<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080</a><br><img src="http://upload-images.jianshu.io/upload_images/588630-50b8f63e09d44fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6d9b459270d4af71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>可以通过下面两种方式获取初始化密码：</p>
<ul>
<li>打开terminal，执行cat命令即可(需要管理员权限)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat /Users/Shared/Jenkins/Home/secrets/initialAdminPassword</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ce8ca0f2434b3c1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>打开Finder，前往文件夹“/Users/Shared/Jenkins/Home/”</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-76d711eea2a7e14d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>把secrets文件下面的initialAdminPassword用文本编辑器打开，<br><img src="http://upload-images.jianshu.io/upload_images/588630-39dd7bbd5fdc33c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5bb5aa765c81f5d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一般会选择Jenkins推荐安装的插件<br><img src="http://upload-images.jianshu.io/upload_images/588630-872658e831f3d277.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>等待进度条完成<br><img src="http://upload-images.jianshu.io/upload_images/588630-cd5b4b8c465f6d32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>输入用户名和密码之后，Jenkins就彻底安装好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4a55f007a1eb1a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7d522da542c2ee7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>安装Jenkins不需要什么技术含量，只需要一步一步傻瓜式的下一步。</p>
<h4 id="执行Jenkins卸载命令"><a href="#执行Jenkins卸载命令" class="headerlink" title="执行Jenkins卸载命令"></a>执行Jenkins卸载命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Library/Application Support/Jenkins/Uninstall.command</div></pre></td></tr></table></figure>
<h4 id="或-依次执行下面的命令"><a href="#或-依次执行下面的命令" class="headerlink" title="或 依次执行下面的命令"></a>或 依次执行下面的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sudo launchctl unload /Library/LaunchDaemons/org.jenkins-ci.plist    </div><div class="line">sudo rm !$    </div><div class="line">sudo rm -rf /Applications/Jenkins &quot;/Library/Application Support/Jenkins&quot; /Library/Documentation/Jenkins    </div><div class="line">sudo rm -rf /Users/Shared/Jenkins    </div><div class="line"># if you want to get rid of all the jobs and builds:    </div><div class="line">sudo dscl . -delete /Users/jenkins    </div><div class="line"># delete the jenkins user and group (if you chose to use them):    </div><div class="line">sudo dscl . -delete /Groups/jenkins</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h5&gt;&lt;p&gt;Jenkins是一个开源软件项目，是基于Java开发的一种&lt;a href=&quot;https://baike.baidu.com/item/%E6
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>App的生命周期</title>
    <link href="https://sunjinshuai.github.io/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://sunjinshuai.github.io/2017/11/18/App的生命周期/</id>
    <published>2017-11-17T16:02:28.000Z</published>
    <updated>2018-08-25T02:52:55.604Z</updated>
    
    <content type="html"><![CDATA[<h4 id="iOS程序的启动执行顺序"><a href="#iOS程序的启动执行顺序" class="headerlink" title="iOS程序的启动执行顺序"></a>iOS程序的启动执行顺序</h4><p>程序启动顺序图<br><img src="http://upload-images.jianshu.io/upload_images/588630-5837771421fe9e63?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS启动原理图"></p>
<p>具体执行流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);//__func__打印方法名</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</div><div class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</div><div class="line">   NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</div><div class="line">  NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123;</div><div class="line">     NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</div><div class="line">    NSLog(@&quot;--- %s ---&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动 <code>APP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate application:didFinishLaunchingWithOptions:] </div><div class="line">-[AppDelegate applicationDidBecomeActive:]</div></pre></td></tr></table></figure></p>
<p>按下 <code>Home</code> 键<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationWillResignActive:]</div><div class="line">-[AppDelegate applicationDidEnterBackground:]</div></pre></td></tr></table></figure></p>
<p>返回 <code>APP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationWillEnterForeground:]</div><div class="line">-[AppDelegate applicationDidBecomeActive:]</div></pre></td></tr></table></figure></p>
<p>内存警告<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-[AppDelegate applicationDidReceiveMemoryWarning:]</div></pre></td></tr></table></figure></p>
<p>注意：<br><code>application:didFinishLaunchingWithOptions:</code>： <code>App</code> 首次启动时调用，一般在这个函数里创建 <code>window</code> 对象，初始化 <code>App</code> 可能用到的第三方 <code>SDK</code> 等。<br><code>applicationWillResignActive:</code>：<code>App</code> 将要进入后台时调用，比如有电话进来或者按下 <code>Home</code> 键。<br>该函数里面主要执行操作:</p>
<ul>
<li>暂停正在执行的任务</li>
<li>停止计时器</li>
<li>减少OpenGL ES帧率</li>
</ul>
<p><code>applicationDidEnterBackground:</code>：<code>App</code> 已经进入后台，一般该方法用来:</p>
<ul>
<li>释放共享资源</li>
<li>保存用户数据(写到硬盘)</li>
<li>销毁计时器</li>
</ul>
<p><code>applicationWillEnterForeground:</code>：<code>App</code> 即将进入前台，一般该方法用来撤销 <code>applicationWillResignActive:</code> 中做的改变。<br><code>applicationDidBecomeActive:</code>：<code>App</code> 已经进入前台，若 <code>App</code> 之前在后台，在此方法内刷新用户界面。</p>
<h4 id="UIViewController-的生命周期"><a href="#UIViewController-的生命周期" class="headerlink" title="UIViewController 的生命周期"></a><code>UIViewController</code> 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">// 非storyBoard(xib或非xib)都走这个方法</div><div class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// storyBoard走这个方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// xib 加载 完成</div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">     NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 加载视图(默认从nib)</div><div class="line">- (void)loadView &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">    self.view.backgroundColor = [UIColor redColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图控制器中的视图加载完成，viewController自带的view加载完成</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidLoad];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图将要出现</div><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// view 即将布局其 Subviews</div><div class="line">- (void)viewWillLayoutSubviews &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillLayoutSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// view 已经布局其 Subviews</div><div class="line">- (void)viewDidLayoutSubviews &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidLayoutSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图已经出现</div><div class="line">- (void)viewDidAppear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图将要消失</div><div class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图已经消失</div><div class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super viewDidDisappear:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 出现内存警告 </div><div class="line">- (void)didReceiveMemoryWarning &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">    [super didReceiveMemoryWarning];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 视图被销毁</div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析 </p>
<ul>
<li><p><code>initWithNibName:bundle:</code><br>初始化<code>UIViewController</code>，执行关键数据初始化操作，非<code>StoryBoard</code>创建<code>UIViewController</code>都会调用这个方法。<br><strong>注意: 不要在这里做<code>View</code>相关操作，<code>View</code>在<code>loadView</code>方法中才初始化。</strong></p>
</li>
<li><p><code>initWithCoder:</code><br>如果使用<code>StoryBoard</code>进行视图管理，程序不会直接初始化一个<code>UIViewController</code>，<code>StoryBoard</code>会自动初始化或在<code>segue</code>被触发时自动初始化，因此方法<code>initWithNibName:bundle</code>不会被调用，但是<code>initWithCoder</code>会被调用。</p>
</li>
<li><p><code>awakeFromNib</code><br>当<code>awakeFromNib</code>方法被调用时，所有视图的<code>outlet</code>和<code>action</code>已经连接，但还没有被确定，这个方法可以算作适合视图控制器的实例化配合一起使用的，因为有些需要根据用户喜好来进行设置的内容，无法存在<code>storyBoard</code>或<code>xib</code>中，所以可以在<code>awakeFromNib</code>方法中被加载进来。</p>
</li>
<li><p><code>loadView</code><br>当执行到<code>loadView</code>方法时，如果视图控制器是通过<code>nib</code>创建，那么视图控制器已经从<code>nib</code>文件中被解档并创建好了，接下来任务就是对<code>view</code>进行初始化。<br><code>loadView</code>方法在<code>UIViewController</code>对象的<code>view</code>被访问且为空的时候调用。这是它与<code>awakeFromNib</code>方法的一个区别。<br>假设我们在处理内存警告时释放<code>view</code>属性：<code>self.view = nil</code>。因此<code>loadView</code>方法在视图控制器的生命周期内可能被调用多次。<br><code>loadView</code>方法不应该直接被调用，而是由系统调用，它会加载或创建一个<code>view</code>并把它赋值给<code>UIViewController</code>的<code>view</code>属性。<br>在创建<code>view</code>的过程中，首先会根据<code>nibName</code>去找对应的<code>nib</code>文件然后加载。如果<code>nibName</code>为空或找不到对应的nib文件，则会创建一个空视图(这种情况一般是纯代码)<br><strong>注意:在重写loadView方法的时候，不要调用父类的方法。</strong></p>
</li>
<li><p><code>viewDidLoad</code><br>当<code>loadView</code>将<code>view</code>载入内存中，会进一步调用<code>viewDidLoad</code>方法来进行进一步设置。此时，视图层次已经放到内存中，通常，我们对于各种初始化数据的载入，初始设定、修改约束、移除视图等很多操作都可以这个方法中实现。</p>
</li>
<li><p><code>viewWillAppear</code><br>系统在载入所有的数据后，将会在屏幕上显示视图，这时会先调用这个方法，通常我们会在这个方法对即将显示的视图做进一步的设置。比如，设置设备不同方向时该如何显示；设置状态栏方向、设置视图显示样式等。<br>另一方面，当APP有多个视图时，上下级视图切换是也会调用这个方法，如果在调入视图时，需要对数据做更新，就只能在这个方法内实现。</p>
</li>
<li><p><code>viewWillLayoutSubviews</code><br><code>view</code>即将布局其<code>Subviews</code>。 比如<code>view</code>的<code>bounds</code>改变了(例如:状态栏从不显示到显示,视图方向变化)，要调整<code>Subviews</code>的位置，在调整之前要做的工作可以放在该方法中实现</p>
</li>
<li><p><code>viewDidLayoutSubviews</code><br><code>view</code>已经布局其<code>Subviews</code>，这里可以放置调整完成之后需要做的工作。</p>
</li>
<li><p><code>viewDidAppear</code><br>在<code>view</code>被添加到视图层级中以及多视图，上下级视图切换时调用这个方法，在这里可以对正在显示的视图做进一步的设置。</p>
</li>
<li><p><code>viewWillDisappear</code><br>在视图切换时，当前视图在即将被移除、或被覆盖是，会调用该方法，此时还没有调用<code>removeFromSuperview</code>。</p>
</li>
<li><p><code>viewDidDisappear</code><br><code>view</code>已经消失或被覆盖，此时已经调用<code>removeFromSuperView</code>;</p>
</li>
<li><p><code>dealloc</code><br>视图被销毁，此次需要对你在<code>init</code>和<code>viewDidLoad</code>中创建的对象进行释放。</p>
</li>
<li><p><code>didReceiveMemoryWarning</code><br>在内存足够的情况下，app的视图通常会一直保存在内存中，但是如果内存不够，一些没有正在显示的viewController就会收到内存不足的警告，然后就会释放自己拥有的视图，以达到释放内存的目的。但是系统只会释放内存，并不会释放对象的所有权，所以通常我们需要在这里将不需要显示在内存中保留的对象释放它的所有权，将其指针置nil。</p>
</li>
</ul>
<h4 id="UIView-的生命周期"><a href="#UIView-的生命周期" class="headerlink" title="UIView 的生命周期"></a>UIView 的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过代码创建控件就会调用这个方法</div><div class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</div><div class="line">    if (self = [super initWithFrame:frame]) &#123;</div><div class="line">        NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 通过storyboared或者xib中创建控件就会调用这个方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</div><div class="line">    if (self = [super initWithCoder:aDecoder]) &#123;</div><div class="line">        NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)awakeFromNib &#123;</div><div class="line">    [super awakeFromNib];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 如果在initWithFrame中添加子视图会调用两次</div><div class="line">- (void)layoutSubviews &#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didAddSubview:(UIView *)subview &#123;</div><div class="line">    [super didAddSubview:subview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)willRemoveSubview:(UIView *)subview &#123;</div><div class="line">    [super willRemoveSubview:subview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview &#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didMoveToSuperview &#123;</div><div class="line">    [super didMoveToSuperview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow &#123;</div><div class="line">    [super willMoveToWindow:newWindow];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)didMoveToWindow &#123;</div><div class="line">    [super didMoveToWindow];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFromSuperview &#123;</div><div class="line">    [super removeFromSuperview];</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当 <code>view</code> 创建时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View initWithFrame:]</div><div class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View init]</div><div class="line">2017-11-06 10:35:12.347153+0800 iOSLife[7587:2353869] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:35:12.347312+0800 iOSLife[7587:2353869] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:35:12.353483+0800 iOSLife[7587:2353869] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:35:12.353644+0800 iOSLife[7587:2353869] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:35:12.363861+0800 iOSLife[7587:2353869] -[View layoutSubviews]</div></pre></td></tr></table></figure>
<p>当 <code>view</code> 销毁时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:41:28.152448+0800 iOSLife[7607:2356750] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:41:28.152693+0800 iOSLife[7607:2356750] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:41:28.155160+0800 iOSLife[7607:2356750] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:41:28.155281+0800 iOSLife[7607:2356750] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:41:28.155336+0800 iOSLife[7607:2356750] -[View removeFromSuperview]</div><div class="line">2017-11-06 10:41:28.155399+0800 iOSLife[7607:2356750] -[View dealloc]</div></pre></td></tr></table></figure>
<p>注意：<br>可以看出上面方法中只会执行一次的方法有 <code>removeFromSuperview</code>、<code>dealloc</code> 两个方法，<code>layoutSubviews</code> 在子视图布局变动时会多次调用，所以可以在 <code>removeFromSuperview</code>、<code>dealloc</code> 这两个方法中执行释放内存等操作，比如移除观察者，定时器等。</p>
<p>给 <code>view</code> 添加子视图时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View initWithFrame:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View init]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView initWithFrame:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView init]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didAddSubview:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[View layoutSubviews]</div><div class="line">2017-11-06 10:45:47.749310+0800 iOSLife[17198:14898063] -[TestView layoutSubviews]</div></pre></td></tr></table></figure>
<p>注意：<code>didAddSubview:</code> 和 <code>willRemoveSubview:</code> 需要有子视图才能执行。</p>
<p>此时再销毁该 <code>view</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToWindow:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToWindow:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToWindow]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToWindow]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willMoveToSuperview:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View didMoveToSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View removeFromSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View dealloc]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[View willRemoveSubview:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView willMoveToSuperview:]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView didMoveToSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView removeFromSuperview]</div><div class="line">2017-11-06 10:46:28.022473+0800 iOSLife[17198:14898063] -[TestView dealloc]</div></pre></td></tr></table></figure>
<p><code>willRemoveSubview</code> 是在 <code>dealloc</code> 后面执行的。如果有多个子视图，<code>willRemoveSubview</code> 会循环执行，直到移除所有子视图。</p>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(nullable UIView *)newSuperview;</div><div class="line">- (void)willMoveToWindow:(nullable UIWindow *)newWindow;</div></pre></td></tr></table></figure></p>
<p>这俩个方法可以根据参数判断，<code>nil</code> 则为销毁，否则为创建；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)didMoveToSuperview;</div><div class="line">- (void)didMoveToWindow;</div></pre></td></tr></table></figure></p>
<p>这个方法可以根据 <code>self.superview</code> 判断，<code>nil</code> 则为销毁，否则为创建。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;a href=&quot;#iOS程序的启动执行顺序&quot; class=&quot;headerlink&quot; title=&quot;iOS程序的启动执行顺序&quot;&gt;&lt;/a&gt;iOS程序的启动执行顺序&lt;/h4&gt;&lt;p&gt;程序启动顺序图&lt;br&gt;&lt;img src=&quot;http://up
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅析 NSTimer 和 CADisplayLink 内存泄漏</title>
    <link href="https://sunjinshuai.github.io/2017/10/12/%E6%B5%85%E6%9E%90-NSTimer-%E5%92%8C-CADisplayLink-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://sunjinshuai.github.io/2017/10/12/浅析-NSTimer-和-CADisplayLink-内存泄漏/</id>
    <published>2017-10-12T13:48:52.000Z</published>
    <updated>2018-09-12T13:49:25.836Z</updated>
    
    <content type="html"><![CDATA[<p>谈论 <code>NSTimer &amp; CADisplayLink</code> 内存泄漏，要理解 <code>NSTimer &amp; CADisplayLink</code> 的基础概念，下面通过一个倒计时的实现的 <code>demo</code> 进入正题。</p>
<ul>
<li>第一种就是直接在 <code>TableView</code> 的 <code>Cell</code> 上使用 <code>NSTimer</code>，然后添加到当前线程所对应的 <code>RunLoop</code> 中的 <code>commonModes</code> 中。</li>
<li>第二种是通过 <code>Dispatch</code> 中的 <code>TimerSource</code> 来实现定时器。</li>
<li>第三种是使用 <code>CADisplayLink</code> 来实现。</li>
</ul>
<p>以 <code>UITableViewCell</code> 为例：</p>
<h3 id="一、在-Cell-中直接使用-NSTimer"><a href="#一、在-Cell-中直接使用-NSTimer" class="headerlink" title="一、在 Cell 中直接使用 NSTimer"></a>一、在 <code>Cell</code> 中直接使用 <code>NSTimer</code></h3><p>首先我们按照常规做法，直接在 <code>UITableView</code> 的 <code>Cell</code> 上添加相应的 <code>NSTimer</code>, 并使用 <code>scheduledTimer</code> 执行相应的代码块。<br>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</div><div class="line">    if (self = [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</div><div class="line">        self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(countDown:) userInfo:nil repeats:YES];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)countDown:(NSTimer *)timer &#123;</div><div class="line">    NSDateFormatter *dateformatter = [[NSDateFormatter alloc] init];</div><div class="line">    dateformatter.dateFormat = @&quot;HH:mm:ss&quot;;</div><div class="line">    self.textLabel.text = [NSString stringWithFormat:@&quot;倒计时:%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.timer invalidate];</div><div class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-07 13:36:11.981473+0800 NSTimer&amp;CADisplayLink[24050:457782] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</div></pre></td></tr></table></figure>
<h3 id="二、DispatchTimerSource"><a href="#二、DispatchTimerSource" class="headerlink" title="二、DispatchTimerSource"></a>二、DispatchTimerSource</h3><p>接下来我们就在 <code>TableView</code> 的 <code>Cell</code> 上添加 <code>DispatchTimerSource</code>，然后看一下运行效果。当然下方代码片段我们是在全局队列中添加的 <code>DispatchTimerSource</code>，在主线程中进行更新。当然我们也可以在 <code>mainQueue</code> 中添加 <code>DispatchTimerSource</code>，这样也是可以正常工作的。当然我们不建议在 <code>MainQueue</code> 中做，因为在编程时尽量的把一些和主线程关联不太大的操作放到子线程中去做。<br>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</div><div class="line">    if (self = [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</div><div class="line">        [self countDown];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)countDown &#123;</div><div class="line">    // 倒计时时间</div><div class="line">    __block NSInteger timeOut = 60.0f;</div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">    // 每秒执行一次</div><div class="line">    dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</div><div class="line">    dispatch_source_set_event_handler(_timer, ^&#123;</div><div class="line">        </div><div class="line">        // 倒计时结束，关闭</div><div class="line">        if (timeOut &lt;= 0) &#123;</div><div class="line">            dispatch_source_cancel(_timer);</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                self.detailTextLabel.text = @&quot;倒计时结束&quot;;</div><div class="line">            &#125;);</div><div class="line">        &#125; else &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                NSDateFormatter *dateformatter = [[NSDateFormatter alloc] init];</div><div class="line">                dateformatter.dateFormat = @&quot;HH:mm:ss&quot;;</div><div class="line">                self.detailTextLabel.text = [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</div><div class="line">            &#125;);</div><div class="line">            timeOut--;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    dispatch_resume(_timer);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController_-[MYNSTimerBlockViewController dealloc]</div></pre></td></tr></table></figure>
<h3 id="三、CADisplayLink"><a href="#三、CADisplayLink" class="headerlink" title="三、CADisplayLink"></a>三、CADisplayLink</h3><p>接下来我们来使用 <code>CADisplayLink</code> 来实现定时器功能，<code>CADisplayLink</code> 可以添加到 <code>RunLoop</code> 中，每当屏幕需要刷新的时候，<code>runloop</code> 就会调用 <code>CADisplayLink</code> 绑定的 <code>target</code> 上的 <code>selector</code>，这时 <code>target</code> 可以读到 <code>CADisplayLink</code> 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。</p>
<p>可以设想一下，我们在动画的过程中，<code>runloop</code> 被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行  <code>CADisplayLink</code> 的调用，从而造成动画过程的卡顿，使动画不流畅。</p>
<p>下方代码，为了不让屏幕的卡顿等引起的主线程所对应的 <code>RunLoop</code> 阻塞所造成的定时器不精确的问题。我们开启了一个新的线程，并且将 <code>CADisplayLink</code> 对象添加到这个子线程的 <code>RunLoop</code> 中，然后在主线程中更新UI即可。<br>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123;</div><div class="line">    if (self = [super initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:reuseIdentifier]) &#123;</div><div class="line">        dispatch_queue_t disqueue =  dispatch_queue_create(&quot;com.countdown&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">        dispatch_group_t disgroup = dispatch_group_create();</div><div class="line">        dispatch_group_async(disgroup, disqueue, ^&#123;</div><div class="line">            self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</div><div class="line">            [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)countDown &#123;</div><div class="line">    NSDateFormatter *dateformatter = [[NSDateFormatter alloc] init];</div><div class="line">    dateformatter.dateFormat = @&quot;HH:mm:ss&quot;;</div><div class="line">    self.detailTextLabel.text = [NSString stringWithFormat:@&quot;倒计时%@&quot;, [dateformatter stringFromDate:[NSDate date]]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [self.link invalidate];</div><div class="line">    NSLog(@&quot;%@_%s&quot;, self.class, __func__);</div><div class="line">&#125;</div><div class="line"></div><div class="line">2017-06-07 13:49:43.630398+0800 NSTimer&amp;CADisplayLink[24317:476977] MYNSTimerBlockViewController-[MYNSTimerBlockViewController dealloc]</div></pre></td></tr></table></figure>
<h2 id="得出结论"><a href="#得出结论" class="headerlink" title="得出结论"></a>得出结论</h2><p>从上面的三种 <code>demo</code> 可以看出 <code>UITableViewCell</code> 没有被释放，由此得出结论，当 <code>UITableViewCell</code> 里面强引用了定时器，定时器又强引用了 <code>UITableViewCell</code>，这样两者的 <code>retainCount</code> 值一直都无法为0，于是内存始终无法释放，导致内存泄露。所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>定时器的运行需要结合一个 <code>NSRunLoop</code>，同时 <code>NSRunLoop</code> 对该定时器会有一个强引用，这也是为什么我们不能对 <code>NSRunLoop</code> 中的定时器进行强引的原因。</p>
<p>由于 <code>NSRunLoop</code> 对定时器有引用，定时器怎样才能被释放掉。</p>
<blockquote>
<p>Removes the object from all runloop modes (releasing the receiver if it has been implicitly retained) and releases the target object.</p>
</blockquote>
<p>据官方介绍可知，<code>- invalidate</code> 做了两件事，首先是把本身（定时器）从 <code>NSRunLoop</code> 中移除，然后就是释放对 <code>target</code> 对象的强引用，从而解决定时器带来的内存泄漏问题。</p>
<p>从上面的 <code>demo</code> 中看出，在 <code>UITableViewCell</code> 的 <code>dealloc</code> 方法中调用 <code>invalidate</code> 方法，并没有解决问题。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里使用下 <code>Xcode8</code> 调试黑科技 <code>Memory Graph</code> 来检测下内存泄漏：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-f2c2468c9ecf756f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从图中可以看出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSRunLoop  ---&gt; 定时器 ---&gt; UITableViewCell</div></pre></td></tr></table></figure></p>
<p>导致 <code>UITableViewCell</code> 中没有释放掉定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(countDown)];</div><div class="line">[self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<p>从代码中看出，<code>Target</code> 直接设置成 <code>self</code> 会造成内存泄， <code>CADisplayLink</code> 会强引用 <code>Target</code>。当 <code>CADisplayLink</code> 添加到 <code>NSRunLoop</code> 中，<code>NSRunLoop</code> 会强引用 <code>CADisplayLink</code>。如果仅仅在 <code>dealloc</code> 中调用 <code>CADisplayLink</code> 的 <code>invalidate</code> 方法是没用的，因为 <code>NSRunLoop</code> 的存在 <code>CADisplayLink</code> 不会被释放，<code>Target</code> 被强引用，<code>Target</code> 的 <code>dealloc</code> 方法不会被调用，<code>CADisplayLink</code> 的 <code>invalidate</code> 方法也不被调用，<code>CADisplayLink</code> 不会从 <code>NSRunLoop</code> 中移除，从而导致内存泄漏。</p>
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">NSRunLoop 的问题请查看这里</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1、Target"><a href="#1、Target" class="headerlink" title="1、Target"></a>1、Target</h3><p>为了解决定时器与 <code>Target</code> 之间类似死锁的问题，我们会将定时器中的 <code>target</code> 对象替换成定时器自己，采用分类实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &quot;NSTimer+TimerTarget.h&quot;</div><div class="line"></div><div class="line">@implementation NSTimer (TimerTarget)</div><div class="line"></div><div class="line">+ (NSTimer *)my_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">					repeat:(BOOL)yesOrNo </div><div class="line">					 block:(void (^)(NSTimer *))block &#123;</div><div class="line">    return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(startTimer:) userInfo:[block copy] repeats:yesOrNo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)startTimer:(NSTimer *)timer &#123;</div><div class="line">    void (^block)(NSTimer *timer) = timer.userInfo;</div><div class="line">    if (block) &#123;</div><div class="line">        block(timer);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h3 id="2、Proxy"><a href="#2、Proxy" class="headerlink" title="2、Proxy"></a>2、Proxy</h3><p>这种方式就是创建一个 <code>NSProxy</code> 子类 <code>TimerProxy</code>，<code>TimerProxy</code> 的作用是什么呢？就是什么也不做，可以说只会重载消息转发机制，如果创建一个 <code>TimerProxy</code> 对象将其作为定时器的 <code>target</code>，专门用于转发定时器消息至 <code>Target</code> 对象，那么问题是不是就解决了呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.25 target:[TimerProxy timerProxyWithTarget:self] selector:@selector(startTimer) userInfo:nil repeats:YES];</div><div class="line"></div><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div><div class="line"></div><div class="line">self.timer = timer;</div></pre></td></tr></table></figure>
<h3 id="3、NSTimer-Block"><a href="#3、NSTimer-Block" class="headerlink" title="3、NSTimer Block"></a>3、NSTimer Block</h3><p>还有一种方式就是采用Block，iOS 10增加的API。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ scheduledTimerWithTimeInterval:repeats:block:</div><div class="line"></div><div class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.25 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</div><div class="line">    NSLog(@&quot;MYNSTimerTargetController timer start&quot;);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div><div class="line">self.timer = timer;</div></pre></td></tr></table></figure>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSTimer%26CADisplayLink" target="_blank" rel="external">浅析NSTimer &amp; CADisplayLink内存泄漏</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谈论 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 内存泄漏，要理解 &lt;code&gt;NSTimer &amp;amp; CADisplayLink&lt;/code&gt; 的基础概念，下面通过一个倒计时的实现的 &lt;code&gt;demo&lt;/code&gt; 进入正题。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之iconfont实战</title>
    <link href="https://sunjinshuai.github.io/2017/08/08/iOS%E4%B9%8Biconfont%E5%AE%9E%E6%88%98/"/>
    <id>https://sunjinshuai.github.io/2017/08/08/iOS之iconfont实战/</id>
    <published>2017-08-08T07:45:34.000Z</published>
    <updated>2017-08-08T08:55:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了<code>APP Slicing</code>功能，我司项目在itunes store下载的IPA体积大约在44M。</p>
<p>把我司iPA解压之后里面的<code>Assert.car</code>资源包的体积大约在22.1M，使用软件导出内部的资源文件发现3X系列的图片大小约为13.1M，2X系列的图片大小约为9.4M，两份加起来大于22.1M，所以可以看出我们的图片还是有很大的优化空间的。</p>
<p><a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>技术的主要目的是为减少应用体积而生。首先<code>icon</code>代表图标<code>font</code>代表字体。此技术便是将图标转化为字体，从而达到减小应用体积的目的(这样避免了@2X图和@3X图的使用，只需要一个字体图标就可搞定)。如需在项目中使用iconfont技术，图标矢量图一开始都应合并转化为字体库，只需要在项目中引入字体库就可以了。</p>
<p>优点:</p>
<ul>
<li>减小应用体积，字体文件比图片要小；</li>
<li>图标保真缩放，解决2x/3x乃至将来nx图问题；</li>
<li>方便更改图标颜色大小，图片复用；</li>
<li>一套图标资源可以在不用平台上使用(android、iOS、web)；</li>
</ul>
<p>缺点:</p>
<ul>
<li>只适用于纯色的icon；</li>
</ul>
<h4 id="iconfont实战"><a href="#iconfont实战" class="headerlink" title="iconfont实战"></a>iconfont实战</h4><ul>
<li><p>获取<code>.ttf</code>文件<br>登录<a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>，创建一个项目，设计师做好图标，把<code>.ttf</code>文件下载下来。<br>iconfont中的图标是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/588630-fff854d89142120b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>字体注册<br>iOS中使用自定义字体，将字体加入项目后，还需要注册字体。<br>注册的方式有两种：<br>－ 在Info.plist中声明”Fonts provided by application”</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b6a5790bed65a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>－ 调用API来注册。考虑到需要支持独立版和插件版，调用API注册更加方便。字体注册和获取的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">+ (void)registerFontWithURL:(NSURL *)url &#123;</div><div class="line">    NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[url path]], @&quot;Font file doesn&apos;t exist&quot;);</div><div class="line">    CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)url);</div><div class="line">    CGFontRef newFont = CGFontCreateWithDataProvider(fontDataProvider);</div><div class="line">    CGDataProviderRelease(fontDataProvider);</div><div class="line">    CTFontManagerRegisterGraphicsFont(newFont, nil);</div><div class="line">    CGFontRelease(newFont);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (UIFont *)fontWithSize:(CGFloat)size &#123;</div><div class="line">    UIFont *font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">    if (font == nil) &#123;</div><div class="line">        [self registerFontWithURL: [[NSBundle mainBundle] URLForResource:[self fontName] withExtension:@&quot;ttf&quot;]];</div><div class="line">        font = [UIFont fontWithName:[self fontName] size:size];</div><div class="line">        NSAssert(font, @&quot;UIFont object should not be nil, check if the font file is added to the application bundle and you&apos;re using the correct font name.&quot;);</div><div class="line">    &#125;</div><div class="line">    return font;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>字体应用方式<br>可能的应用方式：<ul>
<li>UILabel作为Icon</li>
<li>UIButton的titleLabel作为Icon</li>
<li>根据字体生成UIImage</li>
</ul>
</li>
</ul>
<p>在实际项目中，鉴于将我们本来的icon当作字体使用，会让我们在项目中添加的控件方式有所变化，而且不容易控制颜色和图标大小，所以我这里推荐第三种方案，根据图片大小、颜色和Unicode码来生成并返回图片。</p>
<ul>
<li>应用到项目中<br>将<code>.ttf</code>文件引入到自己的工程中</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b463acca775cd8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>目前我司项目重构之后的图标为IconFont，新需求用到的图标也会优先采用IconFont。</p>
<p><a href="https://github.com/sunjinshuai/MYUtils" target="_blank" rel="external">demo地址</a></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://johnwong.github.io/mobile/2015/04/03/using-icon-font-in-ios.html" target="_blank" rel="external">使用IconFont减小iOS应用体积</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;近日在做项目重构时，特别关注一点app瘦身，尽管公司在iOS9之后新增了&lt;code&gt;APP Slicing&lt;/code&gt;功能，我司项目在i
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS AutoLayout 中 Label 的抗拉伸和抗压缩</title>
    <link href="https://sunjinshuai.github.io/2017/07/18/%E6%B5%85%E8%B0%88%20iOS%20AutoLayout%20%E4%B8%AD%20Label%20%E7%9A%84%E6%8A%97%E6%8B%89%E4%BC%B8%E5%92%8C%E6%8A%97%E5%8E%8B%E7%BC%A9/"/>
    <id>https://sunjinshuai.github.io/2017/07/18/浅谈 iOS AutoLayout 中 Label 的抗拉伸和抗压缩/</id>
    <published>2017-07-17T16:42:23.000Z</published>
    <updated>2018-09-12T13:27:55.260Z</updated>
    
    <content type="html"><![CDATA[<p><code>UIView</code> 中关于 <code>Content Hugging</code> 和 <code>Content Compression Resistance</code> 的方法有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line">- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line"></div><div class="line">- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div><div class="line">- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);</div></pre></td></tr></table></figure>
<p>在 <code>Autolayout</code> 优先级的范围是 <code>1 ~ 1000</code>，创建一个约束，默认的优先级是最高的 <code>1000</code>。</p>
<h4 id="Content-Hugging-Priority"><a href="#Content-Hugging-Priority" class="headerlink" title="Content Hugging Priority"></a>Content Hugging Priority</h4><p>Content Hugging Priority: 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是251。</p>
<p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，子视图的总和，不够填充父视图区域时，此属性可以控制优先拉伸哪个视图内容。</p>
<h4 id="Content-Compression-Resistance-Priority"><a href="#Content-Compression-Resistance-Priority" class="headerlink" title="Content Compression Resistance Priority"></a>Content Compression Resistance Priority</h4><p>Content Compression Resistance Priority: 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750。</p>
<p>使用场景：<br>当一个视图上有多个 <code>intrinsic content size</code> 的子控件，并且子控件可能会超出父视图的区域时，此属性可控制哪些视图被内容被优先压缩，使其不超出父视图区域。</p>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>Content Compression Resistance Priority</p>
<p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)demo1 &#123;</div><div class="line"></div><div class="line">UILabel *yellowLabel = [[UILabel alloc] init];</div><div class="line">yellowLabel.text = @&quot;我是黄色Label,我是黄色Label,我是黄色Label,我是黄色Label&quot;;</div><div class="line">yellowLabel.backgroundColor = [UIColor yellowColor];</div><div class="line">[self.view addSubview:yellowLabel];</div><div class="line"></div><div class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">make.center.equalTo(self.view);</div><div class="line">make.left.equalTo(self.view).offset(100);</div><div class="line">make.right.equalTo(self.view).offset(-100);</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-76c5062f92a502d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>从最后的显示效果来看，中间的 <code>Label</code> 被压缩了。因为左右约束的优先级比固有内容相关的优先级要高，所以 <code>Autolayout</code> 布局的时候会优先满足左右两个约束。这时候：<strong>左边约束宽度 + 右边约束宽度 +  <code>Label</code> 的固有内容宽度 &gt; 屏幕宽度</strong>。所以最后只能压缩 <code>Label</code> 显示的宽度。</p>
<p>修改 <code>View</code> 左边约束和右边约束的优先级，或者只修改左(右)边约束优先级，然后设置 <code>Label</code> 抗压缩的优先级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)demo1 &#123;</div><div class="line"></div><div class="line">UILabel *yellowLabel = [[UILabel alloc] init];</div><div class="line">yellowLabel.text = @&quot;我是黄色Label,我是黄色Label&quot;;</div><div class="line">yellowLabel.backgroundColor = [UIColor yellowColor];</div><div class="line">[self.view addSubview:yellowLabel];</div><div class="line">[yellowLabel setContentCompressionResistancePriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</div><div class="line">[yellowLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">make.center.equalTo(self.view);</div><div class="line">make.left.equalTo(self.view).offset(100).priority(250);</div><div class="line">make.right.equalTo(self.view).offset(-100).priority(250);</div><div class="line">&#125;];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-457044f53dc6af44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这时候 <code>Label</code> 控件的抗压缩约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗压缩特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被压缩的就是左边和右边的约束。</p>
<p>Content Hugging Priority</p>
<p>在 <code>View</code> 中添加了一个 <code>UILabel</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)demo2 &#123;</div><div class="line"></div><div class="line">UILabel *bluelabel = [[UILabel alloc] init];</div><div class="line">bluelabel.text = @&quot;我是蓝色Label&quot;;</div><div class="line">bluelabel.backgroundColor = [UIColor blueColor];</div><div class="line">[self.view addSubview:bluelabel];</div><div class="line"></div><div class="line">[bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">make.center.equalTo(self.view);</div><div class="line">make.left.equalTo(self.view).offset(100);</div><div class="line">make.right.equalTo(self.view).offset(-100);</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-a81805a367faf561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>拉伸和压缩的时候类似，左右约束优先级比 <code>Label</code> 的 <code>Content Hugging Priority</code> 优先级高，并且此时：<strong>左边约束宽度 + 右边约束宽度+ <code>Label</code> 的固有内容宽度 &lt; 屏幕宽度</strong>。为了满足左右两个约束，就只有拉伸 <code>Label</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)demo2 &#123;</div><div class="line"></div><div class="line">UILabel *bluelabel = [[UILabel alloc] init];</div><div class="line">bluelabel.text = @&quot;我是蓝色Label&quot;;</div><div class="line">bluelabel.backgroundColor = [UIColor blueColor];</div><div class="line">[self.view addSubview:bluelabel];</div><div class="line">[bluelabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisHorizontal];</div><div class="line">[bluelabel mas_makeConstraints:^(MASConstraintMaker *make) &#123;</div><div class="line">make.center.equalTo(self.view);</div><div class="line">make.left.equalTo(self.view).offset(100).priority(250);</div><div class="line">make.right.equalTo(self.view).offset(-100).priority(250);</div><div class="line">&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/588630-556aa245eb387eae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这时候 <code>Label</code> 控件的抗拉伸约束优先级比右边约束优先级高，<code>Autolayout</code> 先满足 <code>Lable</code> 控件的固有内容 <code>Size</code> 的宽度，然后再满足左边和右边约束，表现出来就是 <code>Lable</code> 抗拉伸特性变强了，它更倾向于显示它固有内容 <code>Size</code>，这时候被拉伸的就是左边和右边的约束。</p>
<p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/Label%26Compress%26Hugging" target="_blank" rel="external">Label 的抗拉伸和抗压缩</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;UIView&lt;/code&gt; 中关于 &lt;code&gt;Content Hugging&lt;/code&gt; 和 &lt;code&gt;Content Compression Resistance&lt;/code&gt; 的方法有：&lt;/p&gt;
&lt;figure class=&quot;highlight pla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac iterm2 配色方案</title>
    <link href="https://sunjinshuai.github.io/2017/06/12/Mac-iterm2-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88/"/>
    <id>https://sunjinshuai.github.io/2017/06/12/Mac-iterm2-配色方案/</id>
    <published>2017-06-12T13:44:57.000Z</published>
    <updated>2018-09-12T13:45:26.353Z</updated>
    
    <content type="html"><![CDATA[<p><strong>安装</strong></p>
<p>首先我们下载的 iTem2 这个软件，比 Mac 自带的终端更加强大。直接官网 <a href="http://iterm2.com/" target="_blank" rel="external">http://iterm2.com/</a> 下载并安装即可。</p>
<p><strong>配色方案</strong></p>
<p>我选用的是 <a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">solarized</a>，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors，或者在 github 上下载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/altercation/solarized.git</div></pre></td></tr></table></figure>
<p>但是打开 iterm2 发现灰蒙蒙的，就像下面这样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-79f94acb51b5baf8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>打开 iTerm2 - Preferences - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉，彩色的世界就回来了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-721e68e0e940bd75?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们下载的 iTem2 这个软件，比 Mac 自带的终端更加强大。直接官网 &lt;a href=&quot;http://iterm2.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://ite
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈 Zombie Objects</title>
    <link href="https://sunjinshuai.github.io/2017/05/10/%E6%B5%85%E8%B0%88-Zombie-Objects/"/>
    <id>https://sunjinshuai.github.io/2017/05/10/浅谈-Zombie-Objects/</id>
    <published>2017-05-10T14:49:17.000Z</published>
    <updated>2018-09-12T14:50:17.062Z</updated>
    
    <content type="html"><![CDATA[<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p>
<h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li>
</ul>
<p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p>
<h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p>
<p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    __unsafe_unretained NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">    [array addObject:@&quot;1&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：</p>
<ul>
<li>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针。<code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</li>
<li><code>assign</code>仅用于修饰<code>NSInteger</code>等OC基础类型，以及<code>short</code>、<code>int</code>、<code>double</code>、结构体等C数据类型，不修饰对象指针。</li>
<li>如果需要弱引用OC对象，建议使用<code>weak</code>关键字，因为被<code>weak</code>指针所引用的对象被回收后，<code>weak</code>指针会被赋为<code>nil</code>（空指针），给<code>nil</code>发任何消息都不会出问题。使用<code>weak</code>修饰代理对象属性就是很好的例子。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;僵尸对象（Zombie-Objects）&quot;&gt;&lt;a href=&quot;#僵尸对象（Zombie-Objects）&quot; class=&quot;headerlink&quot; title=&quot;僵尸对象（Zombie Objects）&quot;&gt;&lt;/a&gt;僵尸对象（Zombie Objects）&lt;/h4&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>神器 iTools 的巧妙使用</title>
    <link href="https://sunjinshuai.github.io/2017/04/12/%E7%A5%9E%E5%99%A8-iTools-%E7%9A%84%E5%B7%A7%E5%A6%99%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2017/04/12/神器-iTools-的巧妙使用/</id>
    <published>2017-04-12T13:41:29.000Z</published>
    <updated>2018-09-12T13:42:26.129Z</updated>
    
    <content type="html"><![CDATA[<p>这几天，公司项目不怎么忙，然后利用些业余的时间，想仿一个 app。下面介绍一下如果获取其他 app 的图片资源：</p>
<ul>
<li>在 MacX 下载 iTools 软件，并安装，直接在百度上搜也能找到。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9d8944eded38ceaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>双击安装 iTools，安装陈宫之后，在 iTools 中点击资源库，如果你连接上你的 iPhone，这个按钮就在右上角，若没有连接 iPhone，该按钮就在坐下角。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-245e9c5096661c18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-265d9ffa8e090bcd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>左边有网络资源和手机资源，点击网络资源下的苹果应用，在右上角搜索你要仿写的 app，点击下载，此时如果你连着 iPhone 显示的就不是下载而是安装，此时会提示你输入 apple id。这里以闲鱼为例：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-823b3dde37b838b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-66e188b3358e55fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>选中下载的软件，然后点击上面的那一排按钮中的导出，保存到桌面上。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-908292ff4068a664.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在桌面上找到下载好的 ipa 文件，右键该文件，选择一个解压软件打开该文件，切记不要使用 iTunes 打开，此时该路径下便会有个文件夹名为项目名称的文件夹。可以导出到桌面然后结归档就好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-166baccabd38113c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>把解归档的文件夹进行打开就好了，资源都在里面，随便拿，有时候是乱的需要自己整理。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b28a8ed864cc4de3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>以上就是总结好的，神器 iTools 的巧妙使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天，公司项目不怎么忙，然后利用些业余的时间，想仿一个 app。下面介绍一下如果获取其他 app 的图片资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 MacX 下载 iTools 软件，并安装，直接在百度上搜也能找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http:/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Charles 之 http、https 配置</title>
    <link href="https://sunjinshuai.github.io/2017/04/12/Charles-%E4%B9%8B-http%E3%80%81https-%E9%85%8D%E7%BD%AE/"/>
    <id>https://sunjinshuai.github.io/2017/04/12/Charles-之-http、https-配置/</id>
    <published>2017-04-12T08:43:51.000Z</published>
    <updated>2018-09-12T13:44:33.298Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/588630-5c8a2583d88afd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="Charles安装"><a href="#Charles安装" class="headerlink" title="Charles安装"></a>Charles安装</h3><p>官网下载安装<a href="https://www.charlesproxy.com/download/" target="_blank" rel="external">Charles</a></p>
<h3 id="http-配置"><a href="#http-配置" class="headerlink" title="http 配置"></a>http 配置</h3><ul>
<li>查看电脑 IP 地址<br>在终端上<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig en4</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-89950831b7209779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>或者</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-0a774d1072f66794.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="配置手机-http-代理"><a href="#配置手机-http-代理" class="headerlink" title="配置手机 http 代理"></a>配置手机 <code>http</code> 代理</h3><p>手机必须和电脑连接同一个局域网，点击“设置-&gt;无线局域网-&gt;选择连接的WiFi”，设置 <code>http</code> 代理：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-180b24c2da236bfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>端口号：8888，端口号随便写。</p>
<h3 id="Charles-进行-http-配置"><a href="#Charles-进行-http-配置" class="headerlink" title="Charles 进行 http 配置"></a><code>Charles</code> 进行 <code>http</code> 配置</h3><p><img src="http://upload-images.jianshu.io/upload_images/588630-408a9827a4b106ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8804c3edf00e8d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>以美团返回的数据为例：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-23f8f4c75256768d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h3 id="https-代理配置"><a href="#https-代理配置" class="headerlink" title="https 代理配置"></a>https 代理配置</h3><p>https 代理配置必须要安装 SSL 证书</p>
<ul>
<li>在手机上安装 SSL 证书<br>点击 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3f06155569d7e898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>点击安装，得到 SSL 证书安装的地址</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-afbf08a0e9a92e95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>在手机 Safari 浏览器输入地址 chls.pro/ssl，出现证书安装页面，点击安装</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aced7f7c60e025de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-239ad1c85aa702d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>Charles 进行 https 配置</li>
</ul>
<p>点击 Proxy -&gt; SSL Proxying Settings…</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8303a9574e6e5276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>勾选 Enable SSL Proxying，点击 Add。以<a href="https://api.weibo.cn/" target="_blank" rel="external">https://api.weibo.cn</a>为例，端口号填写443</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-57107c6cfd7da1c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e4cb9ec7e55199fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/588630-5c8a2583d88afd2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/03/18/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/03/18/iOS之使用Cocoapods创建私有仓库/</id>
    <published>2017-03-18T10:31:52.000Z</published>
    <updated>2018-08-25T03:20:37.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
<p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p>
<ul>
<li><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</li>
<li><p>查看现有的<code>podspec</code>源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul>
<li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li>
<li>创建pod私有库所需要的项目工程文件，并上传到私有库</li>
<li>创建pod所对应的podspec文件，并进行验证／测试</li>
<li>向私有的Spec Repo中提交podspec</li>
<li>使用pod库</li>
</ul>
<h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul>
<li>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</li>
<li><p>将私有Spec Repo关联到本地</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add FXSpesc http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git</div></pre></td></tr></table></figure>
<p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p>
<h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul>
<li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>手动创建Xcode工程(过于简单)</p>
</li>
</ul>
<h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul>
<li>如果用<code>pod</code>命令创建，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你项目工程文件</div><div class="line">pod spec create FXKit.podspec</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  s.name         = &quot;FXKit&quot;</div><div class="line">  s.version      = &quot;0.0.1&quot;</div><div class="line">  s.summary      = &quot;FXKit，繁星优选私有库&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">		   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</div><div class="line">                   DESC</div><div class="line"></div><div class="line">  s.homepage     = &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;</div><div class="line"></div><div class="line">  # s.license    = &quot;MIT (example)&quot;</div><div class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line">  s.author       = &#123; &quot;孙金帅&quot; =&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</div><div class="line">  s.platform     = :ios</div><div class="line">  s.source       = &#123;</div><div class="line">	:git =&gt; &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;,</div><div class="line">	:tag =&gt; &quot;#&#123;s.version&#125;&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.source_files = &apos;FXKit/**/*.&#123;h,m&#125;&apos;</div><div class="line"></div><div class="line">  # s.resource_bundles = &#123;</div><div class="line">  #   &apos;FXKit&apos; =&gt; [&apos;FXKit/Assets/*.png&apos;]</div><div class="line">  # &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;FXKit/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;</div><div class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">s.name：私有库的名称，`pod search`搜索的关键词，注意这里一定要和`.podspec`的名称一样，否则报错。</div><div class="line">s.version：私有库的版本。</div><div class="line">s.ios.deployment_target：支持的pod最低版本。</div><div class="line">s.summary：私有库简介。</div><div class="line">s.description：私有库详细介绍。</div><div class="line">s.homepage：私有库在GitHub上的地址。</div><div class="line">s.license：开源协议。</div><div class="line">s.author：作者。</div><div class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</div><div class="line">s.source：私有库在GitHub上的地址和版本号。</div><div class="line">s.source_files：私有库对外共享的.h和.m文件。</div><div class="line">s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<ul>
<li>commit项目工程的源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git</div><div class="line">git push -u origin master</div><div class="line">git tag -m &quot;first release&quot; 0.0.1</div><div class="line">git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<ul>
<li>验证</li>
</ul>
<p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint FXKit.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p>
<h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</div><div class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</div><div class="line">pod repo push FXSpesc NAME.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings --use-libraries</div></pre></td></tr></table></figure>
<h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MarkDown 语法</title>
    <link href="https://sunjinshuai.github.io/2017/01/09/MarkDown-%E8%AF%AD%E6%B3%95/"/>
    <id>https://sunjinshuai.github.io/2017/01/09/MarkDown-语法/</id>
    <published>2017-01-09T14:06:33.000Z</published>
    <updated>2018-06-09T14:08:52.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># This is an H1</div><div class="line">## This is an H2</div><div class="line">###### This is an H6</div></pre></td></tr></table></figure>
<h4 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h4><p>使用一对各三个的反引号(<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>我是文本块<br>我是文本块<br>我是文本块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 文字高亮</div><div class="line">文字高亮功能能使行内部分文字高亮，使用一对反引号(`)，例如：</div><div class="line"></div><div class="line">`文字高亮`</div><div class="line"></div><div class="line">#### 引用块</div></pre></td></tr></table></figure></p>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 换行</div><div class="line"></div><div class="line">直接回车不能换行，</div><div class="line">可以在上一行文本后面补两个空格，</div><div class="line">这样下一行的文本就换行了，或者就是在两行文本直接加一个空行，也能实现换行效果，但是这个行间距有点大。</div><div class="line"></div><div class="line">#### 列表</div><div class="line">##### 无序列表</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">##### 有序列表</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 横线</div><div class="line">下面每一行都会得到一个水平线</div></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h2 id=""><a href="#" class="headerlink" title="___"></a>___</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">***</div><div class="line">___</div><div class="line">---</div><div class="line"></div><div class="line">#### 链接</div></pre></td></tr></table></figure>
<p>这是一个 <a href="http://example.com/" title="Title" target="_blank" rel="external">连接显示文字</a> 行内链接。<br><a href="http://example.net/" target="_blank" rel="external">连接显示文字</a> 没有title属性。<br><a href="http://example.com/" target="_blank" rel="external">http://example.com/</a> 自动链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 强调</div></pre></td></tr></table></figure></p>
<p><em>single asterisks</em><br><em>single underscores</em><br><strong>double asterisks</strong><br><strong>double underscores</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 图片</div><div class="line">##### 行内图片</div></pre></td></tr></table></figure></p>
<p><img src="/path/to/img.jpg" alt="Alt text"><br><img src="/path/to/img.jpg" alt="Alt text" title="Optional title"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 引用图片</div></pre></td></tr></table></figure></p>
<p>![Alt text][id]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 表格</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">Left-Aligned</th>
<th style="text-align:center">Center Aligned</th>
<th style="text-align:right">Right Aligned</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">some wordy text</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">| Left-Aligned | Center Aligned | Right Aligned |</div><div class="line">| :------------ |:---------------:| -----:|</div><div class="line">| col 3 is | some wordy text | $1600 |</div><div class="line">| col 2 is | centered | $12 |</div><div class="line">| zebra stripes | are neat | $1 |</div><div class="line"></div><div class="line">#### 删除线</div><div class="line"></div><div class="line">文本两端加上两个~~即可，例如：</div><div class="line"></div><div class="line">~~删除我~~</div></pre></td></tr></table></figure>
<p><del>删除我</del><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### github 特有的特性</div><div class="line"></div><div class="line">复选框列表</div><div class="line">在列表符号后面加上 `[]` 或者 `[x]` 代表选中或者未选中情况</div></pre></td></tr></table></figure></p>
<ul>
<li>[x] C</li>
<li>[x] C++</li>
<li>[x] Java</li>
<li>[x] Qt</li>
<li>[x] Android</li>
<li>[ ] C#</li>
<li>[ ] .NET<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* [x] C</div><div class="line">* [x] C++</div><div class="line">* [x] Java</div><div class="line">* [x] Qt</div><div class="line">* [x] Android</div><div class="line">* [ ] C#</div><div class="line">* [ ] .NET</div><div class="line"></div><div class="line">#### emoji表情</div><div class="line"></div><div class="line">github 的 Markdown 语法支持添加 emoji 表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</div><div class="line"></div><div class="line">比如，:blush:</div></pre></td></tr></table></figure>
</li>
</ul>
<p>:blush:<br>```</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>Markdown官网：<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">http://daringfireball.net/projects/markdown/</a></li>
<li>中文参考：<a href="http://markdown.tw/" target="_blank" rel="external">http://markdown.tw/</a></li>
</ul>
<h4 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h4><ul>
<li><a href="http://marxi.co/" target="_blank" rel="external">http://marxi.co/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库踩坑记</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库踩坑记/</id>
    <published>2016-12-08T14:01:03.000Z</published>
    <updated>2018-08-25T03:20:01.224Z</updated>
    
    <content type="html"><![CDATA[<p>即上一篇<a href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/">iOS之使用Cocoapods创建公有仓库</a>，本文就<code>CocoaPods</code>创建公有库踩到的坑做一下分享：</p>
<h4 id="遇到的坑："><a href="#遇到的坑：" class="headerlink" title="遇到的坑："></a>遇到的坑：</h4><ul>
<li>本地的公有仓库验证通过，但是远程仓库上的公有仓库验证不通过，路经不对。<br><img src="http://upload-images.jianshu.io/upload_images/588630-4a5138f97c4c6d1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>重新打开<code>xxx.podspec</code>文件编辑一下，确定共享文件路径没有错误，然后再上传到<code>github</code>上验证。<br><code>source_files</code>文件格式有几种设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s.source_files  = &apos;Classes/*.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes/publicClass.&#123;h,m&#125;&apos;</div><div class="line">s.source_files  = &apos;Classes&apos;</div><div class="line">s.source_files  = &apos;Classes/**/*.&#123;h,m&#125;&apos;</div></pre></td></tr></table></figure>
<ul>
<li>执行<code>pod trunk push TestCocoaPods.podspec</code>时，报<code>[!] {&quot;name&quot;=&gt;[&quot;is already taken&quot;]}</code><br><img src="http://upload-images.jianshu.io/upload_images/588630-2a2f1d0e9d5c0864.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></li>
</ul>
<p>解决办法：<br>执行<code>pod search TestCocoaPods</code>，会发现有一个重名的公有库存在，重新创建一个公有库，<code>CocoaPods</code>不允许有重名的公有库存在。</p>
<ul>
<li>最后所有的验证都通过了也上传成功了，结果使用<code>pod search</code>仍然搜索不到。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7076e838dbb41cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>解决办法：<br>1、执行<code>pod setup</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fd244d2a25ef7af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果最底下会输出<code>setup completed</code>。说明执行<code>pod setup</code>成功。<br>2、如果<code>pod search</code>操作还是搜索失败，删除<code>~/Library/Caches/CocoaPods</code>目录下的<code>search_index.json</code>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure></p>
<p>3、执行<code>pod search</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be3fa814cb06d76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即上一篇&lt;a href=&quot;https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%9
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建公有仓库</title>
    <link href="https://sunjinshuai.github.io/2016/12/08/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2016/12/08/iOS之使用Cocoapods创建公有仓库/</id>
    <published>2016-12-08T05:45:50.000Z</published>
    <updated>2018-08-25T03:19:37.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在开发过程中，经常会使用到第三框架，我们通过一个<code>pod install</code>命令，很方便的就将第三方框架加到我们自己的项目中。</p>
<p>如果我们也想将自己写的组件或库开源出去，让别人也可以通过<code>pod install</code>命令安装自己的框架该怎么做呢？下面，我就教大家一步一步的将自己的<code>pods</code>发布到<code>CocoaPods</code>中。如果你现在对<code>CocoaPods</code>还不太了解，推荐你看一看这篇文章：<a href="https://sunjinshuai.github.io/2016/08/08/CocoaPods%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">CocoaPods的安装与使用</a></p>
<p>在 <a href="https://github.com/" target="_blank" rel="external">GitHub</a> 上创建一个开源项目，项目中必须包含这几个文件</p>
<ul>
<li><code>LICENSE</code>:开源许可证</li>
<li><code>README.md</code>:仓库说明</li>
<li>开源项目</li>
<li><code>cocoaPodsName.podspec</code>: <code>CocoaPods</code> 的描述文件，这个文件<strong>非常重要</strong></li>
</ul>
<p>下面就创建 <code>CocoaPods</code> 公有库做一下分享：</p>
<h4 id="在-github-上创建仓库。"><a href="#在-github-上创建仓库。" class="headerlink" title="在 github 上创建仓库。"></a>在 <code>github</code> 上创建仓库。</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-18287791668c31f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：</p>
<ul>
<li><code>github</code> 仓库的名称，不允许重名。</li>
<li><code>LICENSE</code>：开源许可证，默认一般选择 <code>MIT</code>。</li>
</ul>
<h4 id="创建-podspec-文件"><a href="#创建-podspec-文件" class="headerlink" title="创建 *.podspec 文件"></a>创建 *.podspec 文件</h4><p>使用命令行、<code>sourceTree</code> 或者 <code>GitHub Mac</code> 将项目克隆到本地，然后 <code>cd</code> 进入本地项目工程中，然后创建 <code>*.podspec</code> 文件。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec create cocoaPodsName;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-20364e263a61e972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当 <code>Specification created at cocoaPodsName.podspec</code> 说明创建 <code>*.podspec</code> 文件成功，这时就会在你的本地项目工程中下生成 <code>cocoaPodsName.podspec</code> 文件。</p>
<h4 id="编辑-podspec-文件"><a href="#编辑-podspec-文件" class="headerlink" title="编辑 *.podspec 文件"></a>编辑 *.podspec 文件</h4><p>使用文本编辑器或者 <code>sublime</code> 等编辑 <code>*.podspec</code> 文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ae92088a994e1ce4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>备注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1、s.name：公有库的名称。</div><div class="line">2、s.version：公有库的版本。</div><div class="line">3、s.summary：公有库简短介绍。</div><div class="line">4、s.description：公有库详细介绍。</div><div class="line">5、s.homepage：公有库在GitHub上的地址。</div><div class="line">6、s.license：开源协议。</div><div class="line">7、s.author：作者。</div><div class="line">8、s.source：公有库在GitHub上的地址和版本号。</div><div class="line">9、s.source_files：公有库对外共享的.h和.m文件。</div><div class="line">10、s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<p>没有涉及到的字段可以去<a href="http://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="external">官方文档</a>查阅。</p>
<h4 id="验证-podspec-文件"><a href="#验证-podspec-文件" class="headerlink" title="验证 *.podspec 文件"></a>验证 *.podspec 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint cocoaPodsName.podspec --allow-warnings --verbose</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>--allow-warnings</code> 忽略开源项目工程里面的警告；</li>
<li><code>--verbose</code> 在控制台查看详细的信息。</li>
</ul>
<p>验证成功会出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-&gt; cocoaPodsName (0.0.1)</div><div class="line"></div><div class="line">cocoaPodsName passed validation.</div></pre></td></tr></table></figure></p>
<h4 id="发布-podspec"><a href="#发布-podspec" class="headerlink" title="发布 *.podspec"></a>发布 *.podspec</h4><p>验证有效后，然后再将本地项目工程中得所有文件 <code>push</code> 到 <code>github</code> 上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin https://github.com/sunjinshuai/test.git</div><div class="line">git push -u origin master</div><div class="line">$ git tag -m &quot;first release&quot; 0.0.1</div><div class="line">$ git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<p>向 <code>CocoaPods</code> 注册账户信息，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk register 邮箱 ‘用户名’ --description=‘描述’</div></pre></td></tr></table></figure>
<p>注意：<br>邮箱为<code>github</code>上的登录邮箱、用户名为<code>github</code>上的用户名。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e5852a3ef0d784db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>接收发送到邮箱的链接，点击进入后注册成功。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-31ebbd1972d0b840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>查看注册的个人信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk me</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1c00ba7b4cc7dee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>验证发布到 <code>cocoapods</code>上的公有仓库是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod spec lint cocoaPodsName.podspec --allow-warnings --verbose</div></pre></td></tr></table></figure>
<p>发布自己的库的 <code>podspec</code> 文件给 <code>cocoapods</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod trunk push cocoaPodsName.podspec --allow-warnings --verbose</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3b58f26ecefe1456.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>大功告成，使用<code>pod search cocoaPodsName</code>搜索即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-ebd6b6df003a75e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;在开发过程中，经常会使用到第三框架，我们通过一个&lt;code&gt;pod install&lt;/code&gt;命令，很方便的就将第三方框架加到我们自己的项
    
    </summary>
    
    
  </entry>
  
</feed>
