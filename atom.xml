<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2022-05-15T12:50:49.546Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS superclass 和 isa 指针总结</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/iOS-superclass%E5%92%8Cisa-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/iOS-superclass%E5%92%8Cisa-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T11:25:09.000Z</published>
    <updated>2022-05-15T12:50:49.546Z</updated>
    
    <content type="html"><![CDATA[<p><img src="94c23c27-7848-4abb-b0cd-e6c26f963e64.png" alt="image.png"></p><ul><li><code>instance</code> 的 <code>isa</code> 指针指向 <code>class</code>；</li><li><code>class</code> 的 <code>isa</code> 指向 <code>meta-class</code>；</li><li><code>meta-class</code> 的 <code>isa</code> 指针指向基类的 <code>meta-class</code>；</li><li><code>class</code> 的 <code>superclass</code> 指针指向父类的 <code>class</code>；<br>如果没有父类，<code>superclass</code> 指针为 <code>nil</code></li><li><code>meta-class</code> 的 <code>superclass</code> 指针指向父类的 <code>meta-class</code>；</li><li>基类的 <code>meta-class</code> 的 <code>superclass</code> 指针指向基类的 <code>class</code>；</li></ul><p><code>instance</code> 调用对象方法的轨迹<br>通过 <code>isa</code> 指针找到 <code>class</code>，方法不存在，就通过 <code>superclass</code> 指针找父类，如果父类方法不存在，就通过 <code>superclass</code> 指针找根类(也就是 <code>NSObject</code>)，如果根类方法不存在，就会报 <code>unrecognized selector</code> 错误；</p><p><code>class</code> 调用类方法的轨迹<br>通过 <code>isa</code> 指针找 <code>meta-class</code>，方法不存在，就通过 <code>superclass</code> 找父类的 <code>meta-class</code>，如果父类的 <code>meta-class</code> 方法不存在，就通过 <code>superclass</code> 指针找根类(也就是 <code>NSObject</code>)的 <code>meta-class</code>，如果根类的 <code>meta-class</code> 方法不存在，就通过 <code>superclass</code> 找根类的 <code>class</code>，如果根类方法不存在，就会报 <code>unrecognized selector</code> 错误；</p><p><img src="36c7dac5-38e7-4086-989b-31d8ce4ba551.png" alt="image.png"></p><p>从 <code>64bit</code> 开始，<code>isa</code> 需要进行一次位运算，才能计算出真实地址；说明，实例对象 <code>isa</code> 指针里面存放的地址值应该是这个类对象的。</p><p><img src="5f0349f5-7cd6-4517-a405-7a8975e8b7cd" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;94c23c27-7848-4abb-b0cd-e6c26f963e64.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;instance&lt;/code&gt; 的 &lt;code&gt;isa&lt;/code&gt; 指针指向 &lt;code&gt;cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS superclass 指针</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/iOS-superclass-%E6%8C%87%E9%92%88/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/iOS-superclass-%E6%8C%87%E9%92%88/</id>
    <published>2022-05-15T08:25:09.000Z</published>
    <updated>2022-05-15T11:50:03.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="2297f39e-58dd-4194-9aa7-b555bc9839e9.png" alt="image.png"></p><ul><li><code>class</code> 对象的 <code>superclass</code> 指针</li></ul><p>当 <code>Student</code> 的 <code>instance</code>对象要调用 <code>Person</code> 的对象方法时，会先通过 <code>isa</code> 指针找到 <code>Student</code> 的 <code>class</code>，然后通过 <code>superclass</code> 指针找到 <code>Person</code> 的 <code>class</code>，最后找到对象方法的实现进行调用；</p><p><img src="1652613038862.jpg" alt="image.png"></p><ul><li><code>meta-class</code> 对象的 <code>superclass</code> 指针</li></ul><p>当 <code>Student</code> 的 <code>class</code> 要调用 <code>Person</code> 的类方法时，会先通过 <code>isa</code> 指针找到 <code>Student</code> 的 <code>meta-class</code>，然后通过 <code>superclass</code> 指针找到 <code>Person</code> 的 <code>meta-class</code>，最后找到类方法的实现进行调用；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;2297f39e-58dd-4194-9aa7-b555bc9839e9.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt; 对象的 &lt;code&gt;superclass&lt;/code&gt; 指针&lt;/li&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS isa 指针</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/iOS-isa-%E6%8C%87%E9%92%88/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/iOS-isa-%E6%8C%87%E9%92%88/</id>
    <published>2022-05-15T08:15:09.000Z</published>
    <updated>2022-05-15T11:50:07.124Z</updated>
    
    <content type="html"><![CDATA[<p><img src="6c03c3e0-e575-4136-bc80-f8593db0e0af.png" alt="image.png"></p><ul><li><p>实例对象的 <code>isa</code> 指针<br>实例对象的 <code>isa</code> 指向 <code>class</code>；<br>当调用实例对象方法时，通过实例对象的 <code>isa</code> 找到对应的实例对象 <code>class</code>，最后找到对象方法的实现进行调用；</p></li><li><p>类对象的 <code>isa</code> 指针<br>类对象的 <code>isa</code> 指向 <code>meta-class</code><br>当调用类方法时，通过 <code>class</code> 的 <code>isa</code> 找到 <code>meta-class</code>，最后找到类方法的实现进行调用；</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;6c03c3e0-e575-4136-bc80-f8593db0e0af.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实例对象的 &lt;code&gt;isa&lt;/code&gt; 指针&lt;br&gt;实例对象的 &lt;code&gt;isa&lt;/code&gt; 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>objc_getClass、object_getClass 的区别</title>
    <link href="https://sunjinshuai.github.io/2022/05/15/objc-getClass%E3%80%81object-getClass-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2022/05/15/objc-getClass%E3%80%81object-getClass-%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-05-15T07:50:48.000Z</published>
    <updated>2022-05-15T07:58:37.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="objc-getClass、object-getClass-的区别"><a href="#objc-getClass、object-getClass-的区别" class="headerlink" title="objc_getClass、object_getClass 的区别"></a>objc_getClass、object_getClass 的区别</h3><ul><li><p>objc_getClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getClass(const char *aClassName)</span><br><span class="line">1&gt; 传入字符串类名</span><br><span class="line">2&gt; 返回对应的类对象</span><br></pre></td></tr></table></figure></li><li><p>object_getClass</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class object_getClass(id obj)</span><br><span class="line">1&gt; 传入的 obj 可能是实例对象、class 对象和 meta_class 对象</span><br><span class="line">2&gt; 返回指</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果传入的是实例对象，则返回类对象；</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果传入的是 class 对象，则返回 meta_class 对象；</span><br><span class="line">&#x2F;&#x2F;&#x2F; 如果传入的是 meta_class 对象，则返回 NSObject 对象的 meta_class 对象；</span><br></pre></td></tr></table></figure></li><li><ul><li>(Class)class、+ (Class)class<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回的就是对象</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;objc-getClass、object-getClass-的区别&quot;&gt;&lt;a href=&quot;#objc-getClass、object-getClass-的区别&quot; class=&quot;headerlink&quot; title=&quot;objc_getClass、object_getCl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一个NSObject对象占用多少个字节</title>
    <link href="https://sunjinshuai.github.io/2022/05/07/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/"/>
    <id>https://sunjinshuai.github.io/2022/05/07/%E4%B8%80%E4%B8%AANSObject%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%AD%97%E8%8A%82/</id>
    <published>2022-05-07T07:53:06.000Z</published>
    <updated>2022-05-07T08:04:54.152Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Objective-C</code> 中，我们可以通过一些方法来获取一个 <code>NSObject</code> 对象占用多少字节；<br>代码获取 <code>NSObject</code> 实例对象的成员变量字节大小</p><ul><li><p>获取一个 <code>NSObject</code> 实例对象的成员变量所占用的字节大小，可以用 <code>runtime</code> 的 <code>api</code>， <code>class_getInstanceSize</code> 来获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Returns the size of instances of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param cls A class object.</span><br><span class="line"> * </span><br><span class="line"> * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT size_t</span><br><span class="line">class_getInstanceSize(Class _Nullable cls) </span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8</span><br><span class="line">NSLog(@&quot;%zd&quot;, class_getInstanceSize([NSObject class]));</span><br></pre></td></tr></table></figure></li><li><p>也可以通过 <code>malloc_size</code> 来获取</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern size_t malloc_size(const void *ptr);</span><br><span class="line">&#x2F;* Returns size of given ptr *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获得obj指针所指向内存的大小 &gt;&gt; 16</span><br><span class="line">NSLog(@&quot;%zd&quot;, malloc_size((__bridge const void *)obj));</span><br></pre></td></tr></table></figure><ul><li>通过 lldb</li></ul><p><img src="4fe6154609b94d2e8dff2f95b173a0f6.png" alt="image.png"></p><p>总之，系统分配了 <code>16</code> 个字节给 <code>NSObject</code> 对象，但是 <code>NSObject</code> 对象只使用了 <code>8</code> 个字节的空间；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 &lt;code&gt;Objective-C&lt;/code&gt; 中，我们可以通过一些方法来获取一个 &lt;code&gt;NSObject&lt;/code&gt; 对象占用多少字节；&lt;br&gt;代码获取 &lt;code&gt;NSObject&lt;/code&gt; 实例对象的成员变量字节大小&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RunLoop 的应用</title>
    <link href="https://sunjinshuai.github.io/2022/03/21/RunLoop-%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2022/03/21/RunLoop-%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2022-03-21T00:18:04.000Z</published>
    <updated>2022-03-21T00:21:24.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ImageView-优化"><a href="#ImageView-优化" class="headerlink" title="ImageView 优化"></a>ImageView 优化</h3><p><code>UITableView</code> 在滚动的时候一个优化点之一就是 <code>UIImageView</code> 的显示，通常需要根据网络去下载图片。所以如果用户快速滚动列表的时候，如果立马下载并显示图片的话，势必会对 <code>UI</code> 的刷新产生影响，直观的表现就是会卡顿，<code>FPS</code> 达不到 <code>60</code>。</p><p>利用 <code>RunLoop</code> 可以实现这个效果，就是给下载并显示图片的方法指定 <code>NSRunLoopMode</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)clickLoadIMage:(UIButton *)sender &#123;</span><br><span class="line">    &#x2F;&#x2F;[self.imageview performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;test&quot;] afterDelay:2];</span><br><span class="line">    [self performSelector:@selector(downloadAndShowImage) withObject:nil afterDelay:2 inModes:@[NSDefaultRunLoopMode, UITrackingRunLoopMode]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)downloadAndShowImage &#123;</span><br><span class="line">    self.imageview.image &#x3D; [UIImage imageNamed:@&quot;test&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ImageView-优化&quot;&gt;&lt;a href=&quot;#ImageView-优化&quot; class=&quot;headerlink&quot; title=&quot;ImageView 优化&quot;&gt;&lt;/a&gt;ImageView 优化&lt;/h3&gt;&lt;p&gt;&lt;code&gt;UITableView&lt;/code&gt; 在滚动的时
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>百度云盘破解</title>
    <link href="https://sunjinshuai.github.io/2022/03/20/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98%E7%A0%B4%E8%A7%A3/"/>
    <id>https://sunjinshuai.github.io/2022/03/20/%E7%99%BE%E5%BA%A6%E4%BA%91%E7%9B%98%E7%A0%B4%E8%A7%A3/</id>
    <published>2022-03-20T11:18:37.000Z</published>
    <updated>2022-03-20T11:20:11.063Z</updated>
    
    <content type="html"><![CDATA[<p>会员体验一般为 <code>60</code> 秒，通过本代码可以一直以会员的速度下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;CodeTips&#x2F;BaiduNetdiskPlugin-macOS.git &amp;&amp; .&#x2F;BaiduNetdiskPlugin-macOS&#x2F;Other&#x2F;Install.sh</span><br></pre></td></tr></table></figure><p>百度网盘全速下载</p><ul><li>先将你需要下载的地址复制进浏览器</li><li>然后在域名 <code>baidu</code> 后面拼接 <code>wp</code></li><li>回车。访问页面，选择下载地址 <code>1</code> 即可全速下载。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 之前</span><br><span class="line">https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1ubcQH34m69hIjYu3CD2S2g</span><br><span class="line">&#x2F;&#x2F; 之后</span><br><span class="line">https:&#x2F;&#x2F;pan.baiduwp.com&#x2F;s&#x2F;1ubcQH34m69hIjYu3CD2S2g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会员体验一般为 &lt;code&gt;60&lt;/code&gt; 秒，通过本代码可以一直以会员的速度下载。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS 渲染流程</title>
    <link href="https://sunjinshuai.github.io/2022/02/09/iOS-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"/>
    <id>https://sunjinshuai.github.io/2022/02/09/iOS-%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-02-09T10:33:05.000Z</published>
    <updated>2022-02-09T10:41:02.677Z</updated>
    
    <content type="html"><![CDATA[<p>原生界面更新渲染的流程，可以分为以下四步。</p><ul><li>第一步，更新视图树，同步更新图层树。</li><li>第二步，<code>CPU</code> 计算要显示的内容，包括视图创建（设置 <code>Layer</code> 的属性）、布局计算、视图绘制（创建 <code>Layer</code> 的 <code>Backing Image</code>）、图像解码转换。当 <code>runloop</code> 在 <code>BeforeWaiting</code> 和 <code>Exit</code> 时，会通知注册的监听，然后对图层打包，打完包后，将打包数据发送给一个独立负责渲染的进程 <code>Render Server</code>。</li><li>第三步，数据到达 <code>Render Server</code> 后会被反序列化，得到图层树，按照图层树中图层顺序、<code>RGBA</code> 值、图层 <code>frame</code> 过滤图层中被遮挡的部分，过滤后将图层树转成渲染树，渲染树的信息会转给 <code>OpenGL ES/Metal</code>。前面 <code>CPU</code> 所处理的这些事情统称为 <code>Commit Transaction</code>。</li><li>第四步，<code>Render Server</code> 会调用 <code>GPU</code>，<code>GPU</code> 开始进行前面提到的顶点着色器、形状装配、几何着色器、光栅化、片段着色器、测试与混合六个阶段。完成这六个阶段的工作后，再将 <code>CPU</code> 和 <code>GPU</code> 计算后的数据显示在屏幕的每个像素点上。</li></ul><p>整个渲染过程，如下图所示：<br><img src="d4ae58f7b0d09725757dca84ea7a318f.png" alt="image.png"></p><p>如上图所示，<code>CPU</code> 处理完渲染内容会输入到 <code>Render Server</code> 中，经图层树和渲染树的转换，通过 <code>OpenGL</code> 接口提供给 <code>GPU</code>，<code>GPU</code> 处理完后在屏幕上显示。渲染过程中 <code>Commit Trasaction</code> 的布局计算会重载视图 <code>LayoutSubviews</code> 方法，以及执行 <code>addSubview</code> 方法来添加视图。视图绘制会重载视图的 <code>drawRect</code> 方法。这几个方法都是 <code>iOS</code> 开发中常用的。</p><p>移动视图位置、删除视图、隐藏或显示视图、调用 <code>setNeedsDisplay</code> 或 <code>setNeedsDisplayInRect</code> 方法，都会触发界面更新，执行渲染流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原生界面更新渲染的流程，可以分为以下四步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，更新视图树，同步更新图层树。&lt;/li&gt;
&lt;li&gt;第二步，&lt;code&gt;CPU&lt;/code&gt; 计算要显示的内容，包括视图创建（设置 &lt;code&gt;Layer&lt;/code&gt; 的属性）、布局计算、视图绘制（
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈面向对象的六大设计原则</title>
    <link href="https://sunjinshuai.github.io/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://sunjinshuai.github.io/2019/10/27/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2019-10-27T03:13:57.000Z</published>
    <updated>2022-02-10T07:12:05.989Z</updated>
    
    <content type="html"><![CDATA[<p><img src="588630-7d17a7d220c612f0.png" alt="image.png"></p><h3 id="原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）"><a href="#原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）" class="headerlink" title="原则一、单一职责原则（Single Responsibility Principle，简称SRP ）"></a>原则一、单一职责原则（Single Responsibility Principle，简称SRP ）</h3><p>定义：应该有且仅有一个原因引起类的变更。</p><p>一个类只负责一项职责，如果发生变更时，可以考虑将一个类拆分成两个类，或者在一个类中添加新的方法。</p><p><strong>在真实的开发中，不仅仅是类、函数和接口也要遵循单一职责原则。即：一个函数负责一个功能。如果一个函数里面有不同的功能，则需要将不同的功能的函数分离出去。</strong></p><p>优点：</p><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义。</li><li>类的可读性提高，复杂性减低。</li></ul><p>如果接口或者函数的单一职责做得好，一个接口或者函数的修改只对相应的类有影响，对其他接口或者函数无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><p>例如，需求上指出用一个类描述食肉和食草动物：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 17:55:25.775317+0800 DesignPatterns[54087:24701786] 狼 吃肉</span><br><span class="line">2018-10-27 17:55:25.775689+0800 DesignPatterns[54087:24701786] 豹 吃肉</span><br><span class="line">2018-10-27 17:55:25.775721+0800 DesignPatterns[54087:24701786] 虎 吃肉</span><br></pre></td></tr></table></figure><p>上线后，发现问题了，并不是所有的动物都是吃肉的，比如羊就是吃草的。修改时如果遵循单一职责原则，需要将 <code>Animal</code> 类细分为食草动物类 <code>Herbivore</code>，食肉动物 <code>Carnivore</code>，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Herbivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Herbivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Herbivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Carnivore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">@interface Carnivore : Animal</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Carnivore</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Animal *carnivore &#x3D; [Carnivore new];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[carnivore eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">NSLog(@&quot;\n&quot;);</span><br><span class="line">Animal *herbivore &#x3D; [Herbivore new];</span><br><span class="line">[herbivore eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>在子类里面重写父类的 <code>eatWithAnimalName</code> 函数，运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:04:49.189722+0800 DesignPatterns[54422:24725132] 狼 吃肉</span><br><span class="line">2018-10-27 18:04:49.190450+0800 DesignPatterns[54422:24725132] 豹 吃肉</span><br><span class="line">2018-10-27 18:04:49.190482+0800 DesignPatterns[54422:24725132] 虎 吃肉</span><br><span class="line">2018-10-27 18:04:49.190498+0800 DesignPatterns[54422:24725132] </span><br><span class="line">2018-10-27 18:04:49.190530+0800 DesignPatterns[54422:24725132] 羊 吃草</span><br></pre></td></tr></table></figure><p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加食肉动物和食草动物的其他功能，就可以直接在这两个类里面添加即可。但是，有一点，修改花销是很大的，除了将原来的类分解之外，还需要修改 <code>main</code> 函数 。而直接修改类 <code>Animal</code> 来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    if ([@&quot;羊&quot; isEqualToString:animalName]) &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:16:10.910397+0800 DesignPatterns[54677:24751636] 狼 吃肉</span><br><span class="line">2018-10-27 18:16:10.911105+0800 DesignPatterns[54677:24751636] 豹 吃肉</span><br><span class="line">2018-10-27 18:16:10.911138+0800 DesignPatterns[54677:24751636] 虎 吃肉</span><br><span class="line">2018-10-27 18:16:10.911160+0800 DesignPatterns[54677:24751636] 羊 吃草</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。<br>但是却存在着隐患：<strong>有一天需求上增加牛和马也需要吃草，则又需要修改 <code>Animal</code> 类的 <code>eatWithAnimalName</code> 函数，而对原有代码的修改会对调用狼、豹和虎吃肉等功能带来风险，也许某一天你会发现运行结果变为虎也吃草了。</strong>这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Animal.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Animal : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃草</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  吃肉</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Animal</span><br><span class="line"></span><br><span class="line">- (void)eatGrassWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃草&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatMeatWithAnimalName:(NSString *)animalName &#123;</span><br><span class="line">    NSLog(@&quot;%@ 吃肉&quot;, animalName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Animal *animal &#x3D; [Animal new];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;狼&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;豹&quot;];</span><br><span class="line">[animal eatMeatWithAnimalName:@&quot;虎&quot;];</span><br><span class="line">[animal eatGrassWithAnimalName:@&quot;羊&quot;];</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-10-27 18:31:30.321473+0800 DesignPatterns[55048:24787008] 狼 吃肉</span><br><span class="line">2018-10-27 18:31:30.321884+0800 DesignPatterns[55048:24787008] 豹 吃肉</span><br><span class="line">2018-10-27 18:31:30.321922+0800 DesignPatterns[55048:24787008] 虎 吃肉</span><br><span class="line">2018-10-27 18:31:30.321939+0800 DesignPatterns[55048:24787008] 羊 吃草</span><br></pre></td></tr></table></figure><p>通过运行结果可以看到，这种修改方式没有改动原来的函数，而是在类中新加了一个函数，这样虽然也违背了<strong>类单一职责原则</strong>，但在函数级别上却是符合单一职责原则的，因为它并没有动原来函数的代码。</p><p>在实际的开发应用中，有很多复杂的场景，怎么设计一个类或者一个函数，让应用程序更加灵活，是更多程序员们值得思考的，需要结合特定的需求场景，有可能有些类里面有很多的功能，但是切记不要将不属于这个类本身的功能也强加进来，这样不仅带来不必要的维护成本，也违反了<strong>单一职责的设计原则</strong>。</p><h3 id="原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）"><a href="#原则二、里氏替换原则（Liskov-Substitution-Principle，简称LSP）" class="headerlink" title="原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）"></a>原则二、里氏替换原则（Liskov Substitution Principle，简称LSP）</h3><p>定义：如果对一个类型为 <code>T1</code> 的对象 <code>o1</code>，都有类型为 <code>T2</code> 的对象 <code>o2</code>，使得以 <code>T1</code> 定义的所有程序 <code>P</code> 在所有的对象 <code>o1</code> 都替换成 <code>o2</code> 时，程序 <code>P</code> 的行为没有发生变化，那么类型 <code>T2</code> 是类型 <code>T1</code> 的子类型。有点拗口，通俗点讲，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应</strong>。</p><p>面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。当使用继承时，遵循里氏替换原则。但是使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生影响。子类可以扩展父类的功能，但不能改变父类原有的功能。</p><p>注意：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><p>比如，需要完成一个两数相加的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; A.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface A : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"></span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">A *a &#x3D; [[A alloc] init];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, [a addition:100 b:50]);</span><br><span class="line">NSLog(@&quot;100+80&#x3D;%ld&quot;, [a addition:100 b:80]);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 22:53:23.549358+0800 DesignPatterns[18063:363232] 100+50&#x3D;150</span><br><span class="line">2018-11-01 22:53:23.549586+0800 DesignPatterns[18063:363232] 100+80&#x3D;180</span><br></pre></td></tr></table></figure><p>接着，需求上需要增加一个新的功能，完成两数相加，然后再与 <code>100</code> 求差，由类 <code>B</code> 来负责。即类 <code>B</code> 需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加 <code>100</code>。</li></ul><p>由于类 <code>A</code> 已经实现了加法功能，所以 <code>B</code> 继承 <code>A</code> 之后，只需要完成减法功能就可以了，但是在类 <code>B</code> 中不小心重写了父类 <code>A</code> 的减法功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; B.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface B : A</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 加法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)addition:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 减法</span><br><span class="line"> </span><br><span class="line"> @param a</span><br><span class="line"> @param b</span><br><span class="line"> @return 相加之后的和</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)subtraction:(NSInteger)a b:(NSInteger)b;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">B *b &#x3D; [[B alloc] init];</span><br><span class="line">NSInteger sub &#x3D; [b addition:100 b:50];</span><br><span class="line">NSInteger difference &#x3D; [b subtraction:sub b:100];</span><br><span class="line">NSLog(@&quot;100+50&#x3D;%ld&quot;, sub);</span><br><span class="line">NSLog(@&quot;100+100+50&#x3D;%ld&quot;, difference);</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-01 23:15:06.530080+0800 DesignPatterns[18363:375940] 100+50&#x3D;5000</span><br><span class="line">2018-11-01 23:15:06.530758+0800 DesignPatterns[18363:375940] 100+100+50&#x3D;4900</span><br></pre></td></tr></table></figure><p>发现原本运行正常的相减功能发生了错误，原因就是类 <code>B</code> 在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类 <code>B</code> 重写后的方法，造成原本运行正常的功能出现了错误。如果按照“里氏替换原则”，<strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类</strong>，是不成立的。</p><p>在平时的日常开发中，通常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。</p><h3 id="原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）"><a href="#原则三、依赖倒置原则（Dependence-Inversion-Principle，简称DIP）" class="headerlink" title="原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）"></a>原则三、依赖倒置原则（Dependence Inversion Principle，简称DIP）</h3><p><strong>依赖倒置原则的核心思想是面向接口编程。</strong></p><p>定义：模块间的依赖通过抽象发生，高层模块和低层模块之间不应该发生直接的依赖关系，二者都应该是通过接口或抽象类产生的；即依赖抽象，而不依赖具体的实现。</p><p>例如：类 <code>A</code> 直接依赖类 <code>B</code>，假如要将类 <code>A</code> 改为依赖类 <code>C</code>，则必须通过修改类 <code>A</code> 的代码来达成。比如在这种场景下，业务逻辑层类 <code>A</code> 相对于数据层类 <code>B</code> 是高层模块，因为业务逻辑层需要调用数据层去连接数据库，如果业务逻辑层类 <code>A</code> 依赖数据层类 <code>B</code> 的话，那么将来需求变更，需要把旧的数据层类 <code>B</code> 修改为新的数据层类 <code>C</code>，就必须通过修改类 <code>A</code>，这样就会给应用程序带来不必要的风险。</p><p>解决方案：将类 <code>A</code> 修改为依赖接口 <code>I</code>，类 <code>B</code> 和类 <code>C</code> 各自实现接口 <code>I</code>，类 <code>A</code> 通过接口 <code>I</code> 间接与类 <code>B</code> 或者类 <code>C</code> 发生联系，则会大大降低修改类 <code>A</code> 的几率。要做到可扩展高复用，尽量不要让业务逻辑层依赖数据层，可以在数据层抽象出一个接口，让业务逻辑层依赖于这个抽象接口。</p><p>比如：母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@class Book;</span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(Book *)book;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">[mother tellStory:book];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 14:52:08.759154+0800 DesignPatterns[6135:458778] 妈妈开始讲故事</span><br><span class="line">2018-11-09 14:52:08.759365+0800 DesignPatterns[6135:458778] 很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure><p>将来有一天，需求变更成，增加让母亲讲一下报纸上的故事的功能，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 报纸内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>如果将 <code>Newspaper</code> 类替换 <code>Book</code> 类，发现母亲看不懂报纸上的故事，必须要修改 <code>Mother</code> 类里面的 <code>tellStory</code> 方法才能看不懂报纸上的故事。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code> 类，这显然不是好的设计，高层模块都依赖了低层模块的改动，因此上述设计不符合依赖倒置原则。<code>Mother</code> 类与 <code>Book</code> 类之间的耦合性太高了，必须降低他们之间的耦合度才行。</p><p>解决方案，将母亲讲故事的方法抽象一个接口或者 <code>Protocol</code>，让<code>Mother</code> 类不再依赖 <code>Newspaper</code> 和 <code>Book</code> 类具体实现，而是依赖抽象出来的接口或者 <code>Protocol</code>。并且 <code>Newspaper</code> 和 <code>Book</code> 类也都依赖这个抽象出来的接口或者 <code>Protocol</code>，通过实现接口或者 <code>Protocol</code> 来做自己的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>Mother</code> 类与接口 <code>IReader</code> 发生依赖关系，而 <code>Book</code> 和 <code>Newspaper</code> 都属于读物的范畴，他们各自都去实现 <code>IReader</code> 接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Book.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Book : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Newspaper.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Newspaper : NSObject &lt;IReaderProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IReaderProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IReaderProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 故事内容</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)theStoryContent;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Mother.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Mother : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 讲故事</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Mother</span><br><span class="line"></span><br><span class="line">- (void)tellStory:(NSObject&lt;IReaderProtocol&gt; *)reading &#123;</span><br><span class="line">    NSLog(@&quot;妈妈开始讲故事&quot;);</span><br><span class="line">    if ([reading respondsToSelector:@selector(theStoryContent)]) &#123;</span><br><span class="line">        [reading theStoryContent];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Mother *mother &#x3D; [Mother new];</span><br><span class="line">Book *book &#x3D; [Book new];</span><br><span class="line">Newspaper *newspaper &#x3D; [Newspaper new];</span><br><span class="line">[mother tellStory:book];</span><br><span class="line">[mother tellStory:newspaper];</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-09 15:28:01.182603+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182879+0800 DesignPatterns[7055:532924] 很久很久以前有一个阿拉伯的故事……</span><br><span class="line">2018-11-09 15:28:01.182916+0800 DesignPatterns[7055:532924] 妈妈开始讲故事</span><br><span class="line">2018-11-09 15:28:01.182955+0800 DesignPatterns[7055:532924] 雄鹿终结勇士八连胜……</span><br></pre></td></tr></table></figure><p>这样修改后，无论以后怎样扩展 main 函数，都不需要再修改 <code>Mother</code> 类了。这里只是举了一个比较简单的例子，在实际的项目开发中，尽可能的采用“低耦合，高内聚”的原则，<strong>采用依赖倒置原则给多人并行开发带来了极大的便利</strong>，无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p><h3 id="原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）"><a href="#原则四、接口隔离原则（Interface-Segregation-Principle-简称ISP）" class="headerlink" title="原则四、接口隔离原则（Interface Segregation Principle,简称ISP）"></a>原则四、接口隔离原则（Interface Segregation Principle,简称ISP）</h3><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class &#39;ClassB&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br><span class="line">Class &#39;ClassD&#39; does not conform to protocol &#39;InterfaceH&#39;</span><br></pre></td></tr></table></figure><p><strong>注意：在 <code>Objective-C</code> 中的协议可以通过 <code>@optional</code> 关键字声明不需要必须实现的方法，这个只是 <code>Objective-C</code> 的一个特性，可以消除在 <code>ClassB</code> 和 <code>ClassD</code> 中没有实现 <code>InterfaceH</code> 的 <code>protocol</code> 协议。</strong></p><p>比如，类 A 依赖接口 H 中的方法1、方法2、方法5，类 B 是对类 A 依赖的实现。类 C 依赖接口 H 中的方法3、方法4、方法5，类 D 是对类 C 依赖的实现。对于类 B 和类 D 来说，虽然他们都存在着用不到的方法，但由于实现了接口 H，因为接口 <code>H</code> 对于类 <code>A</code> 和类 <code>C</code> 来说不是最小接口，所以也必须要实现这些用不到的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123;</span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123; </span><br><span class="line">    &#x2F;&#x2F;not necessarily</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则。</p><p><strong>解决方法：将臃肿的接口 <code>H</code> 拆分为独立的几个接口，类 <code>A</code> 和类 <code>C</code> 分别与他们需要的接口建立依赖关系，也就是采用接口隔离原则。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; InterfaceH.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)method5;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH1 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method1;</span><br><span class="line">- (void)method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol InterfaceH2 &lt;InterfaceH&gt;</span><br><span class="line"></span><br><span class="line">- (void)method3;</span><br><span class="line">- (void)method4;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassB.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassB : NSObject &lt;InterfaceH1&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassB</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123;</span><br><span class="line">    NSLog(@&quot;类 B 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassA.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassA : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassA</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH1&gt; *)classB &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classB respondsToSelector:@selector(method1)]) &#123;</span><br><span class="line">        [classB method1];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method2)]) &#123;</span><br><span class="line">        [classB method2];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classB respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classB method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassD.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassD : NSObject &lt;InterfaceH2&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassD</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method4 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法4&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method5 &#123; </span><br><span class="line">    NSLog(@&quot;类 D 实现接口 H 的方法5&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ClassC.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface ClassC : NSObject</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ClassC</span><br><span class="line"></span><br><span class="line">- (void)depend:(NSObject&lt;InterfaceH2&gt; *)classD &#123;</span><br><span class="line">    </span><br><span class="line">    if ([classD respondsToSelector:@selector(method3)]) &#123;</span><br><span class="line">        [classD method3];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method4)]) &#123;</span><br><span class="line">        [classD method4];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([classD respondsToSelector:@selector(method5)]) &#123;</span><br><span class="line">        [classD method5];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。在实际项目开发中，只暴露给调用的类需要的方法，不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系，不要试图去建立一个很庞大的接口供所有依赖它的类去调用。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><h3 id="原则五、迪米特法则（Law-of-Demeter，简称LOD）"><a href="#原则五、迪米特法则（Law-of-Demeter，简称LOD）" class="headerlink" title="原则五、迪米特法则（Law of Demeter，简称LOD）"></a>原则五、迪米特法则（Law of Demeter，简称LOD）</h3><p>定义：一个对象应该对其他对象保持最少的了解。</p><p>当类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外只暴露必要的接口。</p><p>解决方案：尽量降低类与类之间的耦合。</p><p>比如，有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工 <code>ID</code>：<br>Model 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; EmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface EmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 总公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *employee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubEmployeeModel.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubEmployeeModel : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 分公司员工ID</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, copy) NSString *subemployee_id;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Company 类，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; subCompany.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>从上面可以看出，打印 <code>Company</code> 所有员工的 <code>ID</code>，需要依赖分公司 <code>SubCompany</code>。但是在 <code>printAllEmployeeWithSubCompany:</code> 方法里面必须要初始化分公司员工 <code>SubEmployeeModel</code>。而<code>SubEmployeeModel</code> 和 <code>Company</code> 并不是直接联系，换句话说，总公司 <code>Company</code> 只需要依赖分公司 <code>SubCompany</code>，与分公司的员工 <code>SubEmployeeModel</code> 并没有任何联系，这样设计显然是增加了不必要的耦合。</p><p><strong>按照迪米特法则，类与类之间的应该减少不必要的关联程度。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Company.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface Company : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Company</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;EmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        EmployeeModel *employeeModel &#x3D; [[EmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setEmployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployeeWithSubCompany:(SubCompany *)subCompany &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    [subCompany printAllEmployee];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 总公司员工</span><br><span class="line">    NSArray&lt;EmployeeModel *&gt; *employeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (EmployeeModel *employeeModel in employeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;总公司员工ID:%@&quot;, employeeModel.employee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; SubCompany.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface SubCompany : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取所有分公司员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSArray *)getAllEmployee;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 打印分公司所有员工</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)printAllEmployee;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SubCompany</span><br><span class="line"></span><br><span class="line">- (NSArray *)getAllEmployee &#123;</span><br><span class="line">    NSMutableArray&lt;SubEmployeeModel *&gt; *employeeArray &#x3D; [NSMutableArray&lt;SubEmployeeModel *&gt; array];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        SubEmployeeModel *employeeModel &#x3D; [[SubEmployeeModel alloc] init];</span><br><span class="line">        [employeeModel setSubemployee_id:[@(i) stringValue]];</span><br><span class="line">        [employeeArray addObject:employeeModel];</span><br><span class="line">    &#125;</span><br><span class="line">    return employeeArray.copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)printAllEmployee &#123;</span><br><span class="line">    &#x2F;&#x2F; 分公司员工</span><br><span class="line">    NSArray&lt;SubEmployeeModel *&gt; *subEmployeeArray &#x3D; self.getAllEmployee;</span><br><span class="line">    for (SubEmployeeModel *employeeModel in subEmployeeArray) &#123;</span><br><span class="line">        NSLog(@&quot;分公司员工ID:%@&quot;, employeeModel.subemployee_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>修改后，为分公司增加了打印所有公钥 <code>ID</code> 的方法，总公司直接调分公司的打印方法，从而避免了与分公司的员工发生耦合。</p><p>耦合的方式很多，依赖、关联、组合、聚合等。</p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是过分的使用迪米特原则，会产生大量传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="原则六、开闭原则（Open-Close-Principle，简称OCP）"><a href="#原则六、开闭原则（Open-Close-Principle，简称OCP）" class="headerlink" title="原则六、开闭原则（Open Close Principle，简称OCP）"></a>原则六、开闭原则（Open Close Principle，简称OCP）</h3><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>核心思想：<strong>尽量通过扩展应用程序中的类、模块和函数来解决不同的需求场景，而不是通过直接修改已有的类、模块和函数。</strong></p><p><strong>用抽象构建框架，用实现扩展细节</strong>，对扩展开放的关键是抽象，而对象的多态则保证了这种扩展的开放性。开放原则首先意味着我们可以自由地增加功能，而不会影响原有功能。这就要求我们能够通过继承完成功能的扩展。其次，开放原则还意味着实现是可替换的。只有利用抽象，才可以为定义提供不同的实现，然后根据不同的需求实例化不同的实现子类。</p><p>开放封闭原则的优点：</p><ul><li>代码可读性高，可维护性强。</li><li>帮助缩小逻辑粒度，以提高可复用性。</li><li>可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性。</li><li>在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求。</li></ul><p>比如，书店售书的经典例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; IBookProtocol.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@protocol IBookProtocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍名称</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookName;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍售价</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (CGFloat)bookPrice;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 获取书籍作者</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSString *)bookAuthor;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; NovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface NovelBook : NSObject &lt;IBookProtocol&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模拟书店卖书</span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:11:32.642070+0800 DesignPatterns[1863:5763476] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：50.000000</span><br><span class="line">2018-11-12 15:11:32.642495+0800 DesignPatterns[1863:5763476] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:11:32.642530+0800 DesignPatterns[1863:5763476] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:11:32.642558+0800 DesignPatterns[1863:5763476] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br></pre></td></tr></table></figure><p>将来某一天需求变更为项目投产，书店盈利，书店决定，<code>40</code> 元以上打 <code>8</code> 折，<code>40</code> 元以下打 <code>9</code> 折。</p><p>在实际的项目开发中，如果不懂得开闭原则的话，很容易犯下面的错误：</p><ul><li>在 <code>IBookProtocol</code> 上新增加一个方法 <code>bookOffPrice()</code> 方法，专门进行打折，所有实现类实现这个方法，但是如果其他不想打折的书籍也会因为实现了书籍的接口必须打折。 </li><li>修改 <code>NovelBook</code> 实现类中的 <code>bookPrice()</code> 方中实现打折处理，由于该方法已经实现了打折处理价格，因此采购书籍人员看到的也是打折后的价格的情况。</li></ul><p>很显然按照上面两种方案的话，随着需求的增加，需要反复修改之前创建的类，给新增的类造成了不必要的冗余，业务逻辑的处理和需求不相符合等情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; OffNovelBook.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface OffNovelBook : NovelBook</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation OffNovelBook</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBookName:(NSString *)name</span><br><span class="line">                           price:(CGFloat)price</span><br><span class="line">                          author:(NSString *)author &#123;</span><br><span class="line">    return [super initWithBookName:name price:price author:author];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)bookPrice &#123;</span><br><span class="line">    CGFloat originalPrice &#x3D; [super bookPrice];</span><br><span class="line">    CGFloat offPrice      &#x3D; 0;</span><br><span class="line">    if (originalPrice &gt; 40) &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.8;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        offPrice &#x3D; originalPrice * 0.9;</span><br><span class="line">    &#125;</span><br><span class="line">    return offPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; BookStore.h &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">@interface BookStore : NSObject</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BookStore</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)bookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book1 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book2 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book3 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    NovelBook *book4 &#x3D; [[NovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray&lt;IBookProtocol&gt; *)offBookArray &#123;</span><br><span class="line">    NSMutableArray&lt;IBookProtocol&gt; *tempArray &#x3D; [NSMutableArray&lt;IBookProtocol&gt; array];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book1 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;天龙八部&quot; price:30 author:@&quot;金庸&quot;];</span><br><span class="line">    [tempArray addObject:book1];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book2 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;巴黎圣母院&quot; price:70 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book2];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book3 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;悲惨世界&quot; price:80 author:@&quot;雨果&quot;];</span><br><span class="line">    [tempArray addObject:book3];</span><br><span class="line">    </span><br><span class="line">    OffNovelBook *book4 &#x3D; [[OffNovelBook alloc] initWithBookName:@&quot;金瓶梅&quot; price:40 author:@&quot;兰陵王&quot;];</span><br><span class="line">    [tempArray addObject:book4];</span><br><span class="line">    return tempArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main 函数 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">BookStore *bookStore &#x3D; [BookStore new];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的原价书籍记录如下：------------&quot;);</span><br><span class="line">for (NovelBook *novelBook in bookStore.bookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;------------书店卖出去的打折书籍记录如下：------------&quot;);</span><br><span class="line">for (OffNovelBook *novelBook in bookStore.offBookArray) &#123;</span><br><span class="line">    NSLog(@&quot;书籍名称：%@ 书籍作者：%@ 书籍价格：%2f&quot;, [novelBook bookName], [novelBook bookAuthor], [novelBook bookPrice]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2018-11-12 15:52:01.639550+0800 DesignPatterns[2962:6151804] ------------书店卖出去的原价书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.639895+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：30.000000</span><br><span class="line">2018-11-12 15:52:01.639927+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：70.000000</span><br><span class="line">2018-11-12 15:52:01.639951+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：80.000000</span><br><span class="line">2018-11-12 15:52:01.639971+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：40.000000</span><br><span class="line">2018-11-12 15:52:01.639988+0800 DesignPatterns[2962:6151804] ------------书店卖出去的打折书籍记录如下：------------</span><br><span class="line">2018-11-12 15:52:01.640029+0800 DesignPatterns[2962:6151804] 书籍名称：天龙八部 书籍作者：金庸 书籍价格：27.000000</span><br><span class="line">2018-11-12 15:52:01.640145+0800 DesignPatterns[2962:6151804] 书籍名称：巴黎圣母院 书籍作者：雨果 书籍价格：56.000000</span><br><span class="line">2018-11-12 15:52:01.640194+0800 DesignPatterns[2962:6151804] 书籍名称：悲惨世界 书籍作者：雨果 书籍价格：64.000000</span><br><span class="line">2018-11-12 15:52:01.640217+0800 DesignPatterns[2962:6151804] 书籍名称：金瓶梅 书籍作者：兰陵王 书籍价格：36.000000</span><br></pre></td></tr></table></figure><p>在实际的项目开发中，</p><ul><li><p>对抽象定义的修改，要保证定义的接口或者 <code>Protocol</code> 的稳定，尤其要保证被其他对象调用的接口的稳定；否则，就会导致修改蔓延，牵一发而动全身。</p></li><li><p>对具体实现的修改，因为具体实现的修改，可能会给调用者带来意想不到的结果。如果确实需要修改具体的实现，就需要做好达到测试覆盖率要求的单元测试。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;588630-7d17a7d220c612f0.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;原则一、单一职责原则（Single-Responsibility-Principle，简称SRP-）&quot;&gt;&lt;a href=&quot;#原则一、单一职
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 HTTPS 的原理详解</title>
    <link href="https://sunjinshuai.github.io/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://sunjinshuai.github.io/2019/09/13/%E6%B5%85%E8%B0%88-HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-09-13T15:23:54.000Z</published>
    <updated>2022-01-16T05:34:29.036Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p><code>HTTP</code> 协议（<code>HyperText Transfer Protocol</code>，超文本传输协议）：是客户端浏览器或其他程序与 <code>Web</code> 服务器之间的应用层通信协议 。</p></li><li><p><code>HTTPS</code> 协议（<code>HyperText Transfer Protocol over Secure Socket Layer</code>）：可以理解为 <code>HTTP+SSL/TLS</code>， 即 <code>HTTP</code> 下加入 <code>SSL</code> 层，<code>HTTPS</code> 的安全基础是 <code>SSL</code>，因此加密的详细内容就需要 <code>SSL</code>，用于安全的 <code>HTTP</code> 数据传输。</p></li><li><p><code>SSL</code>（<code>Secure Socket Layer</code>，安全套接字层）：<code>1994</code> 年为 <code>Netscape</code> 所研发，<code>SSL</code> 协议位于 <code>TCP/IP</code> 协议与各种应用层协议之间，为数据通讯提供安全支持。</p></li><li><p><code>TLS</code>（<code>Transport Layer Security</code>，传输层安全）：其前身是 <code>SSL</code>，它最初的几个版本（<code>SSL 1.0</code>、<code>SSL 2.0</code>、<code>SSL 3.0</code>）由网景公司开发，<code>1999</code> 年从 <code>3.1</code> 开始被 <code>IETF</code> 标准化并改名，发展至今已经有 <code>TLS 1.0</code>、<code>TLS 1.1</code>、<code>TLS 1.2</code> 三个版本。<code>SSL3.0</code> 和 <code>TLS1.0</code> 由于存在安全漏洞，已经很少被使用到。<code>TLS 1.3</code> 改动会比较大，目前还在草案阶段，目前使用最广泛的是 <code>TLS 1.1</code>、<code>TLS 1.2</code>。</p></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li><code>HTTP</code> 默认工作在 <code>TCP</code> 协议 <code>80</code> 端口，用户访问网站 <code>http://</code> 打头的都是标准 <code>HTTP</code> 服务。</li><li><code>HTTP</code> 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了 <code>Web</code> 浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</li><li><code>HTTPS</code> 默认工作在 <code>TCP</code> 协议 <code>443</code> 端口。</li><li><code>HTTPS</code>（<code>HTTP+SSL/TLS</code>）数据传输过程是加密的，安全性较好。</li></ul><p><code>HTTPS</code> 和 <code>HTTP</code> 协议相比提供了</p><ul><li>数据完整性：内容传输经过完整性校验</li><li>数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</li><li>身份认证：第三方无法伪造服务端（客户端）身份</li></ul><h3 id="TLS-握手流程"><a href="#TLS-握手流程" class="headerlink" title="TLS 握手流程"></a>TLS 握手流程</h3><p><code>HTTPS</code> 在传输数据之前需要客户端与服务端之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。<code>TLS/SSL</code> 协议是一套加密传输的协议，使用了非对称加密，对称加密以及 <code>HASH</code> 算法。以 <code>RSA</code> 为例，<code>TLS</code> 握手流程如下：<br><img src="588630-0e87f4003f1e85ff.png" alt="image.png"></p><p><strong>上图中的 <code>CA</code> 证书验证，这一步是可选的，对于安全性要求高的场景会用到，比如，预防中间人攻击。</strong></p><h4 id="第一步-Client-Hello"><a href="#第一步-Client-Hello" class="headerlink" title="第一步 Client Hello"></a>第一步 <code>Client Hello</code></h4><p>客户端向服务端发送 <code>Client Hello</code> 消息，这个消息里包含了一个客户端生成的随机数 <code>Random1</code>、客户端支持的协议版本，会话 ID，密码套件，压缩算法等信息。</p><h4 id="第二步-Server-Hello"><a href="#第二步-Server-Hello" class="headerlink" title="第二步 Server Hello"></a>第二步 <code>Server Hello</code></h4><p>服务端向客户端发送 <code>Server Hello</code> 消息，这个消息会从 <code>Client Hello</code> 传过来的加密套件里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 <code>Random2</code>。注意，至此客户端和服务端都拥有了两个随机数 <code>Random1+Random2</code> ，这两个随机数会在后续生成对称秘钥时用到。</p><p><strong>Client 发送一个 ClientHello 消息，Server 必须回应一个 ServerHello 消息或产生一个验证的错误并且使连接失败</strong></p><h5 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a><code>Certificate</code></h5><p>在 <code>Server Hello</code> 消息之后，服务端将自己的证书下发给客户端，<code>Server</code> 会在 <code>Certificate</code> 消息中发送它自己的证书，<strong>如果它即将被认证</strong>，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</p><h4 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="Server Key Exchange"></a><code>Server Key Exchange</code></h4><p>此外，如果需要的话，一个 <code>ServerKeyExchange</code> 消息会被发送，(例如, 如果 <code>Server</code> 没有证书, 或者它的证书只用于签名，<code>RSA</code> 密码套件就不会出现 <code>ServerKeyExchange</code> 消息，如果 <code>Server</code> 被认证过了，如果对于已选择的密码套件来说是合适的话，它可能会要求 <code>Client</code> 发送证书)。如果是 <code>DH</code> 算法，这里发送服务器使用的 <code>DH</code> 参数，<code>RSA</code> 算法不需要这一步；</p><h5 id="Certificate-Request"><a href="#Certificate-Request" class="headerlink" title="Certificate Request"></a><code>Certificate Request</code></h5><p>如果 Server 发送了一个 CertificateRequest 消息，Client 必须发送 Certificate 消息。</p><h5 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a><code>Server Hello Done</code></h5><p>Server Hello Done 通知客户端 Server Hello 过程结束。</p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>客户端收到了服务器发来的数据包后，会做这么几件事情：</p><h5 id="Client-Certificate"><a href="#Client-Certificate" class="headerlink" title="Client Certificate"></a><code>Client Certificate</code></h5><p>这是 <code>Client</code> 在收到一个 <code>ServerHelloDone</code> 消息后发送的第一个消息。这个消息只能在 <code>Server</code> 请求一个证书时发送。如果没有合适的证书，<code>Client</code> 必须发送一个不带证书的证书消息。如果 <code>Client</code> 不发送任何证书，<code>Server</code> 可以自行决定是否可以在不验证 <code>Client</code> 的情况下继续握手，<strong>或者回复一个致命 <code>handshake_failure</code> 警报 <code>alert</code> 信息。而且, 如果证书链某些方面不能接受(例如, 它没有被一个知名的可信 <code>CA</code> 签名)，<code>Server</code> 可以自行决定是否继续握手(考虑到 <code>Client</code> 无认证)或发送一个致命的警报 <code>alert</code> 信息。</strong></p><h5 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a><code>Client Key Exchange</code></h5><p>这个消息始终由 <code>Client</code> 发送。如果有 <code>Client Certificate</code> 消息的话，<code>Client Key Exchange</code> 紧跟在 <code>Client Certificate</code> 消息之后发送。如果不存在 <code>Client Certificate</code> 消息的话，它必须是在 <code>Client</code> 收到 <code>ServerHelloDone</code> 后发送的第一个消息。客户端根据服务器传来的公钥生成了 <code>PreMaster Key</code>，<code>Client Key Exchange</code> 就是将这个 <code>key</code> 传给服务端。</p><h5 id="Change-Cipher-Spec-Client"><a href="#Change-Cipher-Spec-Client" class="headerlink" title="Change Cipher Spec Client"></a><code>Change Cipher Spec Client</code></h5><p>将刚才的消息使用刚才的 <code>PreMaster Key</code> 进行加密，生成相应的消息校验值，与刚才的消息一同发还给服务器。</p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>服务器接受到客户端发来的消息后，会做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Client"><a href="#Encrypted-Handshake-Message-Client" class="headerlink" title="Encrypted Handshake Message Client"></a><code>Encrypted Handshake Message Client</code></h5><p>这一步对应的是 <code>Client Finish</code> 消息，使用私钥解密上面第2步中公钥加密的消息，得到客户端产生的随机序列号。使用该随机序列号，对该消息进行加密，验证的到的校验值是否与客户端发来的一致。如果一致则说明消息未被篡改，可以信任。</p><h5 id="Change-Cipher-Spec-Server"><a href="#Change-Cipher-Spec-Server" class="headerlink" title="Change Cipher Spec Server"></a><code>Change Cipher Spec Server</code></h5><p>使用该随机序列号，加上之前第2步中选择的加密算法，加密一段握手消息，发还给客户端。</p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>客户端收到服务器端的消息后，接着做这么几件事情：</p><h5 id="Encrypted-Handshake-Message-Server"><a href="#Encrypted-Handshake-Message-Server" class="headerlink" title="Encrypted Handshake Message Server"></a><code>Encrypted Handshake Message Server</code></h5><p>这一步对应的是 <code>Server Finish</code> 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</p><h4 id="第六步-Application-Data"><a href="#第六步-Application-Data" class="headerlink" title="第六步 Application Data"></a>第六步 <code>Application Data</code></h4><p>握手结束后，客户端和服务器端使用握手阶段产生的随机数以及挑选出来的算法进行对称加解密的传输。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>采用 <code>HTTPS</code> 协议的服务器必须要有自己制作或者 <code>CA</code> 证书，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用 <code>CA</code> 证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。</p><p>客户端收到服务器的回复后，首先客户端会从内置的证书列表中索引，查找服务器下发 <code>CA</code> 证书，如果没有找到，此时就会提示用户该证书是不可信任的。如果查到了对应 <code>CA</code> 证书，则取出 <code>public key</code> 公钥。然后，用 <code>public key</code> 公钥解密得到证书的内容和证书签名，内容包括证书的颁发机构，过期时间等。客户端会先验证证书签名的合法性，签名通过后，会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，客户端就可以安全使用 <code>public key</code> 公钥了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt; 协议（&lt;code&gt;HyperText Transfer Protocol&lt;/code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 iOS ARC 内存管理</title>
    <link href="https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-02-13T09:15:20.000Z</published>
    <updated>2022-01-16T11:28:16.661Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 采用的是引用计数式的内存管理方式：</p><ul><li><p>自己生成的对象自己持有。</p></li><li><p>非自己生成的对象自己也能持有。</p></li><li><p>自己持有的对象不再需要时释放。</p></li><li><p>非自己持有的对象自己无法释放。</p></li><li><p>使用以下名称开头的方法名意味着<strong>自己生成的对象只有自己持有</strong>：</p></li><li><p><code>alloc</code></p></li><li><p><code>new</code></p></li><li><p><code>copy</code></p></li><li><p><code>mutableCopy</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 自己生成并持有该对象</span><br><span class="line"> *&#x2F;</span><br><span class="line"> id obj0 &#x3D; [[NSObeject alloc] init];</span><br><span class="line"> id obj1 &#x3D; [NSObeject new];</span><br></pre></td></tr></table></figure><ul><li><p>非自己生成的对象，自己也能持有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 持有非自己生成的对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">[obj retain]; &#x2F;&#x2F; 自己持有对象</span><br></pre></td></tr></table></figure><p>备注：通过 <code>retain</code> 方法来让指针变量持有这个新生成的对象。</p></li><li><p>不再需要自己持有的对象时释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 不在需要自己持有的对象的时候，释放</span><br><span class="line"> *&#x2F;</span><br><span class="line">id obj &#x3D; [[NSObeject alloc] init]; &#x2F;&#x2F; 此时持有对象</span><br><span class="line">[obj release]; &#x2F;&#x2F; 释放对象</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 指向对象的指针仍就被保留在obj这个变量中</span><br><span class="line"> * 但对象已经释放，不可访问</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p>自己持有的对象，一旦不再需要，持有者有义务释放该对象。释放使用 <code>release</code> 方法。<br>当调用对象的 <code>release</code> 方法只是将对象的引用计数器 <code>-1</code>，当对象的引用计数器为 <code>0</code> 的时候会调用了对象的 <code>dealloc</code> 方法才能进行释放对象的内存。</p></li><li><p>非自己生成的对象持有对象的释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;非自己生成的对象，暂时没有持有</span><br><span class="line">id obj &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过retain持有对象</span><br><span class="line">[obj retain];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放对象</span><br><span class="line">[obj release];</span><br></pre></td></tr></table></figure></li></ul><p>两种不允许的情况：</p><ul><li><p>释放自己不持有的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 非自己持有的对象无法释放</span><br><span class="line"> *&#x2F;</span><br><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">[obj release]; &#x2F;&#x2F; ~~~此时将运行时crash 或编译器报error~~~ 非 ARC 下，调用该方法会导致编译器报 issues。此操作的行为是未定义的，可能会导致运行时 crash 或者其它未知行为</span><br></pre></td></tr></table></figure></li><li><p>释放一个已经废弃了的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [[NSObject alloc] init];&#x2F;&#x2F;持有新生成的对象</span><br><span class="line">[obj doSomething];&#x2F;&#x2F;使用该对象</span><br><span class="line">[obj release];&#x2F;&#x2F;释放该对象，不再持有了</span><br><span class="line">[obj release];&#x2F;&#x2F;释放已经废弃了的对象，崩溃</span><br></pre></td></tr></table></figure></li></ul><h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>当对象超出其作用域时，对象实例的 <code>release</code> 方法就会被调用，<code>autorelease</code> 的具体使用方法如下：</p><ul><li>生成并持有 <code>NSAutoreleasePool</code> 对象。</li><li>调用已分配对象的 <code>autorelease</code> 方法。</li><li>废弃 <code>NSAutoreleasePool</code> 对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id) getAObjNotRetain &#123;</span><br><span class="line">    id obj &#x3D; [[NSObject alloc] init]; &#x2F;&#x2F; 自己持有对象</span><br><span class="line">    [obj autorelease]; &#x2F;&#x2F; 取得的对象存在，但自己不持有该对象</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个特性是使用 <code>autorelease</code> 来实现的，<code>autorelease</code> 使得对象在超出生命周期后能正确的被释放(通过调用 <code>release</code> 方法)。在调用 <code>release</code> 后，对象会被立即释放，而调用 <code>autorelease</code> 后，对象不会被立即释放，而是注册到 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p><p>在 <code>ARC</code> 环境下，<code>id</code> 类型和对象类型和 <code>C</code> 语言其他类型不同，类型前必须加上所有权的修饰符。<br>所有权修饰符总共有4种：</p><ul><li>__strong</li><li>__weak</li><li>__autoreleasing</li><li>__unsafe_unretained</li></ul><h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h2><p><code>__strong</code> 表示强引用，对应定义 <code>property</code> 时用到的 <code>strong</code>。当对象没有任何一个强引用指向它时，它才会被释放。如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要保证所有指向对象强引用置为 <code>nil</code>。<code>__strong</code> 修饰符是 <code>id</code> 类型和对象类型默认的所有权修饰符。</p><h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p><code>__weak</code> 表示弱引用，对应定义 <code>property</code> 时用到的 <code>weak</code>。弱引用不会影响对象的释放，而当对象被释放时，所有指向它的弱引用都会自定被置为 <code>nil</code>，这样可以防止野指针。<code>__weak</code> 最常见的一个作用就是用来避免强引用循环。</p><p><code>__weak</code> 的几个使用场景：</p><ul><li>在 <code>delegate</code> 关系中防止强引用循环。在 <code>ARC</code> 特性下，通常我们应该设置 <code>delegate</code> 属性为 <code>weak</code> 的。但是这里有一个疑问，我们常用到的 <code>UITableView</code> 的 <code>delegate</code> 属性是这样定义的：<code>@property (nonatomic, assign) id&lt;UITableViewDelegate&gt; delegate;</code>，为什么用的修饰符是<code>assign</code> 而不是 <code>weak</code>？其实这个 <code>assign</code> 在 <code>ARC</code> 中意义等同于 <code>__unsafe_unretained</code>（后面会讲到），它是为了在 <code>ARC</code> 特性下兼容 <code>iOS4</code> 及更低版本来实现弱引用机制。一般情况下，你应该尽量使用 <code>weak</code>。</li><li>在 <code>Block</code> 中防止强引用循环。</li><li>用来修饰指向由 <code>Interface Builder</code> 创建的控件。比如：<code>@property (nonatomic, weak) IBOutlet UIButton *testButton;</code>。</li></ul><p>另外，<code>__weak</code> 修饰符的变量，会被注册到 <code>autoreleasePool</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 &#x3D; obj;</span><br><span class="line">    NSLog(@&quot;obj2-%@&quot;,obj1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器转换上述代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initweak(&amp;obj1,obj);</span><br><span class="line">id tmp &#x3D; objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;,tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><p><code>objc_loadWeakRetained</code> 函数获取附有 <code>__weak</code> 修饰符变量所引用的对象并 <code>retain</code>, <code>objc_autorelease</code> 函数将对象放入 <code>autoreleasePool</code> 中，据此当我们访问 <code>weak</code> 修饰指针指向的对象时，实际上是访问注册到自动释放池的对象。因此，如果大量使用 <code>weak</code> 的话，在我们去访问 <code>weak</code> 修饰的对象时，会有大量对象注册到自动释放池,这会影响程序的性能。</p><p>解决方案：<br>要访问 <code>weak</code> 修饰的变量时，先将其赋给一个 <code>strong</code> 变量，然后进行访问。</p><p>为什么访问 <code>weak</code> 修饰的对象就会访问注册到自动释放池的对象呢?</p><p>因为 <code>weak</code> 不会引起对象的引用计数器变化，因此，该对象在运行过程中很有可能会被释放。所以，需要将对象注册到自动释放池中并在 <code>autoreleasePool</code> 销毁时释放对象占用的内存。</p><h2 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h2><p>在 <code>ARC</code> 模式下，我们不能显示的使用 <code>autorelease</code> 方法了，但是 <code>autorelease</code> 的机制还是有效的，通过将对象赋给 <code>__autoreleasing</code> 修饰的变量就能达到在 <code>MRC</code> 模式下调用对象的 <code>autorelease</code> 方法同样的效果。</p><p><code>__autoreleasing</code> 修饰的对象会被注册到 <code>Autorelease Pool</code> 中，并在 <code>Autorelease Pool</code> 销毁时被释放。</p><p><strong>注意：定义 <code>property</code> 时不能使用这个修饰符，因为任何一个对象的 <code>property</code> 都不应该是 <code>autorelease</code> 类型的。</strong></p><h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h2><p><code>ARC</code> 是在 <code>iOS5</code> 引入的，而 <code>__unsafe_unretained</code> 这个修饰符主要是为了在 <code>ARC</code> 刚发布时兼容 <code>iOS4</code> 以及版本更低的系统，因为这些版本没有弱引用机制。这个修饰符在定义 <code>property</code> 时对应的是 <code>unsafe_unretained</code>。<code>__unsafe_unretained</code> 修饰的指针纯粹只是指向对象，没有任何额外的操作，不会去持有对象使得对象的 <code>retainCount +1</code>。而在指向的对象被释放时依然原原本本地指向原来的对象地址，不会被自动置为 <code>nil</code>，所以成为了野指针，非常不安全。</p><p><code>__unsafe_unretained</code> 的应用场景：</p><ul><li>在 ARC 环境下但是要兼容 iOS4.x 的版本，用 <code>__unsafe_unretained</code> 替代 <code>__weak</code> 解决强引用循环的问题。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>总结， <code>autorelease</code> 的机制却依然在很多地方默默起着作用，我们来看看这些场景：</p><ul><li>方法返回值。</li><li>访问 __weak 修饰的变量。</li><li>id 的指针或对象的指针(id *)。</li></ul><h3 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h3><p>首先，我们看这个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  (NSMutableArray *)array  &#123;</span><br><span class="line">    NSMutableArray *array &#x3D; [NSMutableArray array];</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array &#x3D; objc_msgSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleasedReturnValue(array);</span><br><span class="line">objc_release(array);</span><br></pre></td></tr></table></figure><p>这里 <code>array</code> 的所有权修饰符是默认的 <code>__strong</code>。由于 <code>return</code> 使得 <code>array</code> 超出其作用域，它强引用持有的对象本该被释放，但是由于该对象作为函数返回值，所以<strong>一般情况下编译器会自动将其注册到 <code>AutoreleasePool</code> 中（注意这里是一般情况下，在一些特定情况下，<code>ARC</code> 机制提出了巧妙的运行时优化方案来跳过 <code>autorelease</code> 机制。）</strong>。</p><h4 id="ARC-模式下方法返回值跳过-autorelease-机制的优化方案"><a href="#ARC-模式下方法返回值跳过-autorelease-机制的优化方案" class="headerlink" title="ARC 模式下方法返回值跳过 autorelease 机制的优化方案"></a>ARC 模式下方法返回值跳过 autorelease 机制的优化方案</h4><p>为什么方法返回值的时候需要用到 <code>autorelease</code>机制呢？</p><p>当对象被作为参数返回 <code>return</code> 之后，如果调用者需要使用就需要强引用它，那么它 <code>retainCount + 1</code>，用完之后再清理，使它 <code>retainCount - 1</code>。</p><p>如果在方法中创建了对象并作为返回值时，根据 <code>ARC</code> 内存管理的原则，谁创建谁释放。既然作为返回值，就必须保证返回时对象没被释放以便方法外的调用者能拿到有效的对象，否则你返回的是 nil，有何意义呢。所以就需要找一个合理的机制既能延长这个对象的生命周期，又能保证对其释放。这个机制就是 <code>autorelease 机制</code>。</p><p><code>ARC</code> 模式下在方法 <code>return</code> 的时候，会调用 <code>objc_autoreleaseReturnValue()</code><br>方法替代 <code>autorelease</code>。在调用者强引用方法返回对象的时候，会调用 <code>objc_retainAutoreleasedReturnValue()</code> 方法，该方法会去检查该方法或者调用方的执行命令列表，是否会被传给 <code>objc_retainAutoreleasedReturnValue()</code> 方法。如果里面有 <code>objc_retainAutoreleasedReturnValue()</code> 方法，那么该对象就直接返回给方法或者函数的调用方。达到了即使对象不注册到 <code>autoreleasepool</code>中，也可以返回拿到相应的对象。如果没传，那么它就会走 <code>autorelease</code> 的过程注册到 <code>autoreleasepool</code> 中。</p><h3 id="访问-weak-修饰的变量"><a href="#访问-weak-修饰的变量" class="headerlink" title="访问 __weak 修饰的变量"></a>访问 __weak 修饰的变量</h3><p>在访问 <code>__weak</code> 修饰的变量时，实际上必定会访问注册到 <code>AutoreleasePool</code> 的对象。如下来年两段代码是相同的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [obj1 class]);</span><br><span class="line">&#x2F;&#x2F; 等同于：</span><br><span class="line">id __weak obj1 &#x3D; obj0;</span><br><span class="line">id __autoreleasing tmp &#x3D; obj1;</span><br><span class="line">NSLog(@&quot;class&#x3D;%@&quot;, [tmp class]);</span><br></pre></td></tr></table></figure><p>为什么会这样呢？因为 <code>__weak</code> 修饰符只持有对象的弱引用，而在访问对象的过程中，该对象有可能被废弃，如果把被访问的对象注册到 <code>AutoreleasePool</code> 中，就能保证 <code>AutoreleasePool</code> 被销毁前对象是存在的。</p><h3 id="id-的指针或对象的指针-id"><a href="#id-的指针或对象的指针-id" class="headerlink" title="id 的指针或对象的指针(id *)"></a>id 的指针或对象的指针(id *)</h3><p>另一个隐式地使用 <code>__autoreleasing</code> 的例子就是使用 id 的指针或对象的指针(id *) 的时候。</p><p>看一个最常见的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSError *__autoreleasing error;</span><br><span class="line">if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) &#123;</span><br><span class="line">    NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 即使上面你没有写 __autoreleasing 来修饰 error，编译器也会帮你做下面的事情：</span><br><span class="line">NSError *error;</span><br><span class="line">NSError *__autoreleasing tempError &#x3D; error; &#x2F;&#x2F; 编译器添加</span><br><span class="line">if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) &#123;</span><br><span class="line">    error &#x3D; tempError; &#x2F;&#x2F; 编译器添加</span><br><span class="line">    NSLog(@&quot;Error: %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>error</code> 对象在你调用的方法中被创建，然后被放到 <code>AutoreleasePool</code> 中，等到使用结束后随着 <code>AutoreleasePool</code> 的销毁而释放，所以函数外 <code>error</code> 对象的使用者不需要关心它的释放。</p><p>在 <code>ARC</code> 中，所有这种指针的指针类型<code>（id *）</code>的函数参数如果不加修饰符，编译器会默认将他们认定为 <code>__autoreleasing</code> 类型。</p><p>有一点特别需要注意的是，某些类的方法会隐式地使用自己的 <code>AutoreleasePool</code>，在这种时候使用 <code>__autoreleasing</code> 类型要特别小心。比如 <code>NSDictionary</code> 的 <code>enumerateKeysAndObjectsUsingBlock</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        &#x2F;&#x2F; do stuff</span><br><span class="line">        if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">            *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; code:1 userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中其实会隐式地创建一个 <code>AutoreleasePool</code>，类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        @autoreleasepool &#123;  &#x2F;&#x2F; 被隐式创建。</span><br><span class="line">            if (there is some error &amp;&amp; error !&#x3D; nil) &#123;</span><br><span class="line">                *error &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; code:1 userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    &#x2F;&#x2F; *error 在这里已经被dict的做枚举遍历时创建的 Autorelease Pool释放掉了。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够正常的使用 <code>*error</code>，我们需要一个 <code>strong</code> 类型的临时引用，在 <code>dict</code> 的枚举 <code>Block</code> 中是用这个临时引用，保证引用指向的对象不会在出了 <code>dict</code> 的枚举 <code>Block</code> 后被释放，正确的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error &#123;</span><br><span class="line">    NSError * __block tempError; &#x2F;&#x2F; 加 __block 保证可以在Block内被修改。</span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">        if (there is some error) &#123;</span><br><span class="line">            *tempError &#x3D; [NSError errorWithDomain:@&quot;MyError&quot; code:1 userInfo:nil];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    if (error !&#x3D; nil) &#123;</span><br><span class="line">        *error &#x3D; tempError;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Objective-C 采用的是引用计数式的内存管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自己生成的对象自己持有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非自己生成的对象自己也能持有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自己持有的对象不再需要时释放。&lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CocoaPods 使用总结</title>
    <link href="https://sunjinshuai.github.io/2018/05/09/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://sunjinshuai.github.io/2018/05/09/CocoaPods-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2018-05-09T10:31:52.000Z</published>
    <updated>2022-03-21T00:59:18.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocoaPods简介"><a href="#CocoaPods简介" class="headerlink" title="CocoaPods简介"></a>CocoaPods简介</h2><p><code>CocoaPods</code> 是专门为 <code>iOS</code> 工程提供第三方依赖库的管理工具，通过 <code>CocoaPods</code>，我们可以更方便地管理每个第三方库的版本，而且不需要我们做太多的配置，就可以直观、集中和自动化地管理我们项目的第三方库。</p><p><code>CocoaPods</code> 将所有依赖的库都放在一个名为 <code>Pods</code> 的项目下，然后让主项目依赖 <code>Pods</code> 项目。然后，我们编码工作都从主项目转移到 <code>Pods</code> 项目。<code>Pods</code> 项目最终会编译为一个 <code>libPod-项目名.a</code> 静态库，主项目依赖于这个静态库。</p><p>对于资源文件，<code>CocoaPods</code> 提供了一个名为 <code>Pods-resources.sh</code> 的 <code>bash</code> 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。<code>CocoaPods</code> 通过一个名为 <code>Pods.xcconfig</code> 的文件来在编译时设置所有的依赖和参数。<code>CocoaPods</code> 是用 <code>Ruby</code> 写的，并由若干个 <code>Ruby</code> 包 (gems) 构成的。在解析整合过程中，最重要的几个 <code>gems</code> 分别是： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCocoaPods%2F" target="_blank" rel="noopener">CocoaPods/CocoaPods</a>、<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FCore" target="_blank" rel="noopener">CocoaPods/Core</a> 和 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCocoaPods%2FXcodeproj" target="_blank" rel="noopener">CocoaPods/Xcodeproj</a>。</p><h2 id="CocoaPod的核心组件"><a href="#CocoaPod的核心组件" class="headerlink" title="CocoaPod的核心组件"></a>CocoaPod的核心组件</h2><ul><li>CocoaPods/CocoaPod<br>这是一个面向用户的组件，每当执行一个 <code>pod</code> 命令时，这个组件都将被激活。该组件包括了所有使用 <code>CocoaPods</code> 涉及到的功能，并且还能通过调用所有其它的 <code>gems</code> 来执行任务。</li><li>CocoaPods/Core<br><code>Core</code> 组件提供支持与 <code>CocoaPods</code> 相关文件的处理，文件主要是 <code>Podfile</code> 和 <code>podspecs</code>。</li><li>Podfile<br><code>Podfile</code> 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 <code>Podfile</code> 指南。</li><li>Podspec<br><code>.podspec</code> 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、<code>framework</code>、编译选项和某个库所需要的依赖等。</li><li>CocoaPods/Xcodeproj<br>这个 <code>gem</code> 组件负责所有工程文件的整合。它能够创建并修改 <code>.xcodeproj</code> 和 <code>.xcworkspace</code> 文件。它也可以作为单独的一个 <code>gem</code> 包使用。如果你想要写一个脚本来方便地修改工程文件，那么可以使用这个 <code>gem</code>。</li></ul><h2 id="私有库开发流程"><a href="#私有库开发流程" class="headerlink" title="私有库开发流程"></a>私有库开发流程</h2><p>一般公司都会搭建自己的 <code>git</code> 服务器，在实战项目中，经常使用 <code>Cocoapods</code> 管理自己的私有库。</p><ul><li><code>git</code> 仓库至少需要两个，一个用于管理私有库对应版本的 <code>podspec</code> 文件，一个用于存放私有库的源文件。</li><li>查看现有的 <code>podspec</code> 源地址：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建一个私有的-podspec-主要包括如下几步："><a href="#创建一个私有的-podspec-主要包括如下几步：" class="headerlink" title="创建一个私有的 podspec 主要包括如下几步："></a>创建一个私有的 <code>podspec</code> 主要包括如下几步：</h3><ul><li>创建一个私有的 <code>Spec Repo</code>，用于管理私有库对应版本的 <code>podspec</code> 文件；</li><li>创建 <code>pod</code> 私有库所需要的项目工程文件，并上传到私有库；</li><li>创建 <code>pod</code> 所对应的 <code>podspec</code> 文件，并进行验证／测试；</li><li>向私有的 <code>Spec Repo</code> 中提交 <code>podspec</code>；</li><li>使用 <code>pod</code> 库；</li></ul><h3 id="创建一个私有的-Spec-Repo"><a href="#创建一个私有的-Spec-Repo" class="headerlink" title="创建一个私有的 Spec Repo"></a>创建一个私有的 <code>Spec Repo</code></h3><ul><li>在自己公司的 <code>git</code> 服务器上创建 <code>SpecsRepo</code> 仓库；</li><li>将私有 <code>SpecsRepo</code> 关联到本地；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add IMXSpecsRepo http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure></li></ul><p>查看 <code>SpecsRepo</code> 是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods&#x2F;repos</span><br></pre></td></tr></table></figure><h3 id="创建-pod-私有库所需要的项目工程"><a href="#创建-pod-私有库所需要的项目工程" class="headerlink" title="创建 pod 私有库所需要的项目工程"></a>创建 pod 私有库所需要的项目工程</h3><h4 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create 仓库名字 --template-url&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXPodTemplte</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>手动创建</p><p>手动创建 <code>Xcode</code> 工程项目，创建 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create XXXX.podspec</span><br></pre></td></tr></table></figure><p>修改 <code>podspec</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name             &#x3D; &#39;AKCBrowser&#39;</span><br><span class="line">  s.version          &#x3D; &#39;0.0.1&#39;</span><br><span class="line">  s.summary          &#x3D; &#39;A short description of AKCBrowser.&#39;</span><br><span class="line"></span><br><span class="line">  # This description is used to generate tags and improve search results.</span><br><span class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">  #   * Try to keep it short, snappy and to the point.</span><br><span class="line">  #   * Write the description between the DESC delimiters below.</span><br><span class="line">  #   * Finally, don&#39;t worry about the indent, CocoaPods strips it!</span><br><span class="line"></span><br><span class="line">  s.description      &#x3D; &lt;&lt;-DESC</span><br><span class="line">  TODO: Add long description of the pod here.</span><br><span class="line">  DESC</span><br><span class="line"></span><br><span class="line">  s.homepage         &#x3D; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;</span><br><span class="line">  # s.screenshots     &#x3D; &#39;www.example.com&#x2F;screenshots_1&#39;, &#39;www.example.com&#x2F;screenshots_2&#39;</span><br><span class="line">  s.license          &#x3D; &#123; :type &#x3D;&gt; &#39;MIT&#39;, :file &#x3D;&gt; &#39;LICENSE&#39; &#125;</span><br><span class="line">  s.author           &#x3D; &#123; &#39;sunjinshuai&#39; &#x3D;&gt; &#39;s_mike@163.com&#39; &#125;</span><br><span class="line">  s.source           &#x3D; &#123; :git &#x3D;&gt; &#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git&#39;, :tag &#x3D;&gt; s.version.to_s &#125;</span><br><span class="line"></span><br><span class="line">  s.static_framework      &#x3D; true</span><br><span class="line">  s.requires_arc &#x3D; true</span><br><span class="line">  s.frameworks &#x3D; &#39;UIKit&#39;, &#39;Foundation&#39;</span><br><span class="line">  s.ios.deployment_target &#x3D; &#39;8.0&#39;</span><br><span class="line">  s.xcconfig &#x3D; &#123;</span><br><span class="line">    &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;MAS_SHORTHAND_GLOBALS&#x3D;1&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  s.resource_bundles &#x3D; &#123;</span><br><span class="line">    &#39;Browser&#39; &#x3D;&gt; [&#39;AKCBrowser&#x2F;Assets&#x2F;Browser&#x2F;*.*&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">  s.source_files &#x3D; &#39;AKCBrowser&#x2F;Classes&#x2F;**&#x2F;*&#39;</span><br><span class="line"></span><br><span class="line">  s.dependency &#39;SDWebImage&#39;,&#39;4.2.3&#39;</span><br><span class="line">  s.dependency &#39;YYImage&#39;</span><br><span class="line">  s.dependency &#39;AKCFoundation&#39;</span><br><span class="line">  s.dependency &#39;AFNetworking&#x2F;Reachability&#39;</span><br><span class="line">  s.dependency &#39;SVProgressHUD&#39;</span><br><span class="line">  s.dependency &#39;AKCLog&#39;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="podspec-语法简介"><a href="#podspec-语法简介" class="headerlink" title="podspec 语法简介"></a>podspec 语法简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s.name：私有库的名称，&#96;pod search&#96;搜索的关键词，注意这里一定要和&#96;.podspec&#96;的名称一样，否则报错。</span><br><span class="line">s.version：私有库的版本。</span><br><span class="line">s.ios.deployment_target：支持的pod最低版本。</span><br><span class="line">s.summary：私有库简介。</span><br><span class="line">s.description：私有库详细介绍。</span><br><span class="line">s.homepage：私有库在GitHub上的地址。</span><br><span class="line">s.license：开源协议。</span><br><span class="line">s.author：作者。</span><br><span class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</span><br><span class="line">s.source：私有库在GitHub上的地址和版本号。</span><br><span class="line">s.source_files：私有库对外共享的.h和.m文件。</span><br><span class="line">s.requires_arc：是否支持ARC。</span><br></pre></td></tr></table></figure><p>更多语法查看(<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" target="_blank" rel="noopener">http://guides.cocoapods.org/making/specs-and-specs-repo.html</a>)</p><h3 id="上传项目工程的源文件"><a href="#上传项目工程的源文件" class="headerlink" title="上传项目工程的源文件"></a>上传项目工程的源文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;akc-framework-ios&#x2F;AKCBrowser.git</span><br><span class="line">git push -u origin master</span><br><span class="line">git tag -m &quot;first release&quot; 0.0.1</span><br><span class="line">git push --tags     #推送tag到远端仓库</span><br></pre></td></tr></table></figure><h3 id="验证-podspec-文件"><a href="#验证-podspec-文件" class="headerlink" title="验证 podspec 文件"></a>验证 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings --verbose</span><br><span class="line">pod lib lint --use-libraries --allow-warnings   &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line">pod lib lint --sources&#x3D;http:&#x2F;&#x2F;192.168.120.32&#x2F;app&#x2F;sisi-iOS&#x2F;IMXSpecsRepo.git</span><br></pre></td></tr></table></figure><p>当看到 <code>AKCBrowser passed validation</code>。表示验证通过。</p><h3 id="向-Spec-Repo-中提交-podspec-文件"><a href="#向-Spec-Repo-中提交-podspec-文件" class="headerlink" title="向 Spec Repo 中提交 podspec 文件"></a>向 Spec Repo 中提交 podspec 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings</span><br><span class="line">pod repo push IMXSpecsRepo AKCProtobuf.podspec --allow-warnings --use-libraries  &#x2F;&#x2F; 使用静态库后的用法</span><br><span class="line"></span><br><span class="line">pod repo push IMXSpecsRepo AKCFoundation.podspec --allow-warnings --sources&#x3D;&#39;http:&#x2F;&#x2F;192.168.120.32&#x2F;ddcang&#x2F;iOSGiftBox&#x2F;SpecsRepo.git&#39;</span><br></pre></td></tr></table></figure><h2 id="多-target-时-Podfile-该如何写"><a href="#多-target-时-Podfile-该如何写" class="headerlink" title="多 target 时 Podfile 该如何写"></a>多 target 时 Podfile 该如何写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#39;8.0&#39;</span><br><span class="line"></span><br><span class="line">def commonPods #通用pods集</span><br><span class="line">    pod &#39;AFNetworking&#39;, &#39;~&gt; 2.0&#39;</span><br><span class="line">    pod &#39;Masonry&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def appOnlyPods #app专用pods集</span><br><span class="line">    pod &#39;MBProgressHUD&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def extensionPods #扩展专用pods集</span><br><span class="line">    pod &#39;GTSDKExtension&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :TestCocoaPods do</span><br><span class="line">    commonPods</span><br><span class="line">    appOnlyPods</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsTests do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsUITests do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # Pods for testing</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :SecondTarget do</span><br><span class="line">    commonPods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="如何忽略Pods警告"><a href="#如何忽略Pods警告" class="headerlink" title="如何忽略Pods警告"></a>如何忽略Pods警告</h2><p>在 <code>Podfile</code> 中对应的 <code>target</code> 或分组下加上关键字 <code>inhibit_all_warnings</code>即可。</p><h2 id="如何直接引用第三方库中的头文件"><a href="#如何直接引用第三方库中的头文件" class="headerlink" title="如何直接引用第三方库中的头文件"></a>如何直接引用第三方库中的头文件</h2><p>在用 <code>CocoaPods</code> 集成第三方库之后，默认情况下，我们需要使用类似 <code>#import &lt;XXX/YYY.h&gt;</code>的方式引入第三方库的头文件。</p><p>可以在 <code>Build Settings -&gt; User Header Search Paths</code> 中添加 <code>${SRCROOT}</code> 并设置成 <code>recursive</code>，这样我们就可以直接使用 <code>#impot &quot;YYY.h&quot;</code>这种方式了。</p><p>pod install 和 pod update 的选择</p><p>pod install：</p><p>按照官方文档所说，<code>pod install</code>在第一次检索集成第三方以及每一次在 <code>Podfile</code> 中新增、更改或删除 pod 的时候使用。每一次执行 <code>pod install</code>命令，它都会下载安装新的 <code>pod</code>，并且会把每一个安装的 <code>pod</code> 的版本信息写入 <code>Podfile.lock</code> 文件。<code>Podfile.lock</code> 文件跟踪每一个安装的 <code>pod</code> 的版本并且上锁。每一次执行 <code>pod install</code>命令，只解决还没有在 <code>Podfile.lock</code> 中列出的依赖：对于已在 Podfile.lock 中列出的 <code>pod</code>，会下载指定的版本，不会检查是否有新版本。对于没有在 <code>Podfile.lock</code> 中列出的 <code>pod</code>，它会搜索并安装 <code>Podfile</code> 中指定的版本。</p><p>pod update：</p><p>直接执行 <code>pod update</code>命令会检查安装 <code>Podfile</code> 中列出的所有 <code>pod</code> 的最新版本。只有当你想要更新 <code>pod</code> 库的版本时才使用 <code>pod update</code>；它不管 <code>Podfile.lock</code>是否存在，都会读取 <code>Podfile</code> 文件的最新版本，下载好之后，重新生成 <code>Podfile.lock</code>文件。</p><p>两者的区别：</p><ul><li><p>用 <code>pod install</code>命令来安装新的 <code>pod</code>，每次在 <code>Podfile</code> 中新增和删除 <code>pod</code> 都使用 <code>pod install</code>命令。</p></li><li><p>在 <code>Podfile</code> 中添加新的 <code>pod</code> 后应该用 <code>pod install</code>命令，而不是 <code>pod update</code>命令。通过 <code>pod install</code>命令安装新的 <code>pod</code> 而不用担心在同一进程中修改已有的 <code>pod</code>。</p></li><li><p><code>pod update</code>命令仅用在更新指定 <code>pod</code> 到指定版本或者更新所有 <code>pod</code>。</p></li></ul><p>如果想更新指定的 <code>pod</code> 仓库，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update XXX –no-repo-update</span><br></pre></td></tr></table></figure><p>如果想安装新添加的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install –no-repo-update</span><br></pre></td></tr></table></figure><p>当需要在 <code>CocoaPods</code> 中删除一个我们不要的库时 可以在 <code>Podfile</code> 中直接删除相关库；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod update --no-repo-update 会在删除相关库时 更新其他库版本</span><br><span class="line">pod update XXX --no-repo-update 只会删除相关库 和下方一致</span><br><span class="line">pod install --no-repo-update 只会删除相关库</span><br></pre></td></tr></table></figure><p>关于版本指定约束</p><p>一般我们在使用 <code>cocoapods</code> 导入第三方库前都会生成一个 <code>podfile</code> 文件，文件中记录着我们要导入的第三方库以及对应的版本信息，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39;, &#39;~&gt; 4.3.2&#39;</span><br></pre></td></tr></table></figure><p>让 <code>cocoapods</code> 导入 <code>SDWbImage</code>，版本号 <code>4.3.2</code> 和版本号处于 <code>4.3.2-4.4</code> 之间的，不包括 <code>4.4</code> 和更高版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pod &#39;SDWebImage&#39; --- 不指定版本，表示希望使用最新版本</span><br><span class="line">pod &#39;SDWebImage&#39;, &#39;4.3.2&#39; --- 指定明确版本，表示只想要这个版本</span><br><span class="line">逻辑关系</span><br><span class="line">&#39;&gt; 0.1&#39; --- 版本号大于0.1的</span><br><span class="line">&#39;&gt;&#x3D; 0.1&#39; --- 版本0.1和版本号大于0.1的</span><br><span class="line">&#39;&lt; 0.1&#39; --- 版本号小于0.1的</span><br><span class="line">&#39;&lt;&#x3D; 0.1&#39; --- 版本号0.1和版本号小于0.1的</span><br><span class="line">最优匹配</span><br><span class="line">&#39;~&gt; 0.1.2&#39; --- 版本0.1.2和版本号处于0.1.2-0.2之间的,不包括0.2和更高版本</span><br><span class="line">&#39;~&gt; 0.1&#39; --- 版本0.1和版本号处于0.1-1.0之间的,不包括1.0和更高版本</span><br><span class="line">&#39;~&gt; 0&#39; --- 版本0和更高，和没设没啥区</span><br></pre></td></tr></table></figure><p>tag 改动原则:  </p><ul><li>增加 api，修改第三位;   </li><li>修改 api，修改第二位；</li><li>大版本变更修改第一位;</li></ul><p>卸载旧版本 <code>cocoapods</code> 安装新的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> sudo gem uninstall cocoapods-core cocoapods cocoapods-deintegrate cocoapods-downloader cocoapods-plugins cocoapods-search cocoapods-stats cocoapods-trunk cocoapods-try coderay colored2 concurrent-ruby cocoapods-clean</span><br><span class="line">sudo gem install cocoapods</span><br></pre></td></tr></table></figure><p><code>pod</code> 库太多，每次构建编译都很耗费时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install! &#39;cocoapods&#39;, generate_multiple_pod_projects: true</span><br></pre></td></tr></table></figure><p><code>pod</code> 库每次修改代码，主工程必须 <code>clean</code> 再安装才可以看到新改动的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">install! &#39;cocoapods&#39;, :disable_input_output_paths &#x3D;&gt; true</span><br></pre></td></tr></table></figure><p><code>pod lint</code> 产生的信息太多，一屏显示不全,但是出错之后我们可能需要去查看 <code>error</code> 信息，上下翻页不方便</p><p>利用脚本 <code>&gt;1.log 2&gt;&amp;1</code> 将当前的 <code>pod lint</code> 产生的信息写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --sources&#x3D;****,**** --allow-warnings --verbose --use-libraries &gt;1.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CocoaPods简介&quot;&gt;&lt;a href=&quot;#CocoaPods简介&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods简介&quot;&gt;&lt;/a&gt;CocoaPods简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CocoaPods&lt;/code&gt; 是专门为 &lt;code&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 AutoreleasePool 的实现原理</title>
    <link href="https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2017-10-06T13:50:12.000Z</published>
    <updated>2022-01-09T11:51:07.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p><code>autorelease</code> 对象什么时候释放。</p><p><strong><code>autorelease</code> 的本质就是延迟调用 <code>release</code> 方法</strong></p><p>在 <code>MRC</code> 的环境下，可以通过调用 <code>[obj autorelease]</code> 将对象添加到当前的 <code>autoreleasepool</code> 中，来延迟释放内存； </p><p>在 <code>ARC</code>的环境下，当我们创建一个对象，可以通过 <code>__autoreleasing</code> 修饰符，会将对象添加到当前的 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p><p>注意：</p><ul><li><strong>编译器会检查方法名是否以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开始，如果不是则自动将返回值的对象注册到 <code>autoreleasepool</code> 中；</strong></li><li><strong>以 <code>__weak</code> 修饰的对象，会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong>调用 <code>Foundation</code> 对象的类方法(比如，<code>[NSMutableDictionary dictionary]</code>、<code>[NSArray array]</code> 等)会注册到 <code>autoreleasepool</code> 中。</strong></li><li><strong><code>id</code> 的指针或对象的指针在没有显式地指定修饰符时候，会被默认附加上 <code>__autoreleasing</code> 修饰符。</strong></li></ul><p>在没有手动加入 <code>autoreleasepool</code> 的情况下，<code>autorelease</code> 对象是在当前的 <code>runloop</code> 迭代结束时释放的，而它能够释放的原因是<strong>系统在每个 <code>runloop</code> 迭代中都加入了自动释放池 <code>push</code> 和 <code>pop</code></strong>。</p><p>当 <code>autoreleasepool</code> 销毁时，在调用堆栈中可以发现，系统调用了 <code>-[NSAutoreleasePool release]</code> 方法，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 <code>autoreleasepool</code> 中的 <code>autorelease</code> 对象执行 <code>release</code> 操作。</p><h1 id="AutoreleasePool-的实现原理"><a href="#AutoreleasePool-的实现原理" class="headerlink" title="AutoreleasePool 的实现原理"></a>AutoreleasePool 的实现原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>使用 <code>clang -rewrite-objc</code> 命令将下面的 <code>Objective-C</code> 代码重写成 <code>C++</code> 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br></pre></td></tr></table></figure><p>当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure><p>也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line">    void *atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#x2F;&#x2F; 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，单个 <code>autoreleasepool</code> 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code> 、<code>[obj release]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p><h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p><img src="588630-c77baf1ba3747632.png" alt="image.png"></p><p>从图中可以看出 </p><ul><li><code>AutoreleasePoolPage</code> 是由双向链表来实现的，<code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</li><li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整；</li><li><code>AutoreleasePool</code> 是按线程一一对应的，结构中的 <code>thread</code> 指针指向当前线程。</li><li><code>AutoreleasePoolPage</code> 会为每个对象会开辟 <code>4096</code> 字节内存。</li><li><code>id *next</code> 指向了下一个为空的内存地址(初始化为栈底)，如果有添加进来的 <code>autorelease</code> 对象，移动到下一个为空的内存地址中。</li></ul><p>如果 <code>AutoreleasePoolPage</code> 里面的 <code>autorelease</code> 对象满了，也就是 <code>id *next</code> 指针指向了栈顶，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来添加的 <code>autorelease</code> 对象在新的 <code>AutoreleasePoolPage</code> 加入，<code>id *next</code> 指针指向新的 <code>AutoreleasePoolPage</code> 为空的内存地址，即栈底。所以，向一个对象发送 <code>release</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的 <code>id *next</code> 指针指向的位置。</p><h3 id="POOL-SENTINEL-哨兵对象"><a href="#POOL-SENTINEL-哨兵对象" class="headerlink" title="POOL_SENTINEL(哨兵对象)"></a>POOL_SENTINEL(哨兵对象)</h3><p><img src="588630-8d76ce26495dfabd.png" alt="image.png"></p><p><strong><code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</strong></p><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>。</p><p>详细参考<a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">POOL_SENTINEL(哨兵对象)</a></p><h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h3><p><code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    if (UseGC) return nil;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码得出，每次执行 <code>objc_autoreleasePoolPush</code> 其实就是创建了一个新的 <code>autoreleasepool</code>，然后会把一个 <code>POOL_SENTINEL</code> <code>push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">    id *dest &#x3D; autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest &#x3D;&#x3D; POOL_SENTINEL);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数并传入哨兵对象  <code>POOL_SENTINEL</code> 来执行具体的插入操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full.</span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    assert(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    </span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; No pool in place.</span><br><span class="line">    assert(!hotPage());</span><br><span class="line">    </span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">                     (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push an autorelease pool boundary if it wasn&#39;t already requested.</span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p><ul><li>当前 <code>hotPage</code> 存在且没有满时，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 存在且已满时，调用 <code>autoreleaseFullPage</code> 初始化一个新的 <code>page</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li><li>当前 <code>hotPage</code> 不存在时，调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li></ul><h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><p>objc_autoreleasePoolPop(void *)函数本质上也是调用的AutoreleasePoolPage的pop函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    if (UseGC) return;</span><br><span class="line">    &#x2F;&#x2F; fixme rdar:&#x2F;&#x2F;9167170</span><br><span class="line">    if (!ctxt) return;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; pageForPointer(token);</span><br><span class="line">    id *stop &#x3D; (id *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    if (page-&gt;child) &#123;</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是<code>POOL_SENTINEL</code> 的内存地址。根据这个内存地址找到所在的 <code>AutoreleasePoolPage</code> 然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象。</p><p>总结：<br>每调用一次 <code>push</code> 操作就会创建一个新的 <code>autoreleasepool</code>，然后往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址.<br>在执行 <code>pop</code> 操作的时候传入 <code>POOL_SENTINEL</code>，根据传入的哨兵对象地址找到哨兵对象所处的 <code>page</code><br>在当前AutoreleasePoolPage中，然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象，并把 <code>id next</code> 指针到正确位置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试题：&quot;&gt;&lt;a href=&quot;#面试题：&quot; class=&quot;headerlink&quot; title=&quot;面试题：&quot;&gt;&lt;/a&gt;面试题：&lt;/h1&gt;&lt;p&gt;&lt;code&gt;autorelease&lt;/code&gt; 对象什么时候释放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;autore
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Object-C编码规范</title>
    <link href="https://sunjinshuai.github.io/2017/04/07/Object-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://sunjinshuai.github.io/2017/04/07/Object-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2017-04-07T09:24:55.000Z</published>
    <updated>2022-01-20T03:42:29.666Z</updated>
    
    <content type="html"><![CDATA[<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>1、任意函数长度不得超过50行。<br>2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。</p><p>3、在定义函数的行前留白一行。<br>4、功能相近的代码要放在一起。<br>5、使用#pragma来切分不同功能区域的代码。<br>6、二元运算符和参数之间需要放置一个空格，一元运算符、强制类型转换和参数之间不放置空格。关键字之后圆括号之前需要放置一个空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *ptr &#x3D; &amp;value + 10 * 3;</span><br><span class="line">NSString *str1 &#x3D; (NSString *)str2;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">[self doSomeThing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、长的字面值应被拆分为多行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSArray *theShit &#x3D; @[</span><br><span class="line">    @&quot;Got some long string objects in here.&quot;,</span><br><span class="line">    [AndSomeModelObjects too],</span><br><span class="line">    @&quot;Moar strings.&quot;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">NSDictionary *keyedShit &#x3D; @&#123;</span><br><span class="line">    @&quot;this.key&quot;: @&quot;corresponds to this value&quot;,</span><br><span class="line">    @&quot;otherKey&quot;: @&quot;remoteData.payload&quot;,</span><br><span class="line">    @&quot;some&quot;: @&quot;more&quot;,</span><br><span class="line">    @&quot;JSON&quot;: @&quot;keys&quot;,</span><br><span class="line">    @&quot;and&quot;: @&quot;stuff&quot;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名是编程中最基本的技能，我们给变量、函数、类、包等等命名。给他们以名字，让他们有意义，既能表示他们到底是做什么的，也能将其与其他变量区别开来。像人一样娶一个好名字至关重要，“丁当”总比“狗蛋”来的好听。 为什么要命名？ <strong>命名一定要“名副其实”，尽可能使用有意的名称，而且这个意义和指称的变量真实意义相关。</strong><br>1、基本原则<br>尽量不要出现没有任何意义的命名类似于下述形式的命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1;</span><br><span class="line">int b &#x3D; 3;</span><br><span class="line">CGPoint point &#x3D; CGPointMake(a,b);</span><br></pre></td></tr></table></figure><p>如果换成下面的形式是不是可读性强了很多：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int startX &#x3D; 1;</span><br><span class="line">int startY &#x3D; 3;</span><br><span class="line">CGPoint startPoint &#x3D; CGPointMake(startX,startY);</span><br></pre></td></tr></table></figure><p>命名首字母大写，其他命名首字母小写。并且采用驼峰格式分割单词。 例如：<code>FXTest</code><br>仿照 Cocoa 风格来，使用长命名风格。<br>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern ushort APIDefaultPageSize;        &#x2F;&#x2F; 还行，能明白意思了</span><br><span class="line">extern ushort APIDefaultFetchPageSize;   &#x2F;&#x2F; 加上些限定更好一些</span><br><span class="line">extern ushort APIFetchPageSizeDefault;   &#x2F;&#x2F; 再好些，把重要的往前放</span><br><span class="line">FXToolbarComment    &#x2F;&#x2F; 不推荐</span><br><span class="line">FXCommentToolbar    &#x2F;&#x2F; OK，把类型（toolbar）置后</span><br></pre></td></tr></table></figure><p>2、类别的扩展名以“被扩展的类名+自定义命名部分组成” 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSSstring+Utils.h</span><br></pre></td></tr></table></figure><p>3、通知命名<br>基本命名格式是：<code>与通知相关的类名</code> + <code>Did | Will</code> + <code>UniquePartOfName</code> + <code>Notification</code>，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSApplicationDidBecomeActiveNotification</span><br><span class="line">NSWindowDidMiniaturizeNotification</span><br><span class="line">NSTextViewDidChangeSelectionNotification</span><br><span class="line">NSColorPanelColorDidChangeNotification</span><br></pre></td></tr></table></figure><p>4、宏定义，全部字母大写，例如: <code>#define BW_DEBUG 1</code><br>5、常量定义，字符串定义以小写字母k开头，随后首字母大写，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static NSString* const kBWBarTitle &#x3D; @&quot;动态&quot;;</span><br></pre></td></tr></table></figure><p>ps：如果要定义常量使用static const优于宏定义，前者会进行类型检查。<br>6、缩略词，以下是一些常用的首字母缩略词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASCII,PDF,XML,HTML,URL,RTF,HTTP,TIFF,JPG,PNG,GIF,LZW,ROM,RGB,CMYK,MIDI,FTP</span><br></pre></td></tr></table></figure><p>7、命名空间，因为OC没有命名空间的概念，所以使用前两个或者多个字母来表示命名空间，例如<code>&quot;NSObject中的NS&quot;</code>，我们也使用自己的命名空间。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发现模块：DiscoverController，模块里面其他的控件或者model，DCModel，DCView</span><br><span class="line">个人中心模块：PersonalCenterViewController，模块里面其他的控件或者model，PCModel，PCView</span><br></pre></td></tr></table></figure><h4 id="点标记语法"><a href="#点标记语法" class="headerlink" title="点标记语法"></a>点标记语法</h4><p>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.backgroundColor &#x3D; [UIColor orangeColor];</span><br><span class="line">[UIApplication sharedApplication].delegate;</span><br></pre></td></tr></table></figure><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[view setBackgroundColor:[UIColor orangeColor]];</span><br><span class="line">UIApplication.sharedApplication.delegate;</span><br></pre></td></tr></table></figure><h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>1、方法命名尽可能清晰<br>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insertObject:atIndex:</span><br><span class="line">removeObjectAtIndex:</span><br><span class="line">removeObject:</span><br></pre></td></tr></table></figure><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert:at:</span><br><span class="line">remove:</span><br></pre></td></tr></table></figure><p>2、类方法声明在方法类型与返回类型之间要有空格。<br>推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)methodName:(NSString *)string;</span><br></pre></td></tr></table></figure><p>不推荐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)methodName:(NSString *)string;</span><br></pre></td></tr></table></figure><p>3、函数<br>(1)、调用时所有参数应该在同一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</span><br></pre></td></tr></table></figure><p>(2)、或者每行一个参数，以冒号对齐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1</span><br><span class="line">                   name:arg2</span><br><span class="line">                   error:arg3];</span><br></pre></td></tr></table></figure><p>对于参数过多的函数，尽量使用后面一种对其方式。<br>(3)、不要使用下面的缩进风格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2  &#x2F;&#x2F; some lines with &gt;1 arg</span><br><span class="line">              error:arg3];</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">               name:arg2 error:arg3];</span><br><span class="line">[myObject doFooWith:arg1</span><br><span class="line">          name:arg2  &#x2F;&#x2F; aligning keywords instead of colons</span><br><span class="line">          error:arg3];</span><br></pre></td></tr></table></figure><p>(4)、如果对传入参数进行数据保护尽量不要用<code>if(!objc)</code>，使用断言来处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)sendArgs:(NSDictionary*)args &#123;</span><br><span class="line">NSAssert(args, @&quot;args is nil&quot;);</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5)、方法参数名前一般使用的前缀包括“the”、“an”、“new”。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setTitle:(NSString *)aTitle;</span><br><span class="line">- (void)setName:(NSString *)newName;</span><br><span class="line">- (id)keyForOption:(CDCOption *)anOption</span><br><span class="line">- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;</span><br><span class="line">- (CDCEmail *)emailForRecipients: (NSArray *)theRecipients;</span><br></pre></td></tr></table></figure><p>4、方法名<br>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。<br>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。</p><ul><li><code>set</code> 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li><li><code>get</code> 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。<br>例：<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)name;</span><br><span class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</span><br><span class="line">- (NSSize)cellSize;</span><br><span class="line">- (void)setupControllerObservers;</span><br><span class="line">- (void)setupController;</span><br></pre></td></tr></table></figure>不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName;</span><br><span class="line">- (NSSize)calcCellSize;</span><br><span class="line">- (void)setController;</span><br></pre></td></tr></table></figure><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4>长的三元运算符应使用圆括号括起来。三元运算符仅用于赋值和做参数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *gender &#x3D; (stuff &#x3D;&#x3D; thing ? @&quot;男&quot; : @&quot;女&quot;);</span><br></pre></td></tr></table></figure>当有nil时的三元运算符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; thingThatCouldBeNil ? defaultValue : @&quot;&quot;;</span><br></pre></td></tr></table></figure>不推荐<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; thingThatCouldBeNil ?: defaultValue;</span><br></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4>当使用<code>enum</code>关键字时，推荐使用苹果最新引入的固定基础类型语法，因为这将获得强类型检查与代码完成功能。SDK现在包含了一个固定基础类型的宏—<code>NS_ENUM()</code>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, CertifiedModifyPassWordType)</span><br><span class="line">&#123;</span><br><span class="line">    CertifiedModifyPassWordTypeWithdrawals &#x3D; 1,  &#x2F;&#x2F; 提现</span><br><span class="line">    CertifiedModifyPassWordTypePaymentFail,  &#x2F;&#x2F; 支付失败</span><br><span class="line">    CertifiedModifyPassWordTypePayment, &#x2F;&#x2F; 支付</span><br><span class="line">    CertifiedModifyPassWordTypeOther</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4>因为nil被解析为了NO，所以和nil作比较没有任何的必要。不要将变量和YES直接比较，因为YES被定义为1而BOOL类型是8位的unsigned int，即BOOL的值不仅仅是1或0。<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!someObject) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (someObject &#x3D;&#x3D; nil) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (isAwesome)</span><br><span class="line">if (![someObject boolValue])</span><br></pre></td></tr></table></figure>不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ([someObject boolValue] &#x3D;&#x3D; NO)</span><br><span class="line">if (isAwesome &#x3D;&#x3D; YES) &#x2F;&#x2F; Never do this.</span><br></pre></td></tr></table></figure><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4>应该使用线程安全的模式创建共享的单例实例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">   static id sharedInstance &#x3D; nil;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">      sharedInstance &#x3D; [[self alloc] init];</span><br><span class="line">   &#125;);</span><br><span class="line">   return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>单例的另一种做法，利用+ initialize方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static JSONAPI* sharedInstance &#x3D; nil;</span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        sharedInstance &#x3D; [[JSONAPI alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Block相关"><a href="#Block相关" class="headerlink" title="Block相关"></a>Block相关</h4>在block中使用到self变量的时候，一定要先weak再strong。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">[self doABlockOperation:^&#123;</span><br><span class="line">    __strong typeof(weakSelf) strongSelf &#x3D; weakSelf;</span><br><span class="line">    if (strongSelf) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4>代理协议名，常用delegate、dateSource做结尾。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br></pre></td></tr></table></figure>以<code>did</code>、<code>will</code>、<code>should</code>等形容词，代表Event事件的Delegate<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)windowShouldClose:(id)sender;</span><br><span class="line">- (void)browserDidScroll:(NSBrowser *)sender;</span><br><span class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;</span><br></pre></td></tr></table></figure><h4 id="控制结构，if-else"><a href="#控制结构，if-else" class="headerlink" title="控制结构，if-else"></a>控制结构，if-else</h4>1、方法的花括号推荐另起一行。方法内部需要写在一行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)methodName:(NSString *)string &#123;</span><br><span class="line">    if () &#123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>2、条件判断的括号内侧不应有空格。<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (a &lt; b) &#123;</span><br><span class="line">    &#x2F;&#x2F; something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ( a &lt; b ) &#123;</span><br><span class="line">    &#x2F;&#x2F; something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3、关系运算符（如<code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如<code>&amp;&amp;</code>、<code>||</code>）两边要有空格。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(someValue &gt; 100) ? YES : NO</span><br></pre></td></tr></table></figure>二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。<br>多个参数逗号后留一个空格（这也符合正常的西文语法）。<br>4、当需要满足一定条件时才执行某项操作时，使用return是正常合理的。<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethod &#123;</span><br><span class="line">  if (![someOther boolValue]) &#123;</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;Do something important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!error) &#123;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>不推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)someMethod &#123;</span><br><span class="line">  if ([someOther boolValue]) &#123;</span><br><span class="line">      &#x2F;&#x2F;Do something important</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!error)</span><br><span class="line">    return success;</span><br><span class="line">...</span><br><span class="line">if (!error) return success;</span><br></pre></td></tr></table></figure><h4 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h4>UIView的子类初始化的时候，不要进行任何布局操作。布局操作在LayoutSubViews里面做。<br>UIView的子类布局必须在layoutSubViews里面进行，需要布局的时候调用setNeedLayout来告诉系统，需要重新布局该View，不要直接调用layoutSubViews。<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4>在类定义中使用到自己定义的类的时候，尽量不要在头文件中引入自己定义的类的同文件，使用@class替换。在实现文件中引入相应头文件。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BWTest.h</span><br><span class="line">@class BWDataCenter;</span><br><span class="line">@interface BWTest : NSObject</span><br><span class="line">@property (nonatomic, strong) BWDataCenter* dataCenter;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; BWTest.m</span><br><span class="line">#import &quot;BWDataCenter.h&quot;</span><br><span class="line">@implementation BWTest</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h4 id="项目工程文件"><a href="#项目工程文件" class="headerlink" title="项目工程文件"></a>项目工程文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - init Method</span><br><span class="line">填入init,initWithFrame等方法</span><br><span class="line">#pragma mark- View Life Cycle</span><br><span class="line">填入viewdidload,viewdidappear等方法</span><br><span class="line">#pragma mark- Delegate，DataSource, Callback Method</span><br><span class="line">填入tableview，scrollview等代理方法</span><br><span class="line">#pragma mark- Override Parent Methods</span><br><span class="line">填入updateViewConstraints,updateConstraint, prepareForSegue等方法</span><br><span class="line">#pragma mark- SubViews Configuration</span><br><span class="line">填入configureSubViews，configureTableView等方法，这里的方法在init方法或view life cycle被调用</span><br><span class="line">#pragma mark- Actions</span><br><span class="line">填入-(IBAction)action:(id)sender和[self addtarget:self action:@selector(action:)]动作指向的方法</span><br><span class="line">#pragma mark- Public Methods</span><br><span class="line">填入在.h外暴露的方法</span><br><span class="line">#pragma mark- Private Methods</span><br><span class="line">填入.m文件内部调用的方法</span><br><span class="line">#pragma mark- Getter Setter</span><br><span class="line">填入对@property初始化的方法</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h4&gt;&lt;p&gt;1、任意函数长度不得超过50行。&lt;br&gt;2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。&lt;/p&gt;
&lt;p&gt;3、在定义函数
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 Block 捕获外部变量和 __block 实现原理</title>
    <link href="https://sunjinshuai.github.io/2017/02/10/%E6%B5%85%E8%B0%88-Block-%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C-block-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2017/02/10/%E6%B5%85%E8%B0%88-Block-%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C-block-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2017-02-10T08:55:01.000Z</published>
    <updated>2022-02-13T02:30:45.285Z</updated>
    
    <content type="html"><![CDATA[<p><img src="588630-08c2619e323632fa.png" alt="image.png"></p><p><code>block</code> 是 <code>C</code> 语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。<code>block</code> 在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它使用方法。</p><p>完整的 <code>block</code> 语法是如下形式：<br><code>block</code> 的声明格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^blockName)(参数列表);</span><br><span class="line">&#x2F;&#x2F; block的声明</span><br><span class="line">int (^sumblock)(int arg1, int arg2);</span><br><span class="line">void (^blockName)(int arg1, int arg2)</span><br></pre></td></tr></table></figure><p><code>block</code> 的定义格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^block变量名)(形参列表) &#x3D; ^(形参列表) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明并使用 <code>block</code><br>开发者使用 <code>^</code> 操作符声明 <code>block</code> 变量，<code>^</code> 表示是一个 <code>block</code> 的开始。<code>block</code> 的 <code>body</code> 体在 <code>{ }</code>之内。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int multiplier &#x3D; 7;</span><br><span class="line">int (^myblock)(int) &#x3D; ^(int num) &#123;</span><br><span class="line">  return num * multiplier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>block</code> 可以使用“在其定义作用范围内的”变量；如果你声明了一个 <code>block</code> 变量，可以像函数一样使用它。</p><h4 id="block的用法"><a href="#block的用法" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)() &#x3D; ^&#123;</span><br><span class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">blockName();</span><br></pre></td></tr></table></figure><p>有参数无返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)(int a, int b) &#x3D; ^(int a, int b) &#123;</span><br><span class="line">  NSLog(@&quot;%d + %d &#x3D; %d&quot;,a,b,a+b);</span><br><span class="line">&#125;;</span><br><span class="line">blockName(10,10);</span><br></pre></td></tr></table></figure><p>有参数有返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (^sumblock)(int a, int b) &#x3D; ^(int a, int b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">int sum &#x3D; sumblock(10,10);</span><br><span class="line">NSLog(@&quot;sum &#x3D; %d&quot;,sum);</span><br></pre></td></tr></table></figure><p><code>block</code> 结合 <code>typedef</code> 使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^sumblock)(int, int);</span><br><span class="line"></span><br><span class="line">interface ViewController ()</span><br><span class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  self.sumblock &#x3D; ^(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  NSLog(@&quot;sum &#x3D; %d&quot;,self.sumblock(10,10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="block-作为函数参数"><a href="#block-作为函数参数" class="headerlink" title="block 作为函数参数"></a><code>block</code> 作为函数参数</h4><p><code>block</code> 作为 <code>C</code> 函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的C函数</span><br><span class="line">void useblockForC(int(^ablock)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">useblockForC(addblock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">useblockForC(^(int x, int y) &#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>block</code> 作为 <code>OC</code> 函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的OC函数</span><br><span class="line">- (void)useblockForOC:(int(^)(int, int))ablock</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">[self useblockForOC:addblock];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">[self useblockForOC:^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>block</code> 是 <code>C</code> 语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。<code>block</code> 在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它使用方法。</p><p>完整的 <code>block</code> 语法是如下形式：<br><code>block</code> 的声明格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^blockName)(参数列表);</span><br><span class="line">&#x2F;&#x2F; block的声明</span><br><span class="line">int (^sumblock)(int arg1, int arg2);</span><br><span class="line">void (^blockName)(int arg1, int arg2)</span><br></pre></td></tr></table></figure><p><code>block</code> 的定义格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 (^block变量名)(形参列表) &#x3D; ^(形参列表) &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>声明并使用 <code>block</code><br>开发者使用 <code>^</code> 操作符声明 <code>block</code> 变量，<code>^</code> 表示是一个 <code>block</code> 的开始。<code>block</code> 的 <code>body</code> 体在 <code>{ }</code>之内。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int multiplier &#x3D; 7;</span><br><span class="line">int (^myblock)(int) &#x3D; ^(int num) &#123;</span><br><span class="line">  return num * multiplier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>block</code> 可以使用“在其定义作用范围内的”变量；如果你声明了一个 <code>block</code> 变量，可以像函数一样使用它。</p><h4 id="block的用法-1"><a href="#block的用法-1" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)() &#x3D; ^&#123;</span><br><span class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">blockName();</span><br></pre></td></tr></table></figure><p>有参数无返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (^blockName)(int a, int b) &#x3D; ^(int a, int b) &#123;</span><br><span class="line">  NSLog(@&quot;%d + %d &#x3D; %d&quot;,a,b,a+b);</span><br><span class="line">&#125;;</span><br><span class="line">blockName(10,10);</span><br></pre></td></tr></table></figure><p>有参数有返回值的 <code>block</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int (^sumblock)(int a, int b) &#x3D; ^(int a, int b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;;</span><br><span class="line">int sum &#x3D; sumblock(10,10);</span><br><span class="line">NSLog(@&quot;sum &#x3D; %d&quot;,sum);</span><br></pre></td></tr></table></figure><p><code>block</code> 结合 <code>typedef</code> 使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef int (^sumblock)(int, int);</span><br><span class="line"></span><br><span class="line">interface ViewController ()</span><br><span class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  self.sumblock &#x3D; ^(int a, int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">  NSLog(@&quot;sum &#x3D; %d&quot;,self.sumblock(10,10));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="block-作为函数参数-1"><a href="#block-作为函数参数-1" class="headerlink" title="block 作为函数参数"></a><code>block</code> 作为函数参数</h4><p><code>block</code> 作为 <code>C</code> 函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的C函数</span><br><span class="line">void useblockForC(int(^ablock)(int, int))</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">useblockForC(addblock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">useblockForC(^(int x, int y) &#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>block</code> 作为 <code>OC</code> 函数参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.定义一个形参为block的OC函数</span><br><span class="line">- (void)useblockForOC:(int(^)(int, int))ablock</span><br><span class="line">&#123;</span><br><span class="line">  NSLog(@&quot;result &#x3D; %d&quot;, ablock(300,200));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.声明并赋值定义一个block变量</span><br><span class="line">int(^addblock)(int, int) &#x3D; ^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.以block作为函数参数,把block像对象一样传递</span><br><span class="line">[self useblockForOC:addblock];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将第2点和第3点合并一起,以内联定义的block作为函数参数</span><br><span class="line">[self useblockForOC:^(int x, int y)&#123;</span><br><span class="line">  return x+y;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>通过下面几个例子，探讨 <code>block</code> 是如何实现的：</p><h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">  &#125;;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了研究编译器是如何实现 <code>block</code> 的，我们需要使用 <code>clang</code>。<code>clang</code> 提供一个命令，可以将 <code>Objetive-C</code> 的源码改写成 <code>c</code> 语言的，借此可以研究 <code>block</code> 具体的源码实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc block.c</span><br></pre></td></tr></table></figure><p>转化之后，生成 <code>block.app</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从结构体的命名可以看出这是 <code>block</code> 的实现，<code>block</code> 在 <code>clang</code> 编译器编译之后，生成了一个 <code>__block_impl</code> 结构体，<code>isa</code> 指针表明了 <code>block</code> 可以是一个对象，而 <code>FuncPtr</code> 指针显然是 <code>block</code> 对应的函数指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就具体看一下是如何实现的，<code>__main_block_impl_0</code> 就是该 <code>block</code> 的实现，从中我们可以看出：</p><ul><li><code>__main_block_impl_0</code> 中包含了两个成员变量和一个构造函数，成员变量分别是 <code>__block_impl</code> 结构体和描述信息 <code>__main_block_desc_0</code>，之后在构造函数中初始化 <code>block</code> 的类型信息和函数指针等信息。</li><li><code>__main_block_func_0</code> 函数，即 <code>block</code> 对应的函数体。该函数接受一个 <code>__cself</code> 参数，即对应的 <code>block</code> 自身。</li><li><code>__main_block_desc_0</code> 结构体，其中 <code>Block_size</code> 存储 <code>block</code> 大小。</li></ul><p>从上面代码，<strong>可以看出执行 <code>block</code>  就是调用一个以 <code>block</code>  自身作为参数的函数，这个函数对应着 <code>block</code>  的执行体</strong>。</p><h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><p><code>block</code> 如何捕获自动变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int i &#x3D; 1024;</span><br><span class="line">  void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">    printf(&quot;%d&quot;,i);</span><br><span class="line">  &#125;;</span><br><span class="line">  blk();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过clang编译之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int i;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags&#x3D;0) : i(_i) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line">  printf(&quot;%d&quot;,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 1024;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果尝试修改局部变量，编译会报错：</p><p><img src="588630-121cf0b90c682d74.png" alt="图示"></p><p>在 <code>__main_block_impl_0</code> 中，可以看到自动变量 <code>i</code>，被 <code>block</code> 从外面捕获进来，成为 <code>__main_block_impl_0</code> 这个结构体的成员变量了。</p><p>接着看构造函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags&#x3D;0) : i(_i)</span><br></pre></td></tr></table></figure><p>这个构造函数中，自动变量被捕获为成员变量追加到了构造函数中。<br><code>block</code> 捕获外部变量仅仅只捕获 <code>block</code> 闭包里面会用到的值，其他用不到的值，它并不会去捕获。</p><p>我们注意到 <code>__main_block_func_0</code> 这个函数的实现，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line">  printf(&quot;%d&quot;,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，系统自动给我们加上的注释，<code>bound by copy</code>，自动变量 <code>i</code> 虽然被捕获进来了，但是是用 <code>__cself-&gt;i</code> 来访问的。<code>block</code> 仅仅捕获了 <code>i</code> 的值，并没有捕获 <code>i</code> 的内存地址。所以在 <code>__main_block_func_0</code> 这个函数中即使我们重写这个自动变量 <code>i</code> 的值，依旧没法去改变 <code>block</code> 外面自动变量<code>i</code> 的值。</p><p>编译器基于这一点，在编译的层面就防止开发者可能犯的错误，因为自动变量没法在 <code>block</code> 中改变外部变量的值，所以编译过程中就报编译错误，<strong>错误原因告诉我们变量不可赋值，也提醒我们要使用 <code>__block</code> 类型标识符。</strong>错误就是最开始的那张截图。</p><p>自动变量是以值传递方式传递到 <code>block</code> 的构造函数里面去的。<code>block</code> 只捕获 <code>block</code> 中会用到的变量。由于只捕获了自动变量的值，并非内存地址，所以 <code>block</code> 内部不能改变自动变量的值。</p><h4 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h4><p>静态局部变量是如何在 <code>__block</code> 执行体中被修改的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    static int i &#x3D; 10;</span><br><span class="line">    void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">        i &#x3D; 30;</span><br><span class="line">        printf(&quot;%d&quot;, i);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过clang编译之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int *i;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_i, int flags&#x3D;0) : i(_i) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by copy</span><br><span class="line"></span><br><span class="line">        (*i) &#x3D; 30;</span><br><span class="line">        printf(&quot;%d&quot;, (*i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    static int i &#x3D; 10;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;i));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>__main_block_impl_0</code> 中，可以看到静态变量 <code>i</code>，被 <code>block</code> 从外面捕获进来，成为 <code>__main_block_impl_0</code> 这个结构体的成员变量了。</p><p>接着看构造函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_i, int flags&#x3D;0) : i(_i)</span><br></pre></td></tr></table></figure><p>这个构造函数中，静态变量被捕获为成员变量追加到了构造函数中。<br><code>block</code> 捕获外部变量仅仅只捕获 <code>block</code> 闭包里面会用到的值，其他用不到的值，它并不会去捕获。<code>__main_block_impl_0</code> 结构体中成员 <code>i</code> 变成指针类型(<code>int *</code>)。 静态变量传递给 <code>block</code> 是内存地址值，所以能在 <code>block</code> 里面直接改变值。</p><p>当然，全局变量、静态全局变量都可以在 <code>block</code> 执行体内被修改。因为是全局的，作用域很广，所以 <code>block</code> 捕获了它们进去之后，<code>block</code> 结束之后，它们的值依旧可以得以保存下来。更准确地讲，<code>block</code> 可以修改它被调用(这里是 <code>__main_block_func_0</code> )时所处作用域内的变量。比如一个 <code>block</code> 作为成员变量时，它也可以访问同一个对象里的其它成员变量。</p><h4 id="例子4："><a href="#例子4：" class="headerlink" title="例子4："></a>例子4：</h4><p><code>__block</code> 类型变量是如何支持修改。<br><code>int</code> 类型变量加上<code>__block</code>指示符，使得变量 <code>i</code> 可以在 <code>block</code> 函数体中被修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __block int i &#x3D; 1024;</span><br><span class="line">    void (^blk)(void) &#x3D; ^&#123;</span><br><span class="line">        i &#x3D; 1023;</span><br><span class="line">        printf(&quot;%d&quot;,i);</span><br><span class="line">    &#125;;</span><br><span class="line">    blk();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>clang</code> 编译之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags&#x3D;0) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by ref</span><br><span class="line">  (i-&gt;__forwarding-&gt;i) &#x3D; 1023;</span><br><span class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i &#x3D; &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;;</span><br><span class="line">    void (*blk)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</span><br><span class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从中可以看出，多出了一个 <code>__Block_byref_i_0</code> 的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_i_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>__isa</code>：<code>isa</code> 指针。</li><li><code>__forwarding</code>：指向自身类型的 <code>__forwarding</code> 指针。</li><li><code>i</code>：用来存储使用到的局部变量 <code>i</code>。</li></ul><p><code>__main_block_impl_0</code> 对应的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags&#x3D;0) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i &#x3D; __cself-&gt;i; &#x2F;&#x2F; bound by ref</span><br><span class="line">  (i-&gt;__forwarding-&gt;i) &#x3D; 1023;</span><br><span class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__main_block_impl_0</code> 的成员变量 <code>i</code> 变成了 <code>__Block_byref_i_0*</code> 指针类型。</li><li><code>__Block_byref_i_0</code> 指针类型变量 <code>i</code>，通过其成员变量 <code>__forwarding</code> 指针来操作另一个成员变量。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__block int i &#x3D; 0;</span><br><span class="line">NSLog(@&quot;%p&quot;,&amp;i);</span><br><span class="line"></span><br><span class="line">void (^myBlock)(void) &#x3D; ^&#123;</span><br><span class="line">    i ++;</span><br><span class="line">    NSLog(@&quot;Block 里面的%p&quot;,&amp;i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,myBlock);</span><br><span class="line"></span><br><span class="line">myBlock();</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7ff7b6cb5cc0</span><br><span class="line">&lt;__NSMallocBlock__: 0x600003708c00&gt;</span><br><span class="line">Block 里面的0x60000392fb18</span><br></pre></td></tr></table></figure><p>发现打印出来的地址不一样，出现这个不同的原因在于这里把 <code>block</code> 拷贝到了堆上。<br>堆上的 <code>block</code> 会持有对象。我们把 <code>block</code> 通过 <code>copy</code> 到了堆上，堆上也会重新复制一份 <code>block</code>，并且该 <code>block</code> 也会继续持有该 <code>__block</code>。当 <code>block</code> 释放的时候， <code>__block</code> 没有被任何对象引用，也会被释放销毁。</p><p><code>__forwarding</code> 指针这里的作用就是针对堆的 <code>block</code>，把原来 <code>__forwarding</code> 指针指向自己，换成指向 <code>_NSConcreteMallocBlock</code> 上复制之后的 <code>__block</code> 自己。然后堆上的变量的 <code>__forwarding</code> 再指向自己。这样不管 <code>__block</code> 怎么复制到堆上，还是在栈上，都可以通过 <code>(i-&gt;__forwarding-&gt;i)</code> 来访问到变量值。</p><p><img src="6ebe4bab-0feb-4c5e-aec0-aecf1873cdee.png" alt="image.png"></p><p>查看 <code>__main_block_desc_0</code> 结构体，发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8&#x2F;*BLOCK_FIELD_IS_BYREF*&#x2F;);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>此时，<code>__main_block_desc_0</code> 多了两个成员函数：<code>copy</code> 和 <code>dispose</code>，分别指向 <code>__main_block_copy_0</code>和 <code>__main_block_dispose_0</code>。</p><p>当 <code>block</code> 从栈上被 <code>copy</code> 到堆上时，会调用 <code>__main_block_copy_0</code> 将 <code>__block</code> 类型的成员变量 <code>i</code> 从栈上复制到堆上；而当 <code>block</code> 被释放时，相应地会调用 <code>__main_block_dispose_0</code> 来释放 <code>__block</code> 类型的成员变量 <code>i</code>。如果栈上和堆上同时对该变量进行操作，<code>__forwarding</code> 的作用就体现出来了，当一个 <code>__block</code> 变量从栈上被复制到堆上时，栈上的那个 <code>__Block_byref_i_0</code> 结构体中的 <code>__forwarding</code> 指针也会指向堆上的结构。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于非对象的变量来说，</p><ul><li>自动变量的值，被 <code>copy</code> 进了 <code>block</code>，不带 <code>__block</code> 的自动变量只能在里面被访问，并不能改变值。</li><li>带 <code>__block</code> 的自动变量和静态变量就是直接地址访问。所以在 <code>block</code> 里面可以直接改变变量的值。</li><li>而剩下的静态全局变量，全局变量，函数参数，也是可以在直接在<code>block</code> 中改变变量值的，但是他们并没有变成 <code>block</code> 结构体 <code>__main_block_impl_0</code> 的成员变量，因为他们的作用域大，所以可以直接更改他们的值。</li></ul><p>值得注意的是，静态全局变量，全局变量，函数参数他们并不会被 <code>block</code> 持有，也就是说不会增加 <code>retainCount</code> 值。</p><p>对于对象来说，<br>对于声明为 <code>__block</code> 的外部对象，在 <code>block</code> 内部会进行 <code>retain</code>，以至于在 <code>block</code> 环境内能安全的引用外部对象。对于没有声明 <code>__block</code> 的外部对象，在 <code>block</code> 中也会被 <code>retain</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;588630-08c2619e323632fa.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;block&lt;/code&gt; 是 &lt;code&gt;C&lt;/code&gt; 语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。&lt;code&gt;bl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>对称加密与非对称加密</title>
    <link href="https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/"/>
    <id>https://sunjinshuai.github.io/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/</id>
    <published>2016-09-23T14:21:21.000Z</published>
    <updated>2022-01-02T12:43:20.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>加密 <code>encryption</code> 与解密 <code>decryption</code> 使用的是同样的密钥 <code>secret key</code>，对称加密是最快速、最简单的一种加密方式。加密和解密算法是公开的，秘钥必须严格保存，如果秘钥泄露，别人就能够用密文+秘钥还原成你的明文。<br>对称加密有很多种算法，由于它效率很高，所以被广泛使用在很多加密协议的核心当中。<br>对称加密通常使用的是相对较小的密钥，一般小于 <code>256bit</code>。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用 <code>1bit</code> 来做这个密钥，那黑客们可以先试着用 <code>0</code> 来解密，不行的话就再用 <code>1</code> 解；但如果你的密钥有 <code>1MB</code> 大，黑客们可能永远也无法破解，但加密和解密的过程要花费很长的时间。</p><h1 id="For-Example"><a href="#For-Example" class="headerlink" title="For Example"></a>For Example</h1><p>比如常见的 <code>DES/AES</code> 都是属于对称加密算法。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>算法公开、计算量小、加密速度快、加密效率高。</p><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>秘钥的管理和分发非常困难，不够安全。在数据传送前，发送方和接收方必须商定好秘钥，然后双方都必须要保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了。</p><h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（简称公钥）和私有密钥（简称私钥），即常说的“公钥加密，私钥加密”或“私钥加密，公钥加密”。<br>私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。<br>非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</p><h1 id="For-Example-1"><a href="#For-Example-1" class="headerlink" title="For Example"></a>For Example</h1><p><code>RSA</code> 就是最常用的非对称加密算法。<br>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。<br>与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</p><p>虽然非对称加密很安全，但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><h1 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h1><p>安全性更高，公钥是公开的，秘钥是自己保存的，不需要将私钥给别人。</p><h1 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h1><p>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。<br>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。<br>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对称加密&quot;&gt;&lt;a href=&quot;#对称加密&quot; class=&quot;headerlink&quot; title=&quot;对称加密&quot;&gt;&lt;/a&gt;对称加密&lt;/h1&gt;&lt;p&gt;加密 &lt;code&gt;encryption&lt;/code&gt; 与解密 &lt;code&gt;decryption&lt;/code&gt; 使用的是同样的
      
    
    </summary>
    
    
    
      <category term="http" scheme="https://sunjinshuai.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>iOS如何使用TestFlight进行App-Beta版测试</title>
    <link href="https://sunjinshuai.github.io/2016/07/25/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8TestFlight%E8%BF%9B%E8%A1%8CApp-Beta%E7%89%88%E6%B5%8B%E8%AF%95/"/>
    <id>https://sunjinshuai.github.io/2016/07/25/iOS%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8TestFlight%E8%BF%9B%E8%A1%8CApp-Beta%E7%89%88%E6%B5%8B%E8%AF%95/</id>
    <published>2016-07-25T07:36:52.000Z</published>
    <updated>2022-03-20T08:59:17.797Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <code>2014 WWDC</code>中库克用了 <code>20</code> 秒的时间，简短的 <code>3</code> 句话，介绍了测试版本的 <code>TestFlight</code> 服务。<code>TestFlight</code> 用于将 <code>Beta</code> 版测试，<code>TestFlight</code> 已经被苹果收购，所以不要担心存在第三方测试造成数据泄露问题。<code>TestFlight</code> 需要 <code>iOS8</code> 及以上版本的 <code>iOS</code> 设备才能运行，所以 <code>iOS7</code> 及之前的设备就不能安装了。<code>TestFlight</code> 整合进了 <code>iTunes Connect</code>，开发者可以通过电子邮件来邀请测试员来进行测试，这样开发者就可以更简单地让你的同行非同行、你的上级、你的客户、你所想要一起参与测试的人一起来测试应用。</p></blockquote><p><code>TestFlight</code> 的测试方式分为两种：<br>一种是内部测试；<br>一种是外部测试。<br>从功能上讲，这两种方式都可以为测试人员在测试阶段对你的 <code>App</code> 进行测试。但是既然分了内部测试和外部测试，他们肯定还是有区别的，所谓的内部主要是指 <code>iTunes Connect</code> 上在你的开发团队里参与技术开发或者管理的成员。最多可以邀请 <code>25</code> 个内部成员，而与之相对的外部测试，指的是那些不属于你的团队或者公司的测试者，外部测试人员的上限是 <code>2000</code> 人。这里有一点需要注意的是，在你邀请外部成员参与测试之前，需要先通过苹果的审核，一般审核会在一天左右。而这一限制在内部成员上就没有，也就是说只要你把你的 <code>App</code> 上传到 <code>iTunes Connect</code> 上之后内部成员就可以开始进行内部测试了，无需审核。在邀请发出后，有效测试时间为 <code>60</code> 天。</p><p>ps：</p><ul><li>现在公司也有使用比较老的测试方法，就是需要提供参与 <code>app</code> 测试人员的设备 <code>UDID</code>，并且开发者需要将这些设备的 <code>UDID</code> 添加到开发者中心，每次有新的测试人员加入，需要重新生成 <code>profiles</code>，重新打包，最可恶的是，只能添加 <code>100</code> 台设备的限制，总体来说，比较笨拙。</li><li>使用 <code>TestFlight</code> 测试的好处，只需要参与 <code>app</code> 测试人员提供一个邮箱，开发者登录 <code>iTunes Connect</code>，给测试者发送邀请，测试者接受邀请，然后通过 <code>TestFlight</code>，下载安装程序。不需要用户提供设备的 <code>UDID</code>，最重要的一点是没有了 <code>100</code> 台设备的限制，一般内部测试人员最多 <code>25</code> 个人，外部测试人员最多 <code>2000</code> 个人，重点是<strong>不需要重新配置证书了，也不需要手动发送ipa包, 直接上传到iTunes即可。</strong></li><li>然而，也有其他公司在使用<strong>蒲公英</strong>等其他参与测试。</li></ul><p>接下来介绍一下 <code>TestFlight</code> 如何使用：<br>一、开发者需要做的事情<br>1、进入网址：<a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">https://itunesconnect.apple.com</a> 输入账号密码登录iTunes Connect。</p><p><img src="588630-d0d42f7c24a66747.png" alt="Paste_Image.png"></p><p>2、成功登录 <code>iTunes Connect</code>，点击我的 <code>App</code>，进入 <code>App</code> 列表页</p><p><img src="588630-3a15357b0b178e17.png" alt="Paste_Image.png"></p><p>ps：如果是初次创建的 <code>App</code>，需要创建一个 <code>iTunes Connect Record</code>。如果你的 <code>App</code> 已经创建好了，可以直接跳过这段，如果你要新建一个 <code>App</code> 的话，可以按照下面的步骤来做：<br>(1)、登录 <a href="https://itunesconnect.apple.com/" target="_blank" rel="noopener">iTunes Connect</a> 。<br>(2)、在 <code>iTunes Connect</code> 的首页，点击 <code>My Apps</code> 图标。<br>(3)、开发者第一次进到这里的时候，这里是个空白页。点击左上角的 <code>+</code> 号按钮，创建一个新的 <code>App</code> 。在你创建了 <code>App</code> 之后，这里会显示你创建的 <code>App</code> 列表。</p><p><img src="588630-324b5bd0e6da761e.png" alt="Paste_Image.png"><br>(4)、选择 <code>New App</code>。如果你只是 <code>iOS</code> 平台的开发者，这里不会出现其它的选项（如 <code>New Mac App</code>）。<br><img src="588630-b765eb059e0765b1.png" alt="Paste_Image.png"></p><p>(5)、填写好如下弹窗内的信息，点击 <code>Create</code> 按钮完成创建。<br><img src="588630-cdb50ee8226a431c.png" alt="Paste_Image.png"></p><p>(6)、对于一些必填信息，如果未填写的话，<code>Apple</code> 会在对话框内给出如下提示：<br><img src="588630-8441b12a4c4fc269.png" alt="Paste_Image.png"></p><p>(7)、提交 <code>App</code> 到 <code>iTunes connect</code>。<br>在 <code>Xcode</code> 中配置好版本和证书信息。<br>选中菜单 <code>Product-&gt;Archive</code> 将当前代码归档，归档完成后会弹出 <code>Organizer-Archives</code> 对话框。<br>选择 <code>Validate</code> 按钮来检测该归档文件是否符合要求。<br>验证通过之后，你可以选择 <code>Submit</code> 来提交这个归档。</p><p>3、每当你提交一个新的 <code>build</code> 之后，在 <code>iTunes Connect</code> 的列表中都会对应的增加一个 <code>build</code>。</p><p><img src="588630-bfc014c670aafbfe.png" alt="Paste_Image.png"></p><p>选择 <code>TestFlight</code>，在 <code>TestFlight</code> 中填写基本信息接收反馈的邮箱地址，隐私政策网址等。<br><img src="588630-f676a25c7fd7bc87.png" alt="Paste_Image.png"></p><p><img src="588630-522b9923482121e4.png" alt="Paste_Image.png"></p><p>Internal Testing：内部测试<br>External Testing：外部测试</p><p>4、邀请测试人员<br>(1)、内部测试：<br>点击 <code>Internal Testers</code>，添加测试人员（一般内部测试人员最多 <code>25</code> 个人）<br><img src="588630-e792c8a83d99af90.png" alt="Paste_Image.png"></p><p><img src="588630-9c450935e43edb0c.png" alt="Paste_Image.png"></p><p><img src="588630-c12a6503a5d4eacb.webp" alt="Paste_Image.png"></p><p>点击 <code>Select Version to Test</code>，添加测试版本</p><p><img src="588630-e00c5dc3a31901cb.webp" alt="Paste_Image.png"></p><p>选中一个版本，点击 <code>OK</code><br><img src="588630-cdddd120c80789a3.webp" alt="Paste_Image.png"></p><p>点击 <code>save</code><br><img src="588630-07a4d53be2fff9e4.webp" alt="Paste_Image.png"></p><p>点击 <code>Start Testing</code> ，之后会收到两封邮件，一封是邀请你加入测试组的邮件，点击同意即可，另一封是成功加入测试组的通知，点击 <code>start testing</code> 然后跳转到有加粗黑色字体的 <code>8</code> 个字母测试码的页面，下载 <code>TestFlight</code>，然后点击 <code>Redeem</code>，输入这 <code>8</code> 个字母即可下载测试 <code>app</code>。<br><img src="588630-1b81492cfbfc589b.webp" alt="Paste_Image.png"></p><p>点击 <code>Start Testing</code><br><img src="588630-7f7cd7f40baf351a.webp" alt="Paste_Image.png"></p><p><img src="588630-6422ededb401b461.webp" alt="Paste_Image.png"></p><p>(2)、邀请外部测试人员</p><p><img src="588630-0d2cfd6707968216.webp" alt="Paste_Image.png"></p><p>点击 <code>External Testers</code>，选择添加新测试员，或者使用 <code>CSV</code> 批量导入邀请外部测试人员。</p><p><img src="588630-d72551364e933a3f.webp" alt="Paste_Image.png"></p><p>输入电子邮件，名称和姓氏可不填，点击添加。</p><p><img src="588630-7eb69aa72f5ee8b4.webp" alt="Paste_Image.png"></p><p>点击 <code>Add Build to Test</code>，添加测试版本<br><img src="588630-d3248e7c4e3cd6ed.webp" alt="Paste_Image.png"></p><p>点击 <code>Next</code>，进入下一步</p><p><img src="588630-1fd8e33ec43f5002.webp" alt="Paste_Image.png"></p><p>填写测试版本的一些信息，点击 <code>Next</code>，进入下一步</p><p><img src="588630-fb68d9814e468bd9.webp" alt="Paste_Image.png"></p><p>填写联系人信息，和 <code>Beta App Review</code> 审核的测试账号，点击 <code>Next</code>，进入下一步</p><p><img src="588630-a32b330437707eb5.webp" alt="Paste_Image.png"></p><p>填写审核信息，然后点击 <code>submit</code>，提交 <code>Beta</code> 审核，目前来看，<code>Beta</code> 审核还是比较快速的，有时候一个工作日就可以通过审核。可能是现在使用 <code>TestFlight</code> 功能的 <code>App</code> 还不太多吧；不知道等 <code>TestFlight</code> 普及之后，随着参与 <code>Beta Review</code> 的 <code>App</code> 越来越多，<code>Beta</code> 审核还能不能一直这么快。<br><img src="588630-ec3355742ea75e1b.webp" alt="Paste_Image.png"></p><p>ps：还需要一提的是，外部测试人员想要参与测试的话，必须要 <code>App</code> 已经通过了 <code>Beta App Review</code> 才行。审核通过，点击 <code>Invite</code> 邀请按钮，测试者会收到来自 <code>TestFlight Beta Testing</code> 的邀请邮件。</p><p>二、开发者需要做的事情<br>1、在 <code>AppStore</code> 上面搜索 <code>TestFlight</code></p><p><img src="588630-db631f95c1a976ba.webp" alt="41B2276FCDA83285299E76566F7CC7A7.png"></p><p>2、下载 <code>TestFlight</code></p><p><img src="588630-fe71259698ee2c8d.webp" alt="F258A6014C8A0B15D16866DDF08EDE25.png"></p><p>3、打开 <code>TestFligh</code> 进行使用</p><p><img src="588630-10ed12e23ed2eca0.webp" alt="%PIDKXC5O`C%1857`2ZK6W2.jpg"></p><p>ps：<br>(1)、应用提示是否允许“推送通知”，一般是允许的，提醒测试新版本；<br>(2)、这时候 <code>TestFlight</code> 内是没什么内容可看的；<br>(3)、等待开发者邀请测试。（注意查看关联 <code>Apple ID</code> 邮箱的邮件，2封邮件）</p><p>4、接受邀请 <code>iTunes Connect</code></p><p><img src="588630-a4438f414d93e4a7.webp" alt="Paste_Image.png"></p><p>ps：<br>(1)、打开邮箱邮件（电脑和手机操作都可以）；<br>(2)、点击邮件详情里面的 <code>activate your access</code>，跳转到 <code>iTunes Connect</code> 登录页；<br>(3)、登录 <code>Apple ID</code> 账户，按提示勾选同意协议接受邀请。<br>(4)、这是第一封邮件，只有邀请加入开发者用户才会收到。只需要接受一次即可。</p><p><img src="588630-df30a089b79a2f60.webp" alt="Paste_Image.png"></p><p><img src="588630-83424a0311c0efe9.webp" alt="Paste_Image.png"></p><p>5、接受 <code>TestFlight</code> 测试邀请<br>(1)、打开邮箱邮件（电脑和手机操作都可以，推荐手机操作。）；<br>(2)、点击邮件详情里面的 <code>Start Testing</code>；<br>(3)、打开 <code>TestFlight</code>（手机操作第 <code>2</code> 步会自动打开 <code>TestFlight</code>）；<br>(4)、在 <code>TestFlight</code> 显示 <code>App</code> 信息，可以接收测试邀请 <code>Accept</code>。<br>ps：这是第二封邮件，只有邀请加入应用测试的才会收到。只需要接受一次即可。</p><p>电脑操作要有这3步：<br>(1)、Get TestFlight from the App Store<br>（翻译：到 <code>App Store</code> 下载 <code>TestFlight</code>）<br>(2)、Open TestFlight and choose Redeem<br>（翻译：打开 <code>TestFlight</code> 选择 <code>Redeem</code>）<br>(3)、Enter xxxxxx and start testing<br>（翻译：输入验证码，然后开始测试）<br><img src="588630-0967f2e584c09c0e.webp" alt="7A7E0DE90230E930E93080D40EE3C3A3.png"></p><p><img src="588630-f381eb579aeee04b.webp" alt="56CDFF1CE801FA37ECF0948087D22CED.png"></p><p>6、打开 <code>TestFlight</code>，输入验证码，<code>Install</code> 应用。</p><p><img src="588630-3437447b47192f1c.webp" alt="A278F5C094C8A1884412D4F2A6434144.png"></p><p><img src="588630-b09315536296849e.webp" alt="35585F326706916C0C05E3680BBEBCC6.png"></p><p><img src="588630-f9fbf90875f63578.webp" alt="B512850F08A6D399EE6E3DE7F5CF0F8E.png"></p><p>ps：安装完应用，会发现右侧有一个橘红色的点点。<br><img src="588630-f378d0d931119639.webp" alt="Paste_Image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在 &lt;code&gt;2014 WWDC&lt;/code&gt;中库克用了 &lt;code&gt;20&lt;/code&gt; 秒的时间，简短的 &lt;code&gt;3&lt;/code&gt; 句话，介绍了测试版本的 &lt;code&gt;TestFlight&lt;/code&gt; 服务。&lt;code&gt;TestFligh
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>iOS RunTime之一：简介</title>
    <link href="https://sunjinshuai.github.io/2016/06/10/iOS-RunTime%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%AE%80%E4%BB%8B/"/>
    <id>https://sunjinshuai.github.io/2016/06/10/iOS-RunTime%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%AE%80%E4%BB%8B/</id>
    <published>2016-06-10T14:56:47.000Z</published>
    <updated>2022-05-15T09:56:26.943Z</updated>
    
    <content type="html"><![CDATA[<p><code>Objective-C</code> 语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。<br><code>Objective-C</code> 是基于 <code>C</code> 语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要 <code>Runtime</code> 系统来动态创建类和对象，执行编译的代码，进行消息发送和转发。<br><code>Objective-C</code> 的 <code>Runtime</code> 其实是一个 <code>Runtime</code> 库，它基本上是用 <code>C</code> 和汇编写的，这个库使得 <code>C</code> 语言有了面向对象的能力。</p><p>下面通过分析 <a href="[https://github.com/iOS-Strikers/Runtime-723](https://github.com/iOS-Strikers/Runtime-723)">Apple开源的Runtime代码</a> 来深入理解 <code>Objective-C</code> 的 <code>Runtime</code> 机制。</p><p>初学 <code>Objective-C</code> 时，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[object doSomething]</span><br></pre></td></tr></table></figure><p>当成一个简单的方法调用，而无视了<strong>消息发送</strong>这句话的深刻含义，后来对 <code>Runtime</code> 的理解慢慢增加了，逐渐明白了<strong>消息发送</strong>的含义。</p><p>借助 <code>clang</code> 编译器，当执行 <code>[object doSomething]</code> 会被编译器转化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc xxx.m</span><br><span class="line">SEL doSomethingSel &#x3D; @selector(doSomething);</span><br><span class="line">objc_msgSend(object, doSomethingSel);</span><br></pre></td></tr></table></figure><p>打开 <code>objc_msgSend</code>，需要设置一下类型检查参数；<br><img src="588630-7c9f38bb73276434.png" alt="image.png"><br>无参数，则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure><p>如果消息含有参数，则为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure><p>如果消息的接收者能够找到对应的 <code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个 <code>selector</code> 对应的实现内容，要么就干脆玩完崩溃掉。</p><p>现在可以看出 <code>[object doSomething]</code> 不是一个简简单单的方法调用，因为这只是在编译阶段确定了要向接收者发送 <code>doSomething</code> 这条消息，而 <code>receive</code> 将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Objective-C&lt;/code&gt; 语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。&lt;br&gt;&lt;code&gt;Objective-C&lt;/code&gt; 是基于 &lt;code&gt;C&lt;/code&gt; 语言加入了面向对象特性和消息转发机制的动态语言，这
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[self class] 与 [super class]</title>
    <link href="https://sunjinshuai.github.io/2016/04/17/self-class-%E4%B8%8E-super-class/"/>
    <id>https://sunjinshuai.github.io/2016/04/17/self-class-%E4%B8%8E-super-class/</id>
    <published>2016-04-17T06:31:36.000Z</published>
    <updated>2022-01-09T12:46:51.069Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation Son : Father</span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果：</span><br><span class="line">2016-04-17 14:21:36.060 Test[8566:568584] NSStringFromClass([self class]) &#x3D; Son 2016-04-17 14:21:36.061 Test[8566:568584] NSStringFromClass([super class]) &#x3D; Son</span><br></pre></td></tr></table></figure><p><code>self</code> 是类的隐藏参数，指向当前调用方法的这个类的实例。<br><code>super</code> 是一个 <code>Magic Keyword</code>， 它本质是一个编译器标示符，和 <code>self</code> 是指向的同一个消息接受者。而不同的是，<code>super</code> 是告诉编译器，调用 <code>class</code> 这个方法时，要去父类的方法，而不是本类里的。</p><p>上面的demo中不管调用 <code>[self class]</code> 还是 <code>[super class]</code>，最终的接受消息的对象都是当前 <code>Son</code> 这个对象。</p><p>当使用 <code>self</code> 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；<br>当使用 <code>super</code> 时，则从父类的方法列表中开始找。</p><p>通过<code>clang</code>命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc test.m</span><br></pre></td></tr></table></figure><p><img src="588630-865511032a51310f.png" alt="image.png"></p><p>从上面的代码中，我们可以发现当在调用 <code>[self class]</code> 时，会转化成 <code>objc_msgSend</code> 方法。看下方法定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br></pre></td></tr></table></figure><p>而在调用 <code>[super class]</code> 时，会转化成 <code>objc_msgSendSuper</code> 方法。看下方法定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br></pre></td></tr></table></figure><p>查看 <code>objc_super</code> 结构体发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSendSuper(void &#x2F;* struct objc_super *super, SEL op, ... *&#x2F; )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; Specifies the superclass of an instance. </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies an instance of a class.</span><br><span class="line">    __unsafe_unretained id receiver;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; Specifies the particular superclass of the instance to message. </span><br><span class="line">#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span><br><span class="line">    &#x2F;* For compatibility with old objc-runtime.h header *&#x2F;</span><br><span class="line">    __unsafe_unretained Class class;</span><br><span class="line">#else</span><br><span class="line">    __unsafe_unretained Class super_class;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* super_class is the first class to search *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>objc_super</code> 结构体有两个成员：</p><ul><li>第一个成员是接收消息的 <code>receiver</code>, 类似于上面的 <code>objc_msgSend</code> 方法第一个参数 <code>self</code>。</li><li>第二个成员是当前类的父类 <code>super_class</code> 。</li></ul><p>所以，当调用 <code>[self class]</code> 时，实际先调用的是 <code>objc_msgSend</code> 方法，第一个参数是接收消息的 <code>receiver</code> 也就是 <code>Son</code> 当前的这个实例，然后在 <code>Son</code> 类的方法列表开始查找 <code>selector</code>，如果没有，则去父类的方法列表开始查找 <code>selector</code>，如果父类里面也没有，则会在 <code>NSObject</code> 查找方法列表开始查找 <code>selector</code>，找到后以 <code>self</code> 去调用父类的这个 <code>selector</code>。</p><p><code>objc Runtime</code> 开源代码对 <code>- (Class)class</code> 方法的实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (Class)class &#123;</span><br><span class="line">  return object_getClass(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>- (Class)class</code> 的实现就是返回 <code>self</code> 自己，故上述输出结果为 <code>Son</code>。</p><p>而当调用 <code>[super class]</code> 时，会转换成 <code>objc_msgSendSuper</code> 方法：</p><ul><li>从 <code>objc_super</code> 结构体指向的 <code>superClass</code> 父类的方法列表开始查找 <code>selector</code>，找到后以 <code>objc-&gt;receiver</code> 去调用父类的这个 <code>selector</code>。</li><li>由于找到了父类 <code>NSObject</code> 里面的 <code>class</code> 方法的 <code>IMP</code> ，又因为传入的入参 <code>objc_super-&gt;receiver</code> 指向 <code>self</code>。<code>self</code> 也就是 <code>Son</code> 当前的这个实例，所以父类的方法 <code>class</code> 执行 <code>IMP</code> 之后，输出还是 <code>Son</code>。<br>最后输出两个都一样，都是输出 <code>Son</code>。</li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/11/06/runtime-nuts/" target="_blank" rel="noopener">http://blog.sunnyxx.com/2014/11/06/runtime-nuts/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何使用hexo搭建个人博客</title>
    <link href="https://sunjinshuai.github.io/2016/03/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunjinshuai.github.io/2016/03/05/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2016-03-05T13:41:47.000Z</published>
    <updated>2022-01-02T12:41:21.729Z</updated>
    
    <content type="html"><![CDATA[<p>经过各种找资料，踩过何种坑，终于搭建好了 <code>hexo</code>，域名目前用得时 <code>github</code> 的，我的 <code>hexo</code> 是 <code>3.2.2</code> 版本，<code>hexo</code> 不同的版本，很多配置都不一样。好吧，废话不多说了，开始吧。</p><p>之前是想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点我们会使用，并不难，但是要做到让让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于 <code>CSDN</code>、博客园也都可以写文章，但是页面的样式我不是太喜欢，简书还算好点得。最近看到一些大神们的博客，貌似都是用 <code>hexo</code> 写得，我也依葫芦画瓢的搭建了一个。不罗嗦了，直接上搭建步骤。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>hexo</code>是一个<code>npm</code>包，在<code>node</code>环境上运行，功能就是将你的文章（<code>.md</code>文件）生成为静态<code>html</code>文件。</p><h4 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h4><p>下面正式开始搭建博客！首先要想使用 <code>Hexo</code> 和 <code>github pages</code> 搭建博客，需要以下环境：</p><ul><li>在 <code>github</code> 上注册一个账号，并创建一个指定名字的 <code>reposity</code></li><li><code>homebrew</code> 套件管理器，主要用来安装 <code>git</code> 和 <code>node.js</code></li><li><code>git</code> 版本管理工具</li><li><code>node.js</code></li><li>配置 <code>SSH key</code></li><li>安装 <code>hexo</code></li><li>同步 <code>hexo</code> 博客到 <code>github</code></li></ul><h5 id="注册Github账号并创建reposity"><a href="#注册Github账号并创建reposity" class="headerlink" title="注册Github账号并创建reposity"></a>注册Github账号并创建reposity</h5><p>申请完账号，登陆之后，就可以创建 <code>reposity</code> 了，点击 <code>New repository</code><br>，会跳转到这个界面: </p><p><img src="588630-c658dc0c9c467b19.png" alt="Paste_Image.png"></p><h5 id="安装brewhome"><a href="#安装brewhome" class="headerlink" title="安装brewhome"></a>安装brewhome</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.github.com&#x2F;Homebrew&#x2F;homebrew&#x2F;go&#x2F;install)”</span><br></pre></td></tr></table></figure><p>安装失败, 执行以下脚本卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot; </span><br><span class="line">报错：Failed to locate Homebrew!</span><br></pre></td></tr></table></figure><p>执行以下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;.git rm -rf Library .git .gitignore bin&#x2F;brew README.md share&#x2F;man&#x2F;man1&#x2F;brew rm -rf ~&#x2F;Library&#x2F;Caches&#x2F;Homebrew</span><br></pre></td></tr></table></figure><p>成功后，再次执行，下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><p>下载成功</p><h5 id="安装git版本管理工具"><a href="#安装git版本管理工具" class="headerlink" title="安装git版本管理工具"></a>安装git版本管理工具</h5><p><code>git</code> 是一个强大的版本管理工具，<code>github</code> 的版本管理就是基于 <code>git</code> 的，现在 <code>svn</code> 基本过时了，使用 <code>Git</code> 进行版本管理才是王道。安装完 <code>homebrew</code> 之后，安装 <code>Git</code> 几乎零成本，还是在 <code>terminal</code> 终端，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>然后等一段时间就 <code>ok</code> 了，<code>homebrew</code> 会自动去帮你完成下载安装。</p><h5 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h5><p><code>hexo</code> 是基于 <code>node.js</code> 的，所以要让 <code>hexo</code> 运行，<code>node.js</code> 环境是必不可少的。使用 <code>homebrew</code> 安装 <code>node.js</code> 也特别简单，在 <code>terminal</code> 终端输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>ps：安装最新版的 <code>Node.js</code> 之后，我们就可以使用 <code>npm</code> 命令，在 <code>mac</code> 下遇到 <code>npm</code> 命令找不到的问题，解决方案如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node &#x2F;usr&#x2F;lib&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node-waf &#x2F;usr&#x2F;bin&#x2F;node-waf</span><br></pre></td></tr></table></figure><h5 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h5><p>前面我们安装了 <code>node.js</code>，装完 <code>node.js</code> 之后，我们就可以使用 <code>npm</code> 命令了，而 <code>hexo</code> 安装就是使用 <code>npm</code>，在终端输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>ps：等待一会儿，<code>hexo</code> 会自动完成下载安装。等 <code>hexo</code> 安装完成之后，在创建一个文件夹，这个文件夹以后就是你存放本地博客的地方了。</p><h4 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h4><p>创建新建一个文件夹，用来存放本地博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><code>hexo</code>会在创建的文件夹创建本地博客所需的一切资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>访问本地localhost:4000可以看到博客已经搭建成功。</p><h4 id="同步hexo博客到github"><a href="#同步hexo博客到github" class="headerlink" title="同步hexo博客到github"></a>同步hexo博客到github</h4><ul><li>配置本地和<code>github</code>的<code>ssh</code></li><li>在<code>github</code>上创建名字为<code>XXX.github.io</code>的项目，<code>XXX</code>为自己的<code>github</code>用户名。</li><li>开本地的创建的文件夹中的<code>_config.yml</code>配置文件，将其中的<code>type</code>设置为<code>git</code>。</li></ul><h6 id="检查你电脑上现有的ssh-key"><a href="#检查你电脑上现有的ssh-key" class="headerlink" title="检查你电脑上现有的ssh key"></a>检查你电脑上现有的ssh key</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh   # 切换到ssh目录</span><br><span class="line">ls -al ~&#x2F;.ssh # 查看</span><br></pre></td></tr></table></figure><p>注意：<br>如果你本地没有生成的话，终端上面会显示，<code>No such file or directory</code>。说明你是第一次使用git，如果已经存在的话，则会显示<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h6 id="获取ssh"><a href="#获取ssh" class="headerlink" title="获取ssh"></a>获取ssh</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096</span><br></pre></td></tr></table></figure><h6 id="配置github的ssh"><a href="#配置github的ssh" class="headerlink" title="配置github的ssh"></a>配置github的ssh</h6><p>登陆<code>github</code>后，点击右上角自己的头像–&gt;点击Your profile–&gt;点击你的博客远程仓库，页面中就能找到ssh。</p><p><img src="588630-6e5f1d0d3daf4880.png" alt="Paste_Image.png"></p><h4 id="安装自动部署发布工具"><a href="#安装自动部署发布工具" class="headerlink" title="安装自动部署发布工具"></a>安装自动部署发布工具</h4><p>这里用到了 hexo-deployer-git，使用如下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h4 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo: https:&#x2F;&#x2F;github.com&#x2F;sunjinshuai&#x2F;sunjinshuai.github.com</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>在terminal终端，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate   &#x2F;&#x2F; 可以简写成hexo g 根据markdown文件生成静态文件</span><br><span class="line">hexo deploy     &#x2F;&#x2F; 或者简写成hexo d 将本地修改，部署到远端</span><br></pre></td></tr></table></figure><p>此时，打开浏览器，访问<a href="https://sunjinshuai.github.io">https://sunjinshuai.github.io</a> ，就可以看到你的博客。</p><h4 id="Hexo安装新主题apollo"><a href="#Hexo安装新主题apollo" class="headerlink" title="Hexo安装新主题apollo"></a>Hexo安装新主题apollo</h4><p>Hexo换皮肤还是比较简单的，既可以自己根据默认的主题来修改，也可以到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 上去找主题。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>github上的文档给出了详细的安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo init #blogname#</span><br><span class="line">cd #blogname#</span><br><span class="line">npm install</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;pinggod&#x2F;hexo-theme-apollo.git themes&#x2F;apollo</span><br></pre></td></tr></table></figure><h5 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h5><p>安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: apollo</span><br><span class="line"></span><br><span class="line"># 在归档页面显示所有文章</span><br><span class="line"># 需要上面安装的 hexo-generator-archive 插件支持</span><br><span class="line">archive_generator:</span><br><span class="line">per_page: 0</span><br><span class="line">yearly: false</span><br><span class="line">monthly: false</span><br><span class="line">daily: false</span><br></pre></td></tr></table></figure><h4 id="hexo常用的命令"><a href="#hexo常用的命令" class="headerlink" title="hexo常用的命令"></a>hexo常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo init       &#x2F;&#x2F;在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件</span><br><span class="line">hexo new “my new blog title”   &#x2F;&#x2F;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</span><br><span class="line">hexo clean      &#x2F;&#x2F; 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存</span><br><span class="line">hexo generate   &#x2F;&#x2F; 可以简写成hexo g 根据markdown文件生成静态文件</span><br><span class="line">hexo server     &#x2F;&#x2F; 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问</span><br><span class="line">hexo deploy     &#x2F;&#x2F; 或者简写成hexo d 将本地修改，部署到远端</span><br><span class="line">hexo version    &#x2F;&#x2F; 显示hexo版本</span><br></pre></td></tr></table></figure><h4 id="关于HEXO安装失败的解决方法"><a href="#关于HEXO安装失败的解决方法" class="headerlink" title="关于HEXO安装失败的解决方法"></a>关于HEXO安装失败的解决方法</h4><p>目前国内npm源有问题；所以键入如下代码即可安装成功:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">cnpm install hexo-cli -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过各种找资料，踩过何种坑，终于搭建好了 &lt;code&gt;hexo&lt;/code&gt;，域名目前用得时 &lt;code&gt;github&lt;/code&gt; 的，我的 &lt;code&gt;hexo&lt;/code&gt; 是 &lt;code&gt;3.2.2&lt;/code&gt; 版本，&lt;code&gt;hexo&lt;/code&gt; 不同的版本
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://sunjinshuai.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
