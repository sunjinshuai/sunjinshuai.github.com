<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈 AutoreleasePool 的实现原理 · 孙金帅的技术博客</title><meta name="description" content="浅谈 AutoreleasePool 的实现原理 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈 AutoreleasePool 的实现原理</h1><div class="post-info">2017年10月6日</div><div class="post-content"><h1 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h1><p><code>autorelease</code> 对象什么时候释放。</p>
<p><strong><code>autorelease</code> 的本质就是延迟调用 <code>release</code> 方法</strong></p>
<p>在 <code>MRC</code> 的环境下，可以通过调用 <code>[obj autorelease]</code> 将对象添加到当前的 <code>autoreleasepool</code> 中，来延迟释放内存； </p>
<p>在 <code>ARC</code>的环境下，当我们创建一个对象，可以通过 <code>__autoreleasing</code> 修饰符，会将对象添加到当前的 <code>autoreleasepool</code> 中，当 <code>autoreleasepool</code> 销毁时，会对 <code>autoreleasepool</code> 里面的所有对象做一次 <code>release</code> 操作。 </p>
<p>注意：</p>
<ul>
<li><strong>编译器会检查方法名是否以 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code> 开始，如果不是则自动将返回值的对象注册到 <code>autoreleasepool</code> 中；</strong></li>
<li><strong>以 <code>__weak</code> 修饰的对象，会注册到 <code>autoreleasepool</code> 中。</strong></li>
<li><strong>调用 <code>Foundation</code> 对象的类方法(比如，<code>[NSMutableDictionary dictionary]</code>、<code>[NSArray array]</code> 等)会注册到 <code>autoreleasepool</code> 中。</strong></li>
<li><strong><code>id</code> 的指针或对象的指针在没有显式地指定修饰符时候，会被默认附加上 <code>__autoreleasing</code> 修饰符。</strong></li>
</ul>
<p>在没有手动加入 <code>autoreleasepool</code> 的情况下，<code>autorelease</code> 对象是在当前的 <code>runloop</code> 迭代结束时释放的，而它能够释放的原因是<strong>系统在每个 <code>runloop</code> 迭代中都加入了自动释放池 <code>push</code> 和 <code>pop</code></strong>。</p>
<p>当 <code>autoreleasepool</code> 销毁时，在调用堆栈中可以发现，系统调用了 <code>-[NSAutoreleasePool release]</code> 方法，这个方法最终通过调用 <code>AutoreleasePoolPage::pop(void *)</code> 函数来负责对 <code>autoreleasepool</code> 中的 <code>autorelease</code> 对象执行 <code>release</code> 操作。</p>
<h1 id="AutoreleasePool-的实现原理"><a href="#AutoreleasePool-的实现原理" class="headerlink" title="AutoreleasePool 的实现原理"></a>AutoreleasePool 的实现原理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>使用 <code>clang -rewrite-objc</code> 命令将下面的 <code>Objective-C</code> 代码重写成 <code>C++</code> 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</span><br><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    &#x2F;* @autoreleasepool *&#x2F; &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br></pre></td></tr></table></figure>
<p>当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br></pre></td></tr></table></figure>
<p>也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* @autoreleasepool *&#x2F; &#123;</span><br><span class="line">    void *atautoreleasepoolobj &#x3D; objc_autoreleasePoolPush();</span><br><span class="line">    &#x2F;&#x2F; 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，单个 <code>autoreleasepool</code> 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code> 、<code>[obj release]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p>
<h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p><img src="588630-c77baf1ba3747632.png" alt="image.png"></p>
<p>从图中可以看出 </p>
<ul>
<li><code>AutoreleasePoolPage</code> 是由双向链表来实现的，<code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</li>
<li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整；</li>
<li><code>AutoreleasePool</code> 是按线程一一对应的，结构中的 <code>thread</code> 指针指向当前线程。</li>
<li><code>AutoreleasePoolPage</code> 会为每个对象会开辟 <code>4096</code> 字节内存。</li>
<li><code>id *next</code> 指向了下一个为空的内存地址(初始化为栈底)，如果有添加进来的 <code>autorelease</code> 对象，移动到下一个为空的内存地址中。</li>
</ul>
<p>如果 <code>AutoreleasePoolPage</code> 里面的 <code>autorelease</code> 对象满了，也就是 <code>id *next</code> 指针指向了栈顶，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来添加的 <code>autorelease</code> 对象在新的 <code>AutoreleasePoolPage</code> 加入，<code>id *next</code> 指针指向新的 <code>AutoreleasePoolPage</code> 为空的内存地址，即栈底。所以，向一个对象发送 <code>release</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的 <code>id *next</code> 指针指向的位置。</p>
<h3 id="POOL-SENTINEL-哨兵对象"><a href="#POOL-SENTINEL-哨兵对象" class="headerlink" title="POOL_SENTINEL(哨兵对象)"></a>POOL_SENTINEL(哨兵对象)</h3><p><img src="588630-8d76ce26495dfabd.png" alt="image.png"></p>
<p><strong><code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</strong></p>
<p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p>
<p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>。</p>
<p>详细参考<a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">POOL_SENTINEL(哨兵对象)</a></p>
<h3 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush</h3><p><code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void * objc_autoreleasePoolPush(void) &#123;</span><br><span class="line">    if (UseGC) return nil;</span><br><span class="line">    return AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据源码得出，每次执行 <code>objc_autoreleasePoolPush</code> 其实就是创建了一个新的 <code>autoreleasepool</code>，然后会把一个 <code>POOL_SENTINEL</code> <code>push</code> 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static inline void *push() &#123;</span><br><span class="line">    id *dest &#x3D; autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest &#x3D;&#x3D; POOL_SENTINEL);</span><br><span class="line">    return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数并传入哨兵对象  <code>POOL_SENTINEL</code> 来执行具体的插入操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">static inline id *autoreleaseFast(id obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; hotPage();</span><br><span class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        return page-&gt;add(obj);</span><br><span class="line">    &#125; else if (page) &#123;</span><br><span class="line">        return autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    &#x2F;&#x2F; The hot page is full.</span><br><span class="line">    &#x2F;&#x2F; Step to the next non-full page, adding a new page if necessary.</span><br><span class="line">    &#x2F;&#x2F; Then add the object to that page.</span><br><span class="line">    assert(page &#x3D;&#x3D; hotPage());</span><br><span class="line">    assert(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    do &#123;</span><br><span class="line">        if (page-&gt;child) page &#x3D; page-&gt;child;</span><br><span class="line">        else page &#x3D; new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; while (page-&gt;full());</span><br><span class="line">    </span><br><span class="line">    setHotPage(page);</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id *autoreleaseNoPage(id obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; No pool in place.</span><br><span class="line">    assert(!hotPage());</span><br><span class="line">    </span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        &#x2F;&#x2F; We are pushing an object with no pool in place,</span><br><span class="line">        &#x2F;&#x2F; and no-pool debugging was requested by environment.</span><br><span class="line">        _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot;</span><br><span class="line">                     &quot;autoreleased with no pool in place - &quot;</span><br><span class="line">                     &quot;just leaking - break on &quot;</span><br><span class="line">                     &quot;objc_autoreleaseNoPool() to debug&quot;,</span><br><span class="line">                     (void*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Install the first page.</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; new AutoreleasePoolPage(nil);</span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push an autorelease pool boundary if it wasn&#39;t already requested.</span><br><span class="line">    if (obj !&#x3D; POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Push the requested object.</span><br><span class="line">    return page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前 <code>hotPage</code> 存在且没有满时，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li>
<li>当前 <code>hotPage</code> 存在且已满时，调用 <code>autoreleaseFullPage</code> 初始化一个新的 <code>page</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li>
<li>当前 <code>hotPage</code> 不存在时，调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code>，调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中。</li>
</ul>
<h3 id="objc-autoreleasePoolPop"><a href="#objc-autoreleasePoolPop" class="headerlink" title="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop</h3><p>objc_autoreleasePoolPop(void *)函数本质上也是调用的AutoreleasePoolPage的pop函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void objc_autoreleasePoolPop(void *ctxt) &#123;</span><br><span class="line">    if (UseGC) return;</span><br><span class="line">    &#x2F;&#x2F; fixme rdar:&#x2F;&#x2F;9167170</span><br><span class="line">    if (!ctxt) return;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void pop(void *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page &#x3D; pageForPointer(token);</span><br><span class="line">    id *stop &#x3D; (id *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    if (page-&gt;child) &#123;</span><br><span class="line">        if (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; else if (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是<code>POOL_SENTINEL</code> 的内存地址。根据这个内存地址找到所在的 <code>AutoreleasePoolPage</code> 然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象。</p>
<p>总结：<br>每调用一次 <code>push</code> 操作就会创建一个新的 <code>autoreleasepool</code>，然后往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址.<br>在执行 <code>pop</code> 操作的时候传入 <code>POOL_SENTINEL</code>，根据传入的哨兵对象地址找到哨兵对象所处的 <code>page</code><br>在当前AutoreleasePoolPage中，然后使用 <code>objc_release</code> 释放 <code>POOL_SENTINEL</code> 指针之前的对象，并把 <code>id next</code> 指针到正确位置。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/02/13/%E6%B5%85%E8%B0%88-iOS-ARC-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="prev">上一篇</a><a href="/2016/09/23/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2017/10/06/浅谈-AutoreleasePool-的实现原理/';
var disqus_title = '浅谈 AutoreleasePool 的实现原理';
var disqus_url = 'https://sunjinshuai.github.io/2017/10/06/浅谈-AutoreleasePool-的实现原理/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>