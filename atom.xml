<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙金帅的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sunjinshuai.github.io/"/>
  <updated>2017-08-07T03:56:12.000Z</updated>
  <id>https://sunjinshuai.github.io/</id>
  
  <author>
    <name>sunjinshuai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS学习笔记 第4期(2017.05.03)</title>
    <link href="https://sunjinshuai.github.io/2017/05/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E6%9C%9F-2017-05-03/"/>
    <id>https://sunjinshuai.github.io/2017/05/03/iOS学习笔记-第4期-2017-05-03/</id>
    <published>2017-05-03T03:20:08.000Z</published>
    <updated>2017-08-07T03:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>僵尸对象（Zombie Objects）</li>
<li>使用Instruments检测僵尸对象</li>
</ul>
<h4 id="僵尸对象（Zombie-Objects）"><a href="#僵尸对象（Zombie-Objects）" class="headerlink" title="僵尸对象（Zombie Objects）"></a>僵尸对象（Zombie Objects）</h4><p>僵尸对象：已经被释放掉的对象。一般来说，访问已经释放的对象或向它发消息会引起错误。因为指针指向的内存块认为你无权访问或它无法执行该消息，这时候内核会抛出一个异常（EXC），表明你不能访问该存储区域（BAD ACCESS）（EXC_BAD_ACCESS类型错误）。</p>
<h5 id="使用NSZombieEnabled"><a href="#使用NSZombieEnabled" class="headerlink" title="使用NSZombieEnabled"></a>使用NSZombieEnabled</h5><p><code>Xcode</code>提供的<code>NSZombieEnabled</code>，通过生成僵尸对象来替换<code>dealloc</code>的实现，当对象引用计数为0的时候，将需要<code>dealloc</code>的对象转化为僵尸对象。如果之后再给这个僵尸对象发消息，则抛出异常。先选中<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; 勾选Zombie Objects</code>项，显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-458a48c7836e72d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>然后在<code>Product -&gt; Scheme -&gt; Edit Scheme -&gt; Arguments</code>设置<code>NSZombieEnabled</code>、<code>MallocStackLoggingNoCompact</code>两个变量，且值均为<code>YES</code>。显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-03f13097b02f4a8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>仅设置<code>Zombie Objects</code>的话，如果<code>Crash</code>发生在当前调用栈，系统可以把崩溃原因定位到具体代码中；但是如果<code>Crash</code>不是发生在当前调用栈，系统仅仅告知崩溃地址，所以我们需要添加变量<code>MallocStackLoggingNoCompact</code>，让<code>Xcode</code>记录每个地址<code>alloc</code>的历史，然后通过命令将地址还原出来。</li>
</ul>
<p><code>Xcode 7</code>之后使用<code>lldb</code>，使用命令<code>bt</code>来打印调用堆栈。下面是某<code>Crash</code>通过僵尸模式调试，使用<code>bt</code>查看的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f05a70070816a0a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>发版前要将僵尸对象检测这些设置都去掉，否则每次通过指针访问对象时，都去检查指针指向的对象是否为僵尸对象，这就影响效率了。</p>
<h4 id="使用Instruments检测僵尸对象"><a href="#使用Instruments检测僵尸对象" class="headerlink" title="使用Instruments检测僵尸对象"></a>使用Instruments检测僵尸对象</h4><p><code>Instruments</code>为我们提供了一个检测僵尸对象的工具：<code>Zombies</code>。使用这个工具时，将会自动开启<code>Enable Zombie Objects</code>模式，而不需要我们自己手动去设置。</p>
<p>我们以下图这段简单的代码为例，点击Product-&gt;Profile，启动Instrument。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">	// Do any additional setup after loading the view, typically from a nib.</div><div class="line"></div><div class="line">    __unsafe_unretained NSMutableArray *array = [[NSMutableArray alloc] init];</div><div class="line">    [array addObject:@&quot;1&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图所示，我们可以看到<code>&quot;Zombies&quot;</code>这个工具。基本操作和其它工具一样，启动后点击工具栏上的红色按钮来启动程序。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-7059c904039f8cb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>在程序运行期间，如果定位到僵尸对象，则会弹出一个提示对话框，如下图所示。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c1b6dc4cd52e00c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>我们可以点击对话框右侧的箭头来定位到具体的代码及调用栈，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4378fe75488a32bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>双击调用栈对应的方法后，还可以查看具体的代码，如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9f083fc18e1f88f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>不能使用<code>assgin</code>或<code>unsafe_unretained</code>修饰指向OC对象的指针<br><code>assgin</code>和<code>unsafe_unretained</code>表示不持对象，是弱引用。如果指针指向的对象被释放了，它们就变成了野指针，很有可能发生Crash。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;僵尸对象（Zombie Objects）&lt;/li&gt;
&lt;li&gt;使用Instruments检测僵尸对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;僵尸对象（Zombie-Objects）&quot;&gt;&lt;a href=&quot;#僵尸对象（Zom
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS之使用Cocoapods创建私有仓库</title>
    <link href="https://sunjinshuai.github.io/2017/03/18/iOS%E4%B9%8B%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://sunjinshuai.github.io/2017/03/18/iOS之使用Cocoapods创建私有仓库/</id>
    <published>2017-03-18T10:31:52.000Z</published>
    <updated>2017-07-19T02:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用CocoaPods创建，管理私有库"><a href="#使用CocoaPods创建，管理私有库" class="headerlink" title="使用CocoaPods创建，管理私有库"></a>使用<code>CocoaPods</code>创建，管理私有库</h4><p><code>Cocoapods</code>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，以及将自己的项目中的公共组件交由它去管理。</p>
<p>一般公司都会搭建自己的git服务器，在实战项目中，经常使用<code>Cocoapods</code>管理自己的私有库。</p>
<ul>
<li><code>git</code>仓库至少需要两个，一个用于管理私有库对应版本的<code>podspec</code>文件，一个用于存放私有库的源文件</li>
<li><p>查看现有的<code>podspec</code>源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="创建一个私有的podspec主要包括如下几步："><a href="#创建一个私有的podspec主要包括如下几步：" class="headerlink" title="创建一个私有的podspec主要包括如下几步："></a>创建一个私有的podspec主要包括如下几步：</h4><ul>
<li>创建一个私有的Spec Repo，用于管理私有库对应版本的<code>podspec</code>文件</li>
<li>创建pod私有库所需要的项目工程文件，并上传到私有库</li>
<li>创建pod所对应的podspec文件，并进行验证／测试</li>
<li>向私有的Spec Repo中提交podspec</li>
<li>使用pod库</li>
</ul>
<h4 id="创建一个私有的Spec-Repo"><a href="#创建一个私有的Spec-Repo" class="headerlink" title="创建一个私有的Spec Repo"></a>创建一个私有的Spec Repo</h4><ul>
<li>在自己公司的git服务器上创建<code>FXPodSpesc</code>仓库</li>
<li><p>将私有Spec Repo关联到本地</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add FXSpesc http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git</div></pre></td></tr></table></figure>
<p>  注意：<code>FXSpesc</code>这个名字可以随便起，不是一成不变的。</p>
</li>
<li><p>执行命令</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-fea0a6cfb3f66057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>注意：<code>master</code>是<code>CocoaPods</code>官方源，其他则是私有源。</p>
<h4 id="创建pod私有库所需要的项目工程"><a href="#创建pod私有库所需要的项目工程" class="headerlink" title="创建pod私有库所需要的项目工程"></a>创建pod私有库所需要的项目工程</h4><ul>
<li><p><code>pod</code>命令创建<br>  <code>pod lib create NAME</code> 根据提示输入<br><img src="http://upload-images.jianshu.io/upload_images/588630-2772aaef57e97937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>  例如：<br><img src="http://upload-images.jianshu.io/upload_images/588630-188456065c1b5877.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>手动创建Xcode工程(过于简单)</p>
</li>
</ul>
<h4 id="创建pod所对应的podspec文件，并进行验证／测试"><a href="#创建pod所对应的podspec文件，并进行验证／测试" class="headerlink" title="创建pod所对应的podspec文件，并进行验证／测试"></a>创建pod所对应的podspec文件，并进行验证／测试</h4><ul>
<li>如果用<code>pod</code>命令创建，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c11662a6bfecaa30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><p>如果手动创建Xcode，则需要创建<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 你项目工程文件</div><div class="line">pod spec create FXKit.podspec</div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>podspec</code>文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Pod::Spec.new do |s|</div><div class="line"></div><div class="line">  s.name         = &quot;FXKit&quot;</div><div class="line">  s.version      = &quot;0.0.1&quot;</div><div class="line">  s.summary      = &quot;FXKit，繁星优选私有库&quot;</div><div class="line">  s.description  = &lt;&lt;-DESC</div><div class="line">		   FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；FXKit，繁星优选私有库；</div><div class="line">                   DESC</div><div class="line"></div><div class="line">  s.homepage     = &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;</div><div class="line"></div><div class="line">  # s.license    = &quot;MIT (example)&quot;</div><div class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</div><div class="line">  s.author       = &#123; &quot;孙金帅&quot; =&gt; &quot;michael.sun@51fanxing.com&quot; &#125;</div><div class="line">  s.platform     = :ios</div><div class="line">  s.source       = &#123;</div><div class="line">	:git =&gt; &quot;http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git&quot;,</div><div class="line">	:tag =&gt; &quot;#&#123;s.version&#125;&quot;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  s.source_files = &apos;FXKit/**/*.&#123;h,m&#125;&apos;</div><div class="line"></div><div class="line">  # s.resource_bundles = &#123;</div><div class="line">  #   &apos;FXKit&apos; =&gt; [&apos;FXKit/Assets/*.png&apos;]</div><div class="line">  # &#125;</div><div class="line"></div><div class="line">  s.public_header_files = &apos;FXKit/**/*.h&apos;</div><div class="line">  s.frameworks = &apos;UIKit&apos;</div><div class="line">  # s.dependency &apos;AFNetworking&apos;, &apos;~&gt; 2.3&apos;</div><div class="line">end</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">s.name：私有库的名称，`pod search`搜索的关键词，注意这里一定要和`.podspec`的名称一样，否则报错。</div><div class="line">s.version：私有库的版本。</div><div class="line">s.ios.deployment_target：支持的pod最低版本。</div><div class="line">s.summary：私有库简介。</div><div class="line">s.description：私有库详细介绍。</div><div class="line">s.homepage：私有库在GitHub上的地址。</div><div class="line">s.license：开源协议。</div><div class="line">s.author：作者。</div><div class="line">s.social_media_url：社交网址，你的podspec发布成功后会@你</div><div class="line">s.source：私有库在GitHub上的地址和版本号。</div><div class="line">s.source_files：私有库对外共享的.h和.m文件。</div><div class="line">s.requires_arc：是否支持ARC。</div></pre></td></tr></table></figure></p>
<ul>
<li>commit项目工程的源文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add .</div><div class="line">git commit -m &quot;first commit&quot;</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/FXKitExampleDemo.git</div><div class="line">git push -u origin master</div><div class="line">git tag -m &quot;first release&quot; 0.0.1</div><div class="line">git push --tags     #推送tag到远端仓库</div></pre></td></tr></table></figure>
<ul>
<li>验证</li>
</ul>
<p><code>pod lib lint NAME.podspec</code> 如果依赖了私有源则需要添加<code>--sources</code>参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint FXKit.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-be4a246dcb7afe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>当看到<code>FXKit passed validation.</code>表示验证通过。</p>
<h4 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># pod repo push 本地名称(例如上面添加的FXSpesc) NAME.podspec</div><div class="line"># 如果依赖其他私有源 同样需要加上 --sources 参数</div><div class="line">pod repo push FXSpesc NAME.podspec --sources=http://michael@git.51fanxing.com:88/fxbest/ios/FXPodSpesc.git,https://github.com/CocoaPods/Specs.git --allow-warnings --use-libraries</div></pre></td></tr></table></figure>
<h4 id="使用pod库"><a href="#使用pod库" class="headerlink" title="使用pod库"></a>使用pod库</h4><p>提交成功后则可以使用<code>pod search</code>命令，如果搜索不到或者报错，删除下索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm ~/Library/Caches/CocoaPods/search_index.json</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-bb4cc9e42534806d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：由于使用了私有源，所以<code>podfile</code>也需要处理下。<br><img src="http://upload-images.jianshu.io/upload_images/588630-2b4412e8a7e4043c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;a href=&quot;#使用CocoaPods创建，管理私有库&quot; class=&quot;headerlink&quot; title=&quot;使用CocoaPods创建，管理私有库&quot;&gt;&lt;/a&gt;使用&lt;code&gt;CocoaPods&lt;/code&gt;创建，管理
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AutoreleasePool的实现原理</title>
    <link href="https://sunjinshuai.github.io/2016/10/06/AutoreleasePool%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2016/10/06/AutoreleasePool的实现原理/</id>
    <published>2016-10-06T06:32:16.000Z</published>
    <updated>2017-07-06T08:16:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试题：autorelease对象什么时候释放。"><a href="#面试题：autorelease对象什么时候释放。" class="headerlink" title="面试题：autorelease对象什么时候释放。"></a>面试题：autorelease对象什么时候释放。</h4><p>autorelease的本质就是延迟调用<code>release</code>方法，在MRC的环境下，可以通过调用<code>[obj autorelease]</code>来延迟释放内存，在ARC的环境下，当我们创建一个对象，会将对象添加到当前的<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时，会对<code>autoreleasepool</code>里面的所有对象做一次<code>release</code>操作。在没有手动加入<code>autoreleasepool</code>的情况下，<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池<code>push</code>和<code>pop</code>。</p>
<p>当<code>autoreleasepool</code>销毁时，在调用堆栈中可以发现，系统调用了<code>-[NSAutoreleasePool release]</code>方法，这个方法最终通过调用<code>AutoreleasePoolPage::pop(void *)</code>函数来负责对<code>autoreleasepool</code>中的<code>autorelease</code>对象执行<code>release</code>操作。</p>
<h4 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h4><p>我们打开<a href="http://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a> 的源码工程，在 NSObject.mm 文件的第 438-932 行可以找到<code>autoreleasepool</code>的实现源码。其实，<code>autoreleasepool</code>是没有单独的内存结构的，它是通过以<code>AutoreleasePoolPage</code>为结点的双向链表来实现的。</p>
<ul>
<li>每一个线程的<code>autoreleasepool</code>其实就是一个指针的堆栈，结构中的thread指针指向当前线程；</li>
<li>每一个指针代表一个需要<code>release</code>的对象或者<code>POOL_SENTINEL</code>（哨兵对象，代表一个<code>autoreleasepool</code>的边界）；</li>
<li>一个<code>pool token</code>指向<code>autoreleasepool</code>所对应的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>；</li>
</ul>
<p>一个空的<code>AutoreleasePoolPage</code>的内存结构如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/588630-f64cda7c9112e5ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><code>magic</code>用来校验<code>AutoreleasePoolPage</code>的结构是否完整；</li>
<li><code>next</code>指向最新添加的<code>autorelease</code>对象的下一个位置，初始化时指向 begin() ；</li>
<li><code>thread</code>指向当前线程；</li>
<li><code>parent</code>指向父结点，第一个结点的 parent 值为 nil ；</li>
<li><code>child</code>指向子结点，最后一个结点的 child 值为 nil ；</li>
<li><code>depth</code>代表深度，从 0 开始，往后递增 1；</li>
<li><code>hiwat</code>代表 high water mark 。</li>
</ul>
<p>当<code>AutoreleasePoolPage</code>里面的<code>autorelease</code>对象满了，也就是next指针指向了栈顶，会新建一个<code>AutoreleasePoolPage</code>对象，连接链表，后来的<code>autorelease</code>对象在新的<code>AutoreleasePoolPage</code>加入，新<code>AutoreleasePoolPage</code>的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。<br>另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。<br>所以，向一个对象发送<code>release</code>消息，就是将这个对象加入到当前<code>AutoreleasePoolPage</code>的栈顶next指针指向的位置。</p>
<h4 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="autoreleasepool"></a><code>autoreleasepool</code></h4><p>使用<code>clang -rewrite-objc</code>命令将下面的 Objective-C 代码重写成 C++ 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; __declspec(dllimport) void * objc_autoreleasePoolPush(void);</div><div class="line">extern &quot;C&quot; __declspec(dllimport) void objc_autoreleasePoolPop(void *);</div><div class="line"></div><div class="line">struct __AtAutoreleasePool &#123;</div><div class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</div><div class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</div><div class="line">  void * atautoreleasepoolobj;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">#define __OFFSETOFIVAR__(TYPE, MEMBER) ((long long) &amp;((TYPE *)0)-&gt;MEMBER)</div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个<code>__AtAutoreleasePool</code>类型的局部变量<code>__autoreleasepool</code>来实现<code>@autoreleasepool {}</code>。当声明<code>__autoreleasepool</code>变量时，构造函数<code>__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p>当出了当前作用域时，析构函数<code>~__AtAutoreleasePool()</code>被调用，即执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure></p>
<p>也就是说<code>@autoreleasepool {}</code>的实现代码可以进一步简化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* @autoreleasepool */ &#123;</div><div class="line">    void *atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">    // 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 autoreleasepool 中</div><div class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，单个<code>autoreleasepool</code>的运行过程可以简单地理解为<code>objc_autoreleasePoolPush()</code>、<code>[obj release]</code>和<code>objc_autoreleasePoolPop(void *)</code>三个过程。</p>
<h4 id="objc-autoreleasePoolPush"><a href="#objc-autoreleasePoolPush" class="headerlink" title="objc_autoreleasePoolPush()"></a>objc_autoreleasePoolPush()</h4><p>上面提到的<code>objc_autoreleasePoolPush()</code>函数本质上就是调用的<code>AutoreleasePoolPage</code>的<code>push</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void *</div><div class="line">objc_autoreleasePoolPush(void)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return nil;</div><div class="line">    return AutoreleasePoolPage::push();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据源码得出，每次执行<code>objc_autoreleasePoolPush</code>其实就是创建了一个新的<code>autoreleasepool</code>，对应<code>AutoreleasePoolPage</code>的具体实现就是往<code>AutoreleasePoolPage</code>中的<code>next</code>位置插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>的内存地址。并且把<code>pool token</code>指针指向这个地址，在执行<code>pop</code>操作的时候作为函数的入参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static inline void *push()</div><div class="line">&#123;</div><div class="line">    id *dest = autoreleaseFast(POOL_SENTINEL);</div><div class="line">    assert(*dest == POOL_SENTINEL);</div><div class="line">    return dest;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>push</code>函数通过调用<code>autoreleaseFast</code>函数来执行具体的插入操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static inline id *autoreleaseFast(id obj)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage *page = hotPage();</div><div class="line">    if (page &amp;&amp; !page-&gt;full()) &#123;</div><div class="line">        return page-&gt;add(obj);</div><div class="line">    &#125; else if (page) &#123;</div><div class="line">        return autoreleaseFullPage(obj, page);</div><div class="line">    &#125; else &#123;</div><div class="line">        return autoreleaseNoPage(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>autoreleaseFast</code>函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ul>
<li>当前<code>page</code>存在且没有满时，直接将对象添加到当前<code>page</code>中，即<code>next</code>指向的位置；</li>
<li>当前<code>page</code>存在且已满时，创建一个新的<code>page</code> ，并将对象添加到新创建的<code>page</code>中；</li>
<li>当前<code>page</code>不存在时，即还没有<code>page</code>时，创建第一个<code>page</code>，并将对象添加到新创建的<code>page</code>中。<br>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址。</li>
</ul>
<h4 id="objc-autoreleasePoolPop-void"><a href="#objc-autoreleasePoolPop-void" class="headerlink" title="objc_autoreleasePoolPop(void *)"></a>objc_autoreleasePoolPop(void *)</h4><p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">objc_autoreleasePoolPop(void *ctxt)</div><div class="line">&#123;</div><div class="line">    if (UseGC) return;</div><div class="line"></div><div class="line">    // fixme rdar://9167170</div><div class="line">    if (!ctxt) return;</div><div class="line"></div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pop</code>函数的入参就是<code>push</code>函数的返回值，也就是<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，（哨兵对象）的内存地址。当这个<code>autoreleasepool</code>被<code>pop</code>的时候，所有在<code>pool token</code>指针之后的的对象都会被<code>release</code>，直到<code>pool token</code>所在<code>page</code>的<code>next</code>指向<code>pool token</code>为止。</p>
<h4 id="autorelease对象释放原理"><a href="#autorelease对象释放原理" class="headerlink" title="autorelease对象释放原理"></a>autorelease对象释放原理</h4><p>每调用一次<code>push</code>操作就会创建一个新的<code>autoreleasepool</code> ，即往<code>AutoreleasePoolPage</code>中插入一个<code>POOL_SENTINEL</code>（哨兵对象），并且返回插入的<code>POOL_SENTINEL</code>（哨兵对象）的内存地址，在执行<code>objc_autoreleasePoolPop(void *)</code>操作的时候作为函数的入参。<br><img src="http://upload-images.jianshu.io/upload_images/588630-cf6a8a8bd44f721c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>根据传入的哨兵对象地址找到哨兵对象所处的page</li>
<li>在当前<code>AutoreleasePoolPage</code>中，将晚于哨兵对象插入的所有<code>autorelease</code>对象都发送一次<code>release</code>消息，并向回移动next指针到正确位置。</li>
<li>从最新加入的对象一直向前清理，可以向前跨越若干个<code>AutoreleasePoolPage</code>，直到哨兵所在的<code>AutoreleasePoolPage</code>。</li>
</ul>
<p><code>objc_autoreleasePoolPop(void *)</code>函数本质上也是调用的<code>AutoreleasePoolPage</code>的<code>pop</code>函数，当执行<code>pop</code>操作后，<br><img src="http://upload-images.jianshu.io/upload_images/588630-ee6388ccaec8b86f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">http://blog.sunnyxx.com/2014/10/15/behind-autorelease/</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;a href=&quot;#面试题：autorelease对象什么时候释放。&quot; class=&quot;headerlink&quot; title=&quot;面试题：autorelease对象什么时候释放。&quot;&gt;&lt;/a&gt;面试题：autoreleas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git中merge、rebase的区别</title>
    <link href="https://sunjinshuai.github.io/2016/08/04/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E4%B8%ADmerge%E3%80%81rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2016/08/04/源码管理工具之git中merge、rebase的区别/</id>
    <published>2016-08-04T06:15:32.000Z</published>
    <updated>2017-08-04T07:43:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般在公司git整合分支一般有两种方法——快速向前合并<code>git rebase</code>和三路合并<code>git merge</code>。其实在开发中，<code>git rebase</code>和<code>git merge</code>表达都是一个意思，即，将一个分支合并到另一个分支。</p>
<p>当开发一个新功能，一般我们会在<code>develop</code>分支上创建<code>featrue</code>分支：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b6359864017521dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当我们这个新功能开发测试完毕之后，首先要把<code>featrue</code>分支合并到<code>develop</code>分支上，一般会根据实际情况选择是否使用<code>git merge</code>还是<code>git rebase</code>。</p>
<p><strong><code>git merge</code></strong><br>根据分支合并的原则，<code>git</code>会自动根据两个分支的共同祖和两个分支的最新提交<code>commit</code>记录进行一个三方合并，然后将合并中修改的内容生成一个新的<code>commit</code>记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git merge master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2fb4e523cea0a269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git merge</code>是一个安全的操作</strong></p>
<p><strong><code>git rebase</code></strong></p>
<p>它会把整个<code>feature</code>分支移动到<code>develop</code>分支的后面，有效地把所有<code>develop</code>分支上新的提交并入过来。但是，<code>git rebase</code>为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout feature</div><div class="line">git rebase master</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93bdffa37317c083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong><code>git rebase</code>最大的特点就是让你的项目历史提交记录会非常整洁。</strong><br>首先，它不像<code>git merge</code>那样引入不必要的合并提交。其次，如上图所示，<code>git rebase</code>使项目历史提交记录呈现出一条直线。你可以从项目终点到起点浏览而不需要任何的分叉，可以让你更容易的使用<code>git log</code>查看项目的提交记录。</p>
<p><strong><code>git rebase</code>缺点就是安全性和可跟踪性。</strong></p>
<p><code>git rebase</code>的黄金法则：绝对不要在公共的分支上使用。如果你把<code>master</code>分支<code>rebase</code>到你的<code>feature</code>分支上：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aa37afc6fe4ff411.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>这次<code>rebase</code>将<code>master</code>分支上的所有提交都移到了<code>feature</code>分支后面。<br>问题是它只发生在你的代码仓库中，而其他所有的开发者还在原来的<code>master</code>上工作。因为<code>rebase</code>引起了新的提交，所以<code>git</code>会认为你的<code>master</code>分支和其他人的<code>master</code>已经分叉了。</p>
<p>同步两个<code>master</code>分支的唯一办法是把它们<code>merge</code>到一起，导致一个额外的合并提交和两堆包含同样更改的提交。</p>
<p><strong><code>git rebase</code>不适用于公共的分支上。</strong></p>
<p>总结：选择<code>git merge</code>还是<code>git rebase</code>？</p>
<ul>
<li><p><code>git merge</code>是一个合并操作，会采用三路合并的方式将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容，生成一个新的<code>commit</code>记录。</p>
</li>
<li><p><code>git rebase</code>并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面，为原分支上每一个提交创建一个新的提交。</p>
</li>
<li><p><code>git merge</code>与<code>git rebase</code>都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般在公司git整合分支一般有两种方法——快速向前合并&lt;code&gt;git rebase&lt;/code&gt;和三路合并&lt;code&gt;git merge&lt;/code&gt;。其实在开发中，&lt;code&gt;git rebase&lt;/code&gt;和&lt;code&gt;git merge&lt;/code&gt;表达都是一个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第3期(2016.08.03)</title>
    <link href="https://sunjinshuai.github.io/2016/08/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E6%9C%9F-2016-08-03/"/>
    <id>https://sunjinshuai.github.io/2016/08/03/iOS学习笔记-第3期-2016-08-03/</id>
    <published>2016-08-03T02:25:15.000Z</published>
    <updated>2017-08-07T03:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要记录了以下几个问题：</p>
<ul>
<li>数组容错处理</li>
<li>Foundation中的断言处理</li>
</ul>
<h4 id="数组容错处理"><a href="#数组容错处理" class="headerlink" title="数组容错处理"></a>数组容错处理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> @method objectAtIndexCheck:</div><div class="line"> @abstract 检查是否越界和NSNull如果是返回nil</div><div class="line"> @result 返回对象</div><div class="line"> */</div><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (id)objectAtIndexCheck:(NSUInteger)index</div><div class="line">&#123;</div><div class="line">    if (index &gt;= [self count]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id value = [self objectAtIndex:index];</div><div class="line">    if (value == [NSNull null]) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    return value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Foundation中的断言处理"><a href="#Foundation中的断言处理" class="headerlink" title="Foundation中的断言处理"></a>Foundation中的断言处理</h4><p><code>Foundation</code>中定义了两组断言相关的宏，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSAssert / NSCAssert</div><div class="line">NSParameterAssert / NSCParameterAssert</div></pre></td></tr></table></figure></p>
<p>这两组宏主要在功能和语义上有所差别，这些区别主要有以下两点：</p>
<ul>
<li>如果我们需要确保方法或函数的输入参数的正确性，则应该在方法(函数)的顶部使用<code>NSParameterAssert / NSCParameterAssert</code>；而在其它情况下，使用<code>NSAssert / NSCAssert</code>。</li>
<li>另一个不同是介于<code>C</code>和<code>Objective-C</code>之间。<code>NSAssert / NSParameterAssert</code>应该用于<code>Objective-C</code>的上下文(方法)中，而<code>NSCAssert / NSCParameterAssert</code>应该用于<code>C</code>的上下文(函数)中。</li>
</ul>
<p>当断言失败时，通常是会抛出一个如下所示的异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;true is not equal to false&apos;</div></pre></td></tr></table></figure></p>
<p><code>Foundation</code>为了处理断言，专门定义了一个<code>NSAssertionHandler</code>来处理断言的失败情况。<code>NSAssertionHandler</code>对象是自动创建的，用于处理失败的断言。当断言失败时，会传递一个字符串给<code>NSAssertionHandler</code>对象来描述失败的原因。每个线程都有自己的<code>NSAssertionHandler</code>对象。当调用时，一个断言处理器会打印包含方法和类(或函数)的错误消息，并引发一个<code>NSInternalInconsistencyException</code>异常。就像上面所看到的一样。</p>
<p>我们很少直接去调用<code>NSAssertionHandler</code>的断言处理方法，通常都是自动调用的。</p>
<p><code>NSAssertionHandler</code>提供的方法并不多，就三个，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 返回与当前线程的NSAssertionHandler对象。</div><div class="line">// 如果当前线程没有相关的断言处理器，则该方法会创建一个并指定给当前线程</div><div class="line">+ (NSAssertionHandler *)currentHandler</div><div class="line">// 当NSCAssert或NSCParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)object lineNumber:(NSInteger)fileName description:(NSString *)line, format,...</div><div class="line">// 当NSAssert或NSParameterAssert断言失败时，会调用这个方法</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format, ...</div></pre></td></tr></table></figure></p>
<p>另外，还定义了一个常量字符串，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * const NSAssertionHandlerKey;</div></pre></td></tr></table></figure></p>
<p>主要是用于在线程的<code>threadDictionary</code>字典中获取或设置断言处理器。</p>
<p><code>Xcode</code>已经默认将<code>release</code>环境下的断言取消了, 免除了忘记关闭断言造成的程序不稳定. 所以不用担心在开发时候大胆使用。</p>
<p>自定义<code>NSAssertionHandler</code><br><code>NSAssertionHandler</code>实例是自动创建的，用于处理错误断言。如果<code>NSAssert</code>和<code>NSCAssert</code>条件评估为错误，会向<code>NSAssertionHandler</code>实例发送一个表示错误的字符串。每个线程都有它自己的<code>NSAssertionHandler</code>实例。<br>我们可以自定义处理方法，从而使用断言的时候，控制台输出错误，但是程序不会直接崩溃。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &quot;MyAssertHandler.h&quot;</div><div class="line"></div><div class="line">@implementation MyAssertHandler</div><div class="line"></div><div class="line">//处理Objective-C的断言</div><div class="line">- (void)handleFailureInMethod:(SEL)selector object:(id)object file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSAssert Failure: Method %@ for object %@ in %@#%li&quot;, NSStringFromSelector(selector), object, fileName, (long)line);</div><div class="line">&#125;</div><div class="line">//处理C的断言</div><div class="line">- (void)handleFailureInFunction:(NSString *)functionName file:(NSString *)fileName lineNumber:(NSInteger)line description:(NSString *)format,...</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;NSCAssert Failure: Function (%@) in %@#%li&quot;, functionName, fileName, (long)line);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>给线程添加处理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application</div><div class="line">didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  NSAssertionHandler *assertionHandler = [[LoggingAssertionHandler alloc] init];</div><div class="line">  [[[NSThread currentThread] threadDictionary] setValue:assertionHandler</div><div class="line">                                                 forKey:NSAssertionHandlerKey];</div><div class="line">  // ...</div><div class="line">  return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义<code>NSAssertionHandler</code>后,程序能够获得断言失败后的信息,但是程序可以继续运行,不会强制退出程序.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本期主要记录了以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组容错处理&lt;/li&gt;
&lt;li&gt;Foundation中的断言处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;数组容错处理&quot;&gt;&lt;a href=&quot;#数组容错处理&quot; class=&quot;headerlink&quot; title=&quot;数组容错处
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之git的使用</title>
    <link href="https://sunjinshuai.github.io/2016/05/02/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bgit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2016/05/02/源码管理工具之git的使用/</id>
    <published>2016-05-02T03:03:24.000Z</published>
    <updated>2017-08-07T07:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、git简介"><a href="#一、git简介" class="headerlink" title="一、git简介"></a>一、git简介</h4><p><code>git</code>是目前世界上被最广泛使用的现代软件版本管理系统。<code>git</code>本身亦是一个成熟并处于活跃开发状态的开源项目，它最初是由Linux操作系统内核的创造者Linus Torvalds在2005年创造。</p>
<h4 id="二、在Mac-OS-X上安装git"><a href="#二、在Mac-OS-X上安装git" class="headerlink" title="二、在Mac OS X上安装git"></a>二、在Mac OS X上安装git</h4><p>如果你正在使用Mac做开发，有两种安装<code>git</code>的方法。</p>
<ul>
<li>安装<code>homebrew</code>，然后通过<code>homebrew</code>安装<code>git</code>，具体方法请参考<code>homebrew</code>的文档：<a href="http://brew.sh/。" target="_blank" rel="external">http://brew.sh/。</a></li>
<li>直接从<code>AppStore</code>安装<code>Xcode</code>，<code>Xcode</code>集成了<code>git</code>。不过默认没有安装，你需要运行<code>Xcode</code>，选择菜单<code>“Xcode”-&gt;“Preferences”</code>，在弹出窗口中找到<code>“Downloads”</code>，选择<code>“Command Line Tools”</code>，点“Install”就可以完成安装了。</li>
</ul>
<h4 id="三、创建本地仓库"><a href="#三、创建本地仓库" class="headerlink" title="三、创建本地仓库"></a>三、创建本地仓库</h4><p>仓库：英文名<code>repository</code>，可以简单理解成一个目录，这个目录里面的所有文件都可以被<code>git</code>管理起来，每个文件的修改、删除，<code>git</code>都能记录，以便任何时刻都可以查找历史记录，或者在回滚到以前修改的状态。</p>
<p>1、首先，选择一个合适的地方，创建一个空目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure>
<p>创建新的<code>git</code>仓库，会发下在当前的创建的目录下面多了一个<code>.git</code>的目录，这个目录是<code>git</code>来管理仓库的。<br>注意：<br><strong>没事千万不要手动修改这个目录里面的文件，不然就把会<code>git</code>仓库给破坏了。</strong></p>
<p>2、添加文件到git仓库</p>
<p>把文件添加到仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add &lt;filename&gt;</div><div class="line">git add .</div></pre></td></tr></table></figure>
<p>注意：<br><code>git add &lt;filename&gt;</code>是把某一个文件添加到<code>git</code>的缓存区里面。<br><code>git add .</code>是把所有的文件添加到<code>git</code>的缓存区里面。</p>
<p>3、把文件提交到本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;代码提交信息&quot;</div></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>git commit</code>命令，一般会在后面加上<code>-m</code>表示本次提交到本地仓库的记录。</li>
<li><code>commit message</code>言简意赅，不要写无用信息，这样让别人不能看懂这次提交的意义。</li>
<li>在开发时，良好的习惯是根据工作进度及时<code>commit</code>，并务必注意附上有意义的<code>commit message</code>。创建完项目目录后，第一次提交的<code>commit message</code>一般为<code>Initial commit.</code>。</li>
<li>添加一个新的<code>Pod</code>库或<code>pod update</code>后，要单独提交一个<code>commit</code>，统一<code>commit message</code>为<code>pod add xxx</code>或<code>pod update xxx</code>。</li>
</ul>
<h4 id="四、远程仓库"><a href="#四、远程仓库" class="headerlink" title="四、远程仓库"></a>四、远程仓库</h4><p>一般使用<code>git</code>的公司都会有自己的<code>git</code>服务器或者使用第三方<code>git</code>服务器，比如<code>coding.net</code>、码云等。<br>由于你的本地<code>git</code>仓库和<code>git</code>服务器仓库之间的传输是通过<code>SSH</code>加密的，需要设置：</p>
<ul>
<li>创建<code>SSH Key</code>。在用户主目录下，看看有没有<code>.ssh</code>目录。如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有，可直接跳到下一步。如果没有，打开<code>Shell</code>，创建<code>SSH Key</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;your.email@example.com&quot; -b 4096</div></pre></td></tr></table></figure>
<ul>
<li>将公共SSH密钥复制到剪贴板：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure>
<ul>
<li>登陆<code>git</code>服务器，打开<code>“Account settings”</code>，<code>“SSH Keys”</code>页面：</li>
<li>点<code>“Add SSH Key”</code>，填上任意Title，在<code>Key</code>文本框里粘贴<code>id_rsa.pub</code>文件的内容：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-93e16d0ca42e91bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br>为什么<code>git</code>服务器需要<code>SSH Key</code>呢？因为<code>git</code>服务器需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而<code>git</code>支持<code>SSH</code>协议，所以，<code>git</code>服务器只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，<code>git</code>服务器允许你添加多个<code>Key</code>。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的<code>Key</code>都添加到<code>git</code>服务器，就可以在每台电脑上往<code>git</code>服务器推送了。</p>
<h4 id="五、添加远程仓库"><a href="#五、添加远程仓库" class="headerlink" title="五、添加远程仓库"></a>五、添加远程仓库</h4><ul>
<li>登陆<code>git</code>服务器，然后，找到<code>“Create a new repo”</code>按钮，创建一个新的仓库：</li>
<li>在<code>Repository name</code>填入<code>learngit</code>，其他保持默认设置，点击<code>“Create repository”</code>按钮，就成功地创建了一个新的<code>git</code>仓库。<br>注意：<br>目前，在<code>git</code>服务器上的这个<code>learngit</code>仓库还是空的，<code>git</code>服务器告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到<code>git</code>服务器仓库。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-3270bd7b01a820cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>通过上图可以看出：<br>1、如果在本地没有创建仓库，可以通过下面命令从<code>git</code>服务器<code>clone</code>出一个新的仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git clone http://michael@git.51fanxing.com:88/fxbest/ios/learngit.git</div><div class="line">cd learngit</div><div class="line">touch README.md</div><div class="line">git add README.md</div><div class="line">git commit -m &quot;add README&quot;</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<p>2、如果本地已经创建了，可以通过下面命令把本地仓库与<code>git</code>服务器仓库进行关联：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd existing_folder</div><div class="line">git init</div><div class="line">git remote add origin http://michael@git.51fanxing.com:88/fxbest/ios/learngit.git</div><div class="line">git add .</div><div class="line">git commit</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure>
<p>注意：<br>1、<code>git remote add origin</code>表示将本地服务器与<code>git</code>服务器进行关联。<br>2、<code>origin</code>是<code>git</code>服务器的别名，取什么名字都可以，你也可以在<code>push</code>时将<code>git</code>服务器替换为 origin。但为了以后<code>push</code>方便，我们第一次一般都会先<code>remote add</code>。<br>3、<code>git push -u origin master</code>将你修改或者添加的文件提交到<code>git</code>服务器。</p>
<p>3、git remote<br><code>git remote</code>命令允许你创建、查看和删除和其它仓库之间的远程连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote</div></pre></td></tr></table></figure>
<p>列出和其他仓库之间的远程连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure>
<p>列出和其他仓库之间的远程连接，但同时显示每个连接的<code>URL</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add &lt;name&gt; &lt;url&gt;</div></pre></td></tr></table></figure>
<p>创建一个新的远程仓库连接。在添加之后，可以将<code>&lt;name&gt;</code>作为<code>&lt;url&gt;</code>便捷的别名在其他<code>git</code>命令中使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm &lt;name&gt;</div></pre></td></tr></table></figure>
<p>移除名为的远程仓库的连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rename &lt;old-name&gt; &lt;new-name&gt;</div></pre></td></tr></table></figure>
<p>将远程连接从<code>&lt;old-name&gt;</code>重命名为<code>&lt;new-name&gt;</code>。</p>
<h4 id="六、检查仓库状态"><a href="#六、检查仓库状态" class="headerlink" title="六、检查仓库状态"></a>六、检查仓库状态</h4><p>1、git status<br><code>git status</code>命令显示工作目录和缓存区的状态。你可以看到哪些更改被缓存了，哪些还没有，以及哪些还未被<code>git</code>记录。</p>
<p>2、git log<br><code>git log</code>命令查看每次<code>commit</code>的历史记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure>
<p>使用默认格式显示完整地<code>commit</code>记录，如果输出超过一屏，你可以用空格键来滚动，按q退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -n &lt;limit&gt;</div></pre></td></tr></table></figure>
<p>用<limit>限制提交的数量，比如<code>git log -n 3</code>只会显示3个提交。</limit></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --oneline</div></pre></td></tr></table></figure>
<p>将每个提交压缩到一行，当你需要查看项目历史的上层情况时这会很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --stat</div></pre></td></tr></table></figure>
<p>除了<code>git log</code>信息之外，包含哪些文件被更改了，以及每个文件相对的增删行数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log -p</div></pre></td></tr></table></figure>
<p>显示代表每个提交的一堆信息，显示每个提交全部的差异（diff），这也是项目历史中最详细的视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --author=&quot;&lt;pattern&gt;&quot;</div></pre></td></tr></table></figure>
<p>搜索特定作者的提交。<code>&lt;pattern&gt;</code>可以是字符串或正则表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log --grep=&quot;&lt;pattern&gt;&quot;</div></pre></td></tr></table></figure>
<p>搜索提交信息匹配特定<code>&lt;pattern&gt;</code>的提交。<code>&lt;pattern&gt;</code>可以是字符串或正则表达式。</p>
<h4 id="七、git-reset、git-checkout和git-revert"><a href="#七、git-reset、git-checkout和git-revert" class="headerlink" title="七、git reset、git checkout和git revert"></a>七、git reset、git checkout和git revert</h4><p><code>git</code>仓库有三个主要组成——工作目录，缓存区和提交历史。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6a21a168d9789d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>git reset</code>、<code>git checkout</code>和<code>git revert</code>是你的<code>git</code>工具箱中最有用的一些命令。它们都用来撤销代码仓库中的某些更改，而前两个命令不仅可以作用于提交，还可以作用于特定文件。</p>
<p>因为它们非常相似，所以我们经常会搞混，不知道什么场景下该用哪个命令。</p>
<p>1、<code>git reset</code></p>
<p><code>git reset</code>操作会将当前分支的<code>HEAD</code>指向另外一个<code>commit</code>记录，这样可以在当前分支上移除部分<code>commit</code>记录。例如，在hotfix分支上回滚前两次的<code>commit</code>状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset HEAD~2</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b37c7f0e1cc74e53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-353241c3327b5ab1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>当执行<code>git reset</code>时，hotfix分支上最后两次提交的状态会变成空状态，等到<code>git</code>执行垃圾回收的时候，hotfix分支上最后两次提交的状态会被回收。</p>
<ul>
<li>–soft – 缓存区和工作目录都不会被改变</li>
<li>–mixed – 默认选项。缓存区和你指定的提交同步，但工作目录不受影响</li>
<li>–hard – 缓存区和工作目录都同步到你指定的提交</li>
</ul>
<p><code>git reset</code>一般配合这些参数使用，<code>git reset --mixed HEAD</code>将你当前的改动从缓存区中移除，但是这些改动还留在工作目录中。如果你想完全舍弃你没有提交的改动，你可以使用<code>git reset --hard HEAD</code>，这是<code>git reset</code>最常用的两种用法。<br>注意：<br><strong><code>git reset</code>是不可逆的，因为<code>git reset</code>操作会重写当前分支的历史，用来撤销缓存区和工作目录的修改。<code>git reset</code>只适用于本地修改，不能重设服务器上的<code>commit</code>记录。</strong></p>
<p>2、<code>git checkout</code></p>
<ul>
<li>切换分支：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout hotfix</div></pre></td></tr></table></figure>
<p>注意：<br><strong>使用<code>git checkout</code>之前，要把工作区的内容提交到<code>git</code>服务器或者缓存区。<code>git checkout</code>是将<code>HEAD</code>指针从一个分支切换到另一个分支，然后更新工作目录。因为这可能会覆盖本地的修改，<code>git</code>会强制你提交或者缓存工作目录中的所有更改，不然在checkout的时候这些更改都会丢失。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-46593e029f800b33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-0d591979a332a9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>查看文件之前的版本</li>
</ul>
<p>除了切换分支之外，<code>git checkout</code>还可以将<code>HEAD</code>指针移动到当前分支其他的<code>commit</code>记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout HEAD~2</div></pre></td></tr></table></figure>
<p><code>git checkout</code>更改的是工作目录而不是缓存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout HEAD~2 xxx</div></pre></td></tr></table></figure></p>
<p>如果你缓存并且提交了<code>checkout</code>的文件，它具备将某个文件回撤到之前版本的效果，注意它撤销了这个文件后面所有的更改。不影响你仓库的当前状态。你可以在新的快照中像其他文件一样重新提交旧版本。所以，在效果上，<code>git checkout</code>的这个用法可以用来将单个文件回滚到旧版本。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1d467da0f8a6492e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e06dd9f6e82ec593.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br><strong><code>git checkout</code>是可逆的。</strong></p>
<p>3、<code>git revert</code></p>
<p><code>git revert</code>撤销一个<code>commit</code>记录的同时会创建另一个新的<code>commit</code>记录，这是一个安全的方法，而不是从项目历史中移除这个提交。这避免了<code>git</code>丢失项目历史记录，这一点对于你的版本历史和协作的可靠性来说是很重要的。</p>
<p>比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git revert HEAD~2</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-c0b3dfb6eb5f32e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6fef5a231e49f9ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>git revert</code>应该用在你想要在项目历史中移除一整个提交的时候。比如说，你在追踪一个 bug，然后你发现它是由一个提交造成的，这时候撤销就很有用。与其说自己去修复它，然后提交一个新的快照，不如用<code>git revert</code>，它帮你做了所有的事情。</p>
<p><code>git revert</code>回滚了单独一个提交，它没有移除后面的提交记录，同时会创建另一个新的<code>commit</code>记录。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-dcf4353870b8b2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>git reset</code>回滚了单独一个提交，并且移除后面的提交记录，是<strong>不可逆的</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/588630-bde0c98e8c62a2a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><code>git revert</code>可以针对历史记录中任何一个提交，而<code>git reset</code>只能从当前提交向前回滚。比如，你想用<code>git reset</code>重设一个旧的提交，你不得不移除那个提交后的所有提交，再移除那个提交，然后重新提交后面的所有提交。一般公司不提倡这么做。因此，<code>git revert</code>可以用在公共分支上，<code>git reset</code>应该用在私有分支上。</p>
<p>4、<strong><code>git reset</code>用慎用</strong><br>当有<code>commit</code>之后的提交被推送到公共分支上，你绝不应该使用<code>git reset</code>。使用<code>git reset</code>回滚了单独一个提交，并且移除后面的提交记录。当团队成员在上面继续开发的提交在协作时会引发严重的问题。当他们试着和你的仓库同步时，他们会发现项目历史的一部分突然消失了。<br>下面的序列展示了如果你尝试重设公共提交时会发生什么。<code>origin/master</code>是你本地<code>master</code>分支对应的中央仓库中的分支。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4ca6571366212ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-66c305ffcfbb405d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f4eab69ac10165f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>一旦你在重设之后又增加了新的提交，<code>git</code>会认为你的本地历史已经和 <code>origin/master</code>分叉了，同步你的仓库时的合并提交（merge commit）会使你的同事困惑。</p>
<p>5、<code>git clean</code></p>
<p><code>git clean</code>命令将未记录的文件从你的工作目录中移除。它只是提供了一条捷径，因为用<code>git status</code>查看未记录的文件，然后手动移除它们也很方便。和一般的<code>rm</code>命令一样，<code>git clean</code>是无法撤消的，所以在删除未记录的文件之前想清楚，你是否真的要这么做。</p>
<p><code>git clean</code>命令经常和<code>git reset --hard</code>一起使用。记住，<code>git reset</code>只影响被记录的文件，所以还需要一个单独的命令来清理未被记录的文件。这个两个命令相结合，你就可以将工作目录回到之前特定提交时的状态。</p>
<p>注意：<br><strong><code>git clean</code>也是不可逆的。</strong></p>
<h4 id="八、分支"><a href="#八、分支" class="headerlink" title="八、分支"></a>八、分支</h4><p>1、git branch<br>分支代表了一条独立的开发流水线，<code>git branch</code>命令允许你创建、列出、重命名和删除分支。一般<code>git branch</code>和<code>git checkout</code>、<code>git merge</code>这两个命令通常紧密地结合在一起使用。一般使用过<code>git</code>的同学都知道：</p>
<ul>
<li><code>master</code>是长期分支，一般用于管理对外发布版本，每个<code>commit</code>对一个<code>tag</code>，也就是一个发布版本。</li>
<li><code>develop</code>是长期分支，一般用于作为日常开发汇总，即开发版的代码</li>
<li><code>feature</code>是短期分支，一般用于一个新功能的开发。</li>
<li><code>hotfix</code>是短期分支 ，一般用于正式发布以后，出现bug，需要创建一个分支，进行bug修补。</li>
<li><code>release</code>是短期分支，一般用于发布正式版本之前（即合并到<code>master</code>分支之前），需要有的预发布的版本进行测试。<code>release</code>分支在经历测试之后，测试确认验收，将会被合并的<code>develop</code>和<code>master</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch</div></pre></td></tr></table></figure>
<p>列出仓库中所有分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch &lt;branch&gt;</div></pre></td></tr></table></figure></p>
<p>创建一个名为 <branch> 的分支。不会自动切换到那个分支去。</branch></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d &lt;branch&gt;</div></pre></td></tr></table></figure>
<p>删除指定分支。这是一个安全的操作，<code>git</code>会阻止你删除包含未合并更改的分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -D &lt;branch&gt;</div></pre></td></tr></table></figure>
<p>强制删除指定分支，即使包含未合并更改。如果你希望永远删除某条开发线的所有提交，你应该用这个命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -m &lt;branch&gt;</div></pre></td></tr></table></figure>
<p>将当前分支命名为<branch>。</branch></p>
<p>2、git merge<br>用于合并指定分支到当前分支，<code>git merge</code>命令允许你将<code>git branch</code>创建的多条分支合并成一个。</p>
<p>注意：<br>合并指定分支到当前分支，当前分支会被更新，以响应合并操作，但目标分支完全不受影响。也就是说<code>git merge</code>经常和<code>git checkout</code>一起使用，选择当前分支，然后用<code>git branch -d</code>删除废弃的目标分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge &lt;branch&gt;</div></pre></td></tr></table></figure>
<p>将指定分支并入当前分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff &lt;branch&gt;</div></pre></td></tr></table></figure>
<p>将指定分支并入当前分支，但 总是 生成一个合并提交（即使是快速向前合并）。这可以用来记录仓库中发生的所有合并。</p>
<p>3、git merge几种方法</p>
<ul>
<li>快速向前合并<br>当当前分支顶端到目标分支路径是线性之时，我们可以采取快速向前合并。<code>git</code>只需要将当前分支顶端（快速向前地）移动到目标分支顶端，即可整合两个分支的历史，而不需要“真正”合并分支。它在效果上合并了历史，因为目标分支上的提交现在在当前分支可以访问到。比如，<code>some-feature</code>到<code>master</code>分支的快速向前合并会是这样的：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-944fb76a38db291d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-5ac694413e3967f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>三路合并<br>如果分支已经分叉了，那么就无法进行快速向前合并。当和目标分支之间的路径不是线性之时，<code>git</code>只能执行三路合并。三路合并使用一个专门的提交来合并两个分支的历史。这个术语取自这样一个事实，<code>git</code>使用三个提交来生成合并提交：两个分支顶端和它们共同的祖先。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-d78b8f3c40b6ef82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-90ea927631a7c49d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>很多开发者喜欢使用<code>git rebase</code>快速向前合并，来合并微小的功能或者修复bug，使用三路合并来整合长期运行的功能。后者导致的合并提交作为两个分支的连接标志。</p>
<p>4、解决冲突</p>
<p>如果你尝试合并的两个分支同一个文件的同一个部分，<code>git</code>将无法决定使用哪个版本。当这种情况发生时，它会停在合并提交，让你手动解决这些冲突。</p>
<p>当你遇到合并冲突时，运行<code>git status</code>命令来查看哪些文件存在需要解决的冲突。</p>
<p>当你手动修复完冲突之后，只需对冲突的文件运行<code>git add</code>告诉<code>git</code>冲突已解决。然后，运行<code>git commit</code>生成一个合并提交。</p>
<p>使用<code>git log --graph</code>命令可以看到分支合并图。</p>
<p>团队合作的分支看起来就像这样：<br><img src="http://upload-images.jianshu.io/upload_images/588630-d2df21bfde4c29ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>注意：<br><strong>提交冲突只会出现在三路合并中。在快速向前合并中，我们不可能出现冲突的更改。</strong></p>
<h4 id="九、创建标签"><a href="#九、创建标签" class="headerlink" title="九、创建标签"></a>九、创建标签</h4><p>一般在公司每一个上线版本都会打一个标签，为了记录和维护，当线上版本出现紧急bug，我们就可以通过<code>git checkout</code>检出项目，然后创建hotfix分支进行bug的修复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag</div></pre></td></tr></table></figure>
<p>查看所有标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git tag &lt;name&gt;</div><div class="line">git tag &lt;name&gt; commit id</div></pre></td></tr></table></figure>
<p>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个<code>commit id</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git show &lt;tagname&gt;</div></pre></td></tr></table></figure>
<p>查看标签信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin &lt;tagname&gt;</div></pre></td></tr></table></figure>
<p>可以推送一个本地标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin --tags</div></pre></td></tr></table></figure>
<p>可以推送全部未推送过的本地标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -d &lt;tagname&gt;</div></pre></td></tr></table></figure>
<p>可以删除一个本地标签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin :refs/tags/&lt;tagname&gt;</div></pre></td></tr></table></figure>
<p>可以删除一个远程标签</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="external">https://www.atlassian.com/git/tutorials/merging-vs-rebasing</a><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、git简介&quot;&gt;&lt;a href=&quot;#一、git简介&quot; class=&quot;headerlink&quot; title=&quot;一、git简介&quot;&gt;&lt;/a&gt;一、git简介&lt;/h4&gt;&lt;p&gt;&lt;code&gt;git&lt;/code&gt;是目前世界上被最广泛使用的现代软件版本管理系统。&lt;code&gt;git&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第2期(2016.03.03)</title>
    <link href="https://sunjinshuai.github.io/2016/03/03/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E6%9C%9F-2016-03-03/"/>
    <id>https://sunjinshuai.github.io/2016/03/03/iOS学习笔记-第2期-2016-03-03/</id>
    <published>2016-03-03T10:05:30.000Z</published>
    <updated>2017-07-28T04:58:45.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本期主要记录了以下几个问题："><a href="#本期主要记录了以下几个问题：" class="headerlink" title="本期主要记录了以下几个问题："></a>本期主要记录了以下几个问题：</h4><ul>
<li>删除git中的.DS_Store</li>
<li>git关于忽略Xcode工程中UserInterfaceState.xcuserstate文件的问题</li>
<li>bitcode适配指南</li>
</ul>
<h4 id="删除git中的-DS-Store"><a href="#删除git中的-DS-Store" class="headerlink" title="删除git中的.DS_Store"></a>删除git中的.DS_Store</h4><h5 id="DS-Store-是什么"><a href="#DS-Store-是什么" class="headerlink" title=".DS_Store 是什么"></a>.DS_Store 是什么</h5><p>使用<code>Mac</code>的用户可能会注意到，系统经常会自动在每个目录生成一个隐藏的<code>.DS_Store</code>文件。<code>.DS_Store</code>(英文全称<code>Desktop Services Store</code>)是一种由苹果公司的<code>Mac OS X</code>操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于<code>Windows</code>下的 <code>desktop.ini</code>。</p>
<h5 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h5><p>如果你的项目中还没有自动生成的<code>.DS_Store</code> 文件，那么直接将<code>.DS_Store</code>加入到 <code>.gitignore</code>文件就可以了。如果你的项目中已经存在<code>.DS_Store 文件</code>，那就需要先从项目中将其删除，再将它加入到<code>.gitignore</code>。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store</div><div class="line">find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch</div><div class="line"># 将 .DS_Store 加入到 .gitignore</div><div class="line">echo .DS_Store &gt;&gt; ~/.gitignore</div><div class="line"># 更新项目</div><div class="line">git add --all</div><div class="line">git commit -m &apos;.DS_Store banished!&apos;</div></pre></td></tr></table></figure>
<p>如果你只需要删除磁盘上的<code>.DS_Store</code>，可以使用下面的命令来删除当前目录及其子目录下的所有<code>.DS_Store</code>文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name &apos;*.DS_Store&apos; -type f -delete</div></pre></td></tr></table></figure>
<h5 id="禁用或启用自动生成"><a href="#禁用或启用自动生成" class="headerlink" title="禁用或启用自动生成"></a>禁用或启用自动生成</h5><ul>
<li><p>禁止.DS_store生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE</div></pre></td></tr></table></figure>
</li>
<li><p>恢复.DS_store生成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults delete com.apple.desktopservices DSDontWriteNetworkStores</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="git关于忽略Xcode工程中UserInterfaceState-xcuserstate文件的问题"><a href="#git关于忽略Xcode工程中UserInterfaceState-xcuserstate文件的问题" class="headerlink" title="git关于忽略Xcode工程中UserInterfaceState.xcuserstate文件的问题"></a>git关于忽略Xcode工程中UserInterfaceState.xcuserstate文件的问题</h4><p>在使用git管理版本的时候没有配置忽略文件<code>.gitignore</code>文件，结果导致每次提交的时候都会出现<code>UserInterfaceState.xcuserstate</code>，<code>Breakpoints_v2.xcbkptlist</code>这两个文件被修改，有可能还会出现冲突。</p>
<h5 id="添加-gitignore"><a href="#添加-gitignore" class="headerlink" title="添加.gitignore"></a>添加.gitignore</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">*.xcuserstate  </div><div class="line">project.xcworkspace  </div><div class="line">xcuserdata  </div><div class="line">UserInterfaceState.xcuserstate  </div><div class="line">project.xcworkspace/  </div><div class="line">xcuserdata/  </div><div class="line">UserInterface.xcuserstate  </div><div class="line"></div><div class="line">*.xcbkptlist</div></pre></td></tr></table></figure>
<p>然后输入<code>git status</code>时你忽略的文件已经没有了。</p>
<p>如果按照上述方法定义后发现并未生效，原因是<code>.gitignore</code>只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），我一般都是删除所有缓存，不用单个删除，然后再提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m ‘update .gitignore‘</div></pre></td></tr></table></figure>
<h4 id="bitcode适配指南"><a href="#bitcode适配指南" class="headerlink" title="bitcode适配指南"></a>bitcode适配指南</h4><p>随着Xcode7的发布，Apple提供了一项新的技术来支持App瘦身功能，那就是<code>bitcode</code>。本文章将会结合自己在支持<code>bitcode</code>过程中遇到的问题，来阐述支持<code>bitcode</code>的过程。</p>
<h5 id="bitCode是什么"><a href="#bitCode是什么" class="headerlink" title="bitCode是什么"></a>bitCode是什么</h5><blockquote>
<p>Bitcode is an intermediate representation of a compiled program. Apps you upload to iTunes Connect that contain bitcode will be compiled and linked on the store. Including bitcode will allow Apple to re-optimize your app binary in the future without the need to submit a new version of your app to the store.<br>Xcode hides symbols generated during build time by default, so they are not readable by Apple. Only if you choose to include symbols when uploading your app to iTunes Connect would the symbols be sent to Apple. You must include symbols to receive crash reports from Apple.</p>
</blockquote>
<p>其大概意思是<code>bitcode</code>类似于一个中间码，被上传到<code>AppleStore</code>之后，苹果会根据下载应用的用户的手机指令集类型生成只有该指令集的二进制，进行下发。从而达到精简安装包体积的目的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-e10707ed99066a9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="打开bitcode设置"><a href="#打开bitcode设置" class="headerlink" title="打开bitcode设置"></a>打开bitcode设置</h5><p>实际上在Xcode 7中，我们新建一个iOS程序时，<code>bitcode</code>选项默认是设置为YES的。我们可以在<code>&quot;Build Settings&quot;-&gt;&quot;Enable Bitcode&quot;</code>选项中看到这个设置。</p>
<p>如果我们开启了<code>bitcode</code>，在提交包时，下面这个界面也会有个<code>bitcode</code>选项：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f2609c8ef569d059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但是如果其中包含第三方库，不支持<code>bitcode</code>时候。需要将<code>&quot;Enable BitCode&quot;</code>设置成NO。而且这个选项是，只要有一个第三方库不支持，就不能开的。否则连接错误。</p>
<p>确保打包的时候使用的是<code>fembed-bitcode</code>, 而不是<code>fembed-bitcode-maker</code></p>
<blockquote>
<p>You should be aware that a normal build with the -fembed-bitcode-marker option will produce minimal size embedded bitcode sections without any real content. This is done as a way of testing the bitcode-related aspects of your build without slowing down the build process. The actual bitcode content is included when you do an Archive build.</p>
</blockquote>
<ul>
<li><code>fembed-bitcode-maker</code>:只是简单的标记一下在<code>archive</code>出来的二进制中<code>bitcdoe</code>所在的位置。</li>
<li><code>fembed-bitcode</code>: 真的会生成<code>bitcode</code>指令，并且嵌入到二进制中，这个设置不止要在app中设置，同样你也必须在编译静态链接库的时候使用。而且需要主题的是该参数系统只默认在<code>archive</code>模式下会添加。</li>
</ul>
<p>需要注意的是bitcode只默认在archive下编译。在debug和release下并不会。</p>
<h5 id="检测是否打开Bitcode"><a href="#检测是否打开Bitcode" class="headerlink" title="检测是否打开Bitcode"></a>检测是否打开Bitcode</h5><p>当打开<code>bitcdoe</code>选项之后，我们可以使用<code>otool</code>工具来检查二进制文件中是否包含<code>bitcode</code>段。</p>
<p>针对于静态链接库.a文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -arch armv7 -l xxxx.a | grep __bitcode | wc -l</div></pre></td></tr></table></figure></p>
<p>如果是当前库支持.a文件则会输出一个数字</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-1d4181684959122b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果不支持<code>bitcode</code>则不会出现该数字。</p>
<p>上述命令只检查了<code>armv7</code>架构，同时，也必须使用改指令检查其他的指令集是否包含<code>bitcode</code>如：<code>arm64</code>，<code>armv7s</code>等等</p>
<p>检查app或者<code>framework</code>中是否包含<code>bitcode</code></p>
<p>由于app中二进制和<code>framework</code>中二进制文件与.a文件存在差异，因为需要检查的是<code>__LLVM</code>段，当出现该段的时候，则表示支持<code>bitcdoe</code>，否则不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -l xxxx | grep __LLVM | wc -l</div></pre></td></tr></table></figure>
<p>这里<code>otool</code>有个bug，当你的<code>framework</code>使用过lipo命令，进行拆解和合并之后，需要指定指令集进行检查才可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -arch armv7 -l xxxx | grep __LLVM | wc -l</div></pre></td></tr></table></figure></p>
<p><strong>注意, 上述检查过了之后，也不一定是真的支持bitcode，在实际的测试中，发现上述检测命令通过之后，某个使用的第三方库，依然报错不支持bitcode。因而最终结果，还是需要以是否能够连接成功为准。重要事情说三遍，上述网上流传的检测方法只做参考，最终还是要以实际效果为准。</strong></p>
<h5 id="最终结果检查"><a href="#最终结果检查" class="headerlink" title="最终结果检查"></a>最终结果检查</h5><p>在真实项目中，可以直接进行<code>Archive</code>打包，如果出现下图这种情况，说明项目不支持<code>bitcode</code>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-42081e18b5507b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本期主要记录了以下几个问题：&quot;&gt;&lt;a href=&quot;#本期主要记录了以下几个问题：&quot; class=&quot;headerlink&quot; title=&quot;本期主要记录了以下几个问题：&quot;&gt;&lt;/a&gt;本期主要记录了以下几个问题：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;删除git中的.DS_Store
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS学习笔记 第1期(2015.10.05)</title>
    <link href="https://sunjinshuai.github.io/2015/10/05/iOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E6%9C%9F-2015-10-05/"/>
    <id>https://sunjinshuai.github.io/2015/10/05/iOS学习笔记-第1期-2015-10-05/</id>
    <published>2015-10-05T03:10:07.000Z</published>
    <updated>2017-07-18T05:31:15.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本期主要记录了以下几个问题："><a href="#本期主要记录了以下几个问题：" class="headerlink" title="本期主要记录了以下几个问题："></a>本期主要记录了以下几个问题：</h4><ul>
<li>NSString属性什么时候用copy，什么时候用strong?</li>
<li>rvm: command not found</li>
<li>关于HEXO安装失败的解决方法</li>
<li>Mac iterm2 配色方案</li>
</ul>
<h4 id="NSString属性什么时候用copy，什么时候用strong"><a href="#NSString属性什么时候用copy，什么时候用strong" class="headerlink" title="NSString属性什么时候用copy，什么时候用strong?"></a>NSString属性什么时候用copy，什么时候用strong?</h4><p>我们在声明一个<code>NSString</code>属性时，对于其内存相关特性，通常有两种选择(基于<code>ARC</code>环境)：<code>strong</code>与<code>copy</code>。那这两者有什么区别呢？什么时候该用<code>strong</code>，什么时候该用<code>copy</code>呢？让我们先来看个例子。</p>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6><p>我们定义一个类，并为其声明两个字符串属性，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface TestStringClass ()</div><div class="line">@property (nonatomic, strong) NSString *strongString;</div><div class="line">@property (nonatomic, copy) NSString *copyedString;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>上面的代码声明了两个字符串属性，其中一个内存特性是<code>strong</code>，一个是<code>copy</code>。下面我们来看看它们的区别。</p>
<p>首先，我们用一个不可变字符串来为这两个属性赋值，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)test &#123;</div><div class="line">    NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div><div class="line">    self.strongString = string;</div><div class="line">    self.copyedString = string;</div><div class="line">    NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);</div><div class="line">    NSLog(@&quot;strong string: %p, %p&quot;, strongString, &amp;strongString);</div><div class="line">    NSLog(@&quot;copy string: %p, %p&quot;, copyedString, &amp;copyedString);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7fe441592e20, 0x7fff57519a48</div><div class="line">strong string: 0x7fe441592e20, 0x7fe44159e1f8</div><div class="line">copy string: 0x7fe441592e20, 0x7fe44159e200</div></pre></td></tr></table></figure></p>
<p>我们要以看到，这种情况下，不管是<code>strong</code>还是<code>copy</code>属性的对象，其指向的地址都是同一个，即为<code>string</code>指向的地址。如果我们换作<code>MRC</code>环境，打印<code>string</code>的引用计数的话，会看到其引用计数值是3，即<code>strong</code>操作和<code>copy</code>操作都使原字符串对象的引用计数值加了1。</p>
<p>接下来，我们把<code>string</code>由不可变改为可变对象，看看会是什么结果。即将下面这一句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *string = [NSString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure></p>
<p>改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div></pre></td></tr></table></figure></p>
<p>其输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">origin string: 0x7ff5f2e33c90, 0x7fff59937a48</div><div class="line">strong string: 0x7ff5f2e33c90, 0x7ff5f2e2aec8</div><div class="line">copy string: 0x7ff5f2e2aee0, 0x7ff5f2e2aed0</div></pre></td></tr></table></figure></p>
<p>可以发现，此时<code>copy</code>属性字符串已不再指向<code>string</code>字符串对象，而是深拷贝了<code>string</code>字符串，并让<code>_copyedString</code>对象指向这个字符串。在<code>MRC</code>环境下，打印两者的引用计数，可以看到<code>string</code>对象的引用计数是2，而<code>_copyedString</code>对象的引用计数是1。</p>
<p>此时，我们如果去修改<code>string</code>字符串的话，可以看到：因为<code>_strongString</code>与<code>string</code>是指向同一对象，所以<code>_strongString</code>的值也会跟随着改变(需要注意的是，此时<code>_strongString</code>的类型实际上是<code>NSMutableString</code>，而不是<code>NSString</code>)；而<code>_copyedString</code>是指向另一个对象的，所以并不会改变。</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><p>由于<code>NSMutableString</code>是<code>NSString</code>的子类，所以一个<code>NSString</code>指针可以指向<code>NSMutableString</code>对象，让我们的<code>strongString</code>指针指向一个可变字符串是OK的。</p>
<p>而上面的例子可以看出，当原字符串是<code>NSString</code>时，由于字符串是不可变的，所以，不管是<code>strong</code>还是<code>copy</code>属性的对象，都是指向原对象，<code>copy</code>操作只是做了次浅拷贝。</p>
<p>当原字符串是<code>NSMutableString</code>时，<code>strong</code>属性只是增加了原字符串的引用计数，而<code>copy</code>属性则是对原字符串做了次深拷贝，产生一个新的对象，且<code>copy</code>属性对象指向这个新的对象。另外需要注意的是，这个<code>copy</code>属性对象的类型始终是<code>NSString</code>，而不是<code>NSMutableString</code>，因此其是不可变的。</p>
<p>这里还有一个性能问题，即在原字符串是<code>NSMutableString</code>，<code>strong</code>是单纯的增加对象的引用计数，而<code>copy</code>操作是执行了一次深拷贝，所以性能上会有所差异。而如果原字符串是<code>NSString</code>时，则没有这个问题。</p>
<p>所以，在声明<code>NSString</code>属性时，到底是选择<code>strong</code>还是<code>copy</code>，可以根据实际情况来定。不过，一般我们将对象声明为<code>NSString</code>时，都不希望它改变，所以大多数情况下，我们建议用<code>copy</code>，以免因可变字符串的修改导致的一些非预期问题。</p>
<h4 id="rvm-command-not-found"><a href="#rvm-command-not-found" class="headerlink" title="rvm: command not found"></a>rvm: command not found</h4><p>在Mac上安装好ruby的RVM后，在终端输入时，出现rvm: command not found，经过OverStackFlow上的查找，发现了解决办法：<a href="https://stackoverflow.com/questions/11677771/rvm-command-not-found-mac-ox" target="_blank" rel="external">rvm: command not found MAC OX</a></p>
<p>可能是因为ram的shell配置没有加载，在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.rvm/scripts/rvm</div></pre></td></tr></table></figure></p>
<p>接着输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type rvm | head -n 1</div></pre></td></tr></table></figure></p>
<p>如果输出是<code>rvm is a function</code>，则需要将<code>source ~/.rvm/scripts/rvm</code>添加到<code>~/.bash_profile</code>文件中。</p>
<h4 id="关于HEXO安装失败的解决方法"><a href="#关于HEXO安装失败的解决方法" class="headerlink" title="关于HEXO安装失败的解决方法"></a>关于HEXO安装失败的解决方法</h4><p>目前国内npm源有问题；所以键入如下代码即可安装成功:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</div><div class="line">cnpm install hexo-cli -g</div></pre></td></tr></table></figure>
<h4 id="Mac-iterm2-配色方案"><a href="#Mac-iterm2-配色方案" class="headerlink" title="Mac iterm2 配色方案"></a>Mac iterm2 配色方案</h4><p>iTerm2，更改配色方案为 Solarized：<br>注意：iTerm2 3.0.12（应该比这更早）已经内置 Solarized 的配色方案了，直接在 iTerm2 - Preferences - Profiles - Colors 里面配置就好了</p>
<p>Solarized 的主页：<a href="http://ethanschoonover.com/solarized" target="_blank" rel="external">http://ethanschoonover.com/solarized</a></p>
<p>直接去主页下载或者使用 Git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git://github.com/altercation/solarized.git</div></pre></td></tr></table></figure></p>
<p>然后打开 solarized/iterm2-colors-solarized/ 双击里面的文件<br>遇到的问题<br>终端灰蒙蒙的，就像下面这样</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-b5ce8061f9696756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>下面我们来回到彩色世界：<br>依次打开 iTerm2 - Preferences - Profiles - Text - Text Rendering，将 Draw bold text in bright colors 前面的勾去掉<br>彩色的世界就回来了<br><img src="http://upload-images.jianshu.io/upload_images/588630-5ddfa20a33c4e95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本期主要记录了以下几个问题：&quot;&gt;&lt;a href=&quot;#本期主要记录了以下几个问题：&quot; class=&quot;headerlink&quot; title=&quot;本期主要记录了以下几个问题：&quot;&gt;&lt;/a&gt;本期主要记录了以下几个问题：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NSString属性什么时候用c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>源码管理工具之CornerStone的使用</title>
    <link href="https://sunjinshuai.github.io/2015/08/02/%E6%BA%90%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8BCornerStone%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sunjinshuai.github.io/2015/08/02/源码管理工具之CornerStone的使用/</id>
    <published>2015-08-02T01:41:07.000Z</published>
    <updated>2017-08-02T02:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>俗话说：“工欲善其事必先利其器”；</p>
</blockquote>
<p>对于我们程序员来说，不管你是大神，还是小鱼小虾，进入公司之后，都用过源码管理工具，不然你就不是一个合格的程序员，现在各个公司用于源码管理工具通常有下面两种：</p>
<ul>
<li>git：使用git的公司应该是最多的。</li>
<li>svn：现在使用svn的公司比重也挺大的，但是svn有局限性。</li>
</ul>
<p>当然，他们两者的区别，在这里就不做解释了，一般选择用什么源码管理工具，一般会是整个项目的负责人来选择。<br>在iOS开发中，最好用的svn的Mac版源码管理工具就是<code>Cornerstone</code>，下面介绍<code>CornerStone</code>的使用：</p>
<h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p><code>CornerStone</code>是收费，如果是公司需要使用到，建议让公司购买软件使用版权，支持正版，当然网上也是有破解版本的。<a href="https://pan.baidu.com/s/1mhU7yTq" target="_blank" rel="external">破解版</a>，提取密码(p48z)。</p>
<h4 id="二、配置SVN"><a href="#二、配置SVN" class="headerlink" title="二、配置SVN"></a>二、配置SVN</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-8d4bf8bbbc0a28d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>打开<code>Cornerstone</code>，点击“+”号，添加一个仓库。<br><img src="http://upload-images.jianshu.io/upload_images/588630-c58c78cf39769e4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://192.168.1.11:443/svn/FXBest</div></pre></td></tr></table></figure>
<ul>
<li>Protocol：分为HTTP和HTTPS，如果公司给你服务器地址是HTTPS的话，就选择HTTPS，反之，就选择HTTP。</li>
<li><p>Server：填写服务器地址，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.1.11</div></pre></td></tr></table></figure>
</li>
<li><p>Port：服务器地址中端口号，当然有时候是不需要填写的，使用默认的就可以了，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192.168.1.11:443</div></pre></td></tr></table></figure>
</li>
<li><p>Repository path：svn仓库的访问路径</p>
</li>
<li>NickName：仓库显示的名称</li>
<li>用户名</li>
<li>密码</li>
</ul>
<p>注意：<br>1、填写好之后，会自动生成，这样的一串路径。如果你填写完之后不是这种svn://用户名@主机地址:端口号/路径的格式，则说明填写有误。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://michael@192.168.1.11:443/svn/iOS</div></pre></td></tr></table></figure></p>
<p>2、小技巧，一般进入公司，项目负责人会给你开svn的账号，然后会把svn的路径发给你，拿到这串路径，直接复制一下，然后切换到<code>CornerStone</code>，发现svn的路径会自动填充到<code>CornerStone</code>上面。</p>
<h4 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h4><p>1、上传项目到远端仓库repository<br>可以直接将文件或者文件夹拖到repository的子文件夹中，或是选择软件上方的Import按钮上传，会弹出选项填写所在位置及名称，然后选择Import即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-58d24a6615484248.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>2、下载项目</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-cdb6d44ad35cf50c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意：下载项目，一般分为Export和Check Out。<br>他们的区别在于：</p>
<ul>
<li><code>Export</code>后的项目不会与repository中的源文件相关联，是一个独立的版本。</li>
<li><code>Check Out</code>下来的文件会创建一个working copy，此文件与repository中源文件相关联，当有别人修改或是自己修改时，working copy会显示修改数量，白色数量为别人修改数量，灰色数量为自己修改数量，所以如果你是项目中的开发人员，可以选择<code>check out</code>。</li>
<li>如果只是下载查看，不希望自己的修改影响到整个项目，最好是选<code>Export</code>。</li>
</ul>
<p>3、版本管理<br>每一次提交会创建一个新版本，在repository中会保存所有历史版本，可通过修改人及提交信息进行检索版本，所以用svn开发可以很好的控制项目出现不可解决及未知bug时代码的修复问题，例如：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-2899e643efd55075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>注意事项：</p>
<ul>
<li>先更新后提交，当你看到你<code>check out</code>下来的项目有白色圈时，说明有人已经提交了代码，这个时候，你应该先update一下，直至working copy不再显示白色圈，然后运行一下项目，确保项目没有冲突或者丢失的文件，然后在commit自己的代码。否则，会造成项目中出现多处冲突或者覆盖掉别人提交的代码。</li>
<li>在项目开发阶段，最好每次开发完一个独立的功能，或者在测试阶段，解决一个bug之后再提交代码到svn，不要连续多次重复提交，造成版本过多过杂。并且每次提交时务必填写提交信息，方便查看历史版本。</li>
</ul>
<p>小技巧(svn ignores的使用):<br>在项目中引入第三库，在本地运行项目，发现没有任何问题，但是提交到svn，其他人update之后，在运行项目发现报错，很有可能是静态文件没有上传到svn造成的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-77a24a91a542e166.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-07-16 下午12.02.16.png"></p>
<p>选择Preferences</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-d2d2791b16c1d99b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>勾选Use default global ignores，删除.a后，点击save。<br>然后，会发现check out下来的项目中会有这些问号的文件存在(下面的图只是为了举例使用)，把这些带有问号的文件commit到svn，问题就解决了。<br><img src="http://upload-images.jianshu.io/upload_images/588630-8f4104c6a273c470.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>注意：<br><strong>如果选择要忽略提交的文件之后，不要再把<code>Use default global ignores</code>选中，选中<code>Use default global ignores</code>的意思使用缺省的<code>ignores</code>。</strong></p>
<h4 id="四、CornerStone常见的图标含义"><a href="#四、CornerStone常见的图标含义" class="headerlink" title="四、CornerStone常见的图标含义"></a>四、CornerStone常见的图标含义</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-303b290c0b2c3eac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>如果，你想working copy下来的项目中做了修改，那么在修改之后的文件后面会有一个“M”的标志。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-d5a606137ba9126f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>如果，你想working copy下来的项目中新添加一个文件，那么新添加之后的文件后面会有一个“？”的标志，此时你需要点击add，添加到working copy下来的项目中，然后在commit。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8b6269e6f34ed652.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-9bd6ffcba52705ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>如果，你想working copy下来的项目中删除一个文件，那么删除之后的文件后面会有一个“D”的标志。</p>
<p>如果，你想working copy下来的项目中A和B同时修改了同一行代码然后commit到svn，那么冲突之后的文件后面会有一个“C”的标志。<br>ps：原则上同一组开发人员最好不要在同一文件中进行操作，但有时候必须去其他文件中进行操作，或者是误操作，如果同时多人在同一文件的同一位置修改代码，后提交的人会出现版本冲突文件，一般会有三个同样名称不同后缀的文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-4c4bd6dd3af648a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20150531131942823.png"></p>
<p>其中.mine文件：本人所做修改，两个.r0XX文件：XX为数字，数字较小的为更改前的文件，较大的为更改后的文件，在文件中会有&lt;&lt;&lt;&lt; mine .r0XX和&gt;&gt;&gt;&gt;&gt;等字样包含起来的代码，即冲突的地方，此时请和组内同事讨论或自己删除某部分修改文件后进行调试，修复文件。</p>
<h4 id="五、创建分支和Tag"><a href="#五、创建分支和Tag" class="headerlink" title="五、创建分支和Tag"></a>五、创建分支和Tag</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-323fb2612f2a0c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-6aec248bbacf44dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<ul>
<li>选择项目所在的远程仓库 </li>
<li>选择要创建分支的项目 </li>
<li>右键或者点击上图选择Branch </li>
<li>选择分支存放的路径<br>注意：<br>Branch As：分支的名称<br>Where：把分支存放在什么位置<br>Tag同Branch一样</li>
</ul>
<h4 id="六、Merge"><a href="#六、Merge" class="headerlink" title="六、Merge"></a>六、Merge</h4><p><img src="http://upload-images.jianshu.io/upload_images/588630-8f46ea1c0d11d539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>如果两个分支需要合并到主干，Checkout到本地，点击需要合并到的项.<br>点击Merge<br>点击Sychronize Branch：选择需要从被合并的项目（merge from）合并到这里，然后提交就可以了（如果同时有两个分支，最需仍需要在分支上修改的话，先合并一个分支到主干，然后主干在合并到另一个分支，修改冲突后提交，前提是，刚开始主干和两个分支的代码一样，参考上边的步骤生成）<br>注意：<br>1.在workcopying中选择目标copying，然后点击Merge，如图所示<br>2.选择Mergefrom的copying<br>3.Merge之前cornerstone会进行dry run，进行merge分析和预览<br>4.确认无误后Merge Changes （该操作是本地操作，注意解决冲突后在commit）</p>
<h4 id="七、cornerStone错误异常处理"><a href="#七、cornerStone错误异常处理" class="headerlink" title="七、cornerStone错误异常处理"></a>七、cornerStone错误异常处理</h4><p>1、<img src="http://upload-images.jianshu.io/upload_images/588630-08e8c3600b1ce750.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1272323-46573a888e452b07.jpg"><br>主要是由于你操作异常导致的,解决方案是,把生成的错误文件删除,然后在重新安装一下就可以了。<br><img src="http://upload-images.jianshu.io/upload_images/588630-a1ebe29db3f9ec40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1272323-91a005057575e393.jpg"><br>把红色箭头部分的文件删除就可以了。</p>
<p>2、</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-aa25715016f7b24d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>本地代码版本号与服务器当前最新版本号不一致导致<br>点击update to latest，更新服务器最新的就可以了。</p>
<p>先写这么多，以后遇到问题会有更新。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;俗话说：“工欲善其事必先利其器”；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于我们程序员来说，不管你是大神，还是小鱼小虾，进入公司之后，都用过源码管理工具，不然你就不是一个合格的程序员，现在各个公司用于源码管理工具通常有下面两种：&lt;/p&gt;
&lt;u
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Object-C编码规范</title>
    <link href="https://sunjinshuai.github.io/2015/05/05/Object-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://sunjinshuai.github.io/2015/05/05/Object-C编码规范/</id>
    <published>2015-05-05T09:24:55.000Z</published>
    <updated>2017-07-05T09:48:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>1、任意函数长度不得超过50行。<br>2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。</p>
<p>3、在定义函数的行前留白一行。<br>4、功能相近的代码要放在一起。<br>5、使用#pragma来切分不同功能区域的代码。<br>6、二元运算符和参数之间需要放置一个空格，一元运算符、强制类型转换和参数之间不放置空格。关键字之后圆括号之前需要放置一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void *ptr = &amp;value + 10 * 3;</div><div class="line">NSString *str1 = (NSString *)str2;</div><div class="line">for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">	[self doSomeThing];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>7、长的字面值应被拆分为多行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSArray *theShit = @[</div><div class="line">    @&quot;Got some long string objects in here.&quot;,</div><div class="line">    [AndSomeModelObjects too],</div><div class="line">    @&quot;Moar strings.&quot;</div><div class="line">];</div><div class="line"></div><div class="line">NSDictionary *keyedShit = @&#123;</div><div class="line">    @&quot;this.key&quot;: @&quot;corresponds to this value&quot;,</div><div class="line">    @&quot;otherKey&quot;: @&quot;remoteData.payload&quot;,</div><div class="line">    @&quot;some&quot;: @&quot;more&quot;,</div><div class="line">    @&quot;JSON&quot;: @&quot;keys&quot;,</div><div class="line">    @&quot;and&quot;: @&quot;stuff&quot;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><p>命名是编程中最基本的技能，我们给变量、函数、类、包等等命名。给他们以名字，让他们有意义，既能表示他们到底是做什么的，也能将其与其他变量区别开来。像人一样娶一个好名字至关重要，“丁当”总比“狗蛋”来的好听。 为什么要命名？ <strong>命名一定要“名副其实”，尽可能使用有意的名称，而且这个意义和指称的变量真实意义相关。</strong><br>1、基本原则<br>尽量不要出现没有任何意义的命名类似于下述形式的命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = 1;</div><div class="line">int b = 3;</div><div class="line">CGPoint point = CGPointMake(a,b);</div></pre></td></tr></table></figure></p>
<p>如果换成下面的形式是不是可读性强了很多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int startX = 1;</div><div class="line">int startY = 3;</div><div class="line">CGPoint startPoint = CGPointMake(startX,startY);</div></pre></td></tr></table></figure></p>
<p>命名首字母大写，其他命名首字母小写。并且采用驼峰格式分割单词。 例如：<code>FXTest</code><br>仿照 Cocoa 风格来，使用长命名风格。<br>变量命名推荐的命名语素顺序是：最开头是命名空间简写，然后越重要、区别度越大的语素越要往前放。经典的结构是：作用范围+限定修饰+类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">extern ushort APIDefaultPageSize;        // 还行，能明白意思了</div><div class="line">extern ushort APIDefaultFetchPageSize;   // 加上些限定更好一些</div><div class="line">extern ushort APIFetchPageSizeDefault;   // 再好些，把重要的往前放</div><div class="line">FXToolbarComment    // 不推荐</div><div class="line">FXCommentToolbar    // OK，把类型（toolbar）置后</div></pre></td></tr></table></figure></p>
<p>2、类别的扩展名以“被扩展的类名+自定义命名部分组成” 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSSstring+Utils.h</div></pre></td></tr></table></figure></p>
<p>3、通知命名<br>基本命名格式是：<code>与通知相关的类名</code> + <code>Did | Will</code> + <code>UniquePartOfName</code> + <code>Notification</code>，例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSApplicationDidBecomeActiveNotification</div><div class="line">NSWindowDidMiniaturizeNotification</div><div class="line">NSTextViewDidChangeSelectionNotification</div><div class="line">NSColorPanelColorDidChangeNotification</div></pre></td></tr></table></figure></p>
<p>4、宏定义，全部字母大写，例如: <code>#define BW_DEBUG 1</code><br>5、常量定义，字符串定义以小写字母k开头，随后首字母大写，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static NSString* const kBWBarTitle = @&quot;动态&quot;;</div></pre></td></tr></table></figure></p>
<p>ps：如果要定义常量使用static const优于宏定义，前者会进行类型检查。<br>6、缩略词，以下是一些常用的首字母缩略词：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ASCII,PDF,XML,HTML,URL,RTF,HTTP,TIFF,JPG,PNG,GIF,LZW,ROM,RGB,CMYK,MIDI,FTP</div></pre></td></tr></table></figure></p>
<p>7、命名空间，因为OC没有命名空间的概念，所以使用前两个或者多个字母来表示命名空间，例如<code>&quot;NSObject中的NS&quot;</code>，我们也使用自己的命名空间。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">发现模块：DiscoverController，模块里面其他的控件或者model，DCModel，DCView</div><div class="line">个人中心模块：PersonalCenterViewController，模块里面其他的控件或者model，PCModel，PCView</div></pre></td></tr></table></figure></p>
<h4 id="点标记语法"><a href="#点标记语法" class="headerlink" title="点标记语法"></a>点标记语法</h4><p>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [UIColor orangeColor];</div><div class="line">[UIApplication sharedApplication].delegate;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[UIColor orangeColor]];</div><div class="line">UIApplication.sharedApplication.delegate;</div></pre></td></tr></table></figure></p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>1、方法命名尽可能清晰<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">insertObject:atIndex:</div><div class="line">removeObjectAtIndex:</div><div class="line">removeObject:</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insert:at:</div><div class="line">remove:</div></pre></td></tr></table></figure></p>
<p>2、类方法声明在方法类型与返回类型之间要有空格。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)methodName:(NSString *)string;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)methodName:(NSString *)string;</div></pre></td></tr></table></figure></p>
<p>3、函数<br>(1)、调用时所有参数应该在同一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</div></pre></td></tr></table></figure></p>
<p>(2)、或者每行一个参数，以冒号对齐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1</div><div class="line">                   name:arg2</div><div class="line">                   error:arg3];</div></pre></td></tr></table></figure></p>
<p>对于参数过多的函数，尽量使用后面一种对其方式。<br>(3)、不要使用下面的缩进风格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[myObject doFooWith:arg1 name:arg2  // some lines with &gt;1 arg</div><div class="line">              error:arg3];</div><div class="line">[myObject doFooWith:arg1</div><div class="line">               name:arg2 error:arg3];</div><div class="line">[myObject doFooWith:arg1</div><div class="line">          name:arg2  // aligning keywords instead of colons</div><div class="line">          error:arg3];</div></pre></td></tr></table></figure></p>
<p>(4)、如果对传入参数进行数据保护尽量不要用<code>if(!objc)</code>，使用断言来处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)sendArgs:(NSDictionary*)args &#123;</div><div class="line">	NSAssert(args, @&quot;args is nil&quot;);</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(5)、方法参数名前一般使用的前缀包括“the”、“an”、“new”。示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setTitle:(NSString *)aTitle;</div><div class="line">- (void)setName:(NSString *)newName;</div><div class="line">- (id)keyForOption:(CDCOption *)anOption</div><div class="line">- (NSArray *)emailsForMailbox:(CDCMailbox *)theMailbox;</div><div class="line">- (CDCEmail *)emailForRecipients: (NSArray *)theRecipients;</div></pre></td></tr></table></figure></p>
<p>4、方法名<br>以 <code>alloc</code>、<code>copy</code>、<code>init</code>、<code>mutableCopy</code>、<code>new</code> 开头的方法要注意，它们会改变ARC的行为。<br>以 <code>get</code>、<code>set</code> 开头的方法有特殊的意义，不要随意定义。</p>
<ul>
<li><code>set</code> 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 <code>set</code> 开头，可用 <code>setup</code> 替代。</li>
<li><code>get</code> 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如：<code>userInfomation</code>，而不是 <code>getUserInfomation</code>。<br>例：<br>推荐：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (NSString *)name;</div><div class="line">- (void)getName:(NSString **)buffer range:(NSRange)inRange;</div><div class="line">- (NSSize)cellSize;</div><div class="line">- (void)setupControllerObservers;</div><div class="line">- (void)setupController;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)getName;</div><div class="line">- (NSSize)calcCellSize;</div><div class="line">- (void)setController;</div></pre></td></tr></table></figure></p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>长的三元运算符应使用圆括号括起来。三元运算符仅用于赋值和做参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *gender = (stuff == thing ? @&quot;男&quot; : @&quot;女&quot;);</div></pre></td></tr></table></figure></p>
<p>当有nil时的三元运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *name = thingThatCouldBeNil ? defaultValue : @&quot;&quot;;</div></pre></td></tr></table></figure></p>
<p>不推荐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *name = thingThatCouldBeNil ?: defaultValue;</div></pre></td></tr></table></figure></p>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>当使用<code>enum</code>关键字时，推荐使用苹果最新引入的固定基础类型语法，因为这将获得强类型检查与代码完成功能。SDK现在包含了一个固定基础类型的宏—<code>NS_ENUM()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, CertifiedModifyPassWordType)</div><div class="line">&#123;</div><div class="line">    CertifiedModifyPassWordTypeWithdrawals = 1,  // 提现</div><div class="line">    CertifiedModifyPassWordTypePaymentFail,  // 支付失败</div><div class="line">    CertifiedModifyPassWordTypePayment, // 支付</div><div class="line">    CertifiedModifyPassWordTypeOther</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>因为nil被解析为了NO，所以和nil作比较没有任何的必要。不要将变量和YES直接比较，因为YES被定义为1而BOOL类型是8位的unsigned int，即BOOL的值不仅仅是1或0。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (!someObject) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (someObject == nil) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (isAwesome)</div><div class="line">if (![someObject boolValue])</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if ([someObject boolValue] == NO)</div><div class="line">if (isAwesome == YES) // Never do this.</div></pre></td></tr></table></figure></p>
<h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><p>应该使用线程安全的模式创建共享的单例实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedInstance &#123;</div><div class="line">   static id sharedInstance = nil;</div><div class="line">   static dispatch_once_t onceToken;</div><div class="line">   dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">      sharedInstance = [[self alloc] init];</div><div class="line">   &#125;);</div><div class="line">   return sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单例的另一种做法，利用+ initialize方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static JSONAPI* sharedInstance = nil;</div><div class="line">+ (void)initialize &#123;</div><div class="line">    static dispatch_once_t once;</div><div class="line">    dispatch_once(&amp;once, ^&#123;</div><div class="line">        sharedInstance = [[JSONAPI alloc] init];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="Block相关"><a href="#Block相关" class="headerlink" title="Block相关"></a>Block相关</h4><p>在block中使用到self变量的时候，一定要先weak再strong。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">[self doABlockOperation:^&#123;</div><div class="line">    __strong typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">    if (strongSelf) &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<h4 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h4><p>代理协议名，常用delegate、dateSource做结尾。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</div><div class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</div></pre></td></tr></table></figure></p>
<p>以<code>did</code>、<code>will</code>、<code>should</code>等形容词，代表Event事件的Delegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)windowShouldClose:(id)sender;</div><div class="line">- (void)browserDidScroll:(NSBrowser *)sender;</div><div class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;</div></pre></td></tr></table></figure></p>
<h4 id="控制结构，if-else"><a href="#控制结构，if-else" class="headerlink" title="控制结构，if-else"></a>控制结构，if-else</h4><p>1、方法的花括号推荐另起一行。方法内部需要写在一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)methodName:(NSString *)string &#123;</div><div class="line">    if () &#123;</div><div class="line">    &#125; else &#123;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、条件判断的括号内侧不应有空格。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (a &lt; b) &#123;</div><div class="line">    // something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( a &lt; b ) &#123;</div><div class="line">    // something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、关系运算符（如<code>&gt;=</code>、<code>!=</code>）和逻辑运算符（如<code>&amp;&amp;</code>、<code>||</code>）两边要有空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(someValue &gt; 100) ? YES : NO</div></pre></td></tr></table></figure></p>
<p>二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。<br>多个参数逗号后留一个空格（这也符合正常的西文语法）。<br>4、当需要满足一定条件时才执行某项操作时，使用return是正常合理的。<br>推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if (![someOther boolValue]) &#123;</div><div class="line">      return;</div><div class="line">  &#125;</div><div class="line">  //Do something important</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!error) &#123;</div><div class="line">    return success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)someMethod &#123;</div><div class="line">  if ([someOther boolValue]) &#123;</div><div class="line">      //Do something important</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">if (!error)</div><div class="line">    return success;</div><div class="line">...</div><div class="line">if (!error) return success;</div></pre></td></tr></table></figure></p>
<h4 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h4><p>UIView的子类初始化的时候，不要进行任何布局操作。布局操作在LayoutSubViews里面做。<br>UIView的子类布局必须在layoutSubViews里面进行，需要布局的时候调用setNeedLayout来告诉系统，需要重新布局该View，不要直接调用layoutSubViews。</p>
<h4 id="class"><a href="#class" class="headerlink" title="@class"></a>@class</h4><p>在类定义中使用到自己定义的类的时候，尽量不要在头文件中引入自己定义的类的同文件，使用@class替换。在实现文件中引入相应头文件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// BWTest.h</div><div class="line">@class BWDataCenter;</div><div class="line">@interface BWTest : NSObject</div><div class="line">@property (nonatomic, strong) BWDataCenter* dataCenter;</div><div class="line">@end</div><div class="line"></div><div class="line">// BWTest.m</div><div class="line">#import &quot;BWDataCenter.h&quot;</div><div class="line">@implementation BWTest</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<h4 id="项目工程文件"><a href="#项目工程文件" class="headerlink" title="项目工程文件"></a>项目工程文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#pragma mark - init Method</div><div class="line">填入init,initWithFrame等方法</div><div class="line">#pragma mark- View Life Cycle</div><div class="line">填入viewdidload,viewdidappear等方法</div><div class="line">#pragma mark- Delegate，DataSource, Callback Method</div><div class="line">填入tableview，scrollview等代理方法</div><div class="line">#pragma mark- Override Parent Methods</div><div class="line">填入updateViewConstraints,updateConstraint, prepareForSegue等方法</div><div class="line">#pragma mark- SubViews Configuration</div><div class="line">填入configureSubViews，configureTableView等方法，这里的方法在init方法或view life cycle被调用</div><div class="line">#pragma mark- Actions</div><div class="line">填入-(IBAction)action:(id)sender和[self addtarget:self action:@selector(action:)]动作指向的方法</div><div class="line">#pragma mark- Public Methods</div><div class="line">填入在.h外暴露的方法</div><div class="line">#pragma mark- Private Methods</div><div class="line">填入.m文件内部调用的方法</div><div class="line">#pragma mark- Getter Setter</div><div class="line">填入对@property初始化的方法</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;格式&quot;&gt;&lt;a href=&quot;#格式&quot; class=&quot;headerlink&quot; title=&quot;格式&quot;&gt;&lt;/a&gt;格式&lt;/h4&gt;&lt;p&gt;1、任意函数长度不得超过50行。&lt;br&gt;2、任意行代码不得超过80字符。可以在设置中设置超过80个字符的提醒。&lt;/p&gt;
&lt;p&gt;3、在定义函数
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通知中心(NSNotificationCenter)的实现原理</title>
    <link href="https://sunjinshuai.github.io/2014/12/07/%E9%80%9A%E7%9F%A5%E4%B8%AD%E5%BF%83-NSNotificationCenter-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2014/12/07/通知中心-NSNotificationCenter-的实现原理/</id>
    <published>2014-12-07T06:54:58.000Z</published>
    <updated>2017-08-07T07:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通知解决的问题"><a href="#通知解决的问题" class="headerlink" title="通知解决的问题"></a>通知解决的问题</h4><ul>
<li><p>可以实现跨层的传递，例如A页面跳转到B页面，B页面再跳转到C页面，这时候如果我们通过委托回调的模式让A知道C的一些修改，那么实现起来就会很麻烦。</p>
</li>
<li><p>可以实现一对多，<code>NSNotification</code>的实现是一种观察者模式，因此可以对通知实现广播。</p>
</li>
</ul>
<h4 id="NSNotificationCenter的实现原理"><a href="#NSNotificationCenter的实现原理" class="headerlink" title="NSNotificationCenter的实现原理"></a>NSNotificationCenter的实现原理</h4><p><code>NSNotificationCenter</code>就相当于一个广播站，使用defaultCenter来获取通知中心，通知中心实际上是iOS程序内部之间的一种消息广播机制，主要为了解决应用程序内部不同对象之间<strong>解耦</strong>而设计。它是基于观察者模式设计的，不能跨应用程序进程通信，当通知中心接收到消息之后会根据内部的消息转发表，将消息发送给订阅者；它可以向应用任何地方发送和接收通知。在通知中心注册观察者，发送者使用通知中心广播时，以<code>NSNotification</code>的<code>name</code>和<code>object</code>来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</p>
<h4 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h4><p><code>NSNotification</code>是通知中心<code>NSNotificationCenter</code>接收到消息之后根据内部的消息转发表，将消息发送给订阅者封装的对象；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</div><div class="line">//这个成员变量是这个消息对象的唯一标识，用于辨别消息对象</div><div class="line">@property (readonly, copy) NSString *name;</div><div class="line">// 这个成员变量定义一个对象，可以理解为针对某一个对象的消息，代表通知的发送者</div><div class="line">@property (nullable, readonly, retain) id object;</div><div class="line">//这个成员变量是一个字典，可以用其来进行传值</div><div class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</div><div class="line"></div><div class="line">// 初始化方法</div><div class="line">- (instancetype)initWithName:(NSString *)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo NS_AVAILABLE(10_6, 4_0) NS_DESIGNATED_INITIALIZER;</div><div class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><strong>在通知中心注册观察者，发送者使用通知中心广播时，以<code>NSNotification</code>的<code>name</code>和<code>object</code>来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</strong> 因为属性都是只读的，如果要创建消息时要用下面<code>NSNotification(NSNotificationCreation)</code>分类相应的方法进行初始化；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface NSNotification (NSNotificationCreation)</div><div class="line"></div><div class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject;</div><div class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</div><div class="line"></div><div class="line">- (instancetype)init /*NS_UNAVAILABLE*/;    /* do not invoke; not a valid initializer for this class */</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/" target="_blank" rel="external">http://nshipster.com/nsnotification-and-nsnotificationcenter/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;通知解决的问题&quot;&gt;&lt;a href=&quot;#通知解决的问题&quot; class=&quot;headerlink&quot; title=&quot;通知解决的问题&quot;&gt;&lt;/a&gt;通知解决的问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以实现跨层的传递，例如A页面跳转到B页面，B页面再跳转到C页面，这时候如果我们通
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之block的实现原理</title>
    <link href="https://sunjinshuai.github.io/2014/07/10/block%E7%B3%BB%E5%88%97%E4%B9%8Bblock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://sunjinshuai.github.io/2014/07/10/block系列之block的实现原理/</id>
    <published>2014-07-10T15:07:10.000Z</published>
    <updated>2017-08-07T07:27:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过下面几个例子，探讨block是如何实现的：</p>
<h4 id="例子1："><a href="#例子1：" class="headerlink" title="例子1："></a>例子1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  void (^blk)(void) = ^&#123;</div><div class="line">    printf(&quot;Hello, World!\n&quot;);</div><div class="line">  &#125;;</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了研究编译器是如何实现 <code>block</code> 的，我们需要使用 <code>clang</code>。<code>clang</code> 提供一个命令，可以将 Objetive-C 的源码改写成 c 语言的，借此可以研究 <code>block</code> 具体的源码实现方式。该命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc block.c</div></pre></td></tr></table></figure>
<p>转化之后，生成block.app：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>block</code>在<code>clang</code>编译器编译之后，生成了一个<code>__block_impl</code>结构体，<code>isa</code>指针表明了<code>block</code>可以是一个对象，而<code>FuncPtr</code>指针显然是<code>block</code>对应的函数指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  printf(&quot;Hello, World!\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们就具体看一下是如何实现的，<code>__main_block_impl_0</code> 就是该 <code>block</code> 的实现，从中我们可以看出：</p>
<ul>
<li><code>__main_block_impl_0</code>中包含了两个成员变量和一个构造函数，成员变量分别是<code>__block_impl</code>结构体和描述信息<code>__main_block_desc_0</code>，之后在构造函数中初始化<code>block</code>的类型信息和函数指针等信息。</li>
<li><code>__main_block_func_0</code>函数，即<code>block</code>对应的函数体。该函数接受一个<code>__cself</code>参数，即对应的<code>block</code>自身。</li>
<li><code>__main_block_desc_0</code>结构体，其中<code>Block_size</code>存储<code>block</code>大小。<br>从上面代码，可以看出执行block就是调用一个以block自身作为参数的函数，这个函数对应着block的执行体。</li>
</ul>
<h4 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h4><p>block如何捕获变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">  int i = 1024;</div><div class="line">  void (^blk)(void) = ^&#123;</div><div class="line">    printf(&quot;%d&quot;,i);</div><div class="line">  &#125;;</div><div class="line">  blk();</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int i;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int i = __cself-&gt;i; // bound by copy</div><div class="line">  printf(&quot;%d&quot;,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int i = 1024;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出这次的<code>block</code>结构体<code>__main_block_impl_0</code>多了个成员变量<code>i</code>，用来存储使用到的局部变量<code>i</code>。当在 <code>block</code> 中引用的变量<code>i</code>的时候，实际是在声明 <code>block</code> 时，被<code>copy</code>到<code>__main_block_impl_0</code>结构体中的那个成员变量<code>i</code>，并且把<code>__cself</code>指针指向成员变量<code>i</code>。</p>
<p>如果尝试修改局部变量，编译会报错：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-121cf0b90c682d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p><strong>错误原因告诉我们变量不可赋值，也提醒我们要使用__block类型标识符。</strong><br>因为<code>main</code>函数中的局部变量<code>i</code>和函数<code>__main_block_func_0</code>不在同一个作用域中，调用过程中只是进行了值传递。当然，在上面代码中，我们可以通过指针来实现局部变量的修改。不过这是由于在调用<code>__main_block_func_0</code>时，<code>main</code>函数栈还没展开完成，变量<code>i</code>还在栈中。但是在很多情况下，<code>block</code>是作为参数传递以供后续回调执行的。通常在这些情况下，<code>block</code>被执行时，定义时所在的函数栈已经被展开，局部变量已经不在栈中了已经被销毁了，再用指针访问就会报常见的<strong>坏内存访问</strong>。</p>
<h4 id="例子3："><a href="#例子3：" class="headerlink" title="例子3："></a>例子3：</h4><p><code>__block</code>类型变量是如何支持修改。<br>int类型变量加上<code>__block</code>指示符，使得变量i可以在block函数体中被修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __block int i = 1024;</div><div class="line">    void (^blk)(void) = ^&#123;</div><div class="line">        i = 1023;</div><div class="line">        printf(&quot;%d&quot;,i);</div><div class="line">    &#125;;</div><div class="line">    blk();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过clang编译之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line">  (i-&gt;__forwarding-&gt;i) = 1023;</div><div class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 1024&#125;;</div><div class="line">    void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从中可以看出，多出了一个<code>__Block_byref_i_0</code> 的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __Block_byref_i_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_i_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>__isa</code>指针也可以知道<code>__Block_byref_i_0</code>也可以是对象。</li>
<li><code>__forwarding</code>指针指向<code>__Block_byref_i_0</code></li>
<li>成员变量<code>i</code>，用来存储使用到的局部变量<code>i</code>。</li>
</ul>
<p><code>__main_block_impl_0</code>对应的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_i_0 *i; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref</div><div class="line">  (i-&gt;__forwarding-&gt;i) = 1023;</div><div class="line">  printf(&quot;%d&quot;,(i-&gt;__forwarding-&gt;i));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>__main_block_impl_0</code>的成员变量<code>i</code>变成了<code>__Block_byref_i_0*</code>指针类型。</li>
<li><code>__Block_byref_i_0</code>指针类型变量<code>i</code>，通过其成员变量<code>__forwarding</code>指针来操作另一个成员变量。</li>
</ul>
<p>注意：<br><code>__Block_byref_i_0</code>类型变量i仍然处于栈上，当block被回调执行时，变量i所在的栈已经被展开。<br>查看<code>__main_block_desc_0</code>结构体，发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div></pre></td></tr></table></figure>
<p>此时，<code>__main_block_desc_0</code>多了两个成员函数：<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code>。</p>
<p>当<code>block</code>从栈上被<code>copy</code>到堆上时，会调用<code>__main_block_copy_0</code>将<code>__block</code>类型的成员变量i从栈上复制到堆上；而当<code>block</code>被释放时，相应地会调用<code>__main_block_dispose_0</code>来释放<code>__block</code>类型的成员变量i。如果栈上和堆上同时对该变量进行操作，<code>__forwarding</code>的作用就体现出来了，当一个<code>__block</code>变量从栈上被复制到堆上时，栈上的那个<code>__Block_byref_i_0</code>结构体中的<code>__forwarding</code>指针也会指向堆上的结构。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="external">iOS中block实现的探究</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过下面几个例子，探讨block是如何实现的：&lt;/p&gt;
&lt;h4 id=&quot;例子1：&quot;&gt;&lt;a href=&quot;#例子1：&quot; class=&quot;headerlink&quot; title=&quot;例子1：&quot;&gt;&lt;/a&gt;例子1：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之block的存储域</title>
    <link href="https://sunjinshuai.github.io/2014/07/07/block%E7%B3%BB%E5%88%97%E4%B9%8Bblock%E7%9A%84%E5%AD%98%E5%82%A8%E5%9F%9F/"/>
    <id>https://sunjinshuai.github.io/2014/07/07/block系列之block的存储域/</id>
    <published>2014-07-07T13:03:50.000Z</published>
    <updated>2017-07-05T08:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Objective-C 语言中，根据Block对象创建时所处数据区不同而进行区别，一共有 3 种类型的 block：</p>
<ul>
<li><code>_NSConcreteGlobalBlock</code> 全局的静态 block，不会访问任何外部变量，它是设置在程序的数据区域（.data区）中。</li>
<li><code>_NSConcreteStackBlock</code> 保存在栈中的 block，当函数返回时会被销毁，超出变量作用域，栈上的Block以及  __block变量都被销毁。</li>
<li><code>_NSConcreteMallocBlock</code> 保存在堆中的 block，当引用计数为 0 时会被销毁，在变量作用域结束时不受影响。</li>
</ul>
<p>在ARC的环境下，block默认是从栈区copy到堆区。<br>栈上的block，如果其所属的变量作用域结束，该block就被废弃，如同一般的自动变量。当然，block中的__block变量也同时被废弃。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-8ef4fee05adf7961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
<p>在ARC的环境下，为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们需要把block复制到堆中，延长其生命周期。大多数情况下编译器会恰当地进行判断是否有需要将block从栈复制到堆，如果有，自动生成将block从栈上复制到堆上的代码。block的复制操作执行的是copy实例方法。Block只要调用了copy方法，栈块就会变成堆块。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-f9ba1bdcc5db00f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图示"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Objective-C 语言中，根据Block对象创建时所处数据区不同而进行区别，一共有 3 种类型的 block：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_NSConcreteGlobalBlock&lt;/code&gt; 全局的静态 block，不会访问任何外部变量，它是设置
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之避免循环引用__weak与__strong的区别</title>
    <link href="https://sunjinshuai.github.io/2014/07/06/block%E7%B3%BB%E5%88%97%E4%B9%8B%E9%81%BF%E5%85%8D%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8-weak%E4%B8%8E-strong%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sunjinshuai.github.io/2014/07/06/block系列之避免循环引用-weak与-strong的区别/</id>
    <published>2014-07-06T08:04:47.000Z</published>
    <updated>2017-07-05T08:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>抛砖引玉：<br>我们一般都会遇到这样的问题，当A对象里面强引用了B对象，B对象又强引用了A对象，这样两者的retainCount值一直都无法为0。无论是A对象还是B对象销毁，A对象和B对象始终存在在内存无法中释放，从而导致内存泄露。</p>
<p>所谓的内存泄露就是本应该释放的对象，在其生命周期结束之后依旧存在。</p>
<p>首先，先看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  [weakSelf doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在OC中，block是一个很实用的语法，特别是与GCD结合使用，可以很方便的实现多线程的并发。但是，如果使用不当，block也会引起一些循环引用的问题。</p>
<p><strong>__weak的出现就是为了解决在使用block时出现的循环引用问题。</strong>在使用block的时候，由于self是被强引用的，在ARC下，编译器自动将代码中的block从栈拷贝到堆时，block会强引用和持有self，而self恰好也强引用和持有了block，就造成了传说中的循环引用。在上面的代码中，在doSomething方法内，weakSelf不会被释放。<br>但是，像下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  [weakSelf doSomething];</div><div class="line">  [weakSelf doOtherThing];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在doSomething中，weakSelf不会变成nil，不过在doSomething执行完成，调用第二个方法doOtherThing的时候，weakSelf有可能被释放。</p>
<p><strong>__strong的出现为了保证在block内不会被释放。</strong>__strong表示强引用，当对象没有任何一个强引用指向它时，它才会被释放。weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__weak __typeof__(self) weakSelf = self;</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">  __strong __typeof(self) strongSelf = weakSelf;</div><div class="line">  [strongSelf doSomething];</div><div class="line">  [strongSelf doOtherThing];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 block 之前定义对 self 的一个弱引用 wself，因为是弱引用，所以当 self 被释放时 wself 会变为 nil；然后在 block 中引用该弱应用，<strong>考虑到多线程情况</strong>,通过使用强引用 self 来引用该弱引用，这时如果 self 不为 nil 就会 retain self，以防止在后面的使用过程中 self 被释放；然后在之后的 block 块中使用该强引用 self，注意在使用前要对 self 进行了 nil 检测，因为多线程环境下在用弱引用 wself 对强引用 sself 赋值时，弱引用 wself 可能已经为 nil 了。<br>通过这种手法，block 就不会持有 self 的引用，从而打破了循环引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;抛砖引玉：&lt;br&gt;我们一般都会遇到这样的问题，当A对象里面强引用了B对象，B对象又强引用了A对象，这样两者的retainCount值一直都无法为0。无论是A对象还是B对象销毁，A对象和B对象始终存在在内存无法中释放，从而导致内存泄露。&lt;/p&gt;
&lt;p&gt;所谓的内存泄露就是本应该
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block系列之block基础</title>
    <link href="https://sunjinshuai.github.io/2014/07/05/block%E7%B3%BB%E5%88%97%E4%B9%8Bblock%E5%9F%BA%E7%A1%80/"/>
    <id>https://sunjinshuai.github.io/2014/07/05/block系列之block基础/</id>
    <published>2014-07-05T08:01:25.000Z</published>
    <updated>2017-07-05T08:23:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>block是C语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。block在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它的由来和使用方法。</p>
<h4 id="block由来"><a href="#block由来" class="headerlink" title="block由来"></a>block由来</h4><p>先来看看C语言中标准的函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int func(int count);</div></pre></td></tr></table></figure>
<p>它声明了名称为func的函数。下面看看怎么调用的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int result = func(10);</div></pre></td></tr></table></figure>
<p>如果你知道函数指针，那么应该熟悉下面这个式子，它不用知道函数名也能够使用函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int result = （*funcptr）(10);</div></pre></td></tr></table></figure>
<p>但是，实际上仍然需要知道函数的名称。在赋值函数指针时还是需要知道函数名称的，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int *funcptr (int)= &amp;func;</div></pre></td></tr></table></figure>
<p>为什么需要函数指针呢？<br>函数指针是为了获取函数的地址方便将函数作为参数时的调用.<br>为什么会出现匿名函数？<br>是为了代替函数指针，简化函数的书写。<br>block可以真正的实现不需要函数名称的函数，方便了函数的调用。通俗的讲block就是一段匿名代码块。</p>
<p>完整的block语法是如下形式：<br>block的声明格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">返回值类型 (^blockName)(参数列表);</div><div class="line">// block的声明</div><div class="line">int (^sumblock)(int arg1, int arg2);</div><div class="line">void (^blockName)(int arg1, int arg2)</div></pre></td></tr></table></figure>
<p>block的定义格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">返回值类型 (^block变量名)(形参列表) = ^(形参列表) &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>声明并使用block<br>开发者使用^操作符声明block变量，^表示是一个block的开始。block的body体在{ }之内。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int multiplier = 7;</div><div class="line">int (^myblock)(int) = ^(int num) &#123;</div><div class="line">  return num * multiplier;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/588630-08c2619e323632fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>block可以使用“在其定义作用范围内的”变量；如果你声明了一个block变量，可以像函数一样使用它。</p>
<h4 id="block的用法"><a href="#block的用法" class="headerlink" title="block的用法"></a>block的用法</h4><p>无参数无返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void (^blockName)() = ^&#123;</div><div class="line">  NSLog(@&quot;无参数,无返回值的block&quot;);</div><div class="line">&#125;;</div><div class="line">blockName();</div></pre></td></tr></table></figure></p>
<p>有参数无返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void (^blockName)(int a, int b) = ^(int a, int b) &#123;</div><div class="line">  NSLog(@&quot;%d + %d = %d&quot;,a,b,a+b);</div><div class="line">&#125;;</div><div class="line">blockName(10,10);</div></pre></td></tr></table></figure></p>
<p>有参数有返回值的block<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int (^sumblock)(int a, int b) = ^(int a, int b)&#123;</div><div class="line">  return a + b;</div><div class="line">&#125;;</div><div class="line">int sum = sumblock(10,10);</div><div class="line">NSLog(@&quot;sum = %d&quot;,sum);</div></pre></td></tr></table></figure></p>
<p>block结合typedef使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">typedef int (^sumblock)(int, int);</div><div class="line"></div><div class="line">interface ViewController ()</div><div class="line">property (nonatomic, copy, nonnull) sumblock sumblock;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  self.sumblock = ^(int a, int b) &#123;</div><div class="line">    return a + b;</div><div class="line">  &#125;;</div><div class="line">  NSLog(@&quot;sum = %d&quot;,self.sumblock(10,10));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>block作为函数参数<br>block作为C函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1.定义一个形参为block的C函数</div><div class="line">void useblockForC(int(^ablock)(int, int))</div><div class="line">&#123;</div><div class="line">  NSLog(@&quot;result = %d&quot;, ablock(300,200));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.声明并赋值定义一个block变量</div><div class="line">int(^addblock)(int, int) = ^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 3.以block作为函数参数,把block像对象一样传递</div><div class="line">useblockForC(addblock);</div><div class="line"></div><div class="line">// 将第2点和第3点合并一起,以内联定义的block作为函数参数</div><div class="line">useblockForC(^(int x, int y) &#123;</div><div class="line">  return x+y;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>block作为OC函数参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 1.定义一个形参为block的OC函数</div><div class="line">- (void)useblockForOC:(int(^)(int, int))ablock</div><div class="line">&#123;</div><div class="line">  NSLog(@&quot;result = %d&quot;, ablock(300,200));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 2.声明并赋值定义一个block变量</div><div class="line">int(^addblock)(int, int) = ^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 3.以block作为函数参数,把block像对象一样传递</div><div class="line">[self useblockForOC:addblock];</div><div class="line"></div><div class="line">// 将第2点和第3点合并一起,以内联定义的block作为函数参数</div><div class="line">[self useblockForOC:^(int x, int y)&#123;</div><div class="line">  return x+y;</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;block是C语言的扩充功能，也被称为带有自动变量(局部变量)的匿名函数。block在网络请求的回调中起着举足轻重的作用。下面就来一步步的探索它的由来和使用方法。&lt;/p&gt;
&lt;h4 id=&quot;block由来&quot;&gt;&lt;a href=&quot;#block由来&quot; class=&quot;headerli
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HEXO搭建个人博客</title>
    <link href="https://sunjinshuai.github.io/2014/07/04/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://sunjinshuai.github.io/2014/07/04/HEXO搭建个人博客/</id>
    <published>2014-07-04T13:41:47.000Z</published>
    <updated>2017-07-04T14:39:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点会使用，并不难，但是要做到让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢。最近看到一些大神们的博客，貌似都是用hexo写得，本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>安装homebrew</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure>
<p>安装git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install git</div></pre></td></tr></table></figure></p>
<p>安装node<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install node</div></pre></td></tr></table></figure></p>
<p>安装hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure></p>
<h4 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h4><p>创建新建一个文件夹，用来存放本地博客。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo init</div><div class="line">npm install</div></pre></td></tr></table></figure>
<p>Hexo会在创建的文件夹创建本地博客所需的一切资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server</div></pre></td></tr></table></figure></p>
<p>访问本地localhost:4000可以看到博客已经搭建成功。</p>
<h4 id="同步Hexo博客到Github"><a href="#同步Hexo博客到Github" class="headerlink" title="同步Hexo博客到Github"></a>同步Hexo博客到Github</h4><ul>
<li>在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。</li>
<li>开本地的创建的文件夹中的_config.yml配置文件，将其中的type设置为git。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">type: git</div><div class="line">repo: https://github.com/sunjinshuai/sunjinshuai.github.com</div><div class="line">branch: master</div></pre></td></tr></table></figure>
<p>在terminal终端，将当前目录切换到你的本地博客目录，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>在terminal终端，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate   // 可以简写成hexo g 根据markdown文件生成静态文件</div><div class="line">hexo deploy     // 或者简写成hexo d 将本地修改，部署到远端</div></pre></td></tr></table></figure></p>
<p>此时，打开浏览器，访问<a href="https://sunjinshuai.github.io">https://sunjinshuai.github.io</a> ，就可以看到你的博客。</p>
<h4 id="Hexo安装新主题apollo"><a href="#Hexo安装新主题apollo" class="headerlink" title="Hexo安装新主题apollo"></a>Hexo安装新主题apollo</h4><p>Hexo换皮肤还是比较简单的，既可以自己根据默认的主题来修改，也可以到<a href="https://hexo.io/themes/" target="_blank" rel="external">https://hexo.io/themes/</a> 上去找主题。</p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>github上的文档给出了详细的安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo init #blogname#</div><div class="line">cd #blogname# </div><div class="line">npm install</div><div class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</div><div class="line">git clone https://github.com/pinggod/hexo-theme-apollo.git themes/apollo</div></pre></td></tr></table></figure></p>
<h5 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h5><p>安装成功后就可以开始启用主题，主题的启用需要修改_config.yml 的 theme 配置项为 apollo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: apollo</div><div class="line"></div><div class="line"># 在归档页面显示所有文章</div><div class="line"># 需要上面安装的 hexo-generator-archive 插件支持</div><div class="line">archive_generator:</div><div class="line">per_page: 0</div><div class="line">yearly: false</div><div class="line">monthly: false</div><div class="line">daily: false</div></pre></td></tr></table></figure></p>
<h4 id="hexo常用的命令"><a href="#hexo常用的命令" class="headerlink" title="hexo常用的命令"></a>hexo常用的命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hexo init       //在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件</div><div class="line">hexo new “my new blog title”   //新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</div><div class="line">hexo clean      // 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存</div><div class="line">hexo generate   // 可以简写成hexo g 根据markdown文件生成静态文件</div><div class="line">hexo server     // 或者简写成hexo s 启动本地hexo 服务器，默认localhost:4000可以访问</div><div class="line">hexo deploy     // 或者简写成hexo d 将本地修改，部署到远端</div><div class="line">hexo version    // 显示hexo版本</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想着写博客，一方面是给自己做笔记，可以提升自己的写作、总结能力，一个技术点会使用，并不难，但是要做到让别人也能听懂我们讲得，还是需要一定的技巧和经验的。很多类似于CSDN、博客园也都可以写文章，但是页面的样式我不是太喜欢。最近看到一些大神们的博客，貌似都是用hexo写得，本
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sunjinshuai.github.io/2014/07/04/hello-world/"/>
    <id>https://sunjinshuai.github.io/2014/07/04/hello-world/</id>
    <published>2014-07-04T13:40:47.000Z</published>
    <updated>2017-07-05T04:00:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
