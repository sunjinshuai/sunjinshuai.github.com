<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS RunTime之三：消息发送 · 孙金帅的技术博客</title><meta name="description" content="iOS RunTime之三：消息发送 - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS RunTime之三：消息发送</h1><div class="post-info">2016年6月12日</div><div class="post-content"><h4 id="objc-msgSend-函数简介"><a href="#objc-msgSend-函数简介" class="headerlink" title="objc_msgSend 函数简介"></a>objc_msgSend 函数简介</h4><p>在 Objective-C 中，所有的消息传递中的“消息”都会被编译器转化为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id self, SEL op, ... );</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** </span><br><span class="line"> * Sends a message with a simple return value to an instance of a class.</span><br><span class="line"> * </span><br><span class="line"> * @param self A pointer to the instance of the class that is to receive the message.</span><br><span class="line"> * @param op The selector of the method that handles the message.</span><br><span class="line"> * @param ... </span><br><span class="line"> *   A variable argument list containing the arguments to the method.</span><br><span class="line"> * </span><br><span class="line"> * @return The return value of the method.</span><br><span class="line"> * </span><br><span class="line"> * @note When it encounters a method call, the compiler generates a call to one of the</span><br><span class="line"> *  functions \c objc_msgSend, \c objc_msgSend_stret, \c objc_msgSendSuper, or \c objc_msgSendSuper_stret.</span><br><span class="line"> *  Messages sent to an object’s superclass (using the \c super keyword) are sent using \c objc_msgSendSuper; </span><br><span class="line"> *  other messages are sent using \c objc_msgSend. Methods that have data structures as return values</span><br><span class="line"> *  are sent using \c objc_msgSendSuper_stret and \c objc_msgSend_stret.</span><br><span class="line"> *&#x2F;</span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSend(id _Nullable self, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>

<p>注释中大概的意思是当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 <code>objc_msgSend</code>、<code>objc_msgSend_stret</code>、<code>objc_msgSendSuper</code> 和 <code>objc_msgSendSuper_stret</code>；<br>发送给对象的父类的消息会使用 <code>objc_msgSendSuper</code>；<br>有数据结构作为返回值的方法会使用 <code>objc_msgSendSuper_stret</code> 或 <code>objc_msgSend_stret</code>；<br>其它的消息都是使用 <code>objc_msgSend</code> 发送的；</p>
<h4 id="消息发送步骤"><a href="#消息发送步骤" class="headerlink" title="消息发送步骤"></a>消息发送步骤</h4><p><img src="https://upload-images.jianshu.io/upload_images/588630-c48fa6808447b90b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>消息发送的主要步骤：</p>
<ul>
<li>检查 <code>selector</code> 是否需要忽略。</li>
<li>检查 <code>target</code> 是否为 <code>nil</code>。如果为 <code>nil</code>，直接 <code>cleanup</code>，然后 <code>return</code>。<strong>这一点就是为何在OC中给nil发送消息不会崩溃的原因；</strong></li>
<li>确定不是给 <code>nil</code> 发消息之后，就开始查找这个类对应的 <code>IMP</code> 实现；</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1194012-071da64373b4f5f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/332/format/webp" alt="image"></p>
<p>查找 <code>IMP</code> 的过程:</p>
<ul>
<li>先从当前 <code>class</code> 的 <code>cache</code> 方法列表里去查找。</li>
<li>如果找到了，如果找到了就返回对应的 <code>IMP</code> 实现，并把当前的 <code>class</code> 中的 <code>selector</code> 缓存到 <code>cache</code> 里面。</li>
<li>如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 <code>NSObject</code> 类为止。</li>
<li>最后再找不到，就会进入动态方法解析和消息转发的机制。</li>
</ul>
<h4 id="objc-msgSend-源码解析"><a href="#objc-msgSend-源码解析" class="headerlink" title="objc_msgSend 源码解析"></a>objc_msgSend 源码解析</h4><p>以 x86_64 为例，删除其他的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法发送</span><br><span class="line">&#x2F;********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * id objc_msgSend(id self, SEL	_cmd,...);</span><br><span class="line"> * IMP objc_msgLookup(id self, SEL _cmd, ...);</span><br><span class="line"> *</span><br><span class="line"> * objc_msgLookup ABI:</span><br><span class="line"> * IMP returned in r11</span><br><span class="line"> * Forwarding returned in Z flag</span><br><span class="line"> * r10 reserved for our use but not used</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************&#x2F;</span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgSend</span><br><span class="line">	UNWIND _objc_msgSend, NoFrame</span><br><span class="line">	MESSENGER_START</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;1.判断空处理</span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;2.获取isa</span><br><span class="line">	GetIsaFast NORMAL		&#x2F;&#x2F; r10 &#x3D; self-&gt;isa</span><br><span class="line">	&#x2F;&#x2F;3.缓存中查找</span><br><span class="line">	CacheLookup NORMAL, CALL	&#x2F;&#x2F; calls IMP on success</span><br><span class="line"></span><br><span class="line">	NilTestReturnZero NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cache miss: go search the method lists</span><br><span class="line">LCacheMiss:</span><br><span class="line">	&#x2F;&#x2F; isa still in r10</span><br><span class="line">	MESSENGER_END_SLOW</span><br><span class="line">	&#x2F;&#x2F;4.查找方法</span><br><span class="line">	jmp	__objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgSend</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgLookup</span><br><span class="line"></span><br><span class="line">	NilTest	NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaFast NORMAL		&#x2F;&#x2F; r10 &#x3D; self-&gt;isa</span><br><span class="line">	CacheLookup NORMAL, LOOKUP	&#x2F;&#x2F; returns IMP on success</span><br><span class="line"></span><br><span class="line">	NilTestReturnIMP NORMAL</span><br><span class="line"></span><br><span class="line">	GetIsaSupport NORMAL</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cache miss: go search the method lists</span><br><span class="line">LCacheMiss:</span><br><span class="line">	&#x2F;&#x2F; isa still in r10</span><br><span class="line">	jmp	__objc_msgLookup_uncached</span><br><span class="line"></span><br><span class="line">	END_ENTRY _objc_msgLookup</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	ENTRY _objc_msgSend_fixup</span><br><span class="line">	int3</span><br><span class="line">	END_ENTRY _objc_msgSend_fixup</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	STATIC_ENTRY _objc_msgSend_fixedup</span><br><span class="line">	&#x2F;&#x2F; Load _cmd from the message_ref</span><br><span class="line">	movq	8(%a2), %a2</span><br><span class="line">	jmp	_objc_msgSend</span><br><span class="line">	END_ENTRY _objc_msgSend_fixedup</span><br></pre></td></tr></table></figure>
<p>从上面汇编代码中看出，<code>objc_msgSend</code>，会分为有缓存和无缓存两种情况的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; NilTest return-type</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Takes:	$0 &#x3D; NORMAL or FPRET or FP2RET or STRET</span><br><span class="line">&#x2F;&#x2F;		%a1 or %a2 (STRET) &#x3D; receiver</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; On exit: 	Loads non-nil receiver in %a1 or %a2 (STRET)</span><br><span class="line">&#x2F;&#x2F;		or returns.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; NilTestReturnZero return-type</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Takes:	$0 &#x3D; NORMAL or FPRET or FP2RET or STRET</span><br><span class="line">&#x2F;&#x2F;		%a1 or %a2 (STRET) &#x3D; receiver</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; On exit: 	Loads non-nil receiver in %a1 or %a2 (STRET)</span><br><span class="line">&#x2F;&#x2F;		or returns zero.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; NilTestReturnIMP return-type</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Takes:	$0 &#x3D; NORMAL or FPRET or FP2RET or STRET</span><br><span class="line">&#x2F;&#x2F;		%a1 or %a2 (STRET) &#x3D; receiver</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; On exit: 	Loads non-nil receiver in %a1 or %a2 (STRET)</span><br><span class="line">&#x2F;&#x2F;		or returns an IMP in r11 that returns zero.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">.macro ZeroReturn</span><br><span class="line">	xorl	%eax, %eax</span><br><span class="line">	xorl	%edx, %edx</span><br><span class="line">	xorps	%xmm0, %xmm0</span><br><span class="line">	xorps	%xmm1, %xmm1</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">.macro ZeroReturnFPRET</span><br><span class="line">	fldz</span><br><span class="line">	ZeroReturn</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">.macro ZeroReturnFP2RET</span><br><span class="line">	fldz</span><br><span class="line">	fldz</span><br><span class="line">	ZeroReturn</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">.macro ZeroReturnSTRET</span><br><span class="line">	&#x2F;&#x2F; rax gets the struct-return address as passed in rdi</span><br><span class="line">	movq	%rdi, %rax</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgNil</span><br><span class="line">	ZeroReturn</span><br><span class="line">	ret</span><br><span class="line">	END_ENTRY __objc_msgNil</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgNil_fpret</span><br><span class="line">	ZeroReturnFPRET</span><br><span class="line">	ret</span><br><span class="line">	END_ENTRY __objc_msgNil_fpret</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgNil_fp2ret</span><br><span class="line">	ZeroReturnFP2RET</span><br><span class="line">	ret</span><br><span class="line">	END_ENTRY __objc_msgNil_fp2ret</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgNil_stret</span><br><span class="line">	ZeroReturnSTRET</span><br><span class="line">	ret</span><br><span class="line">	END_ENTRY __objc_msgNil_stret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.macro NilTest</span><br><span class="line">.if $0 !&#x3D; STRET</span><br><span class="line">	testq	%a1, %a1</span><br><span class="line">.else</span><br><span class="line">	testq	%a2, %a2</span><br><span class="line">.endif</span><br><span class="line">	PN</span><br><span class="line">	jz	LNilTestSlow_f</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.macro NilTestReturnZero</span><br><span class="line">	.align 3</span><br><span class="line">LNilTestSlow:</span><br><span class="line">	</span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	ZeroReturn</span><br><span class="line">.elseif $0 &#x3D;&#x3D; FPRET</span><br><span class="line">	ZeroReturnFPRET</span><br><span class="line">.elseif $0 &#x3D;&#x3D; FP2RET</span><br><span class="line">	ZeroReturnFP2RET</span><br><span class="line">.elseif $0 &#x3D;&#x3D; STRET</span><br><span class="line">	ZeroReturnSTRET</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">	MESSENGER_END_NIL</span><br><span class="line">	ret	</span><br><span class="line">.endmacro</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.macro NilTestReturnIMP</span><br><span class="line">	.align 3</span><br><span class="line">LNilTestSlow:</span><br><span class="line">	</span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	leaq	__objc_msgNil(%rip), %r11</span><br><span class="line">.elseif $0 &#x3D;&#x3D; FPRET</span><br><span class="line">	leaq	__objc_msgNil_fpret(%rip), %r11</span><br><span class="line">.elseif $0 &#x3D;&#x3D; FP2RET</span><br><span class="line">	leaq	__objc_msgNil_fp2ret(%rip), %r11</span><br><span class="line">.elseif $0 &#x3D;&#x3D; STRET</span><br><span class="line">	leaq	__objc_msgNil_stret(%rip), %r11</span><br><span class="line">.else</span><br><span class="line">.abort oops</span><br><span class="line">.endif</span><br><span class="line">	ret</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p><code>NilTest</code> 是用来检测是否为 <code>nil</code> 的。传入参数有 <code>4</code> 种，<code>NORMAL</code>、<code>FPRET</code>、<code>FP2RET</code> 和 <code>STRET</code>。<br><code>objc_msgSend</code> 传入的参数是 <code>NilTest NORMAL</code>；<br><code>objc_msgSend_fpret</code> 传入的参数是 <code>NilTest FPRET</code>；<br><code>objc_msgSend_fp2ret</code> 传入的参数是 <code>NilTest FP2RET</code>；<br><code>objc_msgSend_stret</code> 传入的参数是 <code>NilTest STRET</code>；<br>如果检测方法的接受者是 <code>nil</code>，那么系统会自动 <code>clean</code> 并且 <code>return</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; GetIsaFast return-type</span><br><span class="line">&#x2F;&#x2F; GetIsaSupport return-type</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Sets r10 &#x3D; obj-&gt;isa. Consults the tagged isa table if necessary.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Takes:	$0 &#x3D; NORMAL or FPRET or FP2RET or STRET</span><br><span class="line">&#x2F;&#x2F;		a1 or a2 (STRET) &#x3D; receiver</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; On exit: 	r10 &#x3D; receiver-&gt;isa</span><br><span class="line">&#x2F;&#x2F;		r11 is clobbered</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">.macro GetIsaFast</span><br><span class="line">.if $0 !&#x3D; STRET</span><br><span class="line">	testb	$$1, %a1b</span><br><span class="line">	PN</span><br><span class="line">	jnz	LGetIsaSlow_f</span><br><span class="line">	movq	$$0x00007ffffffffff8, %r10</span><br><span class="line">	andq	(%a1), %r10</span><br><span class="line">.else</span><br><span class="line">	testb	$$1, %a2b</span><br><span class="line">	PN</span><br><span class="line">	jnz	LGetIsaSlow_f</span><br><span class="line">	movq	$$0x00007ffffffffff8, %r10</span><br><span class="line">	andq	(%a2), %r10</span><br><span class="line">.endif</span><br><span class="line">LGetIsaDone:	</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p><code>GetIsaFast</code> 宏可以快速地获取到对象的 <code>isa</code> 指针地址。<code>r10 = obj-&gt;isa</code></p>
<h5 id="无缓存"><a href="#无缓存" class="headerlink" title="无缓存"></a>无缓存</h5><p>通过 <code>objc_msgSend</code> 汇编代码中可以看出，如果没有命中缓存，会搜索方法列表，程序跳到 <code>__objc_msgSend_uncached</code>，就说明 <code>cache</code> 中无缓存，未命中缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;********************************************************************</span><br><span class="line"> *</span><br><span class="line"> * _objc_msgSend_uncached</span><br><span class="line"> * _objc_msgSend_stret_uncached</span><br><span class="line"> * _objc_msgLookup_uncached</span><br><span class="line"> * _objc_msgLookup_stret_uncached</span><br><span class="line"> *</span><br><span class="line"> * The uncached method lookup.</span><br><span class="line"> *</span><br><span class="line"> ********************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">	STATIC_ENTRY __objc_msgSend_uncached</span><br><span class="line">	UNWIND __objc_msgSend_uncached, FrameWithNoSaves</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">	&#x2F;&#x2F; Out-of-band r10 is the searched class</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; r10 is already the class to search</span><br><span class="line">	MethodTableLookup NORMAL	&#x2F;&#x2F; r11 &#x3D; IMP</span><br><span class="line">	jmp	*%r11			&#x2F;&#x2F; goto *imp</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	STATIC_ENTRY __objc_msgSend_stret_uncached</span><br><span class="line">	UNWIND __objc_msgSend_stret_uncached, FrameWithNoSaves</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">	&#x2F;&#x2F; Out-of-band r10 is the searched class</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; r10 is already the class to search</span><br><span class="line">	MethodTableLookup STRET		&#x2F;&#x2F; r11 &#x3D; IMP</span><br><span class="line">	jmp	*%r11			&#x2F;&#x2F; goto *imp</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgSend_stret_uncached</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	STATIC_ENTRY __objc_msgLookup_uncached</span><br><span class="line">	UNWIND __objc_msgLookup_uncached, FrameWithNoSaves</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">	&#x2F;&#x2F; Out-of-band r10 is the searched class</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; r10 is already the class to search</span><br><span class="line">        &#x2F;&#x2F; 方法列表中查找</span><br><span class="line">	MethodTableLookup NORMAL	&#x2F;&#x2F; r11 &#x3D; IMP</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgLookup_uncached</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	STATIC_ENTRY __objc_msgLookup_stret_uncached</span><br><span class="line">	UNWIND __objc_msgLookup_stret_uncached, FrameWithNoSaves</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; THIS IS NOT A CALLABLE C FUNCTION</span><br><span class="line">	&#x2F;&#x2F; Out-of-band r10 is the searched class</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; r10 is already the class to search</span><br><span class="line">	MethodTableLookup STRET		&#x2F;&#x2F; r11 &#x3D; IMP</span><br><span class="line">	ret</span><br><span class="line"></span><br><span class="line">	END_ENTRY __objc_msgLookup_stret_uncached</span><br></pre></td></tr></table></figure>
<p>查看 <code>__objc_msgSend_uncached</code> 汇编代码，会直接调用 <code>MethodTableLookup</code> 中查找方法列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; MethodTableLookup NORMAL|STRET</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Takes:	a1 or a2 (STRET) &#x3D; receiver</span><br><span class="line">&#x2F;&#x2F;		a2 or a3 (STRET) &#x3D; selector to search for</span><br><span class="line">&#x2F;&#x2F; 		r10 &#x3D; class to search</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; On exit: imp in %r11, eq&#x2F;ne set for forwarding</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;汇编宏定义 MethodTableLookup</span><br><span class="line">.macro MethodTableLookup</span><br><span class="line"></span><br><span class="line">	push	%rbp</span><br><span class="line">	mov	%rsp, %rbp</span><br><span class="line">	</span><br><span class="line">	sub	$$0x80+8, %rsp		&#x2F;&#x2F; +8 for alignment</span><br><span class="line"></span><br><span class="line">	movdqa	%xmm0, -0x80(%rbp)</span><br><span class="line">	push	%rax			&#x2F;&#x2F; might be xmm parameter count</span><br><span class="line">	movdqa	%xmm1, -0x70(%rbp)</span><br><span class="line">	push	%a1</span><br><span class="line">	movdqa	%xmm2, -0x60(%rbp)</span><br><span class="line">	push	%a2</span><br><span class="line">	movdqa	%xmm3, -0x50(%rbp)</span><br><span class="line">	push	%a3</span><br><span class="line">	movdqa	%xmm4, -0x40(%rbp)</span><br><span class="line">	push	%a4</span><br><span class="line">	movdqa	%xmm5, -0x30(%rbp)</span><br><span class="line">	push	%a5</span><br><span class="line">	movdqa	%xmm6, -0x20(%rbp)</span><br><span class="line">	push	%a6</span><br><span class="line">	movdqa	%xmm7, -0x10(%rbp)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; _class_lookupMethodAndLoadCache3(receiver, selector, class)</span><br><span class="line"></span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	&#x2F;&#x2F; receiver already in a1</span><br><span class="line">	&#x2F;&#x2F; selector already in a2</span><br><span class="line">.else</span><br><span class="line">	movq	%a2, %a1</span><br><span class="line">	movq	%a3, %a2</span><br><span class="line">.endif</span><br><span class="line">	movq	%r10, %a3</span><br><span class="line">	&#x2F;&#x2F;调用runtime中的__class_lookupMethodAndLoadCache3</span><br><span class="line">	call	__class_lookupMethodAndLoadCache3</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; IMP is now in %rax</span><br><span class="line">	movq	%rax, %r11</span><br><span class="line"></span><br><span class="line">	movdqa	-0x80(%rbp), %xmm0</span><br><span class="line">	pop	%a6</span><br><span class="line">	movdqa	-0x70(%rbp), %xmm1</span><br><span class="line">	pop	%a5</span><br><span class="line">	movdqa	-0x60(%rbp), %xmm2</span><br><span class="line">	pop	%a4</span><br><span class="line">	movdqa	-0x50(%rbp), %xmm3</span><br><span class="line">	pop	%a3</span><br><span class="line">	movdqa	-0x40(%rbp), %xmm4</span><br><span class="line">	pop	%a2</span><br><span class="line">	movdqa	-0x30(%rbp), %xmm5</span><br><span class="line">	pop	%a1</span><br><span class="line">	movdqa	-0x20(%rbp), %xmm6</span><br><span class="line">	pop	%rax</span><br><span class="line">	movdqa	-0x10(%rbp), %xmm7</span><br><span class="line"></span><br><span class="line">.if $0 &#x3D;&#x3D; NORMAL</span><br><span class="line">	cmp	%r11, %r11		&#x2F;&#x2F; set eq for nonstret forwarding</span><br><span class="line">.else</span><br><span class="line">	test	%r11, %r11		&#x2F;&#x2F; set ne for stret forwarding</span><br><span class="line">.endif</span><br><span class="line">	</span><br><span class="line">	leave</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p><code>MethodTableLookup</code> 是汇编宏定义的一段代码，从中发现一个有用的信息 <code>__class_lookupMethodAndLoadCache3</code>，这个函数在当前的汇编代码里面是找不到实现的。如果去 <code>objc</code> 源码进行全局搜索，也搜不到。如果是一个 <code>C</code> 函数，在底层汇编里面如果需要调用的话，苹果会为其加一个下划线 <code>_</code>，因此上面的的函数删去一个下划线，<code>_class_lookupMethodAndLoadCache3</code>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _class_lookupMethodAndLoadCache.</span><br><span class="line">* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().</span><br><span class="line">* This lookup avoids optimistic cache scan because the dispatcher </span><br><span class="line">* already tried that.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    return lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES&#x2F;*initialize*&#x2F;, NO&#x2F;*cache*&#x2F;, YES&#x2F;*resolver*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个函数里面最终是调用了 <code>lookUpImpOrForward</code> 函数，下面具体分析一下这个函数；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* The standard IMP lookup. </span><br><span class="line">* initialize&#x3D;&#x3D;NO tries to avoid +initialize (but sometimes fails)</span><br><span class="line">* cache&#x3D;&#x3D;NO skips optimistic unlocked lookup (but uses cache elsewhere)</span><br><span class="line">* Most callers should use initialize&#x3D;&#x3D;YES and cache&#x3D;&#x3D;YES.</span><br><span class="line">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span><br><span class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span><br><span class="line">* May return _objc_msgForward_impcache. IMPs destined for external use </span><br><span class="line">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span><br><span class="line">*   If you don&#39;t want forwarding at all, use lookUpImpOrNil() instead.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       bool initialize, bool cache, bool resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    bool triedResolver &#x3D; NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;cache传入值为NO跳过此条件语句</span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (cache) &#123;</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) return imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; runtimeLock is held during isRealized and isInitialized checking</span><br><span class="line">    &#x2F;&#x2F; to prevent races against concurrent realization.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; runtimeLock is held during method search to make</span><br><span class="line">    &#x2F;&#x2F; method-lookup + cache-fill atomic with respect to method addition.</span><br><span class="line">    &#x2F;&#x2F; Otherwise, a category could be added but ignored indefinitely because</span><br><span class="line">    &#x2F;&#x2F; the cache was re-filled with the old value after the cache flush on</span><br><span class="line">    &#x2F;&#x2F; behalf of the category.</span><br><span class="line"></span><br><span class="line">    runtimeLock.read();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.类是否实现了</span><br><span class="line">    if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Drop the read-lock and acquire the write-lock.</span><br><span class="line">        &#x2F;&#x2F; realizeClass() checks isRealized() again to prevent</span><br><span class="line">        &#x2F;&#x2F; a race while the lock is down.</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        runtimeLock.write();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;类实现</span><br><span class="line">        realizeClass(cls);</span><br><span class="line"></span><br><span class="line">        runtimeLock.unlockWrite();</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.类是否初始化了</span><br><span class="line">    if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        &#x2F;&#x2F;---类初始化</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, _class_initialize will send +initialize and </span><br><span class="line">        &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">        &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">        &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertReading();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Try this class&#39;s cache.</span><br><span class="line">    &#x2F;&#x2F;3.查找缓存列表</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) goto done;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;4.当前类方法列表中查找</span><br><span class="line">    &#x2F;&#x2F; Try this class&#39;s method lists.</span><br><span class="line">    &#123;</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            &#x2F;&#x2F;5.添加到缓存列表中</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;6.循环父类方法列表中查找</span><br><span class="line">    &#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">        for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">             curClass !&#x3D; nil;</span><br><span class="line">             curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">            if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;(1)查找父类缓存列表</span><br><span class="line">            &#x2F;&#x2F; Superclass cache.</span><br><span class="line">            imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">            if (imp) &#123;</span><br><span class="line">                &#x2F;&#x2F;需要判断缓存是否_objc_msgForward_impcache</span><br><span class="line">                if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">                    &#x2F;&#x2F;(2)把父类缓存中的方法添加到当前类缓存中</span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    goto done;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                    &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                    &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;(3)查找父类方法列表</span><br><span class="line">            &#x2F;&#x2F; Superclass method list.</span><br><span class="line">            Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            if (meth) &#123;</span><br><span class="line">                &#x2F;&#x2F;(4)把方法列表中的方法添加到当前类缓存中</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp &#x3D; meth-&gt;imp;</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;6.IMP没有找到，尝试方法解析一次</span><br><span class="line">    &#x2F;&#x2F; No implementation found. Try method resolver once.</span><br><span class="line"></span><br><span class="line">    if (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.read();</span><br><span class="line">        &#x2F;&#x2F; Don&#39;t cache the result; we don&#39;t hold the lock so it may have </span><br><span class="line">        &#x2F;&#x2F; changed already. Re-do the search from scratch instead.</span><br><span class="line">        triedResolver &#x3D; YES;</span><br><span class="line">        goto retry;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;7.IMP仍然没有找到，并且解析失败，则使用消息转发</span><br><span class="line">    &#x2F;&#x2F; No implementation found, and method resolver didn&#39;t help. </span><br><span class="line">    &#x2F;&#x2F; Use forwarding.</span><br><span class="line"></span><br><span class="line">    imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);        &#x2F;&#x2F;当IMP为_objc_msgForward_impcache也添加到缓存中去了</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无锁的缓存查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cache传入值为NO跳过此条件语句</span><br><span class="line">&#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">if (cache) &#123;</span><br><span class="line">    imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">    if (imp) return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有加锁的时候对缓存进行查找，提高缓存使用的性能，因为 <code>_class_lookupMethodAndLoadCache3</code> 传入的 <code>cache = NO</code>，所以这里会直接跳过 <code>if</code> 中代码的执行，如果传入的是 <code>YES</code>，那么就会调用 <code>cache_getImp</code> 方法去找到缓存里面对应的 <code>IMP</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.类是否实现了</span><br><span class="line">if (!cls-&gt;isRealized()) &#123;</span><br><span class="line">    &#x2F;&#x2F; Drop the read-lock and acquire the write-lock.</span><br><span class="line">    &#x2F;&#x2F; realizeClass() checks isRealized() again to prevent</span><br><span class="line">    &#x2F;&#x2F; a race while the lock is down.</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    runtimeLock.write();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;类实现</span><br><span class="line">    realizeClass(cls);</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlockWrite();</span><br><span class="line">    runtimeLock.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.类是否初始化了</span><br><span class="line">if (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line">    &#x2F;&#x2F;---类初始化</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    runtimeLock.read();</span><br><span class="line">    &#x2F;&#x2F; If sel &#x3D;&#x3D; initialize, _class_initialize will send +initialize and </span><br><span class="line">    &#x2F;&#x2F; then the messenger will send +initialize again after this </span><br><span class="line">    &#x2F;&#x2F; procedure finishes. Of course, if this is not being called </span><br><span class="line">    &#x2F;&#x2F; from the messenger then it won&#39;t happen. 2778172</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>Objective-C</code> 运行时，初始化的过程中会对其中的类进行第一次初始化也就是执行 <code>realizeClass</code> 方法，为类分配可读写结构体 <code>class_rw_t</code> 的空间，并返回正确的类结构体。</p>
<p>加锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtimeLock.read();</span><br></pre></td></tr></table></figure>

<p>因为在运行时中会动态的添加方法，为了保证线程安全，所以要加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;4.当前类方法列表中查找</span><br><span class="line">&#x2F;&#x2F; Try this class&#39;s method lists.</span><br><span class="line">&#123;</span><br><span class="line">    Method meth &#x3D; getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    if (meth) &#123;</span><br><span class="line">        &#x2F;&#x2F;5.添加到缓存列表中</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp &#x3D; meth-&gt;imp;</span><br><span class="line">        goto done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从当前类的方法列表中寻找方法的实现，调用 <code>getMethodNoSuper_nolock</code> 方法查找对应的方法的结构体指针 <code>method_t</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static method_t *</span><br><span class="line">getMethodNoSuper_nolock(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    &#x2F;&#x2F; fixme nil cls? </span><br><span class="line">    &#x2F;&#x2F; fixme nil sel?</span><br><span class="line"></span><br><span class="line">    for (auto mlists &#x3D; cls-&gt;data()-&gt;methods.beginLists(), </span><br><span class="line">              end &#x3D; cls-&gt;data()-&gt;methods.endLists(); </span><br><span class="line">         mlists !&#x3D; end;</span><br><span class="line">         ++mlists)</span><br><span class="line">    &#123;</span><br><span class="line">        method_t *m &#x3D; search_method_list(*mlists, sel);</span><br><span class="line">        if (m) return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>getMethodNoSuper_nolock</code> 方法中，会遍历一次 <code>methodList</code> 链表，从 <code>beginLists</code> 一直遍历到 <code>endLists</code>。遍历过程中会调用 <code>search_method_list</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static method_t *search_method_list(const method_list_t *mlist, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    int methodListIsFixedUp &#x3D; mlist-&gt;isFixedUp();</span><br><span class="line">    int methodListHasExpectedSize &#x3D; mlist-&gt;entsize() &#x3D;&#x3D; sizeof(method_t);</span><br><span class="line">    </span><br><span class="line">    if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123;</span><br><span class="line">        return findMethodInSortedMethodList(sel, mlist);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Linear search of unsorted method list</span><br><span class="line">        for (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            if (meth.name &#x3D;&#x3D; sel) return &amp;meth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">    &#x2F;&#x2F; sanity-check negative results</span><br><span class="line">    if (mlist-&gt;isFixedUp()) &#123;</span><br><span class="line">        for (auto&amp; meth : *mlist) &#123;</span><br><span class="line">            if (meth.name &#x3D;&#x3D; sel) &#123;</span><br><span class="line">                _objc_fatal(&quot;linear search worked when binary search did not&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>search_method_list</code> 函数中，会去判断当前 <code>methodList</code> 是否有序，如果有序，会调用 <code>findMethodInSortedMethodList</code> 方法，这个方法里面的实现是一个二分搜索，如果非有序，就傻瓜式的遍历搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list)</span><br><span class="line">&#123;</span><br><span class="line">    assert(list);</span><br><span class="line"></span><br><span class="line">    const method_t * const first &#x3D; &amp;list-&gt;first;</span><br><span class="line">    const method_t *base &#x3D; first;</span><br><span class="line">    const method_t *probe;</span><br><span class="line">    uintptr_t keyValue &#x3D; (uintptr_t)key;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    </span><br><span class="line">    for (count &#x3D; list-&gt;count; count !&#x3D; 0; count &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">        probe &#x3D; base + (count &gt;&gt; 1);</span><br><span class="line">        </span><br><span class="line">        uintptr_t probeValue &#x3D; (uintptr_t)probe-&gt;name;</span><br><span class="line">        </span><br><span class="line">        if (keyValue &#x3D;&#x3D; probeValue) &#123;</span><br><span class="line">            &#x2F;&#x2F; &#96;probe&#96; is a match.</span><br><span class="line">            &#x2F;&#x2F; Rewind looking for the *first* occurrence of this value.</span><br><span class="line">            &#x2F;&#x2F; This is required for correct category overrides.</span><br><span class="line">            while (probe &gt; first &amp;&amp; keyValue &#x3D;&#x3D; (uintptr_t)probe[-1].name) &#123;</span><br><span class="line">                probe--;</span><br><span class="line">            &#125;</span><br><span class="line">            return (method_t *)probe;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (keyValue &gt; probeValue) &#123;</span><br><span class="line">            base &#x3D; probe + 1;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在这里找到了方法的实现，将它加入类的缓存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_MESSAGE_LOGGING</span><br><span class="line">    if (objcMsgLogEnabled) &#123;</span><br><span class="line">        bool cacheIt &#x3D; logMessageSend(implementer-&gt;isMetaClass(), </span><br><span class="line">                                      cls-&gt;nameForLogging(),</span><br><span class="line">                                      implementer-&gt;nameForLogging(), </span><br><span class="line">                                      sel);</span><br><span class="line">        if (!cacheIt) return;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    cache_fill (cls, sel, imp, receiver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void cache_fill(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">#if !DEBUG_TASK_THREADS</span><br><span class="line">    mutex_locker_t lock(cacheUpdateLock);</span><br><span class="line">    cache_fill_nolock(cls, sel, imp, receiver);</span><br><span class="line">#else</span><br><span class="line">    _collecting_in_critical();</span><br><span class="line">    return;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Never cache before +initialize is done</span><br><span class="line">    if (!cls-&gt;isInitialized()) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Make sure the entry wasn&#39;t added to the cache by some other thread </span><br><span class="line">    &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">    if (cache_getImp(cls, sel)) return;</span><br><span class="line"></span><br><span class="line">    cache_t *cache &#x3D; getCache(cls);</span><br><span class="line">    cache_key_t key &#x3D; getKey(sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use the cache as-is if it is less than 3&#x2F;4 full</span><br><span class="line">    mask_t newOccupied &#x3D; cache-&gt;occupied() + 1;</span><br><span class="line">    mask_t capacity &#x3D; cache-&gt;capacity();</span><br><span class="line">    if (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (newOccupied &lt;&#x3D; capacity &#x2F; 4 * 3) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is too full. Expand it.</span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span><br><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot because the </span><br><span class="line">    &#x2F;&#x2F; minimum size is 4 and we resized at 3&#x2F;4 full.</span><br><span class="line">    bucket_t *bucket &#x3D; cache-&gt;find(key, receiver);</span><br><span class="line">    if (bucket-&gt;key() &#x3D;&#x3D; 0) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;set(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的分析在 <a href="https://www.jianshu.com/p/3fa276ed26f9" target="_blank" rel="noopener">类结构中 cache_t 如何缓存 sel</a> 提到过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;6.循环父类方法列表中查找</span><br><span class="line">  &#x2F;&#x2F; Try superclass caches and method lists.</span><br><span class="line">  &#123;</span><br><span class="line">      unsigned attempts &#x3D; unreasonableClassCount();</span><br><span class="line">      for (Class curClass &#x3D; cls-&gt;superclass;</span><br><span class="line">           curClass !&#x3D; nil;</span><br><span class="line">           curClass &#x3D; curClass-&gt;superclass)</span><br><span class="line">      &#123;</span><br><span class="line">          &#x2F;&#x2F; Halt if there is a cycle in the superclass chain.</span><br><span class="line">          if (--attempts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">              _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;(1)查找父类缓存列表</span><br><span class="line">          &#x2F;&#x2F; Superclass cache.</span><br><span class="line">          imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">          if (imp) &#123;</span><br><span class="line">              &#x2F;&#x2F;需要判断缓存是否_objc_msgForward_impcache</span><br><span class="line">              if (imp !&#x3D; (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                  &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">                  &#x2F;&#x2F;(2)把父类缓存中的方法添加到当前类缓存中</span><br><span class="line">                  log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                  goto done;</span><br><span class="line">              &#125;</span><br><span class="line">              else &#123;</span><br><span class="line">                  &#x2F;&#x2F; Found a forward:: entry in a superclass.</span><br><span class="line">                  &#x2F;&#x2F; Stop searching, but don&#39;t cache yet; call method </span><br><span class="line">                  &#x2F;&#x2F; resolver for this class first.</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F;(3)查找父类方法列表</span><br><span class="line">          &#x2F;&#x2F; Superclass method list.</span><br><span class="line">          Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">          if (meth) &#123;</span><br><span class="line">              &#x2F;&#x2F;(4)把方法列表中的方法添加到当前类缓存中</span><br><span class="line">              log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">              imp &#x3D; meth-&gt;imp;</span><br><span class="line">              goto done;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果在当前 <code>class</code> 对象里面没有找到该方法，那么会通过 <code>class</code> 对象的 <code>superclass</code> 指针查找父类的 <code>class</code> 的方法列表。同理，找到后把父类方法列表中的方法添加到当前类缓存中，而不是缓存到父类中。</p>
<h4 id="有缓存"><a href="#有缓存" class="headerlink" title="有缓存"></a>有缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">.macro	CacheLookup</span><br><span class="line">.if $0 !&#x3D; STRET</span><br><span class="line">	movq	%a2, %r11		&#x2F;&#x2F; r11 &#x3D; _cmd</span><br><span class="line">.else</span><br><span class="line">	movq	%a3, %r11		&#x2F;&#x2F; r11 &#x3D; _cmd</span><br><span class="line">.endif</span><br><span class="line">	andl	24(%r10), %r11d		&#x2F;&#x2F; r11 &#x3D; _cmd &amp; class-&gt;cache.mask</span><br><span class="line">	shlq	$$4, %r11		&#x2F;&#x2F; r11 &#x3D; offset &#x3D; (_cmd &amp; mask)&lt;&lt;4</span><br><span class="line">	addq	16(%r10), %r11		&#x2F;&#x2F; r11 &#x3D; class-&gt;cache.buckets + offset</span><br><span class="line"></span><br><span class="line">.if $0 !&#x3D; STRET</span><br><span class="line">	cmpq	(%r11), %a2		&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">.else</span><br><span class="line">	cmpq	(%r11), %a3		&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">.endif</span><br><span class="line">	jne 	1f			&#x2F;&#x2F;     scan more</span><br><span class="line">	&#x2F;&#x2F; CacheHit must always be preceded by a not-taken &#96;jne&#96; instruction</span><br><span class="line">	CacheHit $0, $1			&#x2F;&#x2F; call or return imp</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">	&#x2F;&#x2F; loop</span><br><span class="line">	cmpq	$$1, (%r11)</span><br><span class="line">	jbe	3f			&#x2F;&#x2F; if (bucket-&gt;sel &lt;&#x3D; 1) wrap or miss</span><br><span class="line"></span><br><span class="line">	addq	$$16, %r11		&#x2F;&#x2F; bucket++</span><br><span class="line">2:	</span><br><span class="line">.if $0 !&#x3D; STRET</span><br><span class="line">	cmpq	(%r11), %a2		&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">.else</span><br><span class="line">	cmpq	(%r11), %a3		&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">.endif</span><br><span class="line">	jne 	1b			&#x2F;&#x2F;     scan more</span><br><span class="line">	&#x2F;&#x2F; CacheHit must always be preceded by a not-taken &#96;jne&#96; instruction</span><br><span class="line">	CacheHit $0, $1			&#x2F;&#x2F; call or return imp</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">	&#x2F;&#x2F; wrap or miss</span><br><span class="line">	jb	LCacheMiss_f		&#x2F;&#x2F; if (bucket-&gt;sel &lt; 1) cache miss</span><br><span class="line">	&#x2F;&#x2F; wrap</span><br><span class="line">	movq	8(%r11), %r11		&#x2F;&#x2F; bucket-&gt;imp is really first bucket</span><br><span class="line">	jmp 	2f</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Clone scanning loop to miss instead of hang when cache is corrupt.</span><br><span class="line">	&#x2F;&#x2F; The slow path may detect any corruption and halt later.</span><br><span class="line"></span><br><span class="line">1:</span><br><span class="line">	&#x2F;&#x2F; loop</span><br><span class="line">	cmpq	$$1, (%r11)</span><br><span class="line">	jbe	3f			&#x2F;&#x2F; if (bucket-&gt;sel &lt;&#x3D; 1) wrap or miss</span><br><span class="line"></span><br><span class="line">	addq	$$16, %r11		&#x2F;&#x2F; bucket++</span><br><span class="line">2:	</span><br><span class="line">.if $0 !&#x3D; STRET</span><br><span class="line">	cmpq	(%r11), %a2		&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">.else</span><br><span class="line">	cmpq	(%r11), %a3		&#x2F;&#x2F; if (bucket-&gt;sel !&#x3D; _cmd)</span><br><span class="line">.endif</span><br><span class="line">	jne 	1b			&#x2F;&#x2F;     scan more</span><br><span class="line">	&#x2F;&#x2F; CacheHit must always be preceded by a not-taken &#96;jne&#96; instruction</span><br><span class="line">	CacheHit $0, $1			&#x2F;&#x2F; call or return imp</span><br><span class="line"></span><br><span class="line">3:</span><br><span class="line">	&#x2F;&#x2F; double wrap or miss</span><br><span class="line">	jmp	LCacheMiss_f</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>
<p>这段汇编代码大概的意思是在这个 <code>CacheLookup</code> 函数中，不断的通过 <code>_cmd</code> 与 <code>cache</code> 中的 <code>bucket-&gt;sel</code> 进行比较。如果 <code>bucket-&gt;sel &lt; 1</code>，则跳转到 <code>LCacheMiss_f</code> 标记去继续执行。程序跳到 <code>LCacheMiss</code>，就说明 <code>cache</code> 中无缓存，未命中缓存，则要去 <code>MethodTableLookup</code> 查找。如果 <code>bucket-&gt;sel == _cmd</code> 即在 <code>cache</code> 中找到了相应的 <code>SEL</code>，则直接执行该 <code>IMP</code>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/06/14/iOS-RunTime%E4%B9%8B%E5%9B%9B%EF%BC%9A%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/" class="prev">上一篇</a><a href="/2016/06/11/iOS-RunTime%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2016/06/12/iOS-RunTime之三：消息发送/';
var disqus_title = 'iOS RunTime之三：消息发送';
var disqus_url = 'https://sunjinshuai.github.io/2016/06/12/iOS-RunTime之三：消息发送/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2020 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>