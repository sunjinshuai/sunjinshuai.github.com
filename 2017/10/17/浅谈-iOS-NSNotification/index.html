<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈 iOS NSNotification · 孙金帅的技术博客</title><meta name="description" content="浅谈 iOS NSNotification - sunjinshuai"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://sunjinshuai.github.io/atom.xml" title="孙金帅的技术博客"><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="孙金帅的技术博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/5113807465" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/sunjinshuai" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">浅谈 iOS NSNotification</h1><div class="post-info">2017年10月17日</div><div class="post-content"><h4 id="NSNotification-解决的问题"><a href="#NSNotification-解决的问题" class="headerlink" title="NSNotification 解决的问题"></a>NSNotification 解决的问题</h4><ul>
<li>可以实现跨层的传递，例如A页面跳转到B页面，B页面再跳转到C页面，这时候如果我们通过委托回调的模式让A知道C的一些修改，那么实现起来就会很麻烦。</li>
<li>可以实现一对多，<code>NSNotification</code> 的实际是一种观察者模式。</li>
</ul>
<h4 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="NSNotificationCenter"></a>NSNotificationCenter</h4><p><code>NSNotificationCenter</code> 就相当于一个广播站，使用 <code>[NSNotificationCenter defaultCenter]</code> 来获取，<code>NSNotificationCenter</code> 实际上是 <code>iOS</code> 程序内部之间的一种消息广播机制，主要为了解决应用程序内部不同对象之间解耦而设计。<br><code>NSNotificationCenter</code> 是整个通知机制的关键所在，它管理着监听者的注册和注销，通知的发送和接收。<code>NSNotificationCenter</code> 维护着一个通知的分发表，把所有通知发送者发送的通知，转发给对应的监听者们。每一个 <code>iOS</code> 程序都有一个唯一的通知中心，不必自己去创建一个，它是一个单例，通过 <code>[NSNotificationCenter defaultCenter]</code> 方法获取。<br><code>NSNotificationCenter</code> 是基于观察者模式设计的，不能跨应用程序进程通信，当 <code>NSNotificationCenter</code> 接收到消息之后会根据内部的消息转发表，将消息发送给订阅者；它可以向应用任何地方发送和接收通知。<br>在 <code>NSNotificationCenter</code> 注册观察者，发送者使用通知中心广播时，以 <code>NSNotification</code> 的 <code>name</code> 和 <code>object</code> 来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</p>
<h4 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h4><p><code>NSNotification</code> 是 <code>NSNotificationCenter</code> 接收到消息之后根据内部的消息转发表，将消息发送给订阅者封装的对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个成员变量是这个消息对象的唯一标识，用于辨别消息对象</span><br><span class="line">@property (readonly, copy) NSString *name;</span><br><span class="line">&#x2F;&#x2F; 这个成员变量定义一个对象，可以理解为针对某一个对象的消息，代表通知的发送者</span><br><span class="line">@property (nullable, readonly, retain) id object;</span><br><span class="line">&#x2F;&#x2F;这个成员变量是一个字典，可以用其来进行传值</span><br><span class="line">@property (nullable, readonly, copy) NSDictionary *userInfo;</span><br><span class="line">&#x2F;&#x2F; 初始化方法</span><br><span class="line">- (instancetype)initWithName:(NSString *)name object:(nullable id)object userInfo:(nullable NSDictionary *)userInfo NS_AVAILABLE(10_6, 4_0) NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>由于 <code>NSNotification</code> 属性都是只读的，如果要创建通知则要用下面 <code>NSNotification(NSNotificationCreation)</code> 分类相应的方法进行初始化；</p>
<p><code>NSNotification</code> 不能通过 <code>init</code> 实例化，这样会引起下面的异常，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSNotification *notif &#x3D; [[NSNotification alloc] init];</span><br><span class="line"></span><br><span class="line">*** Terminating app due to uncaught exception &#39;NSGenericException&#39;, reason: &#39;*** -[NSConcreteNotification init]: should never be used&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface NSNotification (NSNotificationCreation)</span><br><span class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject;</span><br><span class="line">+ (instancetype)notificationWithName:(NSString *)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo;</span><br><span class="line">- (instancetype)init &#x2F;*NS_UNAVAILABLE*&#x2F;;    &#x2F;* do not invoke; not a valid initializer for this class *&#x2F;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>注意：<br>如果 <code>NSNotification</code> 对象中的 <code>notificationName</code> 为 <code>nil</code>，则会接收所有的通知。通知中心是以 <code>NSNotification</code> 的 <code>name</code> 和 <code>object</code> 来确定需要发送给哪个观察者。监听同一条通知的多个观察者，在通知到达时，它们执行回调的顺序是不确定的，所以我们不能去假设操作的执行会按照添加观察者的顺序来执行。</p>
<p>通知中心默认是以同步的方式发送通知的，也就是说，当一个对象发送了一个通知，<strong>只有当该通知的所有接受者都接受到了通知中心分发的通知消息并且处理完成后，发送通知的对象才能继续执行接下来的方法。</strong></p>
<h4 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="NSNotificationQueue"></a>NSNotificationQueue</h4><p><code>NSNotificationQueue</code> 通知队列，用来管理多个通知的调用。通知队列通常以先进先出 <code>FIFO</code> 顺序维护通。<code>NSNotificationQueue</code> 就像一个缓冲池把一个个通知放进池子中，使用特定方式通过 <code>NSNotificationCenter</code> 发送到相应的观察者。下面我们会提到特定的方式即合并通知和异步通知。</p>
<p>创建通知队列方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithNotificationCenter:(NSNotificationCenter *)notificationCenter NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>往队列加入通知方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;</span><br><span class="line">- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSNotificationCoalescing)coalesceMask forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br></pre></td></tr></table></figure>

<p>移除队列中的通知方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask;</span><br></pre></td></tr></table></figure>

<h5 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h5><p>NSPostingStyle包括三种类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123;</span><br><span class="line">    NSPostWhenIdle &#x3D; 1,</span><br><span class="line">    NSPostASAP &#x3D; 2,</span><br><span class="line">    NSPostNow &#x3D; 3  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NSPostWhenIdle</code>：空闲发送通知，当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。<br><code>NSPostASAP</code>：尽快发送通知，当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。<br><code>NSPostNow</code> ：同步发送通知，如果不使用合并通知和 <code>postNotification:</code> 一样是同步通知。</p>
<h5 id="合并通知"><a href="#合并通知" class="headerlink" title="合并通知"></a>合并通知</h5><p>NSNotificationCoalescing也包括三种类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123;</span><br><span class="line">    NSNotificationNoCoalescing &#x3D; 0,</span><br><span class="line">    NSNotificationCoalescingOnName &#x3D; 1,</span><br><span class="line">    NSNotificationCoalescingOnSender &#x3D; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NSNotificationNoCoalescing</code>：不合并通知。<br><code>NSNotificationCoalescingOnName</code>：合并相同名称的通知。<br><code>NSNotificationCoalescingOnSender</code>：合并相同通知和同一对象的通知。</p>
<p>通过合并我们可以用来保证相同的通知只被发送一次。<code>forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes</code> 可以使用不同的 <code>NSRunLoopMode</code> 配合来发送通知，可以看出实际上 <code>NSNotificationQueue</code> 与 <code>RunLoop</code> 的机制以及运行循环有关系，通过 <code>NSNotificationQueue</code> 队列来发送的通知和关联的 <code>RunLoop</code> 运行机制来进行的。</p>
<h4 id="iOS-9-NSNotificationCenter-无需手动移除观察者"><a href="#iOS-9-NSNotificationCenter-无需手动移除观察者" class="headerlink" title="iOS 9 NSNotificationCenter 无需手动移除观察者"></a>iOS 9 NSNotificationCenter 无需手动移除观察者</h4><p>众所周知，在观察者对象释放之前，需要调用 <code>removeObserver</code> 方法，将观察者从通知中心移除，否则程序可能会出现崩溃。其实，从 <code>iOS 9</code> 开始，即使不移除观察者对象，程序也不会出现异常。这是为什么呢？我们先了解一下，为什么 <code>iOS 9</code> 之前需要手动移除观察者对象。</p>
<p>在 <code>MRC</code> 时代，观察者注册时，通知中心并不会对观察者对象做 <code>retain</code> 操作，而是对观察者对象进行 <code>unsafe_unretained</code> 引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; for attribute</span><br><span class="line">@property (unsafe_unretained) NSObject *unsafeProperty;</span><br><span class="line">&#x2F;&#x2F; for variables</span><br><span class="line">NSObject *__unsafe_unretained unsafeReference;</span><br></pre></td></tr></table></figure>

<p>不安全引用（<code>unsafe reference</code>）和弱引用 (<code>weak reference</code>) 类似，它并不会让被引用的对象保持存活，但是和弱引用不同的是，当被引用的对象释放的时，不安全引用并不会自动被置为 <code>nil</code>，这就意味着它变成了野指针，而对野指针发送消息会导致程序崩溃。</p>
<blockquote>
<p>If your app targets iOS 9.0 and later or macOS 10.11 and later, you don’t need to unregister an observer in its dealloc method.</p>
</blockquote>
<p>而在 <code>iOS 9</code> 以后，通知中心持有的是注册者的 <code>weak</code> 指针，这时即使不对通知进行手动移除，指针也会在注册者被回收后自动置空。但是，通过 <code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock]</code> 方法注册的观察者依然需要手动的释放，因为通知中心对它们持有的是强引用。</p>
<h4 id="NSNotification在多线程中使用"><a href="#NSNotification在多线程中使用" class="headerlink" title="NSNotification在多线程中使用"></a>NSNotification在多线程中使用</h4><p>在多线程中，无论在哪个线程注册了观察者，<code>Notification</code> 接收和处理都是在发送 <code>Notification</code> 的线程中的。所以，当我们需要在接收到 <code>Notification</code> 后作出更新 <code>UI</code> 操作的话，就需要考虑线程的问题了，如果在子线程中发送 <code>Notification</code>，想要在接收到 <code>Notification</code> 后更新 <code>UI</code> 的话就要切换回到主线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSString *NOTIFICATION_NAME &#x3D; @&quot;NOTIFICATION_NAME&quot;;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:NOTIFICATION_NAME object:nil];</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">         NSLog(@&quot;Post notification，Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:NOTIFICATION_NAME object:nil userInfo:nil];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)handleNotification:(NSNotification *)notification &#123;</span><br><span class="line">    NSLog(@&quot;Receive notification，Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-03-11 17:56:33.898 NotificationTest[23457:1615587] Current thread &#x3D; &lt;NSThread: 0x608000078080&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2017-03-11 17:56:33.899 NotificationTest[23457:1615738] Post notification，Current thread &#x3D; &lt;NSThread: 0x60000026c500&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">2017-03-11 17:56:33.899 NotificationTest[23457:1615738] Receive notification，Current thread &#x3D; &lt;NSThread: 0x60000026c500&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们在主线程注册观察者，在子线程发送 <code>Notification</code>，最后 <code>Notification</code> 的接收和处理也是在子线程。</p>
<p>注意：<br>在一个多线程的程序中，发送方发送通知的线程通常就是监听者接受通知的线程，这可能和监听者注册时的线程不一样。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><h6 id="MachPort的使用方式"><a href="#MachPort的使用方式" class="headerlink" title="MachPort的使用方式"></a>MachPort的使用方式</h6><p>最好的方法是在 <code>Notification</code> 所在的默认线程中捕获发送的通知，然后将其重定向到指定的线程中。关于 <code>Notification</code> 的重定向官方文档给出了一个方法：</p>
<blockquote>
<p>一种重定向的实现思路是自定义一个通知队列(不是 <code>NSNotificationQueue</code> 对象)，让这个队列去维护那些我们需要重定向的 <code>Notification</code>。我们仍然是像之前一样去注册一个通知的观察者，当 <code>Notification</code> 到达时，先看看 <code>post</code> 这个 <code>Notification</code> 的线程是不是我们所期望的线程，如果不是，就将这个 <code>Notification</code> 放到我们的队列中，然后发送一个信号<code>signal</code>到期望的线程中，来告诉这个线程需要处理一个 <code>Notification</code>。指定的线程收到这个信号<code>signal</code>后，将 <code>Notification</code> 从队列中移除，并进行后续处理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line">&#x2F;&#x2F;  NotificationTest</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by sunjinshuai on 2017&#x2F;3&#x2F;11.</span><br><span class="line">&#x2F;&#x2F;  Copyright © 2017年 sunjinshuai. All rights reserved.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"> </span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"> </span><br><span class="line">@interface ViewController ()&lt;NSMachPortDelegate&gt;</span><br><span class="line"> </span><br><span class="line">@property (nonatomic) NSMutableArray    *notifications;         &#x2F;&#x2F; 通知队列</span><br><span class="line">@property (nonatomic) NSThread          *notificationThread;    &#x2F;&#x2F; 想要处理通知的线程（目标线程）</span><br><span class="line">@property (nonatomic) NSLock            *notificationLock;      &#x2F;&#x2F; 用于对通知队列加锁的锁对象，避免线程冲突</span><br><span class="line">@property (nonatomic) NSMachPort        *notificationPort;      &#x2F;&#x2F; 用于向目标线程发送信号的通信端口</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation ViewController</span><br><span class="line"> </span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSString *NOTIFICATION_NAME &#x3D; @&quot;NOTIFICATION_NAME&quot;;</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    [self setUpThreadingSupport];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 注册观察者</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:NOTIFICATION_NAME object:nil];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        &#x2F;&#x2F; 发送Notification</span><br><span class="line">        NSLog(@&quot;Post notification，Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:NOTIFICATION_NAME object:nil userInfo:nil];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;*</span><br><span class="line">    在注册任何通知之前，需要先初始化属性。下面方法初始化了队列和锁定对象，保留对当前线程对象的引用，并创建一个Mach通信端口，将其添加到当前线程的运行循环中。</span><br><span class="line">    此方法运行后，发送到notificationPort的任何消息都会在首次运行此方法的线程的run loop中接收。如果接收线程的run loop在Mach消息到达时没有运行，则内核保持该消息，直到下一次进入run loop。接收线程的run loop将传入消息发送到端口delegate的handleMachMessage：方法。</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)setUpThreadingSupport &#123;</span><br><span class="line">    if (self.notifications) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.notifications      &#x3D; [[NSMutableArray alloc] init];</span><br><span class="line">    self.notificationLock   &#x3D; [[NSLock alloc] init];</span><br><span class="line">    self.notificationThread &#x3D; [NSThread currentThread];</span><br><span class="line">    </span><br><span class="line">    self.notificationPort &#x3D; [[NSMachPort alloc] init];</span><br><span class="line">    [self.notificationPort setDelegate:self];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:self.notificationPort</span><br><span class="line">                                forMode:(__bridge NSString*)kCFRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;**</span><br><span class="line"> 端口的代理方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)handleMachMessage:(void *)msg &#123;</span><br><span class="line">    </span><br><span class="line">    [self.notificationLock lock];</span><br><span class="line">    </span><br><span class="line">    while ([self.notifications count]) &#123;</span><br><span class="line">        NSNotification *notification &#x3D; [self.notifications objectAtIndex:0];</span><br><span class="line">        [self.notifications removeObjectAtIndex:0];</span><br><span class="line">        [self.notificationLock unlock];</span><br><span class="line">        [self processNotification:notification];</span><br><span class="line">        [self.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [self.notificationLock unlock];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)processNotification:(NSNotification *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;判断是不是目标线程，不是则转发到目标线程</span><br><span class="line">    if ([NSThread currentThread] !&#x3D; _notificationThread) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将Notification转发到目标线程</span><br><span class="line">        [self.notificationLock lock];</span><br><span class="line">        [self.notifications addObject:notification];</span><br><span class="line">        [self.notificationLock unlock];</span><br><span class="line">        [self.notificationPort sendBeforeDate:[NSDate date]</span><br><span class="line">                                   components:nil</span><br><span class="line">                                         from:nil</span><br><span class="line">                                     reserved:0];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 在此处理通知</span><br><span class="line">        NSLog(@&quot;Receive notification，Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">        NSLog(@&quot;Process notification&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-03-11 18:28:55.788 NotificationTest[24080:1665269] Current thread &#x3D; &lt;NSThread: 0x60800006d4c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2017-03-11 18:28:55.789 NotificationTest[24080:1665396] Post notification，Current thread &#x3D; &lt;NSThread: 0x60800026bc40&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">2017-03-11 18:28:55.795 NotificationTest[24080:1665269] Receive notification，Current thread &#x3D; &lt;NSThread: 0x60800006d4c0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">2017-03-11 18:28:55.795 NotificationTest[24080:1665269] Process notification</span><br></pre></td></tr></table></figure>

<p>在发送通知的子线程处理通知的事件时，将 <code>NSNotification</code> 暂存，然后通过 <code>MachPort</code> 往相应线程的 <code>RunLoop</code> 中发送事件。相应的线程收到该事件后，取出在队列中暂存的 <code>NSNotification</code> , 然后在当前线程中调用处理通知的方法。<br>可以看到，运行结果结果我们想要的：在子线程中发送 <code>Notification</code>，在主线程中接收与处理 <code>Notification</code>。</p>
<p>上面的实现方法也不是绝对完美的，苹果官方指出了这种方法的限制：</p>
<ul>
<li>所有线程的 <code>Notification</code> 的处理都必须通过相同的方法 <code>processNotification:</code>。</li>
<li>每个对象必须提供自己的实现和通信端口。</li>
</ul>
<h6 id="block"><a href="#block" class="headerlink" title="block"></a>block</h6><p>上面苹果官方给我们提供的方法外，我们还可以利用基于 <code>block</code> 的 <code>NSNotification</code> 去实现，<code>apple</code> 从 <code>ios4</code> 之后提供了带有 <code>block</code> 的 <code>NSNotification</code>。使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id&lt;NSObject&gt;)addObserverForName:(NSString *)name</span><br><span class="line">                           object:(id)obj</span><br><span class="line">                            queue:(NSOperationQueue *)queue</span><br><span class="line">                       usingBlock:(void (^)(NSNotification *note))block</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>观察者就是当前对象</li>
<li><code>queue</code> 定义了 <code>block</code> 执行的线程，<code>nil</code> 则表示 <code>block</code> 的执行线程和发通知在同一个线程</li>
<li><code>block</code> 就是相应通知的处理函数</li>
</ul>
<p>这个 <code>API</code> 已经能够让我们方便的控制通知的线程切换。但是，这里有个问题需要注意。就是其 <code>remove</code> 操作。</p>
<p>原来的 <code>NSNotification</code> 的 <code>remove</code> 方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObservers &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:POST_NOTIFICATION object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是带 <code>block</code> 方式的 <code>remove</code> 便不能像上面这样处理了。其方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObservers &#123;</span><br><span class="line">    if（_observer）&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:_observer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>_observer</code> 是 <code>addObserverForName</code> 方式的 <code>api</code> 返回观察者对象。这也就意味着，你需要为每一个观察者记录一个成员对象，然后在 <code>remove</code> 的时候依次删除。试想一下，你如果需要 10 个观察者，则需要记录 10 个成员对象，这个想想就是很麻烦，而且它还不能够方便的指定 <code>observer</code> 。因此，理想的做法就是自己再做一层封装，将这些细节封装起来。</p>
<p>当然，想要在子线程发送 <code>Notification</code>、接收到 <code>Notification</code> 后在主线程中做后续操作，可以用一个很笨的方法，在 <code>handleNotification</code> 里面强制切换线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)handleNotification:(NSNotification *)notification &#123;</span><br><span class="line">   NSLog(@&quot;Receive notification，Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">   dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      NSLog(@&quot;Current thread &#x3D; %@&quot;, [NSThread currentThread]);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在简单情况下可以使用这种方法，但是当我们发送了多个 <code>Notification</code> 并且有多个观察者的时候，难道我们要在每个地方都手动切换线程？所以，这种方法并不是一个有效的方法。</p>
<h4 id="通知的实现原理"><a href="#通知的实现原理" class="headerlink" title="通知的实现原理"></a>通知的实现原理</h4><p>以下源码来自于<a href="https://github.com/gnustep/libs-base" target="_blank" rel="noopener">libs-base</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct NCTbl &#123;</span><br><span class="line">  Observation		*wildcard;	&#x2F;* Get ALL messages.		*&#x2F;</span><br><span class="line">  GSIMapTable		nameless;	&#x2F;* Get messages for any name.	*&#x2F;</span><br><span class="line">  GSIMapTable		named;		&#x2F;* Getting named messages only.	*&#x2F;</span><br><span class="line">  unsigned		lockCount;	&#x2F;* Count recursive operations.	*&#x2F;</span><br><span class="line">  NSRecursiveLock	*_lock;		&#x2F;* Lock out other threads.	*&#x2F;</span><br><span class="line">  Observation		*freeList;</span><br><span class="line">  Observation		**chunks;</span><br><span class="line">  unsigned		numChunks;</span><br><span class="line">  GSIMapTable		cache[CACHESIZE];</span><br><span class="line">  unsigned short	chunkIndex;</span><br><span class="line">  unsigned short	cacheIndex;</span><br><span class="line">&#125; NCTable;</span><br><span class="line"></span><br><span class="line">typedef	struct	Obs &#123;</span><br><span class="line">  id		observer;	&#x2F;* Object to receive message.	*&#x2F;</span><br><span class="line">  SEL		selector;	&#x2F;* Method selector.		*&#x2F;</span><br><span class="line">  struct Obs	*next;		&#x2F;* Next item in linked list.	*&#x2F;</span><br><span class="line">  int		retained;	&#x2F;* Retain count for structure.	*&#x2F;</span><br><span class="line">  struct NCTbl	*link;		&#x2F;* Pointer back to chunk table	*&#x2F;</span><br><span class="line">&#125; Observation;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，在 <code>NSNotificationCenter</code> 内部是由链表组成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">- (void) addObserver: (id)observer</span><br><span class="line">	    selector: (SEL)selector</span><br><span class="line">                name: (NSString*)name</span><br><span class="line">	      object: (id)object</span><br><span class="line">&#123;</span><br><span class="line">  Observation	*list;</span><br><span class="line">  Observation	*o;</span><br><span class="line">  GSIMapTable	m;</span><br><span class="line">  GSIMapNode	n;</span><br><span class="line"></span><br><span class="line">  if (observer &#x3D;&#x3D; nil)</span><br><span class="line">    [NSException raise: NSInvalidArgumentException</span><br><span class="line">		format: @&quot;Nil observer passed to addObserver ...&quot;];</span><br><span class="line"></span><br><span class="line">  if (selector &#x3D;&#x3D; 0)</span><br><span class="line">    [NSException raise: NSInvalidArgumentException</span><br><span class="line">		format: @&quot;Null selector passed to addObserver ...&quot;];</span><br><span class="line"></span><br><span class="line">  if ([observer respondsToSelector: selector] &#x3D;&#x3D; NO)</span><br><span class="line">    &#123;</span><br><span class="line">      [NSException raise: NSInvalidArgumentException</span><br><span class="line">        format: @&quot;[%@-%@] Observer &#39;%@&#39; does not respond to selector &#39;%@&#39;&quot;,</span><br><span class="line">        NSStringFromClass([self class]), NSStringFromSelector(_cmd),</span><br><span class="line">        observer, NSStringFromSelector(selector)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  lockNCTable(TABLE);</span><br><span class="line"></span><br><span class="line">  o &#x3D; obsNew(TABLE, selector, observer);</span><br><span class="line"></span><br><span class="line">  &#x2F;*</span><br><span class="line">   * Record the Observation in one of the linked lists.</span><br><span class="line">   *</span><br><span class="line">   * NB. It is possible to register an observer for a notification more than</span><br><span class="line">   * once - in which case, the observer will receive multiple messages when</span><br><span class="line">   * the notification is posted... odd, but the MacOS-X docs specify this.</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  if (name)</span><br><span class="line">    &#123;</span><br><span class="line">      &#x2F;*</span><br><span class="line">       * Locate the map table for this name - create it if not present.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      n &#x3D; GSIMapNodeForKey(NAMED, (GSIMapKey)(id)name);</span><br><span class="line">      if (n &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	  m &#x3D; mapNew(TABLE);</span><br><span class="line">	  &#x2F;*</span><br><span class="line">	   * As this is the first observation for the given name, we take a</span><br><span class="line">	   * copy of the name so it cannot be mutated while in the map.</span><br><span class="line">	   *&#x2F;</span><br><span class="line">	  name &#x3D; [name copyWithZone: NSDefaultMallocZone()];</span><br><span class="line">	  GSIMapAddPair(NAMED, (GSIMapKey)(id)name, (GSIMapVal)(void*)m);</span><br><span class="line">	  GS_CONSUMED(name)</span><br><span class="line">	&#125;</span><br><span class="line">      else</span><br><span class="line">	&#123;</span><br><span class="line">	  m &#x3D; (GSIMapTable)n-&gt;value.ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;*</span><br><span class="line">       * Add the observation to the list for the correct object.</span><br><span class="line">       *&#x2F;</span><br><span class="line">      n &#x3D; GSIMapNodeForSimpleKey(m, (GSIMapKey)object);</span><br><span class="line">      if (n &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	  o-&gt;next &#x3D; ENDOBS;</span><br><span class="line">	  GSIMapAddPair(m, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">	&#125;</span><br><span class="line">      else</span><br><span class="line">	&#123;</span><br><span class="line">	  list &#x3D; (Observation*)n-&gt;value.ptr;</span><br><span class="line">	  o-&gt;next &#x3D; list-&gt;next;</span><br><span class="line">	  list-&gt;next &#x3D; o;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (object)</span><br><span class="line">    &#123;</span><br><span class="line">      n &#x3D; GSIMapNodeForSimpleKey(NAMELESS, (GSIMapKey)object);</span><br><span class="line">      if (n &#x3D;&#x3D; 0)</span><br><span class="line">	&#123;</span><br><span class="line">	  o-&gt;next &#x3D; ENDOBS;</span><br><span class="line">	  GSIMapAddPair(NAMELESS, (GSIMapKey)object, (GSIMapVal)o);</span><br><span class="line">	&#125;</span><br><span class="line">      else</span><br><span class="line">	&#123;</span><br><span class="line">	  list &#x3D; (Observation*)n-&gt;value.ptr;</span><br><span class="line">	  o-&gt;next &#x3D; list-&gt;next;</span><br><span class="line">	  list-&gt;next &#x3D; o;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      o-&gt;next &#x3D; WILDCARD;</span><br><span class="line">      WILDCARD &#x3D; o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  unlockNCTable(TABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h5><p><a href="https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSNotificationTheory" target="_blank" rel="noopener">https://github.com/iOS-Advanced/iOS-Advanced/tree/master/sourcecode/NSNotificationTheory</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/18/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="prev">上一篇</a><a href="/2017/10/06/%E6%B5%85%E8%B0%88-AutoreleasePool-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sunjinshuai';
var disqus_identifier = '2017/10/17/浅谈-iOS-NSNotification/';
var disqus_title = '浅谈 iOS NSNotification';
var disqus_url = 'https://sunjinshuai.github.io/2017/10/17/浅谈-iOS-NSNotification/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sunjinshuai.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2022 <a href="https://sunjinshuai.github.io">sunjinshuai</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>